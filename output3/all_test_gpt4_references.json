["import numpy as np\nimport torch\nfrom sklearn.metrics import balanced_accuracy_score, f1_score, confusion_matrix, cohen_kappa_score, roc_auc_score, \\\n    precision_recall_curve, auc, r2_score, mean_squared_error\nfrom tqdm import tqdm\n\n\nclass Evaluator:\n    def __init__(self, params, data_loader):\n        self.params = params\n        self.data_loader = data_loader\n\n    def get_metrics_for_multiclass(self, model):\n        model.eval()\n\n        truths = []\n        preds = []\n        for x, y in tqdm(self.data_loader, mininterval=1):\n            x = x.cuda()\n            y = y.cuda()\n\n            pred = model(x)\n            pred_y = torch.max(pred, dim=-1)[1]\n\n            truths += y.cpu().squeeze().numpy().tolist()\n            preds += pred_y.cpu().squeeze().numpy().tolist()\n\n        truths = np.array(truths)\n        preds = np.array(preds)\n        acc = balanced_accuracy_score(truths, preds)\n        f1 = f1_score(truths, preds, average='weighted')\n        kappa = cohen_kappa_score(truths, preds)\n        cm = confusion_matrix(truths, preds)\n        return acc, kappa, f1, cm\n\n    def get_metrics_for_binaryclass(self, model):\n        model.eval()\n\n        truths = []\n        preds = []\n        scores = []\n        for x, y in tqdm(self.data_loader, mininterval=1):\n            x = x.cuda()\n            y = y.cuda()\n            pred = model(x)\n            score_y = torch.sigmoid(pred)\n            pred_y = torch.gt(score_y, 0.5).long()\n            truths += y.long().cpu().squeeze().numpy().tolist()\n            preds += pred_y.cpu().squeeze().numpy().tolist()\n            scores += score_y.cpu().numpy().tolist()\n\n        truths = np.array(truths)\n        preds = np.array(preds)\n        scores = np.array(scores)\n        acc = balanced_accuracy_score(truths, preds)\n        roc_auc = roc_auc_score(truths, scores)\n        precision, recall, thresholds = precision_recall_curve(truths, scores, pos_label=1)\n        pr_auc = auc(recall, precision)\n        cm = confusion_matrix(truths, preds)\n        return acc, pr_auc, roc_auc, cm\n\n    def get_metrics_for_regression(self, model):\n        model.eval()\n\n        truths = []\n        preds = []\n        for x, y in tqdm(self.data_loader, mininterval=1):\n            x = x.cuda()\n            y = y.cuda()\n            pred = model(x)\n            truths += y.cpu().squeeze().numpy().tolist()\n            preds += pred.cpu().squeeze().numpy().tolist()\n\n        truths = np.array(truths)\n        preds = np.array(preds)\n        corrcoef = np.corrcoef(truths, preds)[0, 1]\n        r2 = r2_score(truths, preds)\n        rmse = mean_squared_error(truths, preds) ** 0.5\n        return corrcoef, r2, rmse"]