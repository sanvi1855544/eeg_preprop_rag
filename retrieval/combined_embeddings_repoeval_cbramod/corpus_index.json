[
  {
    "id": "0",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):"
  },
  {
    "id": "1",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)"
  },
  {
    "id": "2",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):"
  },
  {
    "id": "3",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):"
  },
  {
    "id": "4",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):"
  },
  {
    "id": "5",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):"
  },
  {
    "id": "6",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = None):"
  },
  {
    "id": "7",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = None):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    output = val if isinstance(val, tuple) else ((val,) * default(length, 1))\n\n    if exists(length):\n        assert len(output) == length\n\n    return output\n\ndef compact(input_dict):\n    return {key: value for key, value in input_dict.items() if exists(value)}\n\ndef maybe_transform_dict_key(input_dict, key, fn):\n    if key not in input_dict:\n        return input_dict\n\n    copied_dict = input_dict.copy()\n    copied_dict[key] = fn(copied_dict[key])\n    return copied_dict\n\ndef cast_uint8_images_to_float(images):"
  },
  {
    "id": "8",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = None):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    output = val if isinstance(val, tuple) else ((val,) * default(length, 1))\n\n    if exists(length):\n        assert len(output) == length\n\n    return output\n\ndef compact(input_dict):\n    return {key: value for key, value in input_dict.items() if exists(value)}\n\ndef maybe_transform_dict_key(input_dict, key, fn):\n    if key not in input_dict:\n        return input_dict\n\n    copied_dict = input_dict.copy()\n    copied_dict[key] = fn(copied_dict[key])\n    return copied_dict\n\ndef cast_uint8_images_to_float(images):\n    if not images.dtype == torch.uint8:\n        return images\n    return images / 255\n\ndef module_device(module):\n    return next(module.parameters()).device\n\ndef zero_init_(m):"
  },
  {
    "id": "9",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = None):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    output = val if isinstance(val, tuple) else ((val,) * default(length, 1))\n\n    if exists(length):\n        assert len(output) == length\n\n    return output\n\ndef compact(input_dict):\n    return {key: value for key, value in input_dict.items() if exists(value)}\n\ndef maybe_transform_dict_key(input_dict, key, fn):\n    if key not in input_dict:\n        return input_dict\n\n    copied_dict = input_dict.copy()\n    copied_dict[key] = fn(copied_dict[key])\n    return copied_dict\n\ndef cast_uint8_images_to_float(images):\n    if not images.dtype == torch.uint8:\n        return images\n    return images / 255\n\ndef module_device(module):\n    return next(module.parameters()).device\n\ndef zero_init_(m):\n    nn.init.zeros_(m.weight)\n    if exists(m.bias):\n        nn.init.zeros_(m.bias)\n\ndef eval_decorator(fn):\n    def inner(model, *args, **kwargs):\n        was_training = model.training\n        model.eval()\n        out = fn(model, *args, **kwargs)\n        model.train(was_training)\n        return out\n    return inner\n\ndef pad_tuple_to_length(t, length, fillvalue = None):"
  },
  {
    "id": "10",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = None):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    output = val if isinstance(val, tuple) else ((val,) * default(length, 1))\n\n    if exists(length):\n        assert len(output) == length\n\n    return output\n\ndef compact(input_dict):\n    return {key: value for key, value in input_dict.items() if exists(value)}\n\ndef maybe_transform_dict_key(input_dict, key, fn):\n    if key not in input_dict:\n        return input_dict\n\n    copied_dict = input_dict.copy()\n    copied_dict[key] = fn(copied_dict[key])\n    return copied_dict\n\ndef cast_uint8_images_to_float(images):\n    if not images.dtype == torch.uint8:\n        return images\n    return images / 255\n\ndef module_device(module):\n    return next(module.parameters()).device\n\ndef zero_init_(m):\n    nn.init.zeros_(m.weight)\n    if exists(m.bias):\n        nn.init.zeros_(m.bias)\n\ndef eval_decorator(fn):\n    def inner(model, *args, **kwargs):\n        was_training = model.training\n        model.eval()\n        out = fn(model, *args, **kwargs)\n        model.train(was_training)\n        return out\n    return inner\n\ndef pad_tuple_to_length(t, length, fillvalue = None):\n    remain_length = length - len(t)\n    if remain_length <= 0:\n        return t\n    return (*t, *((fillvalue,) * remain_length))\n\n# helper classes\n\nclass Identity(nn.Module):\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n\n    def forward(self, x, *args, **kwargs):\n        return x\n\n# tensor helpers\n\ndef log(t, eps: float = 1e-12):\n    return torch.log(t.clamp(min = eps))\n\ndef l2norm(t):\n    return F.normalize(t, dim = -1)\n\ndef right_pad_dims_to(x, t):"
  },
  {
    "id": "11",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = None):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    output = val if isinstance(val, tuple) else ((val,) * default(length, 1))\n\n    if exists(length):\n        assert len(output) == length\n\n    return output\n\ndef compact(input_dict):\n    return {key: value for key, value in input_dict.items() if exists(value)}\n\ndef maybe_transform_dict_key(input_dict, key, fn):\n    if key not in input_dict:\n        return input_dict\n\n    copied_dict = input_dict.copy()\n    copied_dict[key] = fn(copied_dict[key])\n    return copied_dict\n\ndef cast_uint8_images_to_float(images):\n    if not images.dtype == torch.uint8:\n        return images\n    return images / 255\n\ndef module_device(module):\n    return next(module.parameters()).device\n\ndef zero_init_(m):\n    nn.init.zeros_(m.weight)\n    if exists(m.bias):\n        nn.init.zeros_(m.bias)\n\ndef eval_decorator(fn):\n    def inner(model, *args, **kwargs):\n        was_training = model.training\n        model.eval()\n        out = fn(model, *args, **kwargs)\n        model.train(was_training)\n        return out\n    return inner\n\ndef pad_tuple_to_length(t, length, fillvalue = None):\n    remain_length = length - len(t)\n    if remain_length <= 0:\n        return t\n    return (*t, *((fillvalue,) * remain_length))\n\n# helper classes\n\nclass Identity(nn.Module):\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n\n    def forward(self, x, *args, **kwargs):\n        return x\n\n# tensor helpers\n\ndef log(t, eps: float = 1e-12):\n    return torch.log(t.clamp(min = eps))\n\ndef l2norm(t):\n    return F.normalize(t, dim = -1)\n\ndef right_pad_dims_to(x, t):\n    padding_dims = x.ndim - t.ndim\n    if padding_dims <= 0:\n        return t\n    return t.view(*t.shape, *((1,) * padding_dims))\n\ndef masked_mean(t, *, dim, mask = None):"
  },
  {
    "id": "12",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = None):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    output = val if isinstance(val, tuple) else ((val,) * default(length, 1))\n\n    if exists(length):\n        assert len(output) == length\n\n    return output\n\ndef compact(input_dict):\n    return {key: value for key, value in input_dict.items() if exists(value)}\n\ndef maybe_transform_dict_key(input_dict, key, fn):\n    if key not in input_dict:\n        return input_dict\n\n    copied_dict = input_dict.copy()\n    copied_dict[key] = fn(copied_dict[key])\n    return copied_dict\n\ndef cast_uint8_images_to_float(images):\n    if not images.dtype == torch.uint8:\n        return images\n    return images / 255\n\ndef module_device(module):\n    return next(module.parameters()).device\n\ndef zero_init_(m):\n    nn.init.zeros_(m.weight)\n    if exists(m.bias):\n        nn.init.zeros_(m.bias)\n\ndef eval_decorator(fn):\n    def inner(model, *args, **kwargs):\n        was_training = model.training\n        model.eval()\n        out = fn(model, *args, **kwargs)\n        model.train(was_training)\n        return out\n    return inner\n\ndef pad_tuple_to_length(t, length, fillvalue = None):\n    remain_length = length - len(t)\n    if remain_length <= 0:\n        return t\n    return (*t, *((fillvalue,) * remain_length))\n\n# helper classes\n\nclass Identity(nn.Module):\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n\n    def forward(self, x, *args, **kwargs):\n        return x\n\n# tensor helpers\n\ndef log(t, eps: float = 1e-12):\n    return torch.log(t.clamp(min = eps))\n\ndef l2norm(t):\n    return F.normalize(t, dim = -1)\n\ndef right_pad_dims_to(x, t):\n    padding_dims = x.ndim - t.ndim\n    if padding_dims <= 0:\n        return t\n    return t.view(*t.shape, *((1,) * padding_dims))\n\ndef masked_mean(t, *, dim, mask = None):\n    if not exists(mask):\n        return t.mean(dim = dim)\n\n    denom = mask.sum(dim = dim, keepdim = True)\n    mask = rearrange(mask, 'b n -> b n 1')\n    masked_t = t.masked_fill(~mask, 0.)\n\n    return masked_t.sum(dim = dim) / denom.clamp(min = 1e-5)\n\ndef resize_image_to(\n    image,\n    target_image_size,\n    clamp_range = None,\n    mode = 'nearest'\n):\n    orig_image_size = image.shape[-1]\n\n    if orig_image_size == target_image_size:\n        return image\n\n    out = F.interpolate(image, target_image_size, mode = mode)\n\n    if exists(clamp_range):\n        out = out.clamp(*clamp_range)\n\n    return out\n\ndef calc_all_frame_dims(\n    downsample_factors: List[int],\n    frames\n):\n    if not exists(frames):\n        return (tuple(),) * len(downsample_factors)\n\n    all_frame_dims = []\n\n    for divisor in downsample_factors:\n        assert divisible_by(frames, divisor)\n        all_frame_dims.append((frames // divisor,))\n\n    return all_frame_dims\n\ndef safe_get_tuple_index(tup, index, default = None):"
  },
  {
    "id": "13",
    "text": "import math\nimport copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = None):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    output = val if isinstance(val, tuple) else ((val,) * default(length, 1))\n\n    if exists(length):\n        assert len(output) == length\n\n    return output\n\ndef compact(input_dict):\n    return {key: value for key, value in input_dict.items() if exists(value)}\n\ndef maybe_transform_dict_key(input_dict, key, fn):\n    if key not in input_dict:\n        return input_dict\n\n    copied_dict = input_dict.copy()\n    copied_dict[key] = fn(copied_dict[key])\n    return copied_dict\n\ndef cast_uint8_images_to_float(images):\n    if not images.dtype == torch.uint8:\n        return images\n    return images / 255\n\ndef module_device(module):\n    return next(module.parameters()).device\n\ndef zero_init_(m):\n    nn.init.zeros_(m.weight)\n    if exists(m.bias):\n        nn.init.zeros_(m.bias)\n\ndef eval_decorator(fn):\n    def inner(model, *args, **kwargs):\n        was_training = model.training\n        model.eval()\n        out = fn(model, *args, **kwargs)\n        model.train(was_training)\n        return out\n    return inner\n\ndef pad_tuple_to_length(t, length, fillvalue = None):\n    remain_length = length - len(t)\n    if remain_length <= 0:\n        return t\n    return (*t, *((fillvalue,) * remain_length))\n\n# helper classes\n\nclass Identity(nn.Module):\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n\n    def forward(self, x, *args, **kwargs):\n        return x\n\n# tensor helpers\n\ndef log(t, eps: float = 1e-12):\n    return torch.log(t.clamp(min = eps))\n\ndef l2norm(t):\n    return F.normalize(t, dim = -1)\n\ndef right_pad_dims_to(x, t):\n    padding_dims = x.ndim - t.ndim\n    if padding_dims <= 0:\n        return t\n    return t.view(*t.shape, *((1,) * padding_dims))\n\ndef masked_mean(t, *, dim, mask = None):\n    if not exists(mask):\n        return t.mean(dim = dim)\n\n    denom = mask.sum(dim = dim, keepdim = True)\n    mask = rearrange(mask, 'b n -> b n 1')\n    masked_t = t.masked_fill(~mask, 0.)\n\n    return masked_t.sum(dim = dim) / denom.clamp(min = 1e-5)\n\ndef resize_image_to(\n    image,\n    target_image_size,\n    clamp_range = None,\n    mode = 'nearest'\n):\n    orig_image_size = image.shape[-1]\n\n    if orig_image_size == target_image_size:\n        return image\n\n    out = F.interpolate(image, target_image_size, mode = mode)\n\n    if exists(clamp_range):\n        out = out.clamp(*clamp_range)\n\n    return out\n\ndef calc_all_frame_dims(\n    downsample_factors: List[int],\n    frames\n):\n    if not exists(frames):\n        return (tuple(),) * len(downsample_factors)\n\n    all_frame_dims = []\n\n    for divisor in downsample_factors:\n        assert divisible_by(frames, divisor)\n        all_frame_dims.append((frames // divisor,))\n\n    return all_frame_dims\n\ndef safe_get_tuple_index(tup, index, default = None):\n    if len(tup) <= index:\n        return default\n    return tup[index]\n\n# image normalization functions\n# ddpms expect images to be in the range of -1 to 1\n\ndef normalize_neg_one_to_one(img):\n    return img * 2 - 1\n\ndef unnormalize_zero_to_one(normed_img):\n    return (normed_img + 1) * 0.5\n\n# classifier free guidance functions\n\ndef prob_mask_like(shape, prob, device):"
  },
  {
    "id": "14",
    "text": " copy\nfrom random import random\nfrom beartype.typing import List, Union\nfrom beartype import beartype\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel\nfrom torch import nn, einsum\nfrom torch.cuda.amp import autocast\nfrom torch.special import expm1\nimport torchvision.transforms as T\n\nimport kornia.augmentation as K\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\nfrom imagen_pytorch.imagen_video import Unet3D, resize_video_to, scale_video_time\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):\n    called = False\n    @wraps(fn)\n    def inner(x):\n        nonlocal called\n        if called:\n            return\n        called = True\n        return fn(x)\n    return inner\n\nprint_once = once(print)\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = None):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    output = val if isinstance(val, tuple) else ((val,) * default(length, 1))\n\n    if exists(length):\n        assert len(output) == length\n\n    return output\n\ndef compact(input_dict):\n    return {key: value for key, value in input_dict.items() if exists(value)}\n\ndef maybe_transform_dict_key(input_dict, key, fn):\n    if key not in input_dict:\n        return input_dict\n\n    copied_dict = input_dict.copy()\n    copied_dict[key] = fn(copied_dict[key])\n    return copied_dict\n\ndef cast_uint8_images_to_float(images):\n    if not images.dtype == torch.uint8:\n        return images\n    return images / 255\n\ndef module_device(module):\n    return next(module.parameters()).device\n\ndef zero_init_(m):\n    nn.init.zeros_(m.weight)\n    if exists(m.bias):\n        nn.init.zeros_(m.bias)\n\ndef eval_decorator(fn):\n    def inner(model, *args, **kwargs):\n        was_training = model.training\n        model.eval()\n        out = fn(model, *args, **kwargs)\n        model.train(was_training)\n        return out\n    return inner\n\ndef pad_tuple_to_length(t, length, fillvalue = None):\n    remain_length = length - len(t)\n    if remain_length <= 0:\n        return t\n    return (*t, *((fillvalue,) * remain_length))\n\n# helper classes\n\nclass Identity(nn.Module):\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n\n    def forward(self, x, *args, **kwargs):\n        return x\n\n# tensor helpers\n\ndef log(t, eps: float = 1e-12):\n    return torch.log(t.clamp(min = eps))\n\ndef l2norm(t):\n    return F.normalize(t, dim = -1)\n\ndef right_pad_dims_to(x, t):\n    padding_dims = x.ndim - t.ndim\n    if padding_dims <= 0:\n        return t\n    return t.view(*t.shape, *((1,) * padding_dims))\n\ndef masked_mean(t, *, dim, mask = None):\n    if not exists(mask):\n        return t.mean(dim = dim)\n\n    denom = mask.sum(dim = dim, keepdim = True)\n    mask = rearrange(mask, 'b n -> b n 1')\n    masked_t = t.masked_fill(~mask, 0.)\n\n    return masked_t.sum(dim = dim) / denom.clamp(min = 1e-5)\n\ndef resize_image_to(\n    image,\n    target_image_size,\n    clamp_range = None,\n    mode = 'nearest'\n):\n    orig_image_size = image.shape[-1]\n\n    if orig_image_size == target_image_size:\n        return image\n\n    out = F.interpolate(image, target_image_size, mode = mode)\n\n    if exists(clamp_range):\n        out = out.clamp(*clamp_range)\n\n    return out\n\ndef calc_all_frame_dims(\n    downsample_factors: List[int],\n    frames\n):\n    if not exists(frames):\n        return (tuple(),) * len(downsample_factors)\n\n    all_frame_dims = []\n\n    for divisor in downsample_factors:\n        assert divisible_by(frames, divisor)\n        all_frame_dims.append((frames // divisor,))\n\n    return all_frame_dims\n\ndef safe_get_tuple_index(tup, index, default = None):\n    if len(tup) <= index:\n        return default\n    return tup[index]\n\n# image normalization functions\n# ddpms expect images to be in the range of -1 to 1\n\ndef normalize_neg_one_to_one(img):\n    return img * 2 - 1\n\ndef unnormalize_zero_to_one(normed_img):\n    return (normed_img + 1) * 0.5\n\n# classifier free guidance functions\n\ndef prob_mask_like(shape, prob, device):\n    if prob == 1:\n        return torch.ones(shape, device = device, dtype = torch.bool)\n    elif prob == 0:\n        return torch.zeros(shape, device = device, dtype = torch.bool)\n    else:\n        return torch.zeros(shape, device = device).float().uniform_(0, 1) < prob\n\n# gaussian diffusion with continuous time helper functions and classes\n# large part of this was thanks to @crowsonkb at https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/utils.py\n\n@torch.jit.script\ndef beta_linear_log_snr(t):\n    return -torch.log(expm1(1e-4 + 10 * (t ** 2)))\n\n@torch.jit.script\ndef alpha_cosine_log_snr(t, s: float = 0.008):\n    return -log((torch.cos((t + s) / (1 + s) * math.pi * 0.5) ** -2) - 1, eps = 1e-5) # not sure if this accounts for beta being clipped to 0.999 in discrete version\n\ndef log_snr_to_alpha_sigma(log_snr):\n    return torch.sqrt(torch.sigmoid(log_snr)), torch.sqrt(torch.sigmoid(-log_snr))\n\nclass GaussianDiffusionContinuousTimes(nn.Module):\n    def __init__(self, *, noise_schedule, timesteps = 1000):"
  },
  {
    "id": "15",
    "text": "\n        return images\n    return images / 255\n\ndef module_device(module):\n    return next(module.parameters()).device\n\ndef zero_init_(m):\n    nn.init.zeros_(m.weight)\n    if exists(m.bias):\n        nn.init.zeros_(m.bias)\n\ndef eval_decorator(fn):\n    def inner(model, *args, **kwargs):\n        was_training = model.training\n        model.eval()\n        out = fn(model, *args, **kwargs)\n        model.train(was_training)\n        return out\n    return inner\n\ndef pad_tuple_to_length(t, length, fillvalue = None):\n    remain_length = length - len(t)\n    if remain_length <= 0:\n        return t\n    return (*t, *((fillvalue,) * remain_length))\n\n# helper classes\n\nclass Identity(nn.Module):\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n\n    def forward(self, x, *args, **kwargs):\n        return x\n\n# tensor helpers\n\ndef log(t, eps: float = 1e-12):\n    return torch.log(t.clamp(min = eps))\n\ndef l2norm(t):\n    return F.normalize(t, dim = -1)\n\ndef right_pad_dims_to(x, t):\n    padding_dims = x.ndim - t.ndim\n    if padding_dims <= 0:\n        return t\n    return t.view(*t.shape, *((1,) * padding_dims))\n\ndef masked_mean(t, *, dim, mask = None):\n    if not exists(mask):\n        return t.mean(dim = dim)\n\n    denom = mask.sum(dim = dim, keepdim = True)\n    mask = rearrange(mask, 'b n -> b n 1')\n    masked_t = t.masked_fill(~mask, 0.)\n\n    return masked_t.sum(dim = dim) / denom.clamp(min = 1e-5)\n\ndef resize_image_to(\n    image,\n    target_image_size,\n    clamp_range = None,\n    mode = 'nearest'\n):\n    orig_image_size = image.shape[-1]\n\n    if orig_image_size == target_image_size:\n        return image\n\n    out = F.interpolate(image, target_image_size, mode = mode)\n\n    if exists(clamp_range):\n        out = out.clamp(*clamp_range)\n\n    return out\n\ndef calc_all_frame_dims(\n    downsample_factors: List[int],\n    frames\n):\n    if not exists(frames):\n        return (tuple(),) * len(downsample_factors)\n\n    all_frame_dims = []\n\n    for divisor in downsample_factors:\n        assert divisible_by(frames, divisor)\n        all_frame_dims.append((frames // divisor,))\n\n    return all_frame_dims\n\ndef safe_get_tuple_index(tup, index, default = None):\n    if len(tup) <= index:\n        return default\n    return tup[index]\n\n# image normalization functions\n# ddpms expect images to be in the range of -1 to 1\n\ndef normalize_neg_one_to_one(img):\n    return img * 2 - 1\n\ndef unnormalize_zero_to_one(normed_img):\n    return (normed_img + 1) * 0.5\n\n# classifier free guidance functions\n\ndef prob_mask_like(shape, prob, device):\n    if prob == 1:\n        return torch.ones(shape, device = device, dtype = torch.bool)\n    elif prob == 0:\n        return torch.zeros(shape, device = device, dtype = torch.bool)\n    else:\n        return torch.zeros(shape, device = device).float().uniform_(0, 1) < prob\n\n# gaussian diffusion with continuous time helper functions and classes\n# large part of this was thanks to @crowsonkb at https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/utils.py\n\n@torch.jit.script\ndef beta_linear_log_snr(t):\n    return -torch.log(expm1(1e-4 + 10 * (t ** 2)))\n\n@torch.jit.script\ndef alpha_cosine_log_snr(t, s: float = 0.008):\n    return -log((torch.cos((t + s) / (1 + s) * math.pi * 0.5) ** -2) - 1, eps = 1e-5) # not sure if this accounts for beta being clipped to 0.999 in discrete version\n\ndef log_snr_to_alpha_sigma(log_snr):\n    return torch.sqrt(torch.sigmoid(log_snr)), torch.sqrt(torch.sigmoid(-log_snr))\n\nclass GaussianDiffusionContinuousTimes(nn.Module):\n    def __init__(self, *, noise_schedule, timesteps = 1000):\n        super().__init__()\n\n        if noise_schedule == \"linear\":\n            self.log_snr = beta_linear_log_snr\n        elif noise_schedule == \"cosine\":\n            self.log_snr = alpha_cosine_log_snr\n        else:\n            raise ValueError(f'invalid noise schedule {noise_schedule}')\n\n        self.num_timesteps = timesteps\n\n    def get_times(self, batch_size, noise_level, *, device):\n        return torch.full((batch_size,), noise_level, device = device, dtype = torch.float32)\n\n    def sample_random_times(self, batch_size, *, device):\n        return torch.zeros((batch_size,), device = device).float().uniform_(0, 1)\n\n    def get_condition(self, times):\n        return maybe(self.log_snr)(times)\n\n    def get_sampling_timesteps(self, batch, *, device):\n        times = torch.linspace(1., 0., self.num_timesteps + 1, device = device)\n        times = repeat(times, 't -> b t', b = batch)\n        times = torch.stack((times[:, :-1], times[:, 1:]), dim = 0)\n        times = times.unbind(dim = -1)\n        return times\n\n    def q_posterior(self, x_start, x_t, t, *, t_next = None):\n        t_next = default(t_next, lambda: (t - 1. / self.num_timesteps).clamp(min = 0.))\n\n        \"\"\" https://openreview.net/attachment?id=2LdBqxc1Yv&name=supplementary_material \"\"\"\n        log_snr = self.log_snr(t)\n        log_snr_next = self.log_snr(t_next)\n        log_snr, log_snr_next = map(partial(right_pad_dims_to, x_t), (log_snr, log_snr_next))\n\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        alpha_next, sigma_next = log_snr_to_alpha_sigma(log_snr_next)\n\n        # c - as defined near eq 33\n        c = -expm1(log_snr - log_snr_next)\n        posterior_mean = alpha_next * (x_t * (1 - c) / alpha + c * x_start)\n\n        # following (eq. 33)\n        posterior_variance = (sigma_next ** 2) * c\n        posterior_log_variance_clipped = log(posterior_variance, eps = 1e-20)\n        return posterior_mean, posterior_variance, posterior_log_variance_clipped\n\n    def q_sample(self, x_start, t, noise = None):"
  },
  {
    "id": "16",
    "text": "[index]\n\n# image normalization functions\n# ddpms expect images to be in the range of -1 to 1\n\ndef normalize_neg_one_to_one(img):\n    return img * 2 - 1\n\ndef unnormalize_zero_to_one(normed_img):\n    return (normed_img + 1) * 0.5\n\n# classifier free guidance functions\n\ndef prob_mask_like(shape, prob, device):\n    if prob == 1:\n        return torch.ones(shape, device = device, dtype = torch.bool)\n    elif prob == 0:\n        return torch.zeros(shape, device = device, dtype = torch.bool)\n    else:\n        return torch.zeros(shape, device = device).float().uniform_(0, 1) < prob\n\n# gaussian diffusion with continuous time helper functions and classes\n# large part of this was thanks to @crowsonkb at https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/utils.py\n\n@torch.jit.script\ndef beta_linear_log_snr(t):\n    return -torch.log(expm1(1e-4 + 10 * (t ** 2)))\n\n@torch.jit.script\ndef alpha_cosine_log_snr(t, s: float = 0.008):\n    return -log((torch.cos((t + s) / (1 + s) * math.pi * 0.5) ** -2) - 1, eps = 1e-5) # not sure if this accounts for beta being clipped to 0.999 in discrete version\n\ndef log_snr_to_alpha_sigma(log_snr):\n    return torch.sqrt(torch.sigmoid(log_snr)), torch.sqrt(torch.sigmoid(-log_snr))\n\nclass GaussianDiffusionContinuousTimes(nn.Module):\n    def __init__(self, *, noise_schedule, timesteps = 1000):\n        super().__init__()\n\n        if noise_schedule == \"linear\":\n            self.log_snr = beta_linear_log_snr\n        elif noise_schedule == \"cosine\":\n            self.log_snr = alpha_cosine_log_snr\n        else:\n            raise ValueError(f'invalid noise schedule {noise_schedule}')\n\n        self.num_timesteps = timesteps\n\n    def get_times(self, batch_size, noise_level, *, device):\n        return torch.full((batch_size,), noise_level, device = device, dtype = torch.float32)\n\n    def sample_random_times(self, batch_size, *, device):\n        return torch.zeros((batch_size,), device = device).float().uniform_(0, 1)\n\n    def get_condition(self, times):\n        return maybe(self.log_snr)(times)\n\n    def get_sampling_timesteps(self, batch, *, device):\n        times = torch.linspace(1., 0., self.num_timesteps + 1, device = device)\n        times = repeat(times, 't -> b t', b = batch)\n        times = torch.stack((times[:, :-1], times[:, 1:]), dim = 0)\n        times = times.unbind(dim = -1)\n        return times\n\n    def q_posterior(self, x_start, x_t, t, *, t_next = None):\n        t_next = default(t_next, lambda: (t - 1. / self.num_timesteps).clamp(min = 0.))\n\n        \"\"\" https://openreview.net/attachment?id=2LdBqxc1Yv&name=supplementary_material \"\"\"\n        log_snr = self.log_snr(t)\n        log_snr_next = self.log_snr(t_next)\n        log_snr, log_snr_next = map(partial(right_pad_dims_to, x_t), (log_snr, log_snr_next))\n\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        alpha_next, sigma_next = log_snr_to_alpha_sigma(log_snr_next)\n\n        # c - as defined near eq 33\n        c = -expm1(log_snr - log_snr_next)\n        posterior_mean = alpha_next * (x_t * (1 - c) / alpha + c * x_start)\n\n        # following (eq. 33)\n        posterior_variance = (sigma_next ** 2) * c\n        posterior_log_variance_clipped = log(posterior_variance, eps = 1e-20)\n        return posterior_mean, posterior_variance, posterior_log_variance_clipped\n\n    def q_sample(self, x_start, t, noise = None):\n        dtype = x_start.dtype\n\n        if isinstance(t, float):\n            batch = x_start.shape[0]\n            t = torch.full((batch,), t, device = x_start.device, dtype = dtype)\n\n        noise = default(noise, lambda: torch.randn_like(x_start))\n        log_snr = self.log_snr(t).type(dtype)\n        log_snr_padded_dim = right_pad_dims_to(x_start, log_snr)\n        alpha, sigma =  log_snr_to_alpha_sigma(log_snr_padded_dim)\n\n        return alpha * x_start + sigma * noise, log_snr, alpha, sigma\n\n    def q_sample_from_to(self, x_from, from_t, to_t, noise = None):\n        shape, device, dtype = x_from.shape, x_from.device, x_from.dtype\n        batch = shape[0]\n\n        if isinstance(from_t, float):\n            from_t = torch.full((batch,), from_t, device = device, dtype = dtype)\n\n        if isinstance(to_t, float):\n            to_t = torch.full((batch,), to_t, device = device, dtype = dtype)\n\n        noise = default(noise, lambda: torch.randn_like(x_from))\n\n        log_snr = self.log_snr(from_t)\n        log_snr_padded_dim = right_pad_dims_to(x_from, log_snr)\n        alpha, sigma =  log_snr_to_alpha_sigma(log_snr_padded_dim)\n\n        log_snr_to = self.log_snr(to_t)\n        log_snr_padded_dim_to = right_pad_dims_to(x_from, log_snr_to)\n        alpha_to, sigma_to =  log_snr_to_alpha_sigma(log_snr_padded_dim_to)\n\n        return x_from * (alpha_to / alpha) + noise * (sigma_to * alpha - sigma * alpha_to) / alpha\n\n    def predict_start_from_v(self, x_t, t, v):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return alpha * x_t - sigma * v\n\n    def predict_start_from_noise(self, x_t, t, noise):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return (x_t - sigma * noise) / alpha.clamp(min = 1e-8)\n\n# norms and residuals\n\nclass LayerNorm(nn.Module):\n    def __init__(self, feats, stable = False, dim = -1):"
  },
  {
    "id": "17",
    "text": "to_one(normed_img):\n    return (normed_img + 1) * 0.5\n\n# classifier free guidance functions\n\ndef prob_mask_like(shape, prob, device):\n    if prob == 1:\n        return torch.ones(shape, device = device, dtype = torch.bool)\n    elif prob == 0:\n        return torch.zeros(shape, device = device, dtype = torch.bool)\n    else:\n        return torch.zeros(shape, device = device).float().uniform_(0, 1) < prob\n\n# gaussian diffusion with continuous time helper functions and classes\n# large part of this was thanks to @crowsonkb at https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/utils.py\n\n@torch.jit.script\ndef beta_linear_log_snr(t):\n    return -torch.log(expm1(1e-4 + 10 * (t ** 2)))\n\n@torch.jit.script\ndef alpha_cosine_log_snr(t, s: float = 0.008):\n    return -log((torch.cos((t + s) / (1 + s) * math.pi * 0.5) ** -2) - 1, eps = 1e-5) # not sure if this accounts for beta being clipped to 0.999 in discrete version\n\ndef log_snr_to_alpha_sigma(log_snr):\n    return torch.sqrt(torch.sigmoid(log_snr)), torch.sqrt(torch.sigmoid(-log_snr))\n\nclass GaussianDiffusionContinuousTimes(nn.Module):\n    def __init__(self, *, noise_schedule, timesteps = 1000):\n        super().__init__()\n\n        if noise_schedule == \"linear\":\n            self.log_snr = beta_linear_log_snr\n        elif noise_schedule == \"cosine\":\n            self.log_snr = alpha_cosine_log_snr\n        else:\n            raise ValueError(f'invalid noise schedule {noise_schedule}')\n\n        self.num_timesteps = timesteps\n\n    def get_times(self, batch_size, noise_level, *, device):\n        return torch.full((batch_size,), noise_level, device = device, dtype = torch.float32)\n\n    def sample_random_times(self, batch_size, *, device):\n        return torch.zeros((batch_size,), device = device).float().uniform_(0, 1)\n\n    def get_condition(self, times):\n        return maybe(self.log_snr)(times)\n\n    def get_sampling_timesteps(self, batch, *, device):\n        times = torch.linspace(1., 0., self.num_timesteps + 1, device = device)\n        times = repeat(times, 't -> b t', b = batch)\n        times = torch.stack((times[:, :-1], times[:, 1:]), dim = 0)\n        times = times.unbind(dim = -1)\n        return times\n\n    def q_posterior(self, x_start, x_t, t, *, t_next = None):\n        t_next = default(t_next, lambda: (t - 1. / self.num_timesteps).clamp(min = 0.))\n\n        \"\"\" https://openreview.net/attachment?id=2LdBqxc1Yv&name=supplementary_material \"\"\"\n        log_snr = self.log_snr(t)\n        log_snr_next = self.log_snr(t_next)\n        log_snr, log_snr_next = map(partial(right_pad_dims_to, x_t), (log_snr, log_snr_next))\n\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        alpha_next, sigma_next = log_snr_to_alpha_sigma(log_snr_next)\n\n        # c - as defined near eq 33\n        c = -expm1(log_snr - log_snr_next)\n        posterior_mean = alpha_next * (x_t * (1 - c) / alpha + c * x_start)\n\n        # following (eq. 33)\n        posterior_variance = (sigma_next ** 2) * c\n        posterior_log_variance_clipped = log(posterior_variance, eps = 1e-20)\n        return posterior_mean, posterior_variance, posterior_log_variance_clipped\n\n    def q_sample(self, x_start, t, noise = None):\n        dtype = x_start.dtype\n\n        if isinstance(t, float):\n            batch = x_start.shape[0]\n            t = torch.full((batch,), t, device = x_start.device, dtype = dtype)\n\n        noise = default(noise, lambda: torch.randn_like(x_start))\n        log_snr = self.log_snr(t).type(dtype)\n        log_snr_padded_dim = right_pad_dims_to(x_start, log_snr)\n        alpha, sigma =  log_snr_to_alpha_sigma(log_snr_padded_dim)\n\n        return alpha * x_start + sigma * noise, log_snr, alpha, sigma\n\n    def q_sample_from_to(self, x_from, from_t, to_t, noise = None):\n        shape, device, dtype = x_from.shape, x_from.device, x_from.dtype\n        batch = shape[0]\n\n        if isinstance(from_t, float):\n            from_t = torch.full((batch,), from_t, device = device, dtype = dtype)\n\n        if isinstance(to_t, float):\n            to_t = torch.full((batch,), to_t, device = device, dtype = dtype)\n\n        noise = default(noise, lambda: torch.randn_like(x_from))\n\n        log_snr = self.log_snr(from_t)\n        log_snr_padded_dim = right_pad_dims_to(x_from, log_snr)\n        alpha, sigma =  log_snr_to_alpha_sigma(log_snr_padded_dim)\n\n        log_snr_to = self.log_snr(to_t)\n        log_snr_padded_dim_to = right_pad_dims_to(x_from, log_snr_to)\n        alpha_to, sigma_to =  log_snr_to_alpha_sigma(log_snr_padded_dim_to)\n\n        return x_from * (alpha_to / alpha) + noise * (sigma_to * alpha - sigma * alpha_to) / alpha\n\n    def predict_start_from_v(self, x_t, t, v):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return alpha * x_t - sigma * v\n\n    def predict_start_from_noise(self, x_t, t, noise):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return (x_t - sigma * noise) / alpha.clamp(min = 1e-8)\n\n# norms and residuals\n\nclass LayerNorm(nn.Module):\n    def __init__(self, feats, stable = False, dim = -1):\n        super().__init__()\n        self.stable = stable\n        self.dim = dim\n\n        self.g = nn.Parameter(torch.ones(feats, *((1,) * (-dim - 1))))\n\n    def forward(self, x):"
  },
  {
    "id": "18",
    "text": ", noise_schedule, timesteps = 1000):\n        super().__init__()\n\n        if noise_schedule == \"linear\":\n            self.log_snr = beta_linear_log_snr\n        elif noise_schedule == \"cosine\":\n            self.log_snr = alpha_cosine_log_snr\n        else:\n            raise ValueError(f'invalid noise schedule {noise_schedule}')\n\n        self.num_timesteps = timesteps\n\n    def get_times(self, batch_size, noise_level, *, device):\n        return torch.full((batch_size,), noise_level, device = device, dtype = torch.float32)\n\n    def sample_random_times(self, batch_size, *, device):\n        return torch.zeros((batch_size,), device = device).float().uniform_(0, 1)\n\n    def get_condition(self, times):\n        return maybe(self.log_snr)(times)\n\n    def get_sampling_timesteps(self, batch, *, device):\n        times = torch.linspace(1., 0., self.num_timesteps + 1, device = device)\n        times = repeat(times, 't -> b t', b = batch)\n        times = torch.stack((times[:, :-1], times[:, 1:]), dim = 0)\n        times = times.unbind(dim = -1)\n        return times\n\n    def q_posterior(self, x_start, x_t, t, *, t_next = None):\n        t_next = default(t_next, lambda: (t - 1. / self.num_timesteps).clamp(min = 0.))\n\n        \"\"\" https://openreview.net/attachment?id=2LdBqxc1Yv&name=supplementary_material \"\"\"\n        log_snr = self.log_snr(t)\n        log_snr_next = self.log_snr(t_next)\n        log_snr, log_snr_next = map(partial(right_pad_dims_to, x_t), (log_snr, log_snr_next))\n\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        alpha_next, sigma_next = log_snr_to_alpha_sigma(log_snr_next)\n\n        # c - as defined near eq 33\n        c = -expm1(log_snr - log_snr_next)\n        posterior_mean = alpha_next * (x_t * (1 - c) / alpha + c * x_start)\n\n        # following (eq. 33)\n        posterior_variance = (sigma_next ** 2) * c\n        posterior_log_variance_clipped = log(posterior_variance, eps = 1e-20)\n        return posterior_mean, posterior_variance, posterior_log_variance_clipped\n\n    def q_sample(self, x_start, t, noise = None):\n        dtype = x_start.dtype\n\n        if isinstance(t, float):\n            batch = x_start.shape[0]\n            t = torch.full((batch,), t, device = x_start.device, dtype = dtype)\n\n        noise = default(noise, lambda: torch.randn_like(x_start))\n        log_snr = self.log_snr(t).type(dtype)\n        log_snr_padded_dim = right_pad_dims_to(x_start, log_snr)\n        alpha, sigma =  log_snr_to_alpha_sigma(log_snr_padded_dim)\n\n        return alpha * x_start + sigma * noise, log_snr, alpha, sigma\n\n    def q_sample_from_to(self, x_from, from_t, to_t, noise = None):\n        shape, device, dtype = x_from.shape, x_from.device, x_from.dtype\n        batch = shape[0]\n\n        if isinstance(from_t, float):\n            from_t = torch.full((batch,), from_t, device = device, dtype = dtype)\n\n        if isinstance(to_t, float):\n            to_t = torch.full((batch,), to_t, device = device, dtype = dtype)\n\n        noise = default(noise, lambda: torch.randn_like(x_from))\n\n        log_snr = self.log_snr(from_t)\n        log_snr_padded_dim = right_pad_dims_to(x_from, log_snr)\n        alpha, sigma =  log_snr_to_alpha_sigma(log_snr_padded_dim)\n\n        log_snr_to = self.log_snr(to_t)\n        log_snr_padded_dim_to = right_pad_dims_to(x_from, log_snr_to)\n        alpha_to, sigma_to =  log_snr_to_alpha_sigma(log_snr_padded_dim_to)\n\n        return x_from * (alpha_to / alpha) + noise * (sigma_to * alpha - sigma * alpha_to) / alpha\n\n    def predict_start_from_v(self, x_t, t, v):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return alpha * x_t - sigma * v\n\n    def predict_start_from_noise(self, x_t, t, noise):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return (x_t - sigma * noise) / alpha.clamp(min = 1e-8)\n\n# norms and residuals\n\nclass LayerNorm(nn.Module):\n    def __init__(self, feats, stable = False, dim = -1):\n        super().__init__()\n        self.stable = stable\n        self.dim = dim\n\n        self.g = nn.Parameter(torch.ones(feats, *((1,) * (-dim - 1))))\n\n    def forward(self, x):\n        dtype, dim = x.dtype, self.dim\n\n        if self.stable:\n            x = x / x.amax(dim = dim, keepdim = True).detach()\n\n        eps = 1e-5 if x.dtype == torch.float32 else 1e-3\n        var = torch.var(x, dim = dim, unbiased = False, keepdim = True)\n        mean = torch.mean(x, dim = dim, keepdim = True)\n\n        return (x - mean) * (var + eps).rsqrt().type(dtype) * self.g.type(dtype)\n\nChanLayerNorm = partial(LayerNorm, dim = -3)\n\nclass Always():\n    def __init__(self, val):\n        self.val = val\n\n    def __call__(self, *args, **kwargs):\n        return self.val\n\nclass Residual(nn.Module):\n    def __init__(self, fn):\n        super().__init__()\n        self.fn = fn\n\n    def forward(self, x, **kwargs):\n        return self.fn(x, **kwargs) + x\n\nclass Parallel(nn.Module):\n    def __init__(self, *fns):\n        super().__init__()\n        self.fns = nn.ModuleList(fns)\n\n    def forward(self, x):\n        outputs = [fn(x) for fn in self.fns]\n        return sum(outputs)\n\n# attention pooling\n\nclass PerceiverAttention(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        dim_head = 64,\n        heads = 8,\n        scale = 8\n    ):"
  },
  {
    "id": "19",
    "text": "batch,), t, device = x_start.device, dtype = dtype)\n\n        noise = default(noise, lambda: torch.randn_like(x_start))\n        log_snr = self.log_snr(t).type(dtype)\n        log_snr_padded_dim = right_pad_dims_to(x_start, log_snr)\n        alpha, sigma =  log_snr_to_alpha_sigma(log_snr_padded_dim)\n\n        return alpha * x_start + sigma * noise, log_snr, alpha, sigma\n\n    def q_sample_from_to(self, x_from, from_t, to_t, noise = None):\n        shape, device, dtype = x_from.shape, x_from.device, x_from.dtype\n        batch = shape[0]\n\n        if isinstance(from_t, float):\n            from_t = torch.full((batch,), from_t, device = device, dtype = dtype)\n\n        if isinstance(to_t, float):\n            to_t = torch.full((batch,), to_t, device = device, dtype = dtype)\n\n        noise = default(noise, lambda: torch.randn_like(x_from))\n\n        log_snr = self.log_snr(from_t)\n        log_snr_padded_dim = right_pad_dims_to(x_from, log_snr)\n        alpha, sigma =  log_snr_to_alpha_sigma(log_snr_padded_dim)\n\n        log_snr_to = self.log_snr(to_t)\n        log_snr_padded_dim_to = right_pad_dims_to(x_from, log_snr_to)\n        alpha_to, sigma_to =  log_snr_to_alpha_sigma(log_snr_padded_dim_to)\n\n        return x_from * (alpha_to / alpha) + noise * (sigma_to * alpha - sigma * alpha_to) / alpha\n\n    def predict_start_from_v(self, x_t, t, v):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return alpha * x_t - sigma * v\n\n    def predict_start_from_noise(self, x_t, t, noise):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return (x_t - sigma * noise) / alpha.clamp(min = 1e-8)\n\n# norms and residuals\n\nclass LayerNorm(nn.Module):\n    def __init__(self, feats, stable = False, dim = -1):\n        super().__init__()\n        self.stable = stable\n        self.dim = dim\n\n        self.g = nn.Parameter(torch.ones(feats, *((1,) * (-dim - 1))))\n\n    def forward(self, x):\n        dtype, dim = x.dtype, self.dim\n\n        if self.stable:\n            x = x / x.amax(dim = dim, keepdim = True).detach()\n\n        eps = 1e-5 if x.dtype == torch.float32 else 1e-3\n        var = torch.var(x, dim = dim, unbiased = False, keepdim = True)\n        mean = torch.mean(x, dim = dim, keepdim = True)\n\n        return (x - mean) * (var + eps).rsqrt().type(dtype) * self.g.type(dtype)\n\nChanLayerNorm = partial(LayerNorm, dim = -3)\n\nclass Always():\n    def __init__(self, val):\n        self.val = val\n\n    def __call__(self, *args, **kwargs):\n        return self.val\n\nclass Residual(nn.Module):\n    def __init__(self, fn):\n        super().__init__()\n        self.fn = fn\n\n    def forward(self, x, **kwargs):\n        return self.fn(x, **kwargs) + x\n\nclass Parallel(nn.Module):\n    def __init__(self, *fns):\n        super().__init__()\n        self.fns = nn.ModuleList(fns)\n\n    def forward(self, x):\n        outputs = [fn(x) for fn in self.fns]\n        return sum(outputs)\n\n# attention pooling\n\nclass PerceiverAttention(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        dim_head = 64,\n        heads = 8,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = nn.LayerNorm(dim)\n        self.norm_latents = nn.LayerNorm(dim)\n\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, inner_dim * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            nn.LayerNorm(dim)\n        )\n\n    def forward(self, x, latents, mask = None):\n        x = self.norm(x)\n        latents = self.norm_latents(latents)\n\n        b, h = x.shape[0], self.heads\n\n        q = self.to_q(latents)\n\n        # the paper differs from Perceiver in which they also concat the key / values derived from the latents to be attended to\n        kv_input = torch.cat((x, latents), dim = -2)\n        k, v = self.to_kv(kv_input).chunk(2, dim = -1)\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> b h n d', h = h)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # similarities and masking\n\n        sim = einsum('... i d, ... j d  -> ... i j', q, k) * self.scale\n\n        if exists(mask):\n            max_neg_value = -torch.finfo(sim.dtype).max\n            mask = F.pad(mask, (0, latents.shape[-2]), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        out = einsum('... i j, ... j d -> ... i d', attn, v)\n        out = rearrange(out, 'b h n d -> b n (h d)', h = h)\n        return self.to_out(out)\n\nclass PerceiverResampler(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        depth,\n        dim_head = 64,\n        heads = 8,\n        num_latents = 64,\n        num_latents_mean_pooled = 4, # number of latents derived from mean pooled representation of the sequence\n        max_seq_len = 512,\n        ff_mult = 4\n    ):"
  },
  {
    "id": "20",
    "text": " = torch.full((batch,), to_t, device = device, dtype = dtype)\n\n        noise = default(noise, lambda: torch.randn_like(x_from))\n\n        log_snr = self.log_snr(from_t)\n        log_snr_padded_dim = right_pad_dims_to(x_from, log_snr)\n        alpha, sigma =  log_snr_to_alpha_sigma(log_snr_padded_dim)\n\n        log_snr_to = self.log_snr(to_t)\n        log_snr_padded_dim_to = right_pad_dims_to(x_from, log_snr_to)\n        alpha_to, sigma_to =  log_snr_to_alpha_sigma(log_snr_padded_dim_to)\n\n        return x_from * (alpha_to / alpha) + noise * (sigma_to * alpha - sigma * alpha_to) / alpha\n\n    def predict_start_from_v(self, x_t, t, v):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return alpha * x_t - sigma * v\n\n    def predict_start_from_noise(self, x_t, t, noise):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return (x_t - sigma * noise) / alpha.clamp(min = 1e-8)\n\n# norms and residuals\n\nclass LayerNorm(nn.Module):\n    def __init__(self, feats, stable = False, dim = -1):\n        super().__init__()\n        self.stable = stable\n        self.dim = dim\n\n        self.g = nn.Parameter(torch.ones(feats, *((1,) * (-dim - 1))))\n\n    def forward(self, x):\n        dtype, dim = x.dtype, self.dim\n\n        if self.stable:\n            x = x / x.amax(dim = dim, keepdim = True).detach()\n\n        eps = 1e-5 if x.dtype == torch.float32 else 1e-3\n        var = torch.var(x, dim = dim, unbiased = False, keepdim = True)\n        mean = torch.mean(x, dim = dim, keepdim = True)\n\n        return (x - mean) * (var + eps).rsqrt().type(dtype) * self.g.type(dtype)\n\nChanLayerNorm = partial(LayerNorm, dim = -3)\n\nclass Always():\n    def __init__(self, val):\n        self.val = val\n\n    def __call__(self, *args, **kwargs):\n        return self.val\n\nclass Residual(nn.Module):\n    def __init__(self, fn):\n        super().__init__()\n        self.fn = fn\n\n    def forward(self, x, **kwargs):\n        return self.fn(x, **kwargs) + x\n\nclass Parallel(nn.Module):\n    def __init__(self, *fns):\n        super().__init__()\n        self.fns = nn.ModuleList(fns)\n\n    def forward(self, x):\n        outputs = [fn(x) for fn in self.fns]\n        return sum(outputs)\n\n# attention pooling\n\nclass PerceiverAttention(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        dim_head = 64,\n        heads = 8,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = nn.LayerNorm(dim)\n        self.norm_latents = nn.LayerNorm(dim)\n\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, inner_dim * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            nn.LayerNorm(dim)\n        )\n\n    def forward(self, x, latents, mask = None):\n        x = self.norm(x)\n        latents = self.norm_latents(latents)\n\n        b, h = x.shape[0], self.heads\n\n        q = self.to_q(latents)\n\n        # the paper differs from Perceiver in which they also concat the key / values derived from the latents to be attended to\n        kv_input = torch.cat((x, latents), dim = -2)\n        k, v = self.to_kv(kv_input).chunk(2, dim = -1)\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> b h n d', h = h)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # similarities and masking\n\n        sim = einsum('... i d, ... j d  -> ... i j', q, k) * self.scale\n\n        if exists(mask):\n            max_neg_value = -torch.finfo(sim.dtype).max\n            mask = F.pad(mask, (0, latents.shape[-2]), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        out = einsum('... i j, ... j d -> ... i d', attn, v)\n        out = rearrange(out, 'b h n d -> b n (h d)', h = h)\n        return self.to_out(out)\n\nclass PerceiverResampler(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        depth,\n        dim_head = 64,\n        heads = 8,\n        num_latents = 64,\n        num_latents_mean_pooled = 4, # number of latents derived from mean pooled representation of the sequence\n        max_seq_len = 512,\n        ff_mult = 4\n    ):\n        super().__init__()\n        self.pos_emb = nn.Embedding(max_seq_len, dim)\n\n        self.latents = nn.Parameter(torch.randn(num_latents, dim))\n\n        self.to_latents_from_mean_pooled_seq = None\n\n        if num_latents_mean_pooled > 0:\n            self.to_latents_from_mean_pooled_seq = nn.Sequential(\n                LayerNorm(dim),\n                nn.Linear(dim, dim * num_latents_mean_pooled),\n                Rearrange('b (n d) -> b n d', n = num_latents_mean_pooled)\n            )\n\n        self.layers = nn.ModuleList([])\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                PerceiverAttention(dim = dim, dim_head = dim_head, heads = heads),\n                FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, mask = None):"
  },
  {
    "id": "21",
    "text": "snr_to_alpha_sigma(log_snr)\n        return alpha * x_t - sigma * v\n\n    def predict_start_from_noise(self, x_t, t, noise):\n        log_snr = self.log_snr(t)\n        log_snr = right_pad_dims_to(x_t, log_snr)\n        alpha, sigma = log_snr_to_alpha_sigma(log_snr)\n        return (x_t - sigma * noise) / alpha.clamp(min = 1e-8)\n\n# norms and residuals\n\nclass LayerNorm(nn.Module):\n    def __init__(self, feats, stable = False, dim = -1):\n        super().__init__()\n        self.stable = stable\n        self.dim = dim\n\n        self.g = nn.Parameter(torch.ones(feats, *((1,) * (-dim - 1))))\n\n    def forward(self, x):\n        dtype, dim = x.dtype, self.dim\n\n        if self.stable:\n            x = x / x.amax(dim = dim, keepdim = True).detach()\n\n        eps = 1e-5 if x.dtype == torch.float32 else 1e-3\n        var = torch.var(x, dim = dim, unbiased = False, keepdim = True)\n        mean = torch.mean(x, dim = dim, keepdim = True)\n\n        return (x - mean) * (var + eps).rsqrt().type(dtype) * self.g.type(dtype)\n\nChanLayerNorm = partial(LayerNorm, dim = -3)\n\nclass Always():\n    def __init__(self, val):\n        self.val = val\n\n    def __call__(self, *args, **kwargs):\n        return self.val\n\nclass Residual(nn.Module):\n    def __init__(self, fn):\n        super().__init__()\n        self.fn = fn\n\n    def forward(self, x, **kwargs):\n        return self.fn(x, **kwargs) + x\n\nclass Parallel(nn.Module):\n    def __init__(self, *fns):\n        super().__init__()\n        self.fns = nn.ModuleList(fns)\n\n    def forward(self, x):\n        outputs = [fn(x) for fn in self.fns]\n        return sum(outputs)\n\n# attention pooling\n\nclass PerceiverAttention(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        dim_head = 64,\n        heads = 8,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = nn.LayerNorm(dim)\n        self.norm_latents = nn.LayerNorm(dim)\n\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, inner_dim * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            nn.LayerNorm(dim)\n        )\n\n    def forward(self, x, latents, mask = None):\n        x = self.norm(x)\n        latents = self.norm_latents(latents)\n\n        b, h = x.shape[0], self.heads\n\n        q = self.to_q(latents)\n\n        # the paper differs from Perceiver in which they also concat the key / values derived from the latents to be attended to\n        kv_input = torch.cat((x, latents), dim = -2)\n        k, v = self.to_kv(kv_input).chunk(2, dim = -1)\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> b h n d', h = h)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # similarities and masking\n\n        sim = einsum('... i d, ... j d  -> ... i j', q, k) * self.scale\n\n        if exists(mask):\n            max_neg_value = -torch.finfo(sim.dtype).max\n            mask = F.pad(mask, (0, latents.shape[-2]), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        out = einsum('... i j, ... j d -> ... i d', attn, v)\n        out = rearrange(out, 'b h n d -> b n (h d)', h = h)\n        return self.to_out(out)\n\nclass PerceiverResampler(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        depth,\n        dim_head = 64,\n        heads = 8,\n        num_latents = 64,\n        num_latents_mean_pooled = 4, # number of latents derived from mean pooled representation of the sequence\n        max_seq_len = 512,\n        ff_mult = 4\n    ):\n        super().__init__()\n        self.pos_emb = nn.Embedding(max_seq_len, dim)\n\n        self.latents = nn.Parameter(torch.randn(num_latents, dim))\n\n        self.to_latents_from_mean_pooled_seq = None\n\n        if num_latents_mean_pooled > 0:\n            self.to_latents_from_mean_pooled_seq = nn.Sequential(\n                LayerNorm(dim),\n                nn.Linear(dim, dim * num_latents_mean_pooled),\n                Rearrange('b (n d) -> b n d', n = num_latents_mean_pooled)\n            )\n\n        self.layers = nn.ModuleList([])\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                PerceiverAttention(dim = dim, dim_head = dim_head, heads = heads),\n                FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, mask = None):\n        n, device = x.shape[1], x.device\n        pos_emb = self.pos_emb(torch.arange(n, device = device))\n\n        x_with_pos = x + pos_emb\n\n        latents = repeat(self.latents, 'n d -> b n d', b = x.shape[0])\n\n        if exists(self.to_latents_from_mean_pooled_seq):\n            meanpooled_seq = masked_mean(x, dim = 1, mask = torch.ones(x.shape[:2], device = x.device, dtype = torch.bool))\n            meanpooled_latents = self.to_latents_from_mean_pooled_seq(meanpooled_seq)\n            latents = torch.cat((meanpooled_latents, latents), dim = -2)\n\n        for attn, ff in self.layers:\n            latents = attn(x_with_pos, latents, mask = mask) + latents\n            latents = ff(latents) + latents\n\n        return latents\n\n# attention\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        dim_head = 64,\n        heads = 8,\n        context_dim = None,\n        scale = 8\n    ):"
  },
  {
    "id": "22",
    "text": "\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # similarities and masking\n\n        sim = einsum('... i d, ... j d  -> ... i j', q, k) * self.scale\n\n        if exists(mask):\n            max_neg_value = -torch.finfo(sim.dtype).max\n            mask = F.pad(mask, (0, latents.shape[-2]), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        out = einsum('... i j, ... j d -> ... i d', attn, v)\n        out = rearrange(out, 'b h n d -> b n (h d)', h = h)\n        return self.to_out(out)\n\nclass PerceiverResampler(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        depth,\n        dim_head = 64,\n        heads = 8,\n        num_latents = 64,\n        num_latents_mean_pooled = 4, # number of latents derived from mean pooled representation of the sequence\n        max_seq_len = 512,\n        ff_mult = 4\n    ):\n        super().__init__()\n        self.pos_emb = nn.Embedding(max_seq_len, dim)\n\n        self.latents = nn.Parameter(torch.randn(num_latents, dim))\n\n        self.to_latents_from_mean_pooled_seq = None\n\n        if num_latents_mean_pooled > 0:\n            self.to_latents_from_mean_pooled_seq = nn.Sequential(\n                LayerNorm(dim),\n                nn.Linear(dim, dim * num_latents_mean_pooled),\n                Rearrange('b (n d) -> b n d', n = num_latents_mean_pooled)\n            )\n\n        self.layers = nn.ModuleList([])\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                PerceiverAttention(dim = dim, dim_head = dim_head, heads = heads),\n                FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, mask = None):\n        n, device = x.shape[1], x.device\n        pos_emb = self.pos_emb(torch.arange(n, device = device))\n\n        x_with_pos = x + pos_emb\n\n        latents = repeat(self.latents, 'n d -> b n d', b = x.shape[0])\n\n        if exists(self.to_latents_from_mean_pooled_seq):\n            meanpooled_seq = masked_mean(x, dim = 1, mask = torch.ones(x.shape[:2], device = x.device, dtype = torch.bool))\n            meanpooled_latents = self.to_latents_from_mean_pooled_seq(meanpooled_seq)\n            latents = torch.cat((meanpooled_latents, latents), dim = -2)\n\n        for attn, ff in self.layers:\n            latents = attn(x_with_pos, latents, mask = mask) + latents\n            latents = ff(latents) + latents\n\n        return latents\n\n# attention\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        dim_head = 64,\n        heads = 8,\n        context_dim = None,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = LayerNorm(dim)\n\n        self.null_kv = nn.Parameter(torch.randn(2, dim_head))\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, dim_head * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, dim_head * 2)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            LayerNorm(dim)\n        )\n\n    def forward(self, x, context = None, mask = None, attn_bias = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n\n        q, k, v = (self.to_q(x), *self.to_kv(x).chunk(2, dim = -1))\n\n        q = rearrange(q, 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b 1 d', b = b)\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # add text conditioning, if present\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            k = torch.cat((ck, k), dim = -2)\n            v = torch.cat((cv, v), dim = -2)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # calculate query / key similarities\n\n        sim = einsum('b h i d, b j d -> b h i j', q, k) * self.scale\n\n        # relative positional encoding (T5 style)\n\n        if exists(attn_bias):\n            sim = sim + attn_bias\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):"
  },
  {
    "id": "23",
    "text": "\n            mask = F.pad(mask, (0, latents.shape[-2]), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        out = einsum('... i j, ... j d -> ... i d', attn, v)\n        out = rearrange(out, 'b h n d -> b n (h d)', h = h)\n        return self.to_out(out)\n\nclass PerceiverResampler(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        depth,\n        dim_head = 64,\n        heads = 8,\n        num_latents = 64,\n        num_latents_mean_pooled = 4, # number of latents derived from mean pooled representation of the sequence\n        max_seq_len = 512,\n        ff_mult = 4\n    ):\n        super().__init__()\n        self.pos_emb = nn.Embedding(max_seq_len, dim)\n\n        self.latents = nn.Parameter(torch.randn(num_latents, dim))\n\n        self.to_latents_from_mean_pooled_seq = None\n\n        if num_latents_mean_pooled > 0:\n            self.to_latents_from_mean_pooled_seq = nn.Sequential(\n                LayerNorm(dim),\n                nn.Linear(dim, dim * num_latents_mean_pooled),\n                Rearrange('b (n d) -> b n d', n = num_latents_mean_pooled)\n            )\n\n        self.layers = nn.ModuleList([])\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                PerceiverAttention(dim = dim, dim_head = dim_head, heads = heads),\n                FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, mask = None):\n        n, device = x.shape[1], x.device\n        pos_emb = self.pos_emb(torch.arange(n, device = device))\n\n        x_with_pos = x + pos_emb\n\n        latents = repeat(self.latents, 'n d -> b n d', b = x.shape[0])\n\n        if exists(self.to_latents_from_mean_pooled_seq):\n            meanpooled_seq = masked_mean(x, dim = 1, mask = torch.ones(x.shape[:2], device = x.device, dtype = torch.bool))\n            meanpooled_latents = self.to_latents_from_mean_pooled_seq(meanpooled_seq)\n            latents = torch.cat((meanpooled_latents, latents), dim = -2)\n\n        for attn, ff in self.layers:\n            latents = attn(x_with_pos, latents, mask = mask) + latents\n            latents = ff(latents) + latents\n\n        return latents\n\n# attention\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        dim_head = 64,\n        heads = 8,\n        context_dim = None,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = LayerNorm(dim)\n\n        self.null_kv = nn.Parameter(torch.randn(2, dim_head))\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, dim_head * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, dim_head * 2)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            LayerNorm(dim)\n        )\n\n    def forward(self, x, context = None, mask = None, attn_bias = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n\n        q, k, v = (self.to_q(x), *self.to_kv(x).chunk(2, dim = -1))\n\n        q = rearrange(q, 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b 1 d', b = b)\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # add text conditioning, if present\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            k = torch.cat((ck, k), dim = -2)\n            v = torch.cat((cv, v), dim = -2)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # calculate query / key similarities\n\n        sim = einsum('b h i d, b j d -> b h i j', q, k) * self.scale\n\n        # relative positional encoding (T5 style)\n\n        if exists(attn_bias):\n            sim = sim + attn_bias\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):\n        super().__init__()\n        dim_out = default(dim_out, dim)\n        conv = nn.Conv2d(dim, dim_out * 4, 1)\n\n        self.net = nn.Sequential(\n            conv,\n            nn.SiLU(),\n            nn.PixelShuffle(2)\n        )\n\n        self.init_conv_(conv)\n\n    def init_conv_(self, conv):"
  },
  {
    "id": "24",
    "text": "init__(\n        self,\n        *,\n        dim,\n        depth,\n        dim_head = 64,\n        heads = 8,\n        num_latents = 64,\n        num_latents_mean_pooled = 4, # number of latents derived from mean pooled representation of the sequence\n        max_seq_len = 512,\n        ff_mult = 4\n    ):\n        super().__init__()\n        self.pos_emb = nn.Embedding(max_seq_len, dim)\n\n        self.latents = nn.Parameter(torch.randn(num_latents, dim))\n\n        self.to_latents_from_mean_pooled_seq = None\n\n        if num_latents_mean_pooled > 0:\n            self.to_latents_from_mean_pooled_seq = nn.Sequential(\n                LayerNorm(dim),\n                nn.Linear(dim, dim * num_latents_mean_pooled),\n                Rearrange('b (n d) -> b n d', n = num_latents_mean_pooled)\n            )\n\n        self.layers = nn.ModuleList([])\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                PerceiverAttention(dim = dim, dim_head = dim_head, heads = heads),\n                FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, mask = None):\n        n, device = x.shape[1], x.device\n        pos_emb = self.pos_emb(torch.arange(n, device = device))\n\n        x_with_pos = x + pos_emb\n\n        latents = repeat(self.latents, 'n d -> b n d', b = x.shape[0])\n\n        if exists(self.to_latents_from_mean_pooled_seq):\n            meanpooled_seq = masked_mean(x, dim = 1, mask = torch.ones(x.shape[:2], device = x.device, dtype = torch.bool))\n            meanpooled_latents = self.to_latents_from_mean_pooled_seq(meanpooled_seq)\n            latents = torch.cat((meanpooled_latents, latents), dim = -2)\n\n        for attn, ff in self.layers:\n            latents = attn(x_with_pos, latents, mask = mask) + latents\n            latents = ff(latents) + latents\n\n        return latents\n\n# attention\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        dim_head = 64,\n        heads = 8,\n        context_dim = None,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = LayerNorm(dim)\n\n        self.null_kv = nn.Parameter(torch.randn(2, dim_head))\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, dim_head * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, dim_head * 2)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            LayerNorm(dim)\n        )\n\n    def forward(self, x, context = None, mask = None, attn_bias = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n\n        q, k, v = (self.to_q(x), *self.to_kv(x).chunk(2, dim = -1))\n\n        q = rearrange(q, 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b 1 d', b = b)\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # add text conditioning, if present\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            k = torch.cat((ck, k), dim = -2)\n            v = torch.cat((cv, v), dim = -2)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # calculate query / key similarities\n\n        sim = einsum('b h i d, b j d -> b h i j', q, k) * self.scale\n\n        # relative positional encoding (T5 style)\n\n        if exists(attn_bias):\n            sim = sim + attn_bias\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):\n        super().__init__()\n        dim_out = default(dim_out, dim)\n        conv = nn.Conv2d(dim, dim_out * 4, 1)\n\n        self.net = nn.Sequential(\n            conv,\n            nn.SiLU(),\n            nn.PixelShuffle(2)\n        )\n\n        self.init_conv_(conv)\n\n    def init_conv_(self, conv):\n        o, i, h, w = conv.weight.shape\n        conv_weight = torch.empty(o // 4, i, h, w)\n        nn.init.kaiming_uniform_(conv_weight)\n        conv_weight = repeat(conv_weight, 'o ... -> (o 4) ...')\n\n        conv.weight.data.copy_(conv_weight)\n        nn.init.zeros_(conv.bias.data)\n\n    def forward(self, x):\n        return self.net(x)\n\ndef Downsample(dim, dim_out = None):\n    # https://arxiv.org/abs/2208.03641 shows this is the most optimal way to downsample\n    # named SP-conv in the paper, but basically a pixel unshuffle"
  },
  {
    "id": "25",
    "text": " FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, mask = None):\n        n, device = x.shape[1], x.device\n        pos_emb = self.pos_emb(torch.arange(n, device = device))\n\n        x_with_pos = x + pos_emb\n\n        latents = repeat(self.latents, 'n d -> b n d', b = x.shape[0])\n\n        if exists(self.to_latents_from_mean_pooled_seq):\n            meanpooled_seq = masked_mean(x, dim = 1, mask = torch.ones(x.shape[:2], device = x.device, dtype = torch.bool))\n            meanpooled_latents = self.to_latents_from_mean_pooled_seq(meanpooled_seq)\n            latents = torch.cat((meanpooled_latents, latents), dim = -2)\n\n        for attn, ff in self.layers:\n            latents = attn(x_with_pos, latents, mask = mask) + latents\n            latents = ff(latents) + latents\n\n        return latents\n\n# attention\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        dim_head = 64,\n        heads = 8,\n        context_dim = None,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = LayerNorm(dim)\n\n        self.null_kv = nn.Parameter(torch.randn(2, dim_head))\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, dim_head * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, dim_head * 2)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            LayerNorm(dim)\n        )\n\n    def forward(self, x, context = None, mask = None, attn_bias = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n\n        q, k, v = (self.to_q(x), *self.to_kv(x).chunk(2, dim = -1))\n\n        q = rearrange(q, 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b 1 d', b = b)\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # add text conditioning, if present\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            k = torch.cat((ck, k), dim = -2)\n            v = torch.cat((cv, v), dim = -2)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # calculate query / key similarities\n\n        sim = einsum('b h i d, b j d -> b h i j', q, k) * self.scale\n\n        # relative positional encoding (T5 style)\n\n        if exists(attn_bias):\n            sim = sim + attn_bias\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):\n        super().__init__()\n        dim_out = default(dim_out, dim)\n        conv = nn.Conv2d(dim, dim_out * 4, 1)\n\n        self.net = nn.Sequential(\n            conv,\n            nn.SiLU(),\n            nn.PixelShuffle(2)\n        )\n\n        self.init_conv_(conv)\n\n    def init_conv_(self, conv):\n        o, i, h, w = conv.weight.shape\n        conv_weight = torch.empty(o // 4, i, h, w)\n        nn.init.kaiming_uniform_(conv_weight)\n        conv_weight = repeat(conv_weight, 'o ... -> (o 4) ...')\n\n        conv.weight.data.copy_(conv_weight)\n        nn.init.zeros_(conv.bias.data)\n\n    def forward(self, x):\n        return self.net(x)\n\ndef Downsample(dim, dim_out = None):\n    # https://arxiv.org/abs/2208.03641 shows this is the most optimal way to downsample\n    # named SP-conv in the paper, but basically a pixel unshuffle\n    dim_out = default(dim_out, dim)\n    return nn.Sequential(\n        Rearrange('b c (h s1) (w s2) -> b (c s1 s2) h w', s1 = 2, s2 = 2),\n        nn.Conv2d(dim * 4, dim_out, 1)\n    )\n\nclass SinusoidalPosEmb(nn.Module):\n    def __init__(self, dim):\n        super().__init__()\n        self.dim = dim\n\n    def forward(self, x):\n        half_dim = self.dim // 2\n        emb = math.log(10000) / (half_dim - 1)\n        emb = torch.exp(torch.arange(half_dim, device = x.device) * -emb)\n        emb = rearrange(x, 'i -> i 1') * rearrange(emb, 'j -> 1 j')\n        return torch.cat((emb.sin(), emb.cos()), dim = -1)\n\nclass LearnedSinusoidalPosEmb(nn.Module):\n    \"\"\" following @crowsonkb 's lead with learned sinusoidal pos emb \"\"\"\n    \"\"\" https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/models/danbooru_128.py#L8 \"\"\"\n\n    def __init__(self, dim):"
  },
  {
    "id": "26",
    "text": "torch.arange(n, device = device))\n\n        x_with_pos = x + pos_emb\n\n        latents = repeat(self.latents, 'n d -> b n d', b = x.shape[0])\n\n        if exists(self.to_latents_from_mean_pooled_seq):\n            meanpooled_seq = masked_mean(x, dim = 1, mask = torch.ones(x.shape[:2], device = x.device, dtype = torch.bool))\n            meanpooled_latents = self.to_latents_from_mean_pooled_seq(meanpooled_seq)\n            latents = torch.cat((meanpooled_latents, latents), dim = -2)\n\n        for attn, ff in self.layers:\n            latents = attn(x_with_pos, latents, mask = mask) + latents\n            latents = ff(latents) + latents\n\n        return latents\n\n# attention\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        dim_head = 64,\n        heads = 8,\n        context_dim = None,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = LayerNorm(dim)\n\n        self.null_kv = nn.Parameter(torch.randn(2, dim_head))\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, dim_head * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, dim_head * 2)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            LayerNorm(dim)\n        )\n\n    def forward(self, x, context = None, mask = None, attn_bias = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n\n        q, k, v = (self.to_q(x), *self.to_kv(x).chunk(2, dim = -1))\n\n        q = rearrange(q, 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b 1 d', b = b)\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # add text conditioning, if present\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            k = torch.cat((ck, k), dim = -2)\n            v = torch.cat((cv, v), dim = -2)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # calculate query / key similarities\n\n        sim = einsum('b h i d, b j d -> b h i j', q, k) * self.scale\n\n        # relative positional encoding (T5 style)\n\n        if exists(attn_bias):\n            sim = sim + attn_bias\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):\n        super().__init__()\n        dim_out = default(dim_out, dim)\n        conv = nn.Conv2d(dim, dim_out * 4, 1)\n\n        self.net = nn.Sequential(\n            conv,\n            nn.SiLU(),\n            nn.PixelShuffle(2)\n        )\n\n        self.init_conv_(conv)\n\n    def init_conv_(self, conv):\n        o, i, h, w = conv.weight.shape\n        conv_weight = torch.empty(o // 4, i, h, w)\n        nn.init.kaiming_uniform_(conv_weight)\n        conv_weight = repeat(conv_weight, 'o ... -> (o 4) ...')\n\n        conv.weight.data.copy_(conv_weight)\n        nn.init.zeros_(conv.bias.data)\n\n    def forward(self, x):\n        return self.net(x)\n\ndef Downsample(dim, dim_out = None):\n    # https://arxiv.org/abs/2208.03641 shows this is the most optimal way to downsample\n    # named SP-conv in the paper, but basically a pixel unshuffle\n    dim_out = default(dim_out, dim)\n    return nn.Sequential(\n        Rearrange('b c (h s1) (w s2) -> b (c s1 s2) h w', s1 = 2, s2 = 2),\n        nn.Conv2d(dim * 4, dim_out, 1)\n    )\n\nclass SinusoidalPosEmb(nn.Module):\n    def __init__(self, dim):\n        super().__init__()\n        self.dim = dim\n\n    def forward(self, x):\n        half_dim = self.dim // 2\n        emb = math.log(10000) / (half_dim - 1)\n        emb = torch.exp(torch.arange(half_dim, device = x.device) * -emb)\n        emb = rearrange(x, 'i -> i 1') * rearrange(emb, 'j -> 1 j')\n        return torch.cat((emb.sin(), emb.cos()), dim = -1)\n\nclass LearnedSinusoidalPosEmb(nn.Module):\n    \"\"\" following @crowsonkb 's lead with learned sinusoidal pos emb \"\"\"\n    \"\"\" https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/models/danbooru_128.py#L8 \"\"\"\n\n    def __init__(self, dim):\n        super().__init__()\n        assert (dim % 2) == 0\n        half_dim = dim // 2\n        self.weights = nn.Parameter(torch.randn(half_dim))\n\n    def forward(self, x):"
  },
  {
    "id": "27",
    "text": "pooled_seq(meanpooled_seq)\n            latents = torch.cat((meanpooled_latents, latents), dim = -2)\n\n        for attn, ff in self.layers:\n            latents = attn(x_with_pos, latents, mask = mask) + latents\n            latents = ff(latents) + latents\n\n        return latents\n\n# attention\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        dim_head = 64,\n        heads = 8,\n        context_dim = None,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = LayerNorm(dim)\n\n        self.null_kv = nn.Parameter(torch.randn(2, dim_head))\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, dim_head * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, dim_head * 2)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            LayerNorm(dim)\n        )\n\n    def forward(self, x, context = None, mask = None, attn_bias = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n\n        q, k, v = (self.to_q(x), *self.to_kv(x).chunk(2, dim = -1))\n\n        q = rearrange(q, 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b 1 d', b = b)\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # add text conditioning, if present\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            k = torch.cat((ck, k), dim = -2)\n            v = torch.cat((cv, v), dim = -2)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # calculate query / key similarities\n\n        sim = einsum('b h i d, b j d -> b h i j', q, k) * self.scale\n\n        # relative positional encoding (T5 style)\n\n        if exists(attn_bias):\n            sim = sim + attn_bias\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):\n        super().__init__()\n        dim_out = default(dim_out, dim)\n        conv = nn.Conv2d(dim, dim_out * 4, 1)\n\n        self.net = nn.Sequential(\n            conv,\n            nn.SiLU(),\n            nn.PixelShuffle(2)\n        )\n\n        self.init_conv_(conv)\n\n    def init_conv_(self, conv):\n        o, i, h, w = conv.weight.shape\n        conv_weight = torch.empty(o // 4, i, h, w)\n        nn.init.kaiming_uniform_(conv_weight)\n        conv_weight = repeat(conv_weight, 'o ... -> (o 4) ...')\n\n        conv.weight.data.copy_(conv_weight)\n        nn.init.zeros_(conv.bias.data)\n\n    def forward(self, x):\n        return self.net(x)\n\ndef Downsample(dim, dim_out = None):\n    # https://arxiv.org/abs/2208.03641 shows this is the most optimal way to downsample\n    # named SP-conv in the paper, but basically a pixel unshuffle\n    dim_out = default(dim_out, dim)\n    return nn.Sequential(\n        Rearrange('b c (h s1) (w s2) -> b (c s1 s2) h w', s1 = 2, s2 = 2),\n        nn.Conv2d(dim * 4, dim_out, 1)\n    )\n\nclass SinusoidalPosEmb(nn.Module):\n    def __init__(self, dim):\n        super().__init__()\n        self.dim = dim\n\n    def forward(self, x):\n        half_dim = self.dim // 2\n        emb = math.log(10000) / (half_dim - 1)\n        emb = torch.exp(torch.arange(half_dim, device = x.device) * -emb)\n        emb = rearrange(x, 'i -> i 1') * rearrange(emb, 'j -> 1 j')\n        return torch.cat((emb.sin(), emb.cos()), dim = -1)\n\nclass LearnedSinusoidalPosEmb(nn.Module):\n    \"\"\" following @crowsonkb 's lead with learned sinusoidal pos emb \"\"\"\n    \"\"\" https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/models/danbooru_128.py#L8 \"\"\"\n\n    def __init__(self, dim):\n        super().__init__()\n        assert (dim % 2) == 0\n        half_dim = dim // 2\n        self.weights = nn.Parameter(torch.randn(half_dim))\n\n    def forward(self, x):\n        x = rearrange(x, 'b -> b 1')\n        freqs = x * rearrange(self.weights, 'd -> 1 d') * 2 * math.pi\n        fouriered = torch.cat((freqs.sin(), freqs.cos()), dim = -1)\n        fouriered = torch.cat((x, fouriered), dim = -1)\n        return fouriered\n\nclass Block(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_out,\n        groups = 8,\n        norm = True\n    ):"
  },
  {
    "id": "28",
    "text": " latents\n\n        return latents\n\n# attention\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        dim_head = 64,\n        heads = 8,\n        context_dim = None,\n        scale = 8\n    ):\n        super().__init__()\n        self.scale = scale\n\n        self.heads = heads\n        inner_dim = dim_head * heads\n\n        self.norm = LayerNorm(dim)\n\n        self.null_kv = nn.Parameter(torch.randn(2, dim_head))\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, dim_head * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, dim_head * 2)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            LayerNorm(dim)\n        )\n\n    def forward(self, x, context = None, mask = None, attn_bias = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n\n        q, k, v = (self.to_q(x), *self.to_kv(x).chunk(2, dim = -1))\n\n        q = rearrange(q, 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b 1 d', b = b)\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # add text conditioning, if present\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            k = torch.cat((ck, k), dim = -2)\n            v = torch.cat((cv, v), dim = -2)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # calculate query / key similarities\n\n        sim = einsum('b h i d, b j d -> b h i j', q, k) * self.scale\n\n        # relative positional encoding (T5 style)\n\n        if exists(attn_bias):\n            sim = sim + attn_bias\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):\n        super().__init__()\n        dim_out = default(dim_out, dim)\n        conv = nn.Conv2d(dim, dim_out * 4, 1)\n\n        self.net = nn.Sequential(\n            conv,\n            nn.SiLU(),\n            nn.PixelShuffle(2)\n        )\n\n        self.init_conv_(conv)\n\n    def init_conv_(self, conv):\n        o, i, h, w = conv.weight.shape\n        conv_weight = torch.empty(o // 4, i, h, w)\n        nn.init.kaiming_uniform_(conv_weight)\n        conv_weight = repeat(conv_weight, 'o ... -> (o 4) ...')\n\n        conv.weight.data.copy_(conv_weight)\n        nn.init.zeros_(conv.bias.data)\n\n    def forward(self, x):\n        return self.net(x)\n\ndef Downsample(dim, dim_out = None):\n    # https://arxiv.org/abs/2208.03641 shows this is the most optimal way to downsample\n    # named SP-conv in the paper, but basically a pixel unshuffle\n    dim_out = default(dim_out, dim)\n    return nn.Sequential(\n        Rearrange('b c (h s1) (w s2) -> b (c s1 s2) h w', s1 = 2, s2 = 2),\n        nn.Conv2d(dim * 4, dim_out, 1)\n    )\n\nclass SinusoidalPosEmb(nn.Module):\n    def __init__(self, dim):\n        super().__init__()\n        self.dim = dim\n\n    def forward(self, x):\n        half_dim = self.dim // 2\n        emb = math.log(10000) / (half_dim - 1)\n        emb = torch.exp(torch.arange(half_dim, device = x.device) * -emb)\n        emb = rearrange(x, 'i -> i 1') * rearrange(emb, 'j -> 1 j')\n        return torch.cat((emb.sin(), emb.cos()), dim = -1)\n\nclass LearnedSinusoidalPosEmb(nn.Module):\n    \"\"\" following @crowsonkb 's lead with learned sinusoidal pos emb \"\"\"\n    \"\"\" https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/models/danbooru_128.py#L8 \"\"\"\n\n    def __init__(self, dim):\n        super().__init__()\n        assert (dim % 2) == 0\n        half_dim = dim // 2\n        self.weights = nn.Parameter(torch.randn(half_dim))\n\n    def forward(self, x):\n        x = rearrange(x, 'b -> b 1')\n        freqs = x * rearrange(self.weights, 'd -> 1 d') * 2 * math.pi\n        fouriered = torch.cat((freqs.sin(), freqs.cos()), dim = -1)\n        fouriered = torch.cat((x, fouriered), dim = -1)\n        return fouriered\n\nclass Block(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_out,\n        groups = 8,\n        norm = True\n    ):\n        super().__init__()\n        self.groupnorm = nn.GroupNorm(groups, dim) if norm else Identity()\n        self.activation = nn.SiLU()\n        self.project = nn.Conv2d(dim, dim_out, 3, padding = 1)\n\n    def forward(self, x, scale_shift = None):"
  },
  {
    "id": "29",
    "text": " bias = False)\n        self.to_kv = nn.Linear(dim, dim_head * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, dim_head * 2)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            LayerNorm(dim)\n        )\n\n    def forward(self, x, context = None, mask = None, attn_bias = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n\n        q, k, v = (self.to_q(x), *self.to_kv(x).chunk(2, dim = -1))\n\n        q = rearrange(q, 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b 1 d', b = b)\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # add text conditioning, if present\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            k = torch.cat((ck, k), dim = -2)\n            v = torch.cat((cv, v), dim = -2)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # calculate query / key similarities\n\n        sim = einsum('b h i d, b j d -> b h i j', q, k) * self.scale\n\n        # relative positional encoding (T5 style)\n\n        if exists(attn_bias):\n            sim = sim + attn_bias\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):\n        super().__init__()\n        dim_out = default(dim_out, dim)\n        conv = nn.Conv2d(dim, dim_out * 4, 1)\n\n        self.net = nn.Sequential(\n            conv,\n            nn.SiLU(),\n            nn.PixelShuffle(2)\n        )\n\n        self.init_conv_(conv)\n\n    def init_conv_(self, conv):\n        o, i, h, w = conv.weight.shape\n        conv_weight = torch.empty(o // 4, i, h, w)\n        nn.init.kaiming_uniform_(conv_weight)\n        conv_weight = repeat(conv_weight, 'o ... -> (o 4) ...')\n\n        conv.weight.data.copy_(conv_weight)\n        nn.init.zeros_(conv.bias.data)\n\n    def forward(self, x):\n        return self.net(x)\n\ndef Downsample(dim, dim_out = None):\n    # https://arxiv.org/abs/2208.03641 shows this is the most optimal way to downsample\n    # named SP-conv in the paper, but basically a pixel unshuffle\n    dim_out = default(dim_out, dim)\n    return nn.Sequential(\n        Rearrange('b c (h s1) (w s2) -> b (c s1 s2) h w', s1 = 2, s2 = 2),\n        nn.Conv2d(dim * 4, dim_out, 1)\n    )\n\nclass SinusoidalPosEmb(nn.Module):\n    def __init__(self, dim):\n        super().__init__()\n        self.dim = dim\n\n    def forward(self, x):\n        half_dim = self.dim // 2\n        emb = math.log(10000) / (half_dim - 1)\n        emb = torch.exp(torch.arange(half_dim, device = x.device) * -emb)\n        emb = rearrange(x, 'i -> i 1') * rearrange(emb, 'j -> 1 j')\n        return torch.cat((emb.sin(), emb.cos()), dim = -1)\n\nclass LearnedSinusoidalPosEmb(nn.Module):\n    \"\"\" following @crowsonkb 's lead with learned sinusoidal pos emb \"\"\"\n    \"\"\" https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/models/danbooru_128.py#L8 \"\"\"\n\n    def __init__(self, dim):\n        super().__init__()\n        assert (dim % 2) == 0\n        half_dim = dim // 2\n        self.weights = nn.Parameter(torch.randn(half_dim))\n\n    def forward(self, x):\n        x = rearrange(x, 'b -> b 1')\n        freqs = x * rearrange(self.weights, 'd -> 1 d') * 2 * math.pi\n        fouriered = torch.cat((freqs.sin(), freqs.cos()), dim = -1)\n        fouriered = torch.cat((x, fouriered), dim = -1)\n        return fouriered\n\nclass Block(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_out,\n        groups = 8,\n        norm = True\n    ):\n        super().__init__()\n        self.groupnorm = nn.GroupNorm(groups, dim) if norm else Identity()\n        self.activation = nn.SiLU()\n        self.project = nn.Conv2d(dim, dim_out, 3, padding = 1)\n\n    def forward(self, x, scale_shift = None):\n        x = self.groupnorm(x)\n\n        if exists(scale_shift):\n            scale, shift = scale_shift\n            x = x * (scale + 1) + shift\n\n        x = self.activation(x)\n        return self.project(x)\n\nclass ResnetBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_out,\n        *,\n        cond_dim = None,\n        time_cond_dim = None,\n        groups = 8,\n        linear_attn = False,\n        use_gca = False,\n        squeeze_excite = False,\n        **attn_kwargs\n    ):"
  },
  {
    "id": "30",
    "text": " / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b 1 d', b = b)\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # add text conditioning, if present\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            k = torch.cat((ck, k), dim = -2)\n            v = torch.cat((cv, v), dim = -2)\n\n        # qk rmsnorm\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # calculate query / key similarities\n\n        sim = einsum('b h i d, b j d -> b h i j', q, k) * self.scale\n\n        # relative positional encoding (T5 style)\n\n        if exists(attn_bias):\n            sim = sim + attn_bias\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):\n        super().__init__()\n        dim_out = default(dim_out, dim)\n        conv = nn.Conv2d(dim, dim_out * 4, 1)\n\n        self.net = nn.Sequential(\n            conv,\n            nn.SiLU(),\n            nn.PixelShuffle(2)\n        )\n\n        self.init_conv_(conv)\n\n    def init_conv_(self, conv):\n        o, i, h, w = conv.weight.shape\n        conv_weight = torch.empty(o // 4, i, h, w)\n        nn.init.kaiming_uniform_(conv_weight)\n        conv_weight = repeat(conv_weight, 'o ... -> (o 4) ...')\n\n        conv.weight.data.copy_(conv_weight)\n        nn.init.zeros_(conv.bias.data)\n\n    def forward(self, x):\n        return self.net(x)\n\ndef Downsample(dim, dim_out = None):\n    # https://arxiv.org/abs/2208.03641 shows this is the most optimal way to downsample\n    # named SP-conv in the paper, but basically a pixel unshuffle\n    dim_out = default(dim_out, dim)\n    return nn.Sequential(\n        Rearrange('b c (h s1) (w s2) -> b (c s1 s2) h w', s1 = 2, s2 = 2),\n        nn.Conv2d(dim * 4, dim_out, 1)\n    )\n\nclass SinusoidalPosEmb(nn.Module):\n    def __init__(self, dim):\n        super().__init__()\n        self.dim = dim\n\n    def forward(self, x):\n        half_dim = self.dim // 2\n        emb = math.log(10000) / (half_dim - 1)\n        emb = torch.exp(torch.arange(half_dim, device = x.device) * -emb)\n        emb = rearrange(x, 'i -> i 1') * rearrange(emb, 'j -> 1 j')\n        return torch.cat((emb.sin(), emb.cos()), dim = -1)\n\nclass LearnedSinusoidalPosEmb(nn.Module):\n    \"\"\" following @crowsonkb 's lead with learned sinusoidal pos emb \"\"\"\n    \"\"\" https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/models/danbooru_128.py#L8 \"\"\"\n\n    def __init__(self, dim):\n        super().__init__()\n        assert (dim % 2) == 0\n        half_dim = dim // 2\n        self.weights = nn.Parameter(torch.randn(half_dim))\n\n    def forward(self, x):\n        x = rearrange(x, 'b -> b 1')\n        freqs = x * rearrange(self.weights, 'd -> 1 d') * 2 * math.pi\n        fouriered = torch.cat((freqs.sin(), freqs.cos()), dim = -1)\n        fouriered = torch.cat((x, fouriered), dim = -1)\n        return fouriered\n\nclass Block(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_out,\n        groups = 8,\n        norm = True\n    ):\n        super().__init__()\n        self.groupnorm = nn.GroupNorm(groups, dim) if norm else Identity()\n        self.activation = nn.SiLU()\n        self.project = nn.Conv2d(dim, dim_out, 3, padding = 1)\n\n    def forward(self, x, scale_shift = None):\n        x = self.groupnorm(x)\n\n        if exists(scale_shift):\n            scale, shift = scale_shift\n            x = x * (scale + 1) + shift\n\n        x = self.activation(x)\n        return self.project(x)\n\nclass ResnetBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_out,\n        *,\n        cond_dim = None,\n        time_cond_dim = None,\n        groups = 8,\n        linear_attn = False,\n        use_gca = False,\n        squeeze_excite = False,\n        **attn_kwargs\n    ):\n        super().__init__()\n\n        self.time_mlp = None\n\n        if exists(time_cond_dim):\n            self.time_mlp = nn.Sequential(\n                nn.SiLU(),\n                nn.Linear(time_cond_dim, dim_out * 2)\n            )\n\n        self.cross_attn = None\n\n        if exists(cond_dim):\n            attn_klass = CrossAttention if not linear_attn else LinearCrossAttention\n\n            self.cross_attn = attn_klass(\n                dim = dim_out,\n                context_dim = cond_dim,\n                **attn_kwargs\n            )\n\n        self.block1 = Block(dim, dim_out, groups = groups)\n        self.block2 = Block(dim_out, dim_out, groups = groups)\n\n        self.gca = GlobalContext(dim_in = dim_out, dim_out = dim_out) if use_gca else Always(1)\n\n        self.res_conv = nn.Conv2d(dim, dim_out, 1) if dim != dim_out else Identity()\n\n\n    def forward(self, x, time_emb = None, cond = None):"
  },
  {
    "id": "31",
    "text": " exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        # attention\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        # aggregate values\n\n        out = einsum('b h i j, b j d -> b h i d', attn, v)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\n# decoder\n\ndef Upsample(dim, dim_out = None):\n    dim_out = default(dim_out, dim)\n\n    return nn.Sequential(\n        nn.Upsample(scale_factor = 2, mode = 'nearest'),\n        nn.Conv2d(dim, dim_out, 3, padding = 1)\n    )\n\nclass PixelShuffleUpsample(nn.Module):\n    \"\"\"\n    code shared by @MalumaDev at DALLE2-pytorch for addressing checkboard artifacts\n    https://arxiv.org/ftp/arxiv/papers/1707/1707.02937.pdf\n    \"\"\"\n    def __init__(self, dim, dim_out = None):\n        super().__init__()\n        dim_out = default(dim_out, dim)\n        conv = nn.Conv2d(dim, dim_out * 4, 1)\n\n        self.net = nn.Sequential(\n            conv,\n            nn.SiLU(),\n            nn.PixelShuffle(2)\n        )\n\n        self.init_conv_(conv)\n\n    def init_conv_(self, conv):\n        o, i, h, w = conv.weight.shape\n        conv_weight = torch.empty(o // 4, i, h, w)\n        nn.init.kaiming_uniform_(conv_weight)\n        conv_weight = repeat(conv_weight, 'o ... -> (o 4) ...')\n\n        conv.weight.data.copy_(conv_weight)\n        nn.init.zeros_(conv.bias.data)\n\n    def forward(self, x):\n        return self.net(x)\n\ndef Downsample(dim, dim_out = None):\n    # https://arxiv.org/abs/2208.03641 shows this is the most optimal way to downsample\n    # named SP-conv in the paper, but basically a pixel unshuffle\n    dim_out = default(dim_out, dim)\n    return nn.Sequential(\n        Rearrange('b c (h s1) (w s2) -> b (c s1 s2) h w', s1 = 2, s2 = 2),\n        nn.Conv2d(dim * 4, dim_out, 1)\n    )\n\nclass SinusoidalPosEmb(nn.Module):\n    def __init__(self, dim):\n        super().__init__()\n        self.dim = dim\n\n    def forward(self, x):\n        half_dim = self.dim // 2\n        emb = math.log(10000) / (half_dim - 1)\n        emb = torch.exp(torch.arange(half_dim, device = x.device) * -emb)\n        emb = rearrange(x, 'i -> i 1') * rearrange(emb, 'j -> 1 j')\n        return torch.cat((emb.sin(), emb.cos()), dim = -1)\n\nclass LearnedSinusoidalPosEmb(nn.Module):\n    \"\"\" following @crowsonkb 's lead with learned sinusoidal pos emb \"\"\"\n    \"\"\" https://github.com/crowsonkb/v-diffusion-jax/blob/master/diffusion/models/danbooru_128.py#L8 \"\"\"\n\n    def __init__(self, dim):\n        super().__init__()\n        assert (dim % 2) == 0\n        half_dim = dim // 2\n        self.weights = nn.Parameter(torch.randn(half_dim))\n\n    def forward(self, x):\n        x = rearrange(x, 'b -> b 1')\n        freqs = x * rearrange(self.weights, 'd -> 1 d') * 2 * math.pi\n        fouriered = torch.cat((freqs.sin(), freqs.cos()), dim = -1)\n        fouriered = torch.cat((x, fouriered), dim = -1)\n        return fouriered\n\nclass Block(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_out,\n        groups = 8,\n        norm = True\n    ):\n        super().__init__()\n        self.groupnorm = nn.GroupNorm(groups, dim) if norm else Identity()\n        self.activation = nn.SiLU()\n        self.project = nn.Conv2d(dim, dim_out, 3, padding = 1)\n\n    def forward(self, x, scale_shift = None):\n        x = self.groupnorm(x)\n\n        if exists(scale_shift):\n            scale, shift = scale_shift\n            x = x * (scale + 1) + shift\n\n        x = self.activation(x)\n        return self.project(x)\n\nclass ResnetBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_out,\n        *,\n        cond_dim = None,\n        time_cond_dim = None,\n        groups = 8,\n        linear_attn = False,\n        use_gca = False,\n        squeeze_excite = False,\n        **attn_kwargs\n    ):\n        super().__init__()\n\n        self.time_mlp = None\n\n        if exists(time_cond_dim):\n            self.time_mlp = nn.Sequential(\n                nn.SiLU(),\n                nn.Linear(time_cond_dim, dim_out * 2)\n            )\n\n        self.cross_attn = None\n\n        if exists(cond_dim):\n            attn_klass = CrossAttention if not linear_attn else LinearCrossAttention\n\n            self.cross_attn = attn_klass(\n                dim = dim_out,\n                context_dim = cond_dim,\n                **attn_kwargs\n            )\n\n        self.block1 = Block(dim, dim_out, groups = groups)\n        self.block2 = Block(dim_out, dim_out, groups = groups)\n\n        self.gca = GlobalContext(dim_in = dim_out, dim_out = dim_out) if use_gca else Always(1)\n\n        self.res_conv = nn.Conv2d(dim, dim_out, 1) if dim != dim_out else Identity()\n\n\n    def forward(self, x, time_emb = None, cond = None):\n\n        scale_shift = None\n        if exists(self.time_mlp) and exists(time_emb):\n            time_emb = self.time_mlp(time_emb)\n            time_emb = rearrange(time_emb, 'b c -> b c 1 1')\n            scale_shift = time_emb.chunk(2, dim = 1)\n\n        h = self.block1(x)\n\n        if exists(self.cross_attn):\n            assert exists(cond)\n            h = rearrange(h, 'b c h w -> b h w c')\n            h, ps = pack([h], 'b * c')\n            h = self.cross_attn(h, context = cond) + h\n            h, = unpack(h, ps, 'b * c')\n            h = rearrange(h, 'b h w c -> b c h w')\n\n        h = self.block2(h, scale_shift = scale_shift)\n\n        h = h * self.gca(h)\n\n        return h + self.res_conv(x)\n\nclass CrossAttention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        context_dim = None,\n        dim_head = 64,\n        heads = 8,\n        norm_context = False,\n        scale = 8\n    ):"
  },
  {
    "id": "32",
    "text": " inner_dim * 2, bias = False)\n\n        self.q_scale = nn.Parameter(torch.ones(dim_head))\n        self.k_scale = nn.Parameter(torch.ones(dim_head))\n\n        self.to_out = nn.Sequential(\n            nn.Linear(inner_dim, dim, bias = False),\n            LayerNorm(dim)\n        )\n\n    def forward(self, x, context, mask = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n        context = self.norm_context(context)\n\n        q, k, v = (self.to_q(x), *self.to_kv(context).chunk(2, dim = -1))\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b h 1 d', h = self.heads,  b = b)\n\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # cosine sim attention\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # similarities\n\n        sim = einsum('b h i d, b h j d -> b h i j', q, k) * self.scale\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        out = einsum('b h i j, b h j d -> b h i d', attn, v)\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\nclass LinearCrossAttention(CrossAttention):\n    def forward(self, x, context, mask = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n        context = self.norm_context(context)\n\n        q, k, v = (self.to_q(x), *self.to_kv(context).chunk(2, dim = -1))\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> (b h) n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> (b h) 1 d', h = self.heads,  b = b)\n\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # masking\n\n        max_neg_value = -torch.finfo(x.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b n -> b n 1')\n            k = k.masked_fill(~mask, max_neg_value)\n            v = v.masked_fill(~mask, 0.)\n\n        # linear attention\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) n d -> b n (h d)', h = self.heads)\n        return self.to_out(out)\n\nclass LinearAttention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_head = 32,\n        heads = 8,\n        dropout = 0.05,\n        context_dim = None,\n        **kwargs\n    ):\n        super().__init__()\n        self.scale = dim_head ** -0.5\n        self.heads = heads\n        inner_dim = dim_head * heads\n        self.norm = ChanLayerNorm(dim)\n\n        self.nonlin = nn.SiLU()\n\n        self.to_q = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_k = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_v = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, inner_dim * 2, bias = False)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Conv2d(inner_dim, dim, 1, bias = False),\n            ChanLayerNorm(dim)\n        )\n\n    def forward(self, fmap, context = None):\n        h, x, y = self.heads, *fmap.shape[-2:]\n\n        fmap = self.norm(fmap)\n        q, k, v = map(lambda fn: fn(fmap), (self.to_q, self.to_k, self.to_v))\n        q, k, v = rearrange_many((q, k, v), 'b (h c) x y -> (b h) (x y) c', h = h)\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            ck, cv = rearrange_many((ck, cv), 'b n (h d) -> (b h) n d', h = h)\n            k = torch.cat((k, ck), dim = -2)\n            v = torch.cat((v, cv), dim = -2)\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) (x y) d -> b (h d) x y', h = h, x = x, y = y)\n\n        out = self.nonlin(out)\n        return self.to_out(out)\n\nclass GlobalContext(nn.Module):\n    \"\"\" basically a superior form of squeeze-excitation that is attention-esque \"\"\"\n\n    def __init__(\n        self,\n        *,\n        dim_in,\n        dim_out\n    ):"
  },
  {
    "id": "33",
    "text": "device\n\n        x = self.norm(x)\n        context = self.norm_context(context)\n\n        q, k, v = (self.to_q(x), *self.to_kv(context).chunk(2, dim = -1))\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> b h n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b h 1 d', h = self.heads,  b = b)\n\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # cosine sim attention\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # similarities\n\n        sim = einsum('b h i d, b h j d -> b h i j', q, k) * self.scale\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        out = einsum('b h i j, b h j d -> b h i d', attn, v)\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\nclass LinearCrossAttention(CrossAttention):\n    def forward(self, x, context, mask = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n        context = self.norm_context(context)\n\n        q, k, v = (self.to_q(x), *self.to_kv(context).chunk(2, dim = -1))\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> (b h) n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> (b h) 1 d', h = self.heads,  b = b)\n\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # masking\n\n        max_neg_value = -torch.finfo(x.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b n -> b n 1')\n            k = k.masked_fill(~mask, max_neg_value)\n            v = v.masked_fill(~mask, 0.)\n\n        # linear attention\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) n d -> b n (h d)', h = self.heads)\n        return self.to_out(out)\n\nclass LinearAttention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_head = 32,\n        heads = 8,\n        dropout = 0.05,\n        context_dim = None,\n        **kwargs\n    ):\n        super().__init__()\n        self.scale = dim_head ** -0.5\n        self.heads = heads\n        inner_dim = dim_head * heads\n        self.norm = ChanLayerNorm(dim)\n\n        self.nonlin = nn.SiLU()\n\n        self.to_q = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_k = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_v = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, inner_dim * 2, bias = False)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Conv2d(inner_dim, dim, 1, bias = False),\n            ChanLayerNorm(dim)\n        )\n\n    def forward(self, fmap, context = None):\n        h, x, y = self.heads, *fmap.shape[-2:]\n\n        fmap = self.norm(fmap)\n        q, k, v = map(lambda fn: fn(fmap), (self.to_q, self.to_k, self.to_v))\n        q, k, v = rearrange_many((q, k, v), 'b (h c) x y -> (b h) (x y) c', h = h)\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            ck, cv = rearrange_many((ck, cv), 'b n (h d) -> (b h) n d', h = h)\n            k = torch.cat((k, ck), dim = -2)\n            v = torch.cat((v, cv), dim = -2)\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) (x y) d -> b (h d) x y', h = h, x = x, y = y)\n\n        out = self.nonlin(out)\n        return self.to_out(out)\n\nclass GlobalContext(nn.Module):\n    \"\"\" basically a superior form of squeeze-excitation that is attention-esque \"\"\"\n\n    def __init__(\n        self,\n        *,\n        dim_in,\n        dim_out\n    ):\n        super().__init__()\n        self.to_k = nn.Conv2d(dim_in, 1, 1)\n        hidden_dim = max(3, dim_out // 2)\n\n        self.net = nn.Sequential(\n            nn.Conv2d(dim_in, hidden_dim, 1),\n            nn.SiLU(),\n            nn.Conv2d(hidden_dim, dim_out, 1),\n            nn.Sigmoid()\n        )\n\n    def forward(self, x):"
  },
  {
    "id": "34",
    "text": " value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> b h 1 d', h = self.heads,  b = b)\n\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # cosine sim attention\n\n        q, k = map(l2norm, (q, k))\n        q = q * self.q_scale\n        k = k * self.k_scale\n\n        # similarities\n\n        sim = einsum('b h i d, b h j d -> b h i j', q, k) * self.scale\n\n        # masking\n\n        max_neg_value = -torch.finfo(sim.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n            sim = sim.masked_fill(~mask, max_neg_value)\n\n        attn = sim.softmax(dim = -1, dtype = torch.float32)\n        attn = attn.to(sim.dtype)\n\n        out = einsum('b h i j, b h j d -> b h i d', attn, v)\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\nclass LinearCrossAttention(CrossAttention):\n    def forward(self, x, context, mask = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n        context = self.norm_context(context)\n\n        q, k, v = (self.to_q(x), *self.to_kv(context).chunk(2, dim = -1))\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> (b h) n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> (b h) 1 d', h = self.heads,  b = b)\n\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # masking\n\n        max_neg_value = -torch.finfo(x.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b n -> b n 1')\n            k = k.masked_fill(~mask, max_neg_value)\n            v = v.masked_fill(~mask, 0.)\n\n        # linear attention\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) n d -> b n (h d)', h = self.heads)\n        return self.to_out(out)\n\nclass LinearAttention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_head = 32,\n        heads = 8,\n        dropout = 0.05,\n        context_dim = None,\n        **kwargs\n    ):\n        super().__init__()\n        self.scale = dim_head ** -0.5\n        self.heads = heads\n        inner_dim = dim_head * heads\n        self.norm = ChanLayerNorm(dim)\n\n        self.nonlin = nn.SiLU()\n\n        self.to_q = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_k = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_v = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, inner_dim * 2, bias = False)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Conv2d(inner_dim, dim, 1, bias = False),\n            ChanLayerNorm(dim)\n        )\n\n    def forward(self, fmap, context = None):\n        h, x, y = self.heads, *fmap.shape[-2:]\n\n        fmap = self.norm(fmap)\n        q, k, v = map(lambda fn: fn(fmap), (self.to_q, self.to_k, self.to_v))\n        q, k, v = rearrange_many((q, k, v), 'b (h c) x y -> (b h) (x y) c', h = h)\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            ck, cv = rearrange_many((ck, cv), 'b n (h d) -> (b h) n d', h = h)\n            k = torch.cat((k, ck), dim = -2)\n            v = torch.cat((v, cv), dim = -2)\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) (x y) d -> b (h d) x y', h = h, x = x, y = y)\n\n        out = self.nonlin(out)\n        return self.to_out(out)\n\nclass GlobalContext(nn.Module):\n    \"\"\" basically a superior form of squeeze-excitation that is attention-esque \"\"\"\n\n    def __init__(\n        self,\n        *,\n        dim_in,\n        dim_out\n    ):\n        super().__init__()\n        self.to_k = nn.Conv2d(dim_in, 1, 1)\n        hidden_dim = max(3, dim_out // 2)\n\n        self.net = nn.Sequential(\n            nn.Conv2d(dim_in, hidden_dim, 1),\n            nn.SiLU(),\n            nn.Conv2d(hidden_dim, dim_out, 1),\n            nn.Sigmoid()\n        )\n\n    def forward(self, x):\n        context = self.to_k(x)\n        x, context = rearrange_many((x, context), 'b n ... -> b n (...)')\n        out = einsum('b i n, b c n -> b c i', context.softmax(dim = -1), x)\n        out = rearrange(out, '... -> ... 1')\n        return self.net(out)\n\ndef FeedForward(dim, mult = 2):"
  },
  {
    "id": "35",
    "text": "float32)\n        attn = attn.to(sim.dtype)\n\n        out = einsum('b h i j, b h j d -> b h i d', attn, v)\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)\n\nclass LinearCrossAttention(CrossAttention):\n    def forward(self, x, context, mask = None):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n        context = self.norm_context(context)\n\n        q, k, v = (self.to_q(x), *self.to_kv(context).chunk(2, dim = -1))\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> (b h) n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> (b h) 1 d', h = self.heads,  b = b)\n\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # masking\n\n        max_neg_value = -torch.finfo(x.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b n -> b n 1')\n            k = k.masked_fill(~mask, max_neg_value)\n            v = v.masked_fill(~mask, 0.)\n\n        # linear attention\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) n d -> b n (h d)', h = self.heads)\n        return self.to_out(out)\n\nclass LinearAttention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_head = 32,\n        heads = 8,\n        dropout = 0.05,\n        context_dim = None,\n        **kwargs\n    ):\n        super().__init__()\n        self.scale = dim_head ** -0.5\n        self.heads = heads\n        inner_dim = dim_head * heads\n        self.norm = ChanLayerNorm(dim)\n\n        self.nonlin = nn.SiLU()\n\n        self.to_q = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_k = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_v = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, inner_dim * 2, bias = False)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Conv2d(inner_dim, dim, 1, bias = False),\n            ChanLayerNorm(dim)\n        )\n\n    def forward(self, fmap, context = None):\n        h, x, y = self.heads, *fmap.shape[-2:]\n\n        fmap = self.norm(fmap)\n        q, k, v = map(lambda fn: fn(fmap), (self.to_q, self.to_k, self.to_v))\n        q, k, v = rearrange_many((q, k, v), 'b (h c) x y -> (b h) (x y) c', h = h)\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            ck, cv = rearrange_many((ck, cv), 'b n (h d) -> (b h) n d', h = h)\n            k = torch.cat((k, ck), dim = -2)\n            v = torch.cat((v, cv), dim = -2)\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) (x y) d -> b (h d) x y', h = h, x = x, y = y)\n\n        out = self.nonlin(out)\n        return self.to_out(out)\n\nclass GlobalContext(nn.Module):\n    \"\"\" basically a superior form of squeeze-excitation that is attention-esque \"\"\"\n\n    def __init__(\n        self,\n        *,\n        dim_in,\n        dim_out\n    ):\n        super().__init__()\n        self.to_k = nn.Conv2d(dim_in, 1, 1)\n        hidden_dim = max(3, dim_out // 2)\n\n        self.net = nn.Sequential(\n            nn.Conv2d(dim_in, hidden_dim, 1),\n            nn.SiLU(),\n            nn.Conv2d(hidden_dim, dim_out, 1),\n            nn.Sigmoid()\n        )\n\n    def forward(self, x):\n        context = self.to_k(x)\n        x, context = rearrange_many((x, context), 'b n ... -> b n (...)')\n        out = einsum('b i n, b c n -> b c i', context.softmax(dim = -1), x)\n        out = rearrange(out, '... -> ... 1')\n        return self.net(out)\n\ndef FeedForward(dim, mult = 2):\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        LayerNorm(dim),\n        nn.Linear(dim, hidden_dim, bias = False),\n        nn.GELU(),\n        LayerNorm(hidden_dim),\n        nn.Linear(hidden_dim, dim, bias = False)\n    )\n\ndef ChanFeedForward(dim, mult = 2):  # in paper, it seems for self attention layers they did feedforwards with twice channel width\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        ChanLayerNorm(dim),\n        nn.Conv2d(dim, hidden_dim, 1, bias = False),\n        nn.GELU(),\n        ChanLayerNorm(hidden_dim),\n        nn.Conv2d(hidden_dim, dim, 1, bias = False)\n    )\n\nclass TransformerBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        depth = 1,\n        heads = 8,\n        dim_head = 32,\n        ff_mult = 2,\n        context_dim = None\n    ):"
  },
  {
    "id": "36",
    "text": "):\n        b, n, device = *x.shape[:2], x.device\n\n        x = self.norm(x)\n        context = self.norm_context(context)\n\n        q, k, v = (self.to_q(x), *self.to_kv(context).chunk(2, dim = -1))\n\n        q, k, v = rearrange_many((q, k, v), 'b n (h d) -> (b h) n d', h = self.heads)\n\n        # add null key / value for classifier free guidance in prior net\n\n        nk, nv = repeat_many(self.null_kv.unbind(dim = -2), 'd -> (b h) 1 d', h = self.heads,  b = b)\n\n        k = torch.cat((nk, k), dim = -2)\n        v = torch.cat((nv, v), dim = -2)\n\n        # masking\n\n        max_neg_value = -torch.finfo(x.dtype).max\n\n        if exists(mask):\n            mask = F.pad(mask, (1, 0), value = True)\n            mask = rearrange(mask, 'b n -> b n 1')\n            k = k.masked_fill(~mask, max_neg_value)\n            v = v.masked_fill(~mask, 0.)\n\n        # linear attention\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) n d -> b n (h d)', h = self.heads)\n        return self.to_out(out)\n\nclass LinearAttention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_head = 32,\n        heads = 8,\n        dropout = 0.05,\n        context_dim = None,\n        **kwargs\n    ):\n        super().__init__()\n        self.scale = dim_head ** -0.5\n        self.heads = heads\n        inner_dim = dim_head * heads\n        self.norm = ChanLayerNorm(dim)\n\n        self.nonlin = nn.SiLU()\n\n        self.to_q = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_k = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_v = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, inner_dim * 2, bias = False)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Conv2d(inner_dim, dim, 1, bias = False),\n            ChanLayerNorm(dim)\n        )\n\n    def forward(self, fmap, context = None):\n        h, x, y = self.heads, *fmap.shape[-2:]\n\n        fmap = self.norm(fmap)\n        q, k, v = map(lambda fn: fn(fmap), (self.to_q, self.to_k, self.to_v))\n        q, k, v = rearrange_many((q, k, v), 'b (h c) x y -> (b h) (x y) c', h = h)\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            ck, cv = rearrange_many((ck, cv), 'b n (h d) -> (b h) n d', h = h)\n            k = torch.cat((k, ck), dim = -2)\n            v = torch.cat((v, cv), dim = -2)\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) (x y) d -> b (h d) x y', h = h, x = x, y = y)\n\n        out = self.nonlin(out)\n        return self.to_out(out)\n\nclass GlobalContext(nn.Module):\n    \"\"\" basically a superior form of squeeze-excitation that is attention-esque \"\"\"\n\n    def __init__(\n        self,\n        *,\n        dim_in,\n        dim_out\n    ):\n        super().__init__()\n        self.to_k = nn.Conv2d(dim_in, 1, 1)\n        hidden_dim = max(3, dim_out // 2)\n\n        self.net = nn.Sequential(\n            nn.Conv2d(dim_in, hidden_dim, 1),\n            nn.SiLU(),\n            nn.Conv2d(hidden_dim, dim_out, 1),\n            nn.Sigmoid()\n        )\n\n    def forward(self, x):\n        context = self.to_k(x)\n        x, context = rearrange_many((x, context), 'b n ... -> b n (...)')\n        out = einsum('b i n, b c n -> b c i', context.softmax(dim = -1), x)\n        out = rearrange(out, '... -> ... 1')\n        return self.net(out)\n\ndef FeedForward(dim, mult = 2):\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        LayerNorm(dim),\n        nn.Linear(dim, hidden_dim, bias = False),\n        nn.GELU(),\n        LayerNorm(hidden_dim),\n        nn.Linear(hidden_dim, dim, bias = False)\n    )\n\ndef ChanFeedForward(dim, mult = 2):  # in paper, it seems for self attention layers they did feedforwards with twice channel width\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        ChanLayerNorm(dim),\n        nn.Conv2d(dim, hidden_dim, 1, bias = False),\n        nn.GELU(),\n        ChanLayerNorm(hidden_dim),\n        nn.Conv2d(hidden_dim, dim, 1, bias = False)\n    )\n\nclass TransformerBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        depth = 1,\n        heads = 8,\n        dim_head = 32,\n        ff_mult = 2,\n        context_dim = None\n    ):\n        super().__init__()\n        self.layers = nn.ModuleList([])\n\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                Attention(dim = dim, heads = heads, dim_head = dim_head, context_dim = context_dim),\n                FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, context = None):"
  },
  {
    "id": "37",
    "text": " einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) n d -> b n (h d)', h = self.heads)\n        return self.to_out(out)\n\nclass LinearAttention(nn.Module):\n    def __init__(\n        self,\n        dim,\n        dim_head = 32,\n        heads = 8,\n        dropout = 0.05,\n        context_dim = None,\n        **kwargs\n    ):\n        super().__init__()\n        self.scale = dim_head ** -0.5\n        self.heads = heads\n        inner_dim = dim_head * heads\n        self.norm = ChanLayerNorm(dim)\n\n        self.nonlin = nn.SiLU()\n\n        self.to_q = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_k = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_v = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, inner_dim * 2, bias = False)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Conv2d(inner_dim, dim, 1, bias = False),\n            ChanLayerNorm(dim)\n        )\n\n    def forward(self, fmap, context = None):\n        h, x, y = self.heads, *fmap.shape[-2:]\n\n        fmap = self.norm(fmap)\n        q, k, v = map(lambda fn: fn(fmap), (self.to_q, self.to_k, self.to_v))\n        q, k, v = rearrange_many((q, k, v), 'b (h c) x y -> (b h) (x y) c', h = h)\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            ck, cv = rearrange_many((ck, cv), 'b n (h d) -> (b h) n d', h = h)\n            k = torch.cat((k, ck), dim = -2)\n            v = torch.cat((v, cv), dim = -2)\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) (x y) d -> b (h d) x y', h = h, x = x, y = y)\n\n        out = self.nonlin(out)\n        return self.to_out(out)\n\nclass GlobalContext(nn.Module):\n    \"\"\" basically a superior form of squeeze-excitation that is attention-esque \"\"\"\n\n    def __init__(\n        self,\n        *,\n        dim_in,\n        dim_out\n    ):\n        super().__init__()\n        self.to_k = nn.Conv2d(dim_in, 1, 1)\n        hidden_dim = max(3, dim_out // 2)\n\n        self.net = nn.Sequential(\n            nn.Conv2d(dim_in, hidden_dim, 1),\n            nn.SiLU(),\n            nn.Conv2d(hidden_dim, dim_out, 1),\n            nn.Sigmoid()\n        )\n\n    def forward(self, x):\n        context = self.to_k(x)\n        x, context = rearrange_many((x, context), 'b n ... -> b n (...)')\n        out = einsum('b i n, b c n -> b c i', context.softmax(dim = -1), x)\n        out = rearrange(out, '... -> ... 1')\n        return self.net(out)\n\ndef FeedForward(dim, mult = 2):\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        LayerNorm(dim),\n        nn.Linear(dim, hidden_dim, bias = False),\n        nn.GELU(),\n        LayerNorm(hidden_dim),\n        nn.Linear(hidden_dim, dim, bias = False)\n    )\n\ndef ChanFeedForward(dim, mult = 2):  # in paper, it seems for self attention layers they did feedforwards with twice channel width\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        ChanLayerNorm(dim),\n        nn.Conv2d(dim, hidden_dim, 1, bias = False),\n        nn.GELU(),\n        ChanLayerNorm(hidden_dim),\n        nn.Conv2d(hidden_dim, dim, 1, bias = False)\n    )\n\nclass TransformerBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        depth = 1,\n        heads = 8,\n        dim_head = 32,\n        ff_mult = 2,\n        context_dim = None\n    ):\n        super().__init__()\n        self.layers = nn.ModuleList([])\n\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                Attention(dim = dim, heads = heads, dim_head = dim_head, context_dim = context_dim),\n                FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, context = None):\n        x = rearrange(x, 'b c h w -> b h w c')\n        x, ps = pack([x], 'b * c')\n\n        for attn, ff in self.layers:\n            x = attn(x, context = context) + x\n            x = ff(x) + x\n\n        x, = unpack(x, ps, 'b * c')\n        x = rearrange(x, 'b h w c -> b c h w')\n        return x\n\nclass LinearAttentionTransformerBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        depth = 1,\n        heads = 8,\n        dim_head = 32,\n        ff_mult = 2,\n        context_dim = None,\n        **kwargs\n    ):\n        super().__init__()\n        self.layers = nn.ModuleList([])\n\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                LinearAttention(dim = dim, heads = heads, dim_head = dim_head, context_dim = context_dim),\n                ChanFeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, context = None):\n        for attn, ff in self.layers:\n            x = attn(x, context = context) + x\n            x = ff(x) + x\n        return x\n\nclass CrossEmbedLayer(nn.Module):\n    def __init__(\n        self,\n        dim_in,\n        kernel_sizes,\n        dim_out = None,\n        stride = 2\n    ):"
  },
  {
    "id": "38",
    "text": "),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_v = nn.Sequential(\n            nn.Dropout(dropout),\n            nn.Conv2d(dim, inner_dim, 1, bias = False),\n            nn.Conv2d(inner_dim, inner_dim, 3, bias = False, padding = 1, groups = inner_dim)\n        )\n\n        self.to_context = nn.Sequential(nn.LayerNorm(context_dim), nn.Linear(context_dim, inner_dim * 2, bias = False)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Conv2d(inner_dim, dim, 1, bias = False),\n            ChanLayerNorm(dim)\n        )\n\n    def forward(self, fmap, context = None):\n        h, x, y = self.heads, *fmap.shape[-2:]\n\n        fmap = self.norm(fmap)\n        q, k, v = map(lambda fn: fn(fmap), (self.to_q, self.to_k, self.to_v))\n        q, k, v = rearrange_many((q, k, v), 'b (h c) x y -> (b h) (x y) c', h = h)\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            ck, cv = rearrange_many((ck, cv), 'b n (h d) -> (b h) n d', h = h)\n            k = torch.cat((k, ck), dim = -2)\n            v = torch.cat((v, cv), dim = -2)\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) (x y) d -> b (h d) x y', h = h, x = x, y = y)\n\n        out = self.nonlin(out)\n        return self.to_out(out)\n\nclass GlobalContext(nn.Module):\n    \"\"\" basically a superior form of squeeze-excitation that is attention-esque \"\"\"\n\n    def __init__(\n        self,\n        *,\n        dim_in,\n        dim_out\n    ):\n        super().__init__()\n        self.to_k = nn.Conv2d(dim_in, 1, 1)\n        hidden_dim = max(3, dim_out // 2)\n\n        self.net = nn.Sequential(\n            nn.Conv2d(dim_in, hidden_dim, 1),\n            nn.SiLU(),\n            nn.Conv2d(hidden_dim, dim_out, 1),\n            nn.Sigmoid()\n        )\n\n    def forward(self, x):\n        context = self.to_k(x)\n        x, context = rearrange_many((x, context), 'b n ... -> b n (...)')\n        out = einsum('b i n, b c n -> b c i', context.softmax(dim = -1), x)\n        out = rearrange(out, '... -> ... 1')\n        return self.net(out)\n\ndef FeedForward(dim, mult = 2):\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        LayerNorm(dim),\n        nn.Linear(dim, hidden_dim, bias = False),\n        nn.GELU(),\n        LayerNorm(hidden_dim),\n        nn.Linear(hidden_dim, dim, bias = False)\n    )\n\ndef ChanFeedForward(dim, mult = 2):  # in paper, it seems for self attention layers they did feedforwards with twice channel width\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        ChanLayerNorm(dim),\n        nn.Conv2d(dim, hidden_dim, 1, bias = False),\n        nn.GELU(),\n        ChanLayerNorm(hidden_dim),\n        nn.Conv2d(hidden_dim, dim, 1, bias = False)\n    )\n\nclass TransformerBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        depth = 1,\n        heads = 8,\n        dim_head = 32,\n        ff_mult = 2,\n        context_dim = None\n    ):\n        super().__init__()\n        self.layers = nn.ModuleList([])\n\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                Attention(dim = dim, heads = heads, dim_head = dim_head, context_dim = context_dim),\n                FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, context = None):\n        x = rearrange(x, 'b c h w -> b h w c')\n        x, ps = pack([x], 'b * c')\n\n        for attn, ff in self.layers:\n            x = attn(x, context = context) + x\n            x = ff(x) + x\n\n        x, = unpack(x, ps, 'b * c')\n        x = rearrange(x, 'b h w c -> b c h w')\n        return x\n\nclass LinearAttentionTransformerBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        depth = 1,\n        heads = 8,\n        dim_head = 32,\n        ff_mult = 2,\n        context_dim = None,\n        **kwargs\n    ):\n        super().__init__()\n        self.layers = nn.ModuleList([])\n\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                LinearAttention(dim = dim, heads = heads, dim_head = dim_head, context_dim = context_dim),\n                ChanFeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, context = None):\n        for attn, ff in self.layers:\n            x = attn(x, context = context) + x\n            x = ff(x) + x\n        return x\n\nclass CrossEmbedLayer(nn.Module):\n    def __init__(\n        self,\n        dim_in,\n        kernel_sizes,\n        dim_out = None,\n        stride = 2\n    ):\n        super().__init__()\n        assert all([*map(lambda t: (t % 2) == (stride % 2), kernel_sizes)])\n        dim_out = default(dim_out, dim_in)\n\n        kernel_sizes = sorted(kernel_sizes)\n        num_scales = len(kernel_sizes)\n\n        # calculate the dimension at each scale\n        dim_scales = [int(dim_out / (2 ** i)) for i in range(1, num_scales)]\n        dim_scales = [*dim_scales, dim_out - sum(dim_scales)]\n\n        self.convs = nn.ModuleList([])\n        for kernel, dim_scale in zip(kernel_sizes, dim_scales):\n            self.convs.append(nn.Conv2d(dim_in, dim_scale, kernel, stride = stride, padding = (kernel - stride) // 2))\n\n    def forward(self, x):\n        fmaps = tuple(map(lambda conv: conv(x), self.convs))\n        return torch.cat(fmaps, dim = 1)\n\nclass UpsampleCombiner(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        enabled = False,\n        dim_ins = tuple(),\n        dim_outs = tuple()\n    ):"
  },
  {
    "id": "39",
    "text": " bias = False)) if exists(context_dim) else None\n\n        self.to_out = nn.Sequential(\n            nn.Conv2d(inner_dim, dim, 1, bias = False),\n            ChanLayerNorm(dim)\n        )\n\n    def forward(self, fmap, context = None):\n        h, x, y = self.heads, *fmap.shape[-2:]\n\n        fmap = self.norm(fmap)\n        q, k, v = map(lambda fn: fn(fmap), (self.to_q, self.to_k, self.to_v))\n        q, k, v = rearrange_many((q, k, v), 'b (h c) x y -> (b h) (x y) c', h = h)\n\n        if exists(context):\n            assert exists(self.to_context)\n            ck, cv = self.to_context(context).chunk(2, dim = -1)\n            ck, cv = rearrange_many((ck, cv), 'b n (h d) -> (b h) n d', h = h)\n            k = torch.cat((k, ck), dim = -2)\n            v = torch.cat((v, cv), dim = -2)\n\n        q = q.softmax(dim = -1)\n        k = k.softmax(dim = -2)\n\n        q = q * self.scale\n\n        context = einsum('b n d, b n e -> b d e', k, v)\n        out = einsum('b n d, b d e -> b n e', q, context)\n        out = rearrange(out, '(b h) (x y) d -> b (h d) x y', h = h, x = x, y = y)\n\n        out = self.nonlin(out)\n        return self.to_out(out)\n\nclass GlobalContext(nn.Module):\n    \"\"\" basically a superior form of squeeze-excitation that is attention-esque \"\"\"\n\n    def __init__(\n        self,\n        *,\n        dim_in,\n        dim_out\n    ):\n        super().__init__()\n        self.to_k = nn.Conv2d(dim_in, 1, 1)\n        hidden_dim = max(3, dim_out // 2)\n\n        self.net = nn.Sequential(\n            nn.Conv2d(dim_in, hidden_dim, 1),\n            nn.SiLU(),\n            nn.Conv2d(hidden_dim, dim_out, 1),\n            nn.Sigmoid()\n        )\n\n    def forward(self, x):\n        context = self.to_k(x)\n        x, context = rearrange_many((x, context), 'b n ... -> b n (...)')\n        out = einsum('b i n, b c n -> b c i', context.softmax(dim = -1), x)\n        out = rearrange(out, '... -> ... 1')\n        return self.net(out)\n\ndef FeedForward(dim, mult = 2):\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        LayerNorm(dim),\n        nn.Linear(dim, hidden_dim, bias = False),\n        nn.GELU(),\n        LayerNorm(hidden_dim),\n        nn.Linear(hidden_dim, dim, bias = False)\n    )\n\ndef ChanFeedForward(dim, mult = 2):  # in paper, it seems for self attention layers they did feedforwards with twice channel width\n    hidden_dim = int(dim * mult)\n    return nn.Sequential(\n        ChanLayerNorm(dim),\n        nn.Conv2d(dim, hidden_dim, 1, bias = False),\n        nn.GELU(),\n        ChanLayerNorm(hidden_dim),\n        nn.Conv2d(hidden_dim, dim, 1, bias = False)\n    )\n\nclass TransformerBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        depth = 1,\n        heads = 8,\n        dim_head = 32,\n        ff_mult = 2,\n        context_dim = None\n    ):\n        super().__init__()\n        self.layers = nn.ModuleList([])\n\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                Attention(dim = dim, heads = heads, dim_head = dim_head, context_dim = context_dim),\n                FeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, context = None):\n        x = rearrange(x, 'b c h w -> b h w c')\n        x, ps = pack([x], 'b * c')\n\n        for attn, ff in self.layers:\n            x = attn(x, context = context) + x\n            x = ff(x) + x\n\n        x, = unpack(x, ps, 'b * c')\n        x = rearrange(x, 'b h w c -> b c h w')\n        return x\n\nclass LinearAttentionTransformerBlock(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        depth = 1,\n        heads = 8,\n        dim_head = 32,\n        ff_mult = 2,\n        context_dim = None,\n        **kwargs\n    ):\n        super().__init__()\n        self.layers = nn.ModuleList([])\n\n        for _ in range(depth):\n            self.layers.append(nn.ModuleList([\n                LinearAttention(dim = dim, heads = heads, dim_head = dim_head, context_dim = context_dim),\n                ChanFeedForward(dim = dim, mult = ff_mult)\n            ]))\n\n    def forward(self, x, context = None):\n        for attn, ff in self.layers:\n            x = attn(x, context = context) + x\n            x = ff(x) + x\n        return x\n\nclass CrossEmbedLayer(nn.Module):\n    def __init__(\n        self,\n        dim_in,\n        kernel_sizes,\n        dim_out = None,\n        stride = 2\n    ):\n        super().__init__()\n        assert all([*map(lambda t: (t % 2) == (stride % 2), kernel_sizes)])\n        dim_out = default(dim_out, dim_in)\n\n        kernel_sizes = sorted(kernel_sizes)\n        num_scales = len(kernel_sizes)\n\n        # calculate the dimension at each scale\n        dim_scales = [int(dim_out / (2 ** i)) for i in range(1, num_scales)]\n        dim_scales = [*dim_scales, dim_out - sum(dim_scales)]\n\n        self.convs = nn.ModuleList([])\n        for kernel, dim_scale in zip(kernel_sizes, dim_scales):\n            self.convs.append(nn.Conv2d(dim_in, dim_scale, kernel, stride = stride, padding = (kernel - stride) // 2))\n\n    def forward(self, x):\n        fmaps = tuple(map(lambda conv: conv(x), self.convs))\n        return torch.cat(fmaps, dim = 1)\n\nclass UpsampleCombiner(nn.Module):\n    def __init__(\n        self,\n        dim,\n        *,\n        enabled = False,\n        dim_ins = tuple(),\n        dim_outs = tuple()\n    ):\n        super().__init__()\n        dim_outs = cast_tuple(dim_outs, len(dim_ins))\n        assert len(dim_ins) == len(dim_outs)\n\n        self.enabled = enabled\n\n        if not self.enabled:\n            self.dim_out = dim\n            return\n\n        self.fmap_convs = nn.ModuleList([Block(dim_in, dim_out) for dim_in, dim_out in zip(dim_ins, dim_outs)])\n        self.dim_out = dim + (sum(dim_outs) if len(dim_outs) > 0 else 0)\n\n    def forward(self, x, fmaps = None):"
  },
  {
    "id": "40",
    "text": " = Downsample\n\n        if cross_embed_downsample:\n            downsample_klass = partial(CrossEmbedLayer, kernel_sizes = cross_embed_downsample_kernel_sizes)\n\n        # initial resnet block (for memory efficient unet)\n\n        self.init_resnet_block = resnet_klass(init_dim, init_dim, time_cond_dim = time_cond_dim, groups = resnet_groups[0], use_gca = use_global_context_attn) if memory_efficient else None\n\n        # scale for resnet skip connections\n\n        self.skip_connect_scale = 1. if not scale_skip_connection else (2 ** -0.5)\n\n        # layers\n\n        self.downs = nn.ModuleList([])\n        self.ups = nn.ModuleList([])\n        num_resolutions = len(in_out)\n\n        layer_params = [num_resnet_blocks, resnet_groups, layer_attns, layer_attns_depth, layer_cross_attns, use_linear_attn, use_linear_cross_attn]\n        reversed_layer_params = list(map(reversed, layer_params))\n\n        # downsampling layers\n\n        skip_connect_dims = [] # keep track of skip connection dimensions\n\n        for ind, ((dim_in, dim_out), layer_num_resnet_blocks, groups, layer_attn, layer_attn_depth, layer_cross_attn, layer_use_linear_attn, layer_use_linear_cross_attn) in enumerate(zip(in_out, *layer_params)):\n            is_last = ind >= (num_resolutions - 1)\n\n            layer_cond_dim = cond_dim if layer_cross_attn or layer_use_linear_cross_attn else None\n\n            if layer_attn:\n                transformer_block_klass = TransformerBlock\n            elif layer_use_linear_attn:\n                transformer_block_klass = LinearAttentionTransformerBlock\n            else:\n                transformer_block_klass = Identity\n\n            current_dim = dim_in\n\n            # whether to pre-downsample, from memory efficient unet\n\n            pre_downsample = None\n\n            if memory_efficient:\n                pre_downsample = downsample_klass(dim_in, dim_out)\n                current_dim = dim_out\n\n            skip_connect_dims.append(current_dim)\n\n            # whether to do post-downsample, for non-memory efficient unet\n\n            post_downsample = None\n            if not memory_efficient:\n                post_downsample = downsample_klass(current_dim, dim_out) if not is_last else Parallel(nn.Conv2d(dim_in, dim_out, 3, padding = 1), nn.Conv2d(dim_in, dim_out, 1))\n\n            self.downs.append(nn.ModuleList([\n                pre_downsample,\n                resnet_klass(current_dim, current_dim, cond_dim = layer_cond_dim, linear_attn = layer_use_linear_cross_attn, time_cond_dim = time_cond_dim, groups = groups),\n                nn.ModuleList([ResnetBlock(current_dim, current_dim, time_cond_dim = time_cond_dim, groups = groups, use_gca = use_global_context_attn) for _ in range(layer_num_resnet_blocks)]),\n                transformer_block_klass(dim = current_dim, depth = layer_attn_depth, ff_mult = ff_mult, context_dim = cond_dim, **attn_kwargs),\n                post_downsample\n            ]))\n\n        # middle layers\n\n        mid_dim = dims[-1]\n\n        self.mid_block1 = ResnetBlock(mid_dim, mid_dim, cond_dim = cond_dim, time_cond_dim = time_cond_dim, groups = resnet_groups[-1])\n        self.mid_attn = TransformerBlock(mid_dim, depth = layer_mid_attns_depth, **attn_kwargs) if attend_at_middle else None\n        self.mid_block2 = ResnetBlock(mid_dim, mid_dim, cond_dim = cond_dim, time_cond_dim = time_cond_dim, groups = resnet_groups[-1])\n\n        # upsample klass\n\n        upsample_klass = Upsample if not pixel_shuffle_upsample else PixelShuffleUpsample\n\n        # upsampling layers\n\n        upsample_fmap_dims = []\n\n        for ind, ((dim_in, dim_out), layer_num_resnet_blocks, groups, layer_attn, layer_attn_depth, layer_cross_attn, layer_use_linear_attn, layer_use_linear_cross_attn) in enumerate(zip(reversed(in_out), *reversed_layer_params)):\n            is_last = ind == (len(in_out) - 1)\n\n            layer_cond_dim = cond_dim if layer_cross_attn or layer_use_linear_cross_attn else None\n\n            if layer_attn:\n                transformer_block_klass = TransformerBlock\n            elif layer_use_linear_attn:\n                transformer_block_klass = LinearAttentionTransformerBlock\n            else:\n                transformer_block_klass = Identity\n\n            skip_connect_dim = skip_connect_dims.pop()\n\n            upsample_fmap_dims.append(dim_out)\n\n            self.ups.append(nn.ModuleList([\n                resnet_klass(dim_out + skip_connect_dim, dim_out, cond_dim = layer_cond_dim, linear_attn = layer_use_linear_cross_attn, time_cond_dim = time_cond_dim, groups = groups),\n                nn.ModuleList([ResnetBlock(dim_out + skip_connect_dim, dim_out, time_cond_dim = time_cond_dim, groups = groups, use_gca = use_global_context_attn) for _ in range(layer_num_resnet_blocks)]),\n                transformer_block_klass(dim = dim_out, depth = layer_attn_depth, ff_mult = ff_mult, context_dim = cond_dim, **attn_kwargs),\n                upsample_klass(dim_out, dim_in) if not is_last or memory_efficient else Identity()\n            ]))\n\n        # whether to combine feature maps from all upsample blocks before final resnet block out\n\n        self.upsample_combiner = UpsampleCombiner(\n            dim = dim,\n            enabled = combine_upsample_fmaps,\n            dim_ins = upsample_fmap_dims,\n            dim_outs = dim\n        )\n\n        # whether to do a final residual from initial conv to the final resnet block out\n\n        self.init_conv_to_final_conv_residual = init_conv_to_final_conv_residual\n        final_conv_dim = self.upsample_combiner.dim_out + (dim if init_conv_to_final_conv_residual else 0)\n\n        # final optional resnet block and convolution out\n\n        self.final_res_block = ResnetBlock(final_conv_dim, dim, time_cond_dim = time_cond_dim, groups = resnet_groups[0], use_gca = True) if final_resnet_block else None\n\n        final_conv_dim_in = dim if final_resnet_block else final_conv_dim\n        final_conv_dim_in += (channels if lowres_cond else 0)\n\n        self.final_conv = nn.Conv2d(final_conv_dim_in, self.channels_out, final_conv_kernel_size, padding = final_conv_kernel_size // 2)\n\n        zero_init_(self.final_conv)\n\n        # resize mode\n\n        self.resize_mode = resize_mode\n\n    # if the current settings for the unet are not correct\n    # for cascading DDPM, then reinit the unet with the right settings\n    def cast_model_parameters(\n        self,\n        *,\n        lowres_cond,\n        text_embed_dim,\n        channels,\n        channels_out,\n        cond_on_text\n    ):"
  },
  {
    "id": "41",
    "text": "        # loss\n\n        if loss_type == 'l1':\n            loss_fn = F.l1_loss\n        elif loss_type == 'l2':\n            loss_fn = F.mse_loss\n        elif loss_type == 'huber':\n            loss_fn = F.smooth_l1_loss\n        else:\n            raise NotImplementedError()\n\n        self.loss_type = loss_type\n        self.loss_fn = loss_fn\n\n        # conditioning hparams\n\n        self.condition_on_text = condition_on_text\n        self.unconditional = not condition_on_text\n\n        # channels\n\n        self.channels = channels\n\n        # automatically take care of ensuring that first unet is unconditional\n        # while the rest of the unets are conditioned on the low resolution image produced by previous unet\n\n        unets = cast_tuple(unets)\n        num_unets = len(unets)\n\n        # determine noise schedules per unet\n\n        timesteps = cast_tuple(timesteps, num_unets)\n\n        # make sure noise schedule defaults to 'cosine', 'cosine', and then 'linear' for rest of super-resoluting unets\n\n        noise_schedules = cast_tuple(noise_schedules)\n        noise_schedules = pad_tuple_to_length(noise_schedules, 2, 'cosine')\n        noise_schedules = pad_tuple_to_length(noise_schedules, num_unets, 'linear')\n\n        # construct noise schedulers\n\n        noise_scheduler_klass = GaussianDiffusionContinuousTimes\n        self.noise_schedulers = nn.ModuleList([])\n\n        for timestep, noise_schedule in zip(timesteps, noise_schedules):\n            noise_scheduler = noise_scheduler_klass(noise_schedule = noise_schedule, timesteps = timestep)\n            self.noise_schedulers.append(noise_scheduler)\n\n        # randomly cropping for upsampler training\n\n        self.random_crop_sizes = cast_tuple(random_crop_sizes, num_unets)\n        assert not exists(first(self.random_crop_sizes)), 'you should not need to randomly crop image during training for base unet, only for upsamplers - so pass in `random_crop_sizes = (None, 128, 256)` as example'\n\n        # lowres augmentation noise schedule\n\n        self.lowres_noise_schedule = GaussianDiffusionContinuousTimes(noise_schedule = lowres_noise_schedule)\n\n        # ddpm objectives - predicting noise by default\n\n        self.pred_objectives = cast_tuple(pred_objectives, num_unets)\n\n        # get text encoder\n\n        self.text_encoder_name = text_encoder_name\n        self.text_embed_dim = default(text_embed_dim, lambda: get_encoded_dim(text_encoder_name))\n\n        self.encode_text = partial(t5_encode_text, name = text_encoder_name)\n\n        # construct unets\n\n        self.unets = nn.ModuleList([])\n\n        self.unet_being_trained_index = -1 # keeps track of which unet is being trained at the moment\n        self.only_train_unet_number = only_train_unet_number\n\n        for ind, one_unet in enumerate(unets):\n            assert isinstance(one_unet, (Unet, Unet3D, NullUnet))\n            is_first = ind == 0\n\n            one_unet = one_unet.cast_model_parameters(\n                lowres_cond = not is_first,\n                cond_on_text = self.condition_on_text,\n                text_embed_dim = self.text_embed_dim if self.condition_on_text else None,\n                channels = self.channels,\n                channels_out = self.channels\n            )\n\n            self.unets.append(one_unet)\n\n        # unet image sizes\n\n        image_sizes = cast_tuple(image_sizes)\n        self.image_sizes = image_sizes\n\n        assert num_unets == len(image_sizes), f'you did not supply the correct number of u-nets ({len(unets)}) for resolutions {image_sizes}'\n\n        self.sample_channels = cast_tuple(self.channels, num_unets)\n\n        # determine whether we are training on images or video\n\n        is_video = any([isinstance(unet, Unet3D) for unet in self.unets])\n        self.is_video = is_video\n\n        self.right_pad_dims_to_datatype = partial(rearrange, pattern = ('b -> b 1 1 1' if not is_video else 'b -> b 1 1 1 1'))\n\n        self.resize_to = resize_video_to if is_video else resize_image_to\n        self.resize_to = partial(self.resize_to, mode = resize_mode)\n\n        # temporal interpolation\n\n        temporal_downsample_factor = cast_tuple(temporal_downsample_factor, num_unets)\n        self.temporal_downsample_factor = temporal_downsample_factor\n\n        self.resize_cond_video_frames = resize_cond_video_frames\n        self.temporal_downsample_divisor = temporal_downsample_factor[0]\n\n        assert temporal_downsample_factor[-1] == 1, 'downsample factor of last stage must be 1'\n        assert tuple(sorted(temporal_downsample_factor, reverse = True)) == temporal_downsample_factor, 'temporal downsample factor must be in order of descending'\n\n        # cascading ddpm related stuff\n\n        lowres_conditions = tuple(map(lambda t: t.lowres_cond, self.unets))\n        assert lowres_conditions == (False, *((True,) * (num_unets - 1))), 'the first unet must be unconditioned (by low resolution image), and the rest of the unets must have `lowres_cond` set to True'\n\n        self.lowres_sample_noise_level = lowres_sample_noise_level\n        self.per_sample_random_aug_noise_level = per_sample_random_aug_noise_level\n\n        # classifier free guidance\n\n        self.cond_drop_prob = cond_drop_prob\n        self.can_classifier_guidance = cond_drop_prob > 0.\n\n        # normalize and unnormalize image functions\n\n        self.normalize_img = normalize_neg_one_to_one if auto_normalize_img else identity\n        self.unnormalize_img = unnormalize_zero_to_one if auto_normalize_img else identity\n        self.input_image_range = (0. if auto_normalize_img else -1., 1.)\n\n        # dynamic thresholding\n\n        self.dynamic_thresholding = cast_tuple(dynamic_thresholding, num_unets)\n        self.dynamic_thresholding_percentile = dynamic_thresholding_percentile\n\n        # p2 loss weight\n\n        self.p2_loss_weight_k = p2_loss_weight_k\n        self.p2_loss_weight_gamma = cast_tuple(p2_loss_weight_gamma, num_unets)\n\n        assert all([(gamma_value <= 2) for gamma_value in self.p2_loss_weight_gamma]), 'in paper, they noticed any gamma greater than 2 is harmful'\n\n        # one temp parameter for keeping track of device\n\n        self.register_buffer('_temp', torch.tensor([0.]), persistent = False)\n\n        # default to device of unets passed in\n\n        self.to(next(self.unets.parameters()).device)\n\n    def force_unconditional_(self):\n        self.condition_on_text = False\n        self.unconditional = True\n\n        for unet in self.unets:\n            unet.cond_on_text = False\n\n    @property\n    def device(self):\n        return self._temp.device\n\n    def get_unet(self, unet_number):"
  },
  {
    "id": "42",
    "text": "import json\nfrom pydantic import BaseModel, validator, root_validator\nfrom typing import List, Iterable, Optional, Union, Tuple, Dict, Any\nfrom enum import Enum\n\nfrom imagen_pytorch.imagen_pytorch import Imagen, Unet, Unet3D, NullUnet\nfrom imagen_pytorch.trainer import ImagenTrainer\nfrom imagen_pytorch.elucidated_imagen import ElucidatedImagen\nfrom imagen_pytorch.t5 import DEFAULT_T5_NAME, get_encoded_dim\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    return val if exists(val) else d\n\ndef ListOrTuple(inner_type):\n    return Union[List[inner_type], Tuple[inner_type]]\n\ndef SingleOrList(inner_type):\n    return Union[inner_type, ListOrTuple(inner_type)]\n\n# noise schedule\n\nclass NoiseSchedule(Enum):\n    cosine = 'cosine'\n    linear = 'linear'\n\nclass AllowExtraBaseModel(BaseModel):\n    class Config:\n        extra = \"allow\"\n        use_enum_values = True\n\n# imagen pydantic classes\n\nclass NullUnetConfig(BaseModel):\n    is_null:            bool\n\n    def create(self):\n        return NullUnet()\n\nclass UnetConfig(AllowExtraBaseModel):\n    dim:                int\n    dim_mults:          ListOrTuple(int)\n    text_embed_dim:     int = get_encoded_dim(DEFAULT_T5_NAME)\n    cond_dim:           int = None\n    channels:           int = 3\n    attn_dim_head:      int = 32\n    attn_heads:         int = 16\n\n    def create(self):\n        return Unet(**self.dict())\n\nclass Unet3DConfig(AllowExtraBaseModel):\n    dim:                int\n    dim_mults:          ListOrTuple(int)\n    text_embed_dim:     int = get_encoded_dim(DEFAULT_T5_NAME)\n    cond_dim:           int = None\n    channels:           int = 3\n    attn_dim_head:      int = 32\n    attn_heads:         int = 16\n\n    def create(self):\n        return Unet3D(**self.dict())\n\nclass ImagenConfig(AllowExtraBaseModel):\n    unets:                  ListOrTuple(Union[UnetConfig, Unet3DConfig, NullUnetConfig])\n    image_sizes:            ListOrTuple(int)\n    video:                  bool = False\n    timesteps:              SingleOrList(int) = 1000\n    noise_schedules:        SingleOrList(NoiseSchedule) = 'cosine'\n    text_encoder_name:      str = DEFAULT_T5_NAME\n    channels:               int = 3\n    loss_type:              str = 'l2'\n    cond_drop_prob:         float = 0.5\n\n    @validator('image_sizes')\n    def check_image_sizes(cls, image_sizes, values):"
  },
  {
    "id": "43",
    "text": "import json\nfrom pydantic import BaseModel, validator, root_validator\nfrom typing import List, Iterable, Optional, Union, Tuple, Dict, Any\nfrom enum import Enum\n\nfrom imagen_pytorch.imagen_pytorch import Imagen, Unet, Unet3D, NullUnet\nfrom imagen_pytorch.trainer import ImagenTrainer\nfrom imagen_pytorch.elucidated_imagen import ElucidatedImagen\nfrom imagen_pytorch.t5 import DEFAULT_T5_NAME, get_encoded_dim\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    return val if exists(val) else d\n\ndef ListOrTuple(inner_type):\n    return Union[List[inner_type], Tuple[inner_type]]\n\ndef SingleOrList(inner_type):\n    return Union[inner_type, ListOrTuple(inner_type)]\n\n# noise schedule\n\nclass NoiseSchedule(Enum):\n    cosine = 'cosine'\n    linear = 'linear'\n\nclass AllowExtraBaseModel(BaseModel):\n    class Config:\n        extra = \"allow\"\n        use_enum_values = True\n\n# imagen pydantic classes\n\nclass NullUnetConfig(BaseModel):\n    is_null:            bool\n\n    def create(self):\n        return NullUnet()\n\nclass UnetConfig(AllowExtraBaseModel):\n    dim:                int\n    dim_mults:          ListOrTuple(int)\n    text_embed_dim:     int = get_encoded_dim(DEFAULT_T5_NAME)\n    cond_dim:           int = None\n    channels:           int = 3\n    attn_dim_head:      int = 32\n    attn_heads:         int = 16\n\n    def create(self):\n        return Unet(**self.dict())\n\nclass Unet3DConfig(AllowExtraBaseModel):\n    dim:                int\n    dim_mults:          ListOrTuple(int)\n    text_embed_dim:     int = get_encoded_dim(DEFAULT_T5_NAME)\n    cond_dim:           int = None\n    channels:           int = 3\n    attn_dim_head:      int = 32\n    attn_heads:         int = 16\n\n    def create(self):\n        return Unet3D(**self.dict())\n\nclass ImagenConfig(AllowExtraBaseModel):\n    unets:                  ListOrTuple(Union[UnetConfig, Unet3DConfig, NullUnetConfig])\n    image_sizes:            ListOrTuple(int)\n    video:                  bool = False\n    timesteps:              SingleOrList(int) = 1000\n    noise_schedules:        SingleOrList(NoiseSchedule) = 'cosine'\n    text_encoder_name:      str = DEFAULT_T5_NAME\n    channels:               int = 3\n    loss_type:              str = 'l2'\n    cond_drop_prob:         float = 0.5\n\n    @validator('image_sizes')\n    def check_image_sizes(cls, image_sizes, values):\n        unets = values.get('unets')\n        if len(image_sizes) != len(unets):\n            raise ValueError(f'image sizes length {len(image_sizes)} must be equivalent to the number of unets {len(unets)}')\n        return image_sizes\n\n    def create(self):"
  },
  {
    "id": "44",
    "text": "from pathlib import Path\nfrom functools import partial\n\nimport torch\nfrom torch import nn\nfrom torch.utils.data import Dataset, DataLoader\nfrom torchvision import transforms as T, utils\nimport torch.nn.functional as F\nfrom imagen_pytorch import t5\nfrom torch.nn.utils.rnn import pad_sequence\n\nfrom PIL import Image\n\nfrom datasets.utils.file_utils import get_datasets_user_agent\nimport io\nimport urllib\n\nUSER_AGENT = get_datasets_user_agent()\n\n# helpers functions\n\ndef exists(val):\n    return val is not None\n\ndef cycle(dl):"
  },
  {
    "id": "45",
    "text": "import math\nimport copy\nimport operator\nimport functools\nfrom typing import List\nfrom tqdm.auto import tqdm\nfrom functools import partial, wraps\nfrom contextlib import contextmanager, nullcontext\nfrom collections import namedtuple\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch import nn, einsum\n\nfrom einops import rearrange, repeat, reduce, pack, unpack\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops_exts import rearrange_many, repeat_many, check_shape\nfrom einops_exts.torch import EinopsToAndFrom\n\nfrom imagen_pytorch.t5 import t5_encode_text, get_encoded_dim, DEFAULT_T5_NAME\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef identity(t, *args, **kwargs):\n    return t\n\ndef first(arr, d = None):\n    if len(arr) == 0:\n        return d\n    return arr[0]\n\ndef divisible_by(numer, denom):\n    return (numer % denom) == 0\n\ndef maybe(fn):\n    @wraps(fn)\n    def inner(x):\n        if not exists(x):\n            return x\n        return fn(x)\n    return inner\n\ndef once(fn):"
  },
  {
    "id": "46",
    "text": "import torch\nimport transformers\nfrom typing import List\nfrom transformers import T5Tokenizer, T5EncoderModel, T5Config\nfrom einops import rearrange\n\ntransformers.logging.set_verbosity_error()\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\n# config\n\nMAX_LENGTH = 256\n\nDEFAULT_T5_NAME = 'google/t5-v1_1-base'\n\nT5_CONFIGS = {}\n\n# singleton globals\n\ndef get_tokenizer(name):\n    tokenizer = T5Tokenizer.from_pretrained(name, model_max_length=MAX_LENGTH)\n    return tokenizer\n\ndef get_model(name):\n    model = T5EncoderModel.from_pretrained(name)\n    return model\n\ndef get_model_and_tokenizer(name):\n    global T5_CONFIGS\n\n    if name not in T5_CONFIGS:\n        T5_CONFIGS[name] = dict()\n    if \"model\" not in T5_CONFIGS[name]:\n        T5_CONFIGS[name][\"model\"] = get_model(name)\n    if \"tokenizer\" not in T5_CONFIGS[name]:\n        T5_CONFIGS[name][\"tokenizer\"] = get_tokenizer(name)\n\n    return T5_CONFIGS[name]['model'], T5_CONFIGS[name]['tokenizer']\n\ndef get_encoded_dim(name):"
  },
  {
    "id": "47",
    "text": "import os\nimport time\nimport copy\nfrom pathlib import Path\nfrom math import ceil\nfrom contextlib import contextmanager, nullcontext\nfrom functools import partial, wraps\nfrom collections.abc import Iterable\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.utils.data import random_split, DataLoader\nfrom torch.optim import Adam\nfrom lion_pytorch import Lion\nfrom torch.optim.lr_scheduler import CosineAnnealingLR, LambdaLR\nfrom torch.cuda.amp import autocast, GradScaler\n\nimport pytorch_warmup as warmup\n\nfrom imagen_pytorch.imagen_pytorch import Imagen, NullUnet\nfrom imagen_pytorch.elucidated_imagen import ElucidatedImagen\nfrom imagen_pytorch.data import cycle\n\nfrom imagen_pytorch.version import __version__\nfrom packaging import version\n\nimport numpy as np\n\nfrom ema_pytorch import EMA\n\nfrom accelerate import Accelerator, DistributedType, DistributedDataParallelKwargs\n\nfrom fsspec.core import url_to_fs\nfrom fsspec.implementations.local import LocalFileSystem\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):"
  },
  {
    "id": "48",
    "text": "import os\nimport time\nimport copy\nfrom pathlib import Path\nfrom math import ceil\nfrom contextlib import contextmanager, nullcontext\nfrom functools import partial, wraps\nfrom collections.abc import Iterable\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.utils.data import random_split, DataLoader\nfrom torch.optim import Adam\nfrom lion_pytorch import Lion\nfrom torch.optim.lr_scheduler import CosineAnnealingLR, LambdaLR\nfrom torch.cuda.amp import autocast, GradScaler\n\nimport pytorch_warmup as warmup\n\nfrom imagen_pytorch.imagen_pytorch import Imagen, NullUnet\nfrom imagen_pytorch.elucidated_imagen import ElucidatedImagen\nfrom imagen_pytorch.data import cycle\n\nfrom imagen_pytorch.version import __version__\nfrom packaging import version\n\nimport numpy as np\n\nfrom ema_pytorch import EMA\n\nfrom accelerate import Accelerator, DistributedType, DistributedDataParallelKwargs\n\nfrom fsspec.core import url_to_fs\nfrom fsspec.implementations.local import LocalFileSystem\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = 1):"
  },
  {
    "id": "49",
    "text": "import os\nimport time\nimport copy\nfrom pathlib import Path\nfrom math import ceil\nfrom contextlib import contextmanager, nullcontext\nfrom functools import partial, wraps\nfrom collections.abc import Iterable\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.utils.data import random_split, DataLoader\nfrom torch.optim import Adam\nfrom lion_pytorch import Lion\nfrom torch.optim.lr_scheduler import CosineAnnealingLR, LambdaLR\nfrom torch.cuda.amp import autocast, GradScaler\n\nimport pytorch_warmup as warmup\n\nfrom imagen_pytorch.imagen_pytorch import Imagen, NullUnet\nfrom imagen_pytorch.elucidated_imagen import ElucidatedImagen\nfrom imagen_pytorch.data import cycle\n\nfrom imagen_pytorch.version import __version__\nfrom packaging import version\n\nimport numpy as np\n\nfrom ema_pytorch import EMA\n\nfrom accelerate import Accelerator, DistributedType, DistributedDataParallelKwargs\n\nfrom fsspec.core import url_to_fs\nfrom fsspec.implementations.local import LocalFileSystem\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = 1):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    return val if isinstance(val, tuple) else ((val,) * length)\n\ndef find_first(fn, arr):\n    for ind, el in enumerate(arr):\n        if fn(el):\n            return ind\n    return -1\n\ndef pick_and_pop(keys, d):\n    values = list(map(lambda key: d.pop(key), keys))\n    return dict(zip(keys, values))\n\ndef group_dict_by_key(cond, d):"
  },
  {
    "id": "50",
    "text": "import os\nimport time\nimport copy\nfrom pathlib import Path\nfrom math import ceil\nfrom contextlib import contextmanager, nullcontext\nfrom functools import partial, wraps\nfrom collections.abc import Iterable\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.utils.data import random_split, DataLoader\nfrom torch.optim import Adam\nfrom lion_pytorch import Lion\nfrom torch.optim.lr_scheduler import CosineAnnealingLR, LambdaLR\nfrom torch.cuda.amp import autocast, GradScaler\n\nimport pytorch_warmup as warmup\n\nfrom imagen_pytorch.imagen_pytorch import Imagen, NullUnet\nfrom imagen_pytorch.elucidated_imagen import ElucidatedImagen\nfrom imagen_pytorch.data import cycle\n\nfrom imagen_pytorch.version import __version__\nfrom packaging import version\n\nimport numpy as np\n\nfrom ema_pytorch import EMA\n\nfrom accelerate import Accelerator, DistributedType, DistributedDataParallelKwargs\n\nfrom fsspec.core import url_to_fs\nfrom fsspec.implementations.local import LocalFileSystem\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = 1):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    return val if isinstance(val, tuple) else ((val,) * length)\n\ndef find_first(fn, arr):\n    for ind, el in enumerate(arr):\n        if fn(el):\n            return ind\n    return -1\n\ndef pick_and_pop(keys, d):\n    values = list(map(lambda key: d.pop(key), keys))\n    return dict(zip(keys, values))\n\ndef group_dict_by_key(cond, d):\n    return_val = [dict(),dict()]\n    for key in d.keys():\n        match = bool(cond(key))\n        ind = int(not match)\n        return_val[ind][key] = d[key]\n    return (*return_val,)\n\ndef string_begins_with(prefix, str):\n    return str.startswith(prefix)\n\ndef group_by_key_prefix(prefix, d):\n    return group_dict_by_key(partial(string_begins_with, prefix), d)\n\ndef groupby_prefix_and_trim(prefix, d):"
  },
  {
    "id": "51",
    "text": "import os\nimport time\nimport copy\nfrom pathlib import Path\nfrom math import ceil\nfrom contextlib import contextmanager, nullcontext\nfrom functools import partial, wraps\nfrom collections.abc import Iterable\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.utils.data import random_split, DataLoader\nfrom torch.optim import Adam\nfrom lion_pytorch import Lion\nfrom torch.optim.lr_scheduler import CosineAnnealingLR, LambdaLR\nfrom torch.cuda.amp import autocast, GradScaler\n\nimport pytorch_warmup as warmup\n\nfrom imagen_pytorch.imagen_pytorch import Imagen, NullUnet\nfrom imagen_pytorch.elucidated_imagen import ElucidatedImagen\nfrom imagen_pytorch.data import cycle\n\nfrom imagen_pytorch.version import __version__\nfrom packaging import version\n\nimport numpy as np\n\nfrom ema_pytorch import EMA\n\nfrom accelerate import Accelerator, DistributedType, DistributedDataParallelKwargs\n\nfrom fsspec.core import url_to_fs\nfrom fsspec.implementations.local import LocalFileSystem\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = 1):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    return val if isinstance(val, tuple) else ((val,) * length)\n\ndef find_first(fn, arr):\n    for ind, el in enumerate(arr):\n        if fn(el):\n            return ind\n    return -1\n\ndef pick_and_pop(keys, d):\n    values = list(map(lambda key: d.pop(key), keys))\n    return dict(zip(keys, values))\n\ndef group_dict_by_key(cond, d):\n    return_val = [dict(),dict()]\n    for key in d.keys():\n        match = bool(cond(key))\n        ind = int(not match)\n        return_val[ind][key] = d[key]\n    return (*return_val,)\n\ndef string_begins_with(prefix, str):\n    return str.startswith(prefix)\n\ndef group_by_key_prefix(prefix, d):\n    return group_dict_by_key(partial(string_begins_with, prefix), d)\n\ndef groupby_prefix_and_trim(prefix, d):\n    kwargs_with_prefix, kwargs = group_dict_by_key(partial(string_begins_with, prefix), d)\n    kwargs_without_prefix = dict(map(lambda x: (x[0][len(prefix):], x[1]), tuple(kwargs_with_prefix.items())))\n    return kwargs_without_prefix, kwargs\n\ndef num_to_groups(num, divisor):"
  },
  {
    "id": "52",
    "text": "import os\nimport time\nimport copy\nfrom pathlib import Path\nfrom math import ceil\nfrom contextlib import contextmanager, nullcontext\nfrom functools import partial, wraps\nfrom collections.abc import Iterable\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.utils.data import random_split, DataLoader\nfrom torch.optim import Adam\nfrom lion_pytorch import Lion\nfrom torch.optim.lr_scheduler import CosineAnnealingLR, LambdaLR\nfrom torch.cuda.amp import autocast, GradScaler\n\nimport pytorch_warmup as warmup\n\nfrom imagen_pytorch.imagen_pytorch import Imagen, NullUnet\nfrom imagen_pytorch.elucidated_imagen import ElucidatedImagen\nfrom imagen_pytorch.data import cycle\n\nfrom imagen_pytorch.version import __version__\nfrom packaging import version\n\nimport numpy as np\n\nfrom ema_pytorch import EMA\n\nfrom accelerate import Accelerator, DistributedType, DistributedDataParallelKwargs\n\nfrom fsspec.core import url_to_fs\nfrom fsspec.implementations.local import LocalFileSystem\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = 1):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    return val if isinstance(val, tuple) else ((val,) * length)\n\ndef find_first(fn, arr):\n    for ind, el in enumerate(arr):\n        if fn(el):\n            return ind\n    return -1\n\ndef pick_and_pop(keys, d):\n    values = list(map(lambda key: d.pop(key), keys))\n    return dict(zip(keys, values))\n\ndef group_dict_by_key(cond, d):\n    return_val = [dict(),dict()]\n    for key in d.keys():\n        match = bool(cond(key))\n        ind = int(not match)\n        return_val[ind][key] = d[key]\n    return (*return_val,)\n\ndef string_begins_with(prefix, str):\n    return str.startswith(prefix)\n\ndef group_by_key_prefix(prefix, d):\n    return group_dict_by_key(partial(string_begins_with, prefix), d)\n\ndef groupby_prefix_and_trim(prefix, d):\n    kwargs_with_prefix, kwargs = group_dict_by_key(partial(string_begins_with, prefix), d)\n    kwargs_without_prefix = dict(map(lambda x: (x[0][len(prefix):], x[1]), tuple(kwargs_with_prefix.items())))\n    return kwargs_without_prefix, kwargs\n\ndef num_to_groups(num, divisor):\n    groups = num // divisor\n    remainder = num % divisor\n    arr = [divisor] * groups\n    if remainder > 0:\n        arr.append(remainder)\n    return arr\n\n# url to fs, bucket, path - for checkpointing to cloud\n\ndef url_to_bucket(url):\n    if '://' not in url:\n        return url\n\n    _, suffix = url.split('://')\n\n    if prefix in {'gs', 's3'}:\n        return suffix.split('/')[0]\n    else:\n        raise ValueError(f'storage type prefix \"{prefix}\" is not supported yet')\n\n# decorators\n\ndef eval_decorator(fn):\n    def inner(model, *args, **kwargs):\n        was_training = model.training\n        model.eval()\n        out = fn(model, *args, **kwargs)\n        model.train(was_training)\n        return out\n    return inner\n\ndef cast_torch_tensor(fn, cast_fp16 = False):\n    @wraps(fn)\n    def inner(model, *args, **kwargs):"
  },
  {
    "id": "53",
    "text": "import os\nimport time\nimport copy\nfrom pathlib import Path\nfrom math import ceil\nfrom contextlib import contextmanager, nullcontext\nfrom functools import partial, wraps\nfrom collections.abc import Iterable\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.utils.data import random_split, DataLoader\nfrom torch.optim import Adam\nfrom lion_pytorch import Lion\nfrom torch.optim.lr_scheduler import CosineAnnealingLR, LambdaLR\nfrom torch.cuda.amp import autocast, GradScaler\n\nimport pytorch_warmup as warmup\n\nfrom imagen_pytorch.imagen_pytorch import Imagen, NullUnet\nfrom imagen_pytorch.elucidated_imagen import ElucidatedImagen\nfrom imagen_pytorch.data import cycle\n\nfrom imagen_pytorch.version import __version__\nfrom packaging import version\n\nimport numpy as np\n\nfrom ema_pytorch import EMA\n\nfrom accelerate import Accelerator, DistributedType, DistributedDataParallelKwargs\n\nfrom fsspec.core import url_to_fs\nfrom fsspec.implementations.local import LocalFileSystem\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    if exists(val):\n        return val\n    return d() if callable(d) else d\n\ndef cast_tuple(val, length = 1):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    return val if isinstance(val, tuple) else ((val,) * length)\n\ndef find_first(fn, arr):\n    for ind, el in enumerate(arr):\n        if fn(el):\n            return ind\n    return -1\n\ndef pick_and_pop(keys, d):\n    values = list(map(lambda key: d.pop(key), keys))\n    return dict(zip(keys, values))\n\ndef group_dict_by_key(cond, d):\n    return_val = [dict(),dict()]\n    for key in d.keys():\n        match = bool(cond(key))\n        ind = int(not match)\n        return_val[ind][key] = d[key]\n    return (*return_val,)\n\ndef string_begins_with(prefix, str):\n    return str.startswith(prefix)\n\ndef group_by_key_prefix(prefix, d):\n    return group_dict_by_key(partial(string_begins_with, prefix), d)\n\ndef groupby_prefix_and_trim(prefix, d):\n    kwargs_with_prefix, kwargs = group_dict_by_key(partial(string_begins_with, prefix), d)\n    kwargs_without_prefix = dict(map(lambda x: (x[0][len(prefix):], x[1]), tuple(kwargs_with_prefix.items())))\n    return kwargs_without_prefix, kwargs\n\ndef num_to_groups(num, divisor):\n    groups = num // divisor\n    remainder = num % divisor\n    arr = [divisor] * groups\n    if remainder > 0:\n        arr.append(remainder)\n    return arr\n\n# url to fs, bucket, path - for checkpointing to cloud\n\ndef url_to_bucket(url):\n    if '://' not in url:\n        return url\n\n    _, suffix = url.split('://')\n\n    if prefix in {'gs', 's3'}:\n        return suffix.split('/')[0]\n    else:\n        raise ValueError(f'storage type prefix \"{prefix}\" is not supported yet')\n\n# decorators\n\ndef eval_decorator(fn):\n    def inner(model, *args, **kwargs):\n        was_training = model.training\n        model.eval()\n        out = fn(model, *args, **kwargs)\n        model.train(was_training)\n        return out\n    return inner\n\ndef cast_torch_tensor(fn, cast_fp16 = False):\n    @wraps(fn)\n    def inner(model, *args, **kwargs):\n        device = kwargs.pop('_device', model.device)\n        cast_device = kwargs.pop('_cast_device', True)\n\n        should_cast_fp16 = cast_fp16 and model.cast_half_at_training\n\n        kwargs_keys = kwargs.keys()\n        all_args = (*args, *kwargs.values())\n        split_kwargs_index = len(all_args) - len(kwargs_keys)\n        all_args = tuple(map(lambda t: torch.from_numpy(t) if exists(t) and isinstance(t, np.ndarray) else t, all_args))\n\n        if cast_device:\n            all_args = tuple(map(lambda t: t.to(device) if exists(t) and isinstance(t, torch.Tensor) else t, all_args))\n\n        if should_cast_fp16:\n            all_args = tuple(map(lambda t: t.half() if exists(t) and isinstance(t, torch.Tensor) and t.dtype != torch.bool else t, all_args))\n\n        args, kwargs_values = all_args[:split_kwargs_index], all_args[split_kwargs_index:]\n        kwargs = dict(tuple(zip(kwargs_keys, kwargs_values)))\n\n        out = fn(model, *args, **kwargs)\n        return out\n    return inner\n\n# gradient accumulation functions\n\ndef split_iterable(it, split_size):\n    accum = []\n    for ind in range(ceil(len(it) / split_size)):\n        start_index = ind * split_size\n        accum.append(it[start_index: (start_index + split_size)])\n    return accum\n\ndef split(t, split_size = None):\n    if not exists(split_size):\n        return t\n\n    if isinstance(t, torch.Tensor):\n        return t.split(split_size, dim = 0)\n\n    if isinstance(t, Iterable):\n        return split_iterable(t, split_size)\n\n    return TypeError\n\ndef find_first(cond, arr):"
  },
  {
    "id": "54",
    "text": "\n    locked = False\n\n    def __init__(\n        self,\n        imagen = None,\n        imagen_checkpoint_path = None,\n        use_ema = True,\n        lr = 1e-4,\n        eps = 1e-8,\n        beta1 = 0.9,\n        beta2 = 0.99,\n        max_grad_norm = None,\n        group_wd_params = True,\n        warmup_steps = None,\n        cosine_decay_max_steps = None,\n        only_train_unet_number = None,\n        fp16 = False,\n        precision = None,\n        split_batches = True,\n        dl_tuple_output_keywords_names = ('images', 'text_embeds', 'text_masks', 'cond_images'),\n        verbose = True,\n        split_valid_fraction = 0.025,\n        split_valid_from_train = False,\n        split_random_seed = 42,\n        checkpoint_path = None,\n        checkpoint_every = None,\n        checkpoint_fs = None,\n        fs_kwargs: dict = None,\n        max_checkpoints_keep = 20,\n        use_lion = False,\n        **kwargs\n    ):\n        super().__init__()\n        assert not ImagenTrainer.locked, 'ImagenTrainer can only be initialized once per process - for the sake of distributed training, you will now have to create a separate script to train each unet (or a script that accepts unet number as an argument)'\n        assert exists(imagen) ^ exists(imagen_checkpoint_path), 'either imagen instance is passed into the trainer, or a checkpoint path that contains the imagen config'\n\n        # determine filesystem, using fsspec, for saving to local filesystem or cloud\n\n        self.fs = checkpoint_fs\n\n        if not exists(self.fs):\n            fs_kwargs = default(fs_kwargs, {})\n            self.fs, _ = url_to_fs(default(checkpoint_path, './'), **fs_kwargs)\n\n        assert isinstance(imagen, (Imagen, ElucidatedImagen))\n        ema_kwargs, kwargs = groupby_prefix_and_trim('ema_', kwargs)\n\n        # elucidated or not\n\n        self.is_elucidated = isinstance(imagen, ElucidatedImagen)\n\n        # create accelerator instance\n\n        accelerate_kwargs, kwargs = groupby_prefix_and_trim('accelerate_', kwargs)\n\n        assert not (fp16 and exists(precision)), 'either set fp16 = True or forward the precision (\"fp16\", \"bf16\") to Accelerator'\n        accelerator_mixed_precision = default(precision, 'fp16' if fp16 else 'no')\n\n        self.accelerator = Accelerator(**{\n            'split_batches': split_batches,\n            'mixed_precision': accelerator_mixed_precision,\n            'kwargs_handlers': [DistributedDataParallelKwargs(find_unused_parameters = True)]\n        , **accelerate_kwargs})\n\n        ImagenTrainer.locked = self.is_distributed\n\n        # cast data to fp16 at training time if needed\n\n        self.cast_half_at_training = accelerator_mixed_precision == 'fp16'\n\n        # grad scaler must be managed outside of accelerator\n\n        grad_scaler_enabled = fp16\n\n        # imagen, unets and ema unets\n\n        self.imagen = imagen\n        self.num_unets = len(self.imagen.unets)\n\n        self.use_ema = use_ema and self.is_main\n        self.ema_unets = nn.ModuleList([])\n\n        # keep track of what unet is being trained on\n        # only going to allow 1 unet training at a time\n\n        self.ema_unet_being_trained_index = -1 # keeps track of which ema unet is being trained on\n\n        # data related functions\n\n        self.train_dl_iter = None\n        self.train_dl = None\n\n        self.valid_dl_iter = None\n        self.valid_dl = None\n\n        self.dl_tuple_output_keywords_names = dl_tuple_output_keywords_names\n\n        # auto splitting validation from training, if dataset is passed in\n\n        self.split_valid_from_train = split_valid_from_train\n\n        assert 0 <= split_valid_fraction <= 1, 'split valid fraction must be between 0 and 1'\n        self.split_valid_fraction = split_valid_fraction\n        self.split_random_seed = split_random_seed\n\n        # be able to finely customize learning rate, weight decay\n        # per unet\n\n        lr, eps, warmup_steps, cosine_decay_max_steps = map(partial(cast_tuple, length = self.num_unets), (lr, eps, warmup_steps, cosine_decay_max_steps))\n\n        for ind, (unet, unet_lr, unet_eps, unet_warmup_steps, unet_cosine_decay_max_steps) in enumerate(zip(self.imagen.unets, lr, eps, warmup_steps, cosine_decay_max_steps)):\n\n            if use_lion:\n                optimizer = Lion(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    betas = (beta1, beta2),\n                    use_triton = True\n                )\n            else:\n                optimizer = Adam(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    eps = unet_eps,\n                    betas = (beta1, beta2),\n                    **kwargs\n                )\n\n            if self.use_ema:\n                self.ema_unets.append(EMA(unet, **ema_kwargs))\n\n            scaler = GradScaler(enabled = grad_scaler_enabled)\n\n            scheduler = warmup_scheduler = None\n\n            if exists(unet_cosine_decay_max_steps):\n                scheduler = CosineAnnealingLR(optimizer, T_max = unet_cosine_decay_max_steps)\n\n            if exists(unet_warmup_steps):\n                warmup_scheduler = warmup.LinearWarmup(optimizer, warmup_period = unet_warmup_steps)\n\n                if not exists(scheduler):\n                    scheduler = LambdaLR(optimizer, lr_lambda = lambda step: 1.0)\n\n            # set on object\n\n            setattr(self, f'optim{ind}', optimizer) # cannot use pytorch ModuleList for some reason with optimizers\n            setattr(self, f'scaler{ind}', scaler)\n            setattr(self, f'scheduler{ind}', scheduler)\n            setattr(self, f'warmup{ind}', warmup_scheduler)\n\n        # gradient clipping if needed\n\n        self.max_grad_norm = max_grad_norm\n\n        # step tracker and misc\n\n        self.register_buffer('steps', torch.tensor([0] * self.num_unets))\n\n        self.verbose = verbose\n\n        # automatic set devices based on what accelerator decided\n\n        self.imagen.to(self.device)\n        self.to(self.device)\n\n        # checkpointing\n\n        assert not (exists(checkpoint_path) ^ exists(checkpoint_every))\n        self.checkpoint_path = checkpoint_path\n        self.checkpoint_every = checkpoint_every\n        self.max_checkpoints_keep = max_checkpoints_keep\n\n        self.can_checkpoint = self.is_local_main if isinstance(checkpoint_fs, LocalFileSystem) else self.is_main\n\n        if exists(checkpoint_path) and self.can_checkpoint:\n            bucket = url_to_bucket(checkpoint_path)\n\n            if not self.fs.exists(bucket):\n                self.fs.mkdir(bucket)\n\n            self.load_from_checkpoint_folder()\n\n        # only allowing training for unet\n\n        self.only_train_unet_number = only_train_unet_number\n        self.prepared = False\n\n\n    def prepare(self):"
  },
  {
    "id": "55",
    "text": "et (or a script that accepts unet number as an argument)'\n        assert exists(imagen) ^ exists(imagen_checkpoint_path), 'either imagen instance is passed into the trainer, or a checkpoint path that contains the imagen config'\n\n        # determine filesystem, using fsspec, for saving to local filesystem or cloud\n\n        self.fs = checkpoint_fs\n\n        if not exists(self.fs):\n            fs_kwargs = default(fs_kwargs, {})\n            self.fs, _ = url_to_fs(default(checkpoint_path, './'), **fs_kwargs)\n\n        assert isinstance(imagen, (Imagen, ElucidatedImagen))\n        ema_kwargs, kwargs = groupby_prefix_and_trim('ema_', kwargs)\n\n        # elucidated or not\n\n        self.is_elucidated = isinstance(imagen, ElucidatedImagen)\n\n        # create accelerator instance\n\n        accelerate_kwargs, kwargs = groupby_prefix_and_trim('accelerate_', kwargs)\n\n        assert not (fp16 and exists(precision)), 'either set fp16 = True or forward the precision (\"fp16\", \"bf16\") to Accelerator'\n        accelerator_mixed_precision = default(precision, 'fp16' if fp16 else 'no')\n\n        self.accelerator = Accelerator(**{\n            'split_batches': split_batches,\n            'mixed_precision': accelerator_mixed_precision,\n            'kwargs_handlers': [DistributedDataParallelKwargs(find_unused_parameters = True)]\n        , **accelerate_kwargs})\n\n        ImagenTrainer.locked = self.is_distributed\n\n        # cast data to fp16 at training time if needed\n\n        self.cast_half_at_training = accelerator_mixed_precision == 'fp16'\n\n        # grad scaler must be managed outside of accelerator\n\n        grad_scaler_enabled = fp16\n\n        # imagen, unets and ema unets\n\n        self.imagen = imagen\n        self.num_unets = len(self.imagen.unets)\n\n        self.use_ema = use_ema and self.is_main\n        self.ema_unets = nn.ModuleList([])\n\n        # keep track of what unet is being trained on\n        # only going to allow 1 unet training at a time\n\n        self.ema_unet_being_trained_index = -1 # keeps track of which ema unet is being trained on\n\n        # data related functions\n\n        self.train_dl_iter = None\n        self.train_dl = None\n\n        self.valid_dl_iter = None\n        self.valid_dl = None\n\n        self.dl_tuple_output_keywords_names = dl_tuple_output_keywords_names\n\n        # auto splitting validation from training, if dataset is passed in\n\n        self.split_valid_from_train = split_valid_from_train\n\n        assert 0 <= split_valid_fraction <= 1, 'split valid fraction must be between 0 and 1'\n        self.split_valid_fraction = split_valid_fraction\n        self.split_random_seed = split_random_seed\n\n        # be able to finely customize learning rate, weight decay\n        # per unet\n\n        lr, eps, warmup_steps, cosine_decay_max_steps = map(partial(cast_tuple, length = self.num_unets), (lr, eps, warmup_steps, cosine_decay_max_steps))\n\n        for ind, (unet, unet_lr, unet_eps, unet_warmup_steps, unet_cosine_decay_max_steps) in enumerate(zip(self.imagen.unets, lr, eps, warmup_steps, cosine_decay_max_steps)):\n\n            if use_lion:\n                optimizer = Lion(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    betas = (beta1, beta2),\n                    use_triton = True\n                )\n            else:\n                optimizer = Adam(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    eps = unet_eps,\n                    betas = (beta1, beta2),\n                    **kwargs\n                )\n\n            if self.use_ema:\n                self.ema_unets.append(EMA(unet, **ema_kwargs))\n\n            scaler = GradScaler(enabled = grad_scaler_enabled)\n\n            scheduler = warmup_scheduler = None\n\n            if exists(unet_cosine_decay_max_steps):\n                scheduler = CosineAnnealingLR(optimizer, T_max = unet_cosine_decay_max_steps)\n\n            if exists(unet_warmup_steps):\n                warmup_scheduler = warmup.LinearWarmup(optimizer, warmup_period = unet_warmup_steps)\n\n                if not exists(scheduler):\n                    scheduler = LambdaLR(optimizer, lr_lambda = lambda step: 1.0)\n\n            # set on object\n\n            setattr(self, f'optim{ind}', optimizer) # cannot use pytorch ModuleList for some reason with optimizers\n            setattr(self, f'scaler{ind}', scaler)\n            setattr(self, f'scheduler{ind}', scheduler)\n            setattr(self, f'warmup{ind}', warmup_scheduler)\n\n        # gradient clipping if needed\n\n        self.max_grad_norm = max_grad_norm\n\n        # step tracker and misc\n\n        self.register_buffer('steps', torch.tensor([0] * self.num_unets))\n\n        self.verbose = verbose\n\n        # automatic set devices based on what accelerator decided\n\n        self.imagen.to(self.device)\n        self.to(self.device)\n\n        # checkpointing\n\n        assert not (exists(checkpoint_path) ^ exists(checkpoint_every))\n        self.checkpoint_path = checkpoint_path\n        self.checkpoint_every = checkpoint_every\n        self.max_checkpoints_keep = max_checkpoints_keep\n\n        self.can_checkpoint = self.is_local_main if isinstance(checkpoint_fs, LocalFileSystem) else self.is_main\n\n        if exists(checkpoint_path) and self.can_checkpoint:\n            bucket = url_to_bucket(checkpoint_path)\n\n            if not self.fs.exists(bucket):\n                self.fs.mkdir(bucket)\n\n            self.load_from_checkpoint_folder()\n\n        # only allowing training for unet\n\n        self.only_train_unet_number = only_train_unet_number\n        self.prepared = False\n\n\n    def prepare(self):\n        assert not self.prepared, f'The trainer is allready prepared'\n        self.validate_and_set_unet_being_trained(self.only_train_unet_number)\n        self.prepared = True\n    # computed values\n\n    @property\n    def device(self):\n        return self.accelerator.device\n\n    @property\n    def is_distributed(self):\n        return not (self.accelerator.distributed_type == DistributedType.NO and self.accelerator.num_processes == 1)\n\n    @property\n    def is_main(self):\n        return self.accelerator.is_main_process\n\n    @property\n    def is_local_main(self):\n        return self.accelerator.is_local_main_process\n\n    @property\n    def unwrapped_unet(self):\n        return self.accelerator.unwrap_model(self.unet_being_trained)\n\n    # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):"
  },
  {
    "id": "56",
    "text": "and_trim('ema_', kwargs)\n\n        # elucidated or not\n\n        self.is_elucidated = isinstance(imagen, ElucidatedImagen)\n\n        # create accelerator instance\n\n        accelerate_kwargs, kwargs = groupby_prefix_and_trim('accelerate_', kwargs)\n\n        assert not (fp16 and exists(precision)), 'either set fp16 = True or forward the precision (\"fp16\", \"bf16\") to Accelerator'\n        accelerator_mixed_precision = default(precision, 'fp16' if fp16 else 'no')\n\n        self.accelerator = Accelerator(**{\n            'split_batches': split_batches,\n            'mixed_precision': accelerator_mixed_precision,\n            'kwargs_handlers': [DistributedDataParallelKwargs(find_unused_parameters = True)]\n        , **accelerate_kwargs})\n\n        ImagenTrainer.locked = self.is_distributed\n\n        # cast data to fp16 at training time if needed\n\n        self.cast_half_at_training = accelerator_mixed_precision == 'fp16'\n\n        # grad scaler must be managed outside of accelerator\n\n        grad_scaler_enabled = fp16\n\n        # imagen, unets and ema unets\n\n        self.imagen = imagen\n        self.num_unets = len(self.imagen.unets)\n\n        self.use_ema = use_ema and self.is_main\n        self.ema_unets = nn.ModuleList([])\n\n        # keep track of what unet is being trained on\n        # only going to allow 1 unet training at a time\n\n        self.ema_unet_being_trained_index = -1 # keeps track of which ema unet is being trained on\n\n        # data related functions\n\n        self.train_dl_iter = None\n        self.train_dl = None\n\n        self.valid_dl_iter = None\n        self.valid_dl = None\n\n        self.dl_tuple_output_keywords_names = dl_tuple_output_keywords_names\n\n        # auto splitting validation from training, if dataset is passed in\n\n        self.split_valid_from_train = split_valid_from_train\n\n        assert 0 <= split_valid_fraction <= 1, 'split valid fraction must be between 0 and 1'\n        self.split_valid_fraction = split_valid_fraction\n        self.split_random_seed = split_random_seed\n\n        # be able to finely customize learning rate, weight decay\n        # per unet\n\n        lr, eps, warmup_steps, cosine_decay_max_steps = map(partial(cast_tuple, length = self.num_unets), (lr, eps, warmup_steps, cosine_decay_max_steps))\n\n        for ind, (unet, unet_lr, unet_eps, unet_warmup_steps, unet_cosine_decay_max_steps) in enumerate(zip(self.imagen.unets, lr, eps, warmup_steps, cosine_decay_max_steps)):\n\n            if use_lion:\n                optimizer = Lion(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    betas = (beta1, beta2),\n                    use_triton = True\n                )\n            else:\n                optimizer = Adam(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    eps = unet_eps,\n                    betas = (beta1, beta2),\n                    **kwargs\n                )\n\n            if self.use_ema:\n                self.ema_unets.append(EMA(unet, **ema_kwargs))\n\n            scaler = GradScaler(enabled = grad_scaler_enabled)\n\n            scheduler = warmup_scheduler = None\n\n            if exists(unet_cosine_decay_max_steps):\n                scheduler = CosineAnnealingLR(optimizer, T_max = unet_cosine_decay_max_steps)\n\n            if exists(unet_warmup_steps):\n                warmup_scheduler = warmup.LinearWarmup(optimizer, warmup_period = unet_warmup_steps)\n\n                if not exists(scheduler):\n                    scheduler = LambdaLR(optimizer, lr_lambda = lambda step: 1.0)\n\n            # set on object\n\n            setattr(self, f'optim{ind}', optimizer) # cannot use pytorch ModuleList for some reason with optimizers\n            setattr(self, f'scaler{ind}', scaler)\n            setattr(self, f'scheduler{ind}', scheduler)\n            setattr(self, f'warmup{ind}', warmup_scheduler)\n\n        # gradient clipping if needed\n\n        self.max_grad_norm = max_grad_norm\n\n        # step tracker and misc\n\n        self.register_buffer('steps', torch.tensor([0] * self.num_unets))\n\n        self.verbose = verbose\n\n        # automatic set devices based on what accelerator decided\n\n        self.imagen.to(self.device)\n        self.to(self.device)\n\n        # checkpointing\n\n        assert not (exists(checkpoint_path) ^ exists(checkpoint_every))\n        self.checkpoint_path = checkpoint_path\n        self.checkpoint_every = checkpoint_every\n        self.max_checkpoints_keep = max_checkpoints_keep\n\n        self.can_checkpoint = self.is_local_main if isinstance(checkpoint_fs, LocalFileSystem) else self.is_main\n\n        if exists(checkpoint_path) and self.can_checkpoint:\n            bucket = url_to_bucket(checkpoint_path)\n\n            if not self.fs.exists(bucket):\n                self.fs.mkdir(bucket)\n\n            self.load_from_checkpoint_folder()\n\n        # only allowing training for unet\n\n        self.only_train_unet_number = only_train_unet_number\n        self.prepared = False\n\n\n    def prepare(self):\n        assert not self.prepared, f'The trainer is allready prepared'\n        self.validate_and_set_unet_being_trained(self.only_train_unet_number)\n        self.prepared = True\n    # computed values\n\n    @property\n    def device(self):\n        return self.accelerator.device\n\n    @property\n    def is_distributed(self):\n        return not (self.accelerator.distributed_type == DistributedType.NO and self.accelerator.num_processes == 1)\n\n    @property\n    def is_main(self):\n        return self.accelerator.is_main_process\n\n    @property\n    def is_local_main(self):\n        return self.accelerator.is_local_main_process\n\n    @property\n    def unwrapped_unet(self):\n        return self.accelerator.unwrap_model(self.unet_being_trained)\n\n    # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):\n        if exists(unet_number):\n            self.validate_unet_number(unet_number)\n\n        assert not exists(self.only_train_unet_number) or self.only_train_unet_number == unet_number, 'you cannot only train on one unet at a time. you will need to save the trainer into a checkpoint, and resume training on a new unet'\n\n        self.only_train_unet_number = unet_number\n        self.imagen.only_train_unet_number = unet_number\n\n        if not exists(unet_number):\n            return\n\n        self.wrap_unet(unet_number)\n\n    def wrap_unet(self, unet_number):"
  },
  {
    "id": "57",
    "text": "aler_enabled = fp16\n\n        # imagen, unets and ema unets\n\n        self.imagen = imagen\n        self.num_unets = len(self.imagen.unets)\n\n        self.use_ema = use_ema and self.is_main\n        self.ema_unets = nn.ModuleList([])\n\n        # keep track of what unet is being trained on\n        # only going to allow 1 unet training at a time\n\n        self.ema_unet_being_trained_index = -1 # keeps track of which ema unet is being trained on\n\n        # data related functions\n\n        self.train_dl_iter = None\n        self.train_dl = None\n\n        self.valid_dl_iter = None\n        self.valid_dl = None\n\n        self.dl_tuple_output_keywords_names = dl_tuple_output_keywords_names\n\n        # auto splitting validation from training, if dataset is passed in\n\n        self.split_valid_from_train = split_valid_from_train\n\n        assert 0 <= split_valid_fraction <= 1, 'split valid fraction must be between 0 and 1'\n        self.split_valid_fraction = split_valid_fraction\n        self.split_random_seed = split_random_seed\n\n        # be able to finely customize learning rate, weight decay\n        # per unet\n\n        lr, eps, warmup_steps, cosine_decay_max_steps = map(partial(cast_tuple, length = self.num_unets), (lr, eps, warmup_steps, cosine_decay_max_steps))\n\n        for ind, (unet, unet_lr, unet_eps, unet_warmup_steps, unet_cosine_decay_max_steps) in enumerate(zip(self.imagen.unets, lr, eps, warmup_steps, cosine_decay_max_steps)):\n\n            if use_lion:\n                optimizer = Lion(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    betas = (beta1, beta2),\n                    use_triton = True\n                )\n            else:\n                optimizer = Adam(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    eps = unet_eps,\n                    betas = (beta1, beta2),\n                    **kwargs\n                )\n\n            if self.use_ema:\n                self.ema_unets.append(EMA(unet, **ema_kwargs))\n\n            scaler = GradScaler(enabled = grad_scaler_enabled)\n\n            scheduler = warmup_scheduler = None\n\n            if exists(unet_cosine_decay_max_steps):\n                scheduler = CosineAnnealingLR(optimizer, T_max = unet_cosine_decay_max_steps)\n\n            if exists(unet_warmup_steps):\n                warmup_scheduler = warmup.LinearWarmup(optimizer, warmup_period = unet_warmup_steps)\n\n                if not exists(scheduler):\n                    scheduler = LambdaLR(optimizer, lr_lambda = lambda step: 1.0)\n\n            # set on object\n\n            setattr(self, f'optim{ind}', optimizer) # cannot use pytorch ModuleList for some reason with optimizers\n            setattr(self, f'scaler{ind}', scaler)\n            setattr(self, f'scheduler{ind}', scheduler)\n            setattr(self, f'warmup{ind}', warmup_scheduler)\n\n        # gradient clipping if needed\n\n        self.max_grad_norm = max_grad_norm\n\n        # step tracker and misc\n\n        self.register_buffer('steps', torch.tensor([0] * self.num_unets))\n\n        self.verbose = verbose\n\n        # automatic set devices based on what accelerator decided\n\n        self.imagen.to(self.device)\n        self.to(self.device)\n\n        # checkpointing\n\n        assert not (exists(checkpoint_path) ^ exists(checkpoint_every))\n        self.checkpoint_path = checkpoint_path\n        self.checkpoint_every = checkpoint_every\n        self.max_checkpoints_keep = max_checkpoints_keep\n\n        self.can_checkpoint = self.is_local_main if isinstance(checkpoint_fs, LocalFileSystem) else self.is_main\n\n        if exists(checkpoint_path) and self.can_checkpoint:\n            bucket = url_to_bucket(checkpoint_path)\n\n            if not self.fs.exists(bucket):\n                self.fs.mkdir(bucket)\n\n            self.load_from_checkpoint_folder()\n\n        # only allowing training for unet\n\n        self.only_train_unet_number = only_train_unet_number\n        self.prepared = False\n\n\n    def prepare(self):\n        assert not self.prepared, f'The trainer is allready prepared'\n        self.validate_and_set_unet_being_trained(self.only_train_unet_number)\n        self.prepared = True\n    # computed values\n\n    @property\n    def device(self):\n        return self.accelerator.device\n\n    @property\n    def is_distributed(self):\n        return not (self.accelerator.distributed_type == DistributedType.NO and self.accelerator.num_processes == 1)\n\n    @property\n    def is_main(self):\n        return self.accelerator.is_main_process\n\n    @property\n    def is_local_main(self):\n        return self.accelerator.is_local_main_process\n\n    @property\n    def unwrapped_unet(self):\n        return self.accelerator.unwrap_model(self.unet_being_trained)\n\n    # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):\n        if exists(unet_number):\n            self.validate_unet_number(unet_number)\n\n        assert not exists(self.only_train_unet_number) or self.only_train_unet_number == unet_number, 'you cannot only train on one unet at a time. you will need to save the trainer into a checkpoint, and resume training on a new unet'\n\n        self.only_train_unet_number = unet_number\n        self.imagen.only_train_unet_number = unet_number\n\n        if not exists(unet_number):\n            return\n\n        self.wrap_unet(unet_number)\n\n    def wrap_unet(self, unet_number):\n        if hasattr(self, 'one_unet_wrapped'):\n            return\n\n        unet = self.imagen.get_unet(unet_number)\n        unet_index = unet_number - 1\n\n        optimizer = getattr(self, f'optim{unet_index}')\n        scheduler = getattr(self, f'scheduler{unet_index}')\n\n        if self.train_dl:\n            self.unet_being_trained, self.train_dl, optimizer = self.accelerator.prepare(unet, self.train_dl, optimizer)\n        else:\n            self.unet_being_trained, optimizer = self.accelerator.prepare(unet, optimizer)\n\n        if exists(scheduler):\n            scheduler = self.accelerator.prepare(scheduler)\n\n        setattr(self, f'optim{unet_index}', optimizer)\n        setattr(self, f'scheduler{unet_index}', scheduler)\n\n        self.one_unet_wrapped = True\n\n    # hacking accelerator due to not having separate gradscaler per optimizer\n\n    def set_accelerator_scaler(self, unet_number):"
  },
  {
    "id": "58",
    "text": " None\n\n        self.valid_dl_iter = None\n        self.valid_dl = None\n\n        self.dl_tuple_output_keywords_names = dl_tuple_output_keywords_names\n\n        # auto splitting validation from training, if dataset is passed in\n\n        self.split_valid_from_train = split_valid_from_train\n\n        assert 0 <= split_valid_fraction <= 1, 'split valid fraction must be between 0 and 1'\n        self.split_valid_fraction = split_valid_fraction\n        self.split_random_seed = split_random_seed\n\n        # be able to finely customize learning rate, weight decay\n        # per unet\n\n        lr, eps, warmup_steps, cosine_decay_max_steps = map(partial(cast_tuple, length = self.num_unets), (lr, eps, warmup_steps, cosine_decay_max_steps))\n\n        for ind, (unet, unet_lr, unet_eps, unet_warmup_steps, unet_cosine_decay_max_steps) in enumerate(zip(self.imagen.unets, lr, eps, warmup_steps, cosine_decay_max_steps)):\n\n            if use_lion:\n                optimizer = Lion(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    betas = (beta1, beta2),\n                    use_triton = True\n                )\n            else:\n                optimizer = Adam(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    eps = unet_eps,\n                    betas = (beta1, beta2),\n                    **kwargs\n                )\n\n            if self.use_ema:\n                self.ema_unets.append(EMA(unet, **ema_kwargs))\n\n            scaler = GradScaler(enabled = grad_scaler_enabled)\n\n            scheduler = warmup_scheduler = None\n\n            if exists(unet_cosine_decay_max_steps):\n                scheduler = CosineAnnealingLR(optimizer, T_max = unet_cosine_decay_max_steps)\n\n            if exists(unet_warmup_steps):\n                warmup_scheduler = warmup.LinearWarmup(optimizer, warmup_period = unet_warmup_steps)\n\n                if not exists(scheduler):\n                    scheduler = LambdaLR(optimizer, lr_lambda = lambda step: 1.0)\n\n            # set on object\n\n            setattr(self, f'optim{ind}', optimizer) # cannot use pytorch ModuleList for some reason with optimizers\n            setattr(self, f'scaler{ind}', scaler)\n            setattr(self, f'scheduler{ind}', scheduler)\n            setattr(self, f'warmup{ind}', warmup_scheduler)\n\n        # gradient clipping if needed\n\n        self.max_grad_norm = max_grad_norm\n\n        # step tracker and misc\n\n        self.register_buffer('steps', torch.tensor([0] * self.num_unets))\n\n        self.verbose = verbose\n\n        # automatic set devices based on what accelerator decided\n\n        self.imagen.to(self.device)\n        self.to(self.device)\n\n        # checkpointing\n\n        assert not (exists(checkpoint_path) ^ exists(checkpoint_every))\n        self.checkpoint_path = checkpoint_path\n        self.checkpoint_every = checkpoint_every\n        self.max_checkpoints_keep = max_checkpoints_keep\n\n        self.can_checkpoint = self.is_local_main if isinstance(checkpoint_fs, LocalFileSystem) else self.is_main\n\n        if exists(checkpoint_path) and self.can_checkpoint:\n            bucket = url_to_bucket(checkpoint_path)\n\n            if not self.fs.exists(bucket):\n                self.fs.mkdir(bucket)\n\n            self.load_from_checkpoint_folder()\n\n        # only allowing training for unet\n\n        self.only_train_unet_number = only_train_unet_number\n        self.prepared = False\n\n\n    def prepare(self):\n        assert not self.prepared, f'The trainer is allready prepared'\n        self.validate_and_set_unet_being_trained(self.only_train_unet_number)\n        self.prepared = True\n    # computed values\n\n    @property\n    def device(self):\n        return self.accelerator.device\n\n    @property\n    def is_distributed(self):\n        return not (self.accelerator.distributed_type == DistributedType.NO and self.accelerator.num_processes == 1)\n\n    @property\n    def is_main(self):\n        return self.accelerator.is_main_process\n\n    @property\n    def is_local_main(self):\n        return self.accelerator.is_local_main_process\n\n    @property\n    def unwrapped_unet(self):\n        return self.accelerator.unwrap_model(self.unet_being_trained)\n\n    # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):\n        if exists(unet_number):\n            self.validate_unet_number(unet_number)\n\n        assert not exists(self.only_train_unet_number) or self.only_train_unet_number == unet_number, 'you cannot only train on one unet at a time. you will need to save the trainer into a checkpoint, and resume training on a new unet'\n\n        self.only_train_unet_number = unet_number\n        self.imagen.only_train_unet_number = unet_number\n\n        if not exists(unet_number):\n            return\n\n        self.wrap_unet(unet_number)\n\n    def wrap_unet(self, unet_number):\n        if hasattr(self, 'one_unet_wrapped'):\n            return\n\n        unet = self.imagen.get_unet(unet_number)\n        unet_index = unet_number - 1\n\n        optimizer = getattr(self, f'optim{unet_index}')\n        scheduler = getattr(self, f'scheduler{unet_index}')\n\n        if self.train_dl:\n            self.unet_being_trained, self.train_dl, optimizer = self.accelerator.prepare(unet, self.train_dl, optimizer)\n        else:\n            self.unet_being_trained, optimizer = self.accelerator.prepare(unet, optimizer)\n\n        if exists(scheduler):\n            scheduler = self.accelerator.prepare(scheduler)\n\n        setattr(self, f'optim{unet_index}', optimizer)\n        setattr(self, f'scheduler{unet_index}', scheduler)\n\n        self.one_unet_wrapped = True\n\n    # hacking accelerator due to not having separate gradscaler per optimizer\n\n    def set_accelerator_scaler(self, unet_number):\n        unet_number = self.validate_unet_number(unet_number)\n        scaler = getattr(self, f'scaler{unet_number - 1}')\n\n        self.accelerator.scaler = scaler\n        for optimizer in self.accelerator._optimizers:\n            optimizer.scaler = scaler\n\n    # helper print\n\n    def print(self, msg):\n        if not self.is_main:\n            return\n\n        if not self.verbose:\n            return\n\n        return self.accelerator.print(msg)\n\n    # validating the unet number\n\n    def validate_unet_number(self, unet_number = None):"
  },
  {
    "id": "59",
    "text": " fraction must be between 0 and 1'\n        self.split_valid_fraction = split_valid_fraction\n        self.split_random_seed = split_random_seed\n\n        # be able to finely customize learning rate, weight decay\n        # per unet\n\n        lr, eps, warmup_steps, cosine_decay_max_steps = map(partial(cast_tuple, length = self.num_unets), (lr, eps, warmup_steps, cosine_decay_max_steps))\n\n        for ind, (unet, unet_lr, unet_eps, unet_warmup_steps, unet_cosine_decay_max_steps) in enumerate(zip(self.imagen.unets, lr, eps, warmup_steps, cosine_decay_max_steps)):\n\n            if use_lion:\n                optimizer = Lion(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    betas = (beta1, beta2),\n                    use_triton = True\n                )\n            else:\n                optimizer = Adam(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    eps = unet_eps,\n                    betas = (beta1, beta2),\n                    **kwargs\n                )\n\n            if self.use_ema:\n                self.ema_unets.append(EMA(unet, **ema_kwargs))\n\n            scaler = GradScaler(enabled = grad_scaler_enabled)\n\n            scheduler = warmup_scheduler = None\n\n            if exists(unet_cosine_decay_max_steps):\n                scheduler = CosineAnnealingLR(optimizer, T_max = unet_cosine_decay_max_steps)\n\n            if exists(unet_warmup_steps):\n                warmup_scheduler = warmup.LinearWarmup(optimizer, warmup_period = unet_warmup_steps)\n\n                if not exists(scheduler):\n                    scheduler = LambdaLR(optimizer, lr_lambda = lambda step: 1.0)\n\n            # set on object\n\n            setattr(self, f'optim{ind}', optimizer) # cannot use pytorch ModuleList for some reason with optimizers\n            setattr(self, f'scaler{ind}', scaler)\n            setattr(self, f'scheduler{ind}', scheduler)\n            setattr(self, f'warmup{ind}', warmup_scheduler)\n\n        # gradient clipping if needed\n\n        self.max_grad_norm = max_grad_norm\n\n        # step tracker and misc\n\n        self.register_buffer('steps', torch.tensor([0] * self.num_unets))\n\n        self.verbose = verbose\n\n        # automatic set devices based on what accelerator decided\n\n        self.imagen.to(self.device)\n        self.to(self.device)\n\n        # checkpointing\n\n        assert not (exists(checkpoint_path) ^ exists(checkpoint_every))\n        self.checkpoint_path = checkpoint_path\n        self.checkpoint_every = checkpoint_every\n        self.max_checkpoints_keep = max_checkpoints_keep\n\n        self.can_checkpoint = self.is_local_main if isinstance(checkpoint_fs, LocalFileSystem) else self.is_main\n\n        if exists(checkpoint_path) and self.can_checkpoint:\n            bucket = url_to_bucket(checkpoint_path)\n\n            if not self.fs.exists(bucket):\n                self.fs.mkdir(bucket)\n\n            self.load_from_checkpoint_folder()\n\n        # only allowing training for unet\n\n        self.only_train_unet_number = only_train_unet_number\n        self.prepared = False\n\n\n    def prepare(self):\n        assert not self.prepared, f'The trainer is allready prepared'\n        self.validate_and_set_unet_being_trained(self.only_train_unet_number)\n        self.prepared = True\n    # computed values\n\n    @property\n    def device(self):\n        return self.accelerator.device\n\n    @property\n    def is_distributed(self):\n        return not (self.accelerator.distributed_type == DistributedType.NO and self.accelerator.num_processes == 1)\n\n    @property\n    def is_main(self):\n        return self.accelerator.is_main_process\n\n    @property\n    def is_local_main(self):\n        return self.accelerator.is_local_main_process\n\n    @property\n    def unwrapped_unet(self):\n        return self.accelerator.unwrap_model(self.unet_being_trained)\n\n    # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):\n        if exists(unet_number):\n            self.validate_unet_number(unet_number)\n\n        assert not exists(self.only_train_unet_number) or self.only_train_unet_number == unet_number, 'you cannot only train on one unet at a time. you will need to save the trainer into a checkpoint, and resume training on a new unet'\n\n        self.only_train_unet_number = unet_number\n        self.imagen.only_train_unet_number = unet_number\n\n        if not exists(unet_number):\n            return\n\n        self.wrap_unet(unet_number)\n\n    def wrap_unet(self, unet_number):\n        if hasattr(self, 'one_unet_wrapped'):\n            return\n\n        unet = self.imagen.get_unet(unet_number)\n        unet_index = unet_number - 1\n\n        optimizer = getattr(self, f'optim{unet_index}')\n        scheduler = getattr(self, f'scheduler{unet_index}')\n\n        if self.train_dl:\n            self.unet_being_trained, self.train_dl, optimizer = self.accelerator.prepare(unet, self.train_dl, optimizer)\n        else:\n            self.unet_being_trained, optimizer = self.accelerator.prepare(unet, optimizer)\n\n        if exists(scheduler):\n            scheduler = self.accelerator.prepare(scheduler)\n\n        setattr(self, f'optim{unet_index}', optimizer)\n        setattr(self, f'scheduler{unet_index}', scheduler)\n\n        self.one_unet_wrapped = True\n\n    # hacking accelerator due to not having separate gradscaler per optimizer\n\n    def set_accelerator_scaler(self, unet_number):\n        unet_number = self.validate_unet_number(unet_number)\n        scaler = getattr(self, f'scaler{unet_number - 1}')\n\n        self.accelerator.scaler = scaler\n        for optimizer in self.accelerator._optimizers:\n            optimizer.scaler = scaler\n\n    # helper print\n\n    def print(self, msg):\n        if not self.is_main:\n            return\n\n        if not self.verbose:\n            return\n\n        return self.accelerator.print(msg)\n\n    # validating the unet number\n\n    def validate_unet_number(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        assert 0 < unet_number <= self.num_unets, f'unet number should be in between 1 and {self.num_unets}'\n        return unet_number\n\n    # number of training steps taken\n\n    def num_steps_taken(self, unet_number = None):"
  },
  {
    "id": "60",
    "text": "r = unet_lr,\n                    betas = (beta1, beta2),\n                    use_triton = True\n                )\n            else:\n                optimizer = Adam(\n                    unet.parameters(),\n                    lr = unet_lr,\n                    eps = unet_eps,\n                    betas = (beta1, beta2),\n                    **kwargs\n                )\n\n            if self.use_ema:\n                self.ema_unets.append(EMA(unet, **ema_kwargs))\n\n            scaler = GradScaler(enabled = grad_scaler_enabled)\n\n            scheduler = warmup_scheduler = None\n\n            if exists(unet_cosine_decay_max_steps):\n                scheduler = CosineAnnealingLR(optimizer, T_max = unet_cosine_decay_max_steps)\n\n            if exists(unet_warmup_steps):\n                warmup_scheduler = warmup.LinearWarmup(optimizer, warmup_period = unet_warmup_steps)\n\n                if not exists(scheduler):\n                    scheduler = LambdaLR(optimizer, lr_lambda = lambda step: 1.0)\n\n            # set on object\n\n            setattr(self, f'optim{ind}', optimizer) # cannot use pytorch ModuleList for some reason with optimizers\n            setattr(self, f'scaler{ind}', scaler)\n            setattr(self, f'scheduler{ind}', scheduler)\n            setattr(self, f'warmup{ind}', warmup_scheduler)\n\n        # gradient clipping if needed\n\n        self.max_grad_norm = max_grad_norm\n\n        # step tracker and misc\n\n        self.register_buffer('steps', torch.tensor([0] * self.num_unets))\n\n        self.verbose = verbose\n\n        # automatic set devices based on what accelerator decided\n\n        self.imagen.to(self.device)\n        self.to(self.device)\n\n        # checkpointing\n\n        assert not (exists(checkpoint_path) ^ exists(checkpoint_every))\n        self.checkpoint_path = checkpoint_path\n        self.checkpoint_every = checkpoint_every\n        self.max_checkpoints_keep = max_checkpoints_keep\n\n        self.can_checkpoint = self.is_local_main if isinstance(checkpoint_fs, LocalFileSystem) else self.is_main\n\n        if exists(checkpoint_path) and self.can_checkpoint:\n            bucket = url_to_bucket(checkpoint_path)\n\n            if not self.fs.exists(bucket):\n                self.fs.mkdir(bucket)\n\n            self.load_from_checkpoint_folder()\n\n        # only allowing training for unet\n\n        self.only_train_unet_number = only_train_unet_number\n        self.prepared = False\n\n\n    def prepare(self):\n        assert not self.prepared, f'The trainer is allready prepared'\n        self.validate_and_set_unet_being_trained(self.only_train_unet_number)\n        self.prepared = True\n    # computed values\n\n    @property\n    def device(self):\n        return self.accelerator.device\n\n    @property\n    def is_distributed(self):\n        return not (self.accelerator.distributed_type == DistributedType.NO and self.accelerator.num_processes == 1)\n\n    @property\n    def is_main(self):\n        return self.accelerator.is_main_process\n\n    @property\n    def is_local_main(self):\n        return self.accelerator.is_local_main_process\n\n    @property\n    def unwrapped_unet(self):\n        return self.accelerator.unwrap_model(self.unet_being_trained)\n\n    # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):\n        if exists(unet_number):\n            self.validate_unet_number(unet_number)\n\n        assert not exists(self.only_train_unet_number) or self.only_train_unet_number == unet_number, 'you cannot only train on one unet at a time. you will need to save the trainer into a checkpoint, and resume training on a new unet'\n\n        self.only_train_unet_number = unet_number\n        self.imagen.only_train_unet_number = unet_number\n\n        if not exists(unet_number):\n            return\n\n        self.wrap_unet(unet_number)\n\n    def wrap_unet(self, unet_number):\n        if hasattr(self, 'one_unet_wrapped'):\n            return\n\n        unet = self.imagen.get_unet(unet_number)\n        unet_index = unet_number - 1\n\n        optimizer = getattr(self, f'optim{unet_index}')\n        scheduler = getattr(self, f'scheduler{unet_index}')\n\n        if self.train_dl:\n            self.unet_being_trained, self.train_dl, optimizer = self.accelerator.prepare(unet, self.train_dl, optimizer)\n        else:\n            self.unet_being_trained, optimizer = self.accelerator.prepare(unet, optimizer)\n\n        if exists(scheduler):\n            scheduler = self.accelerator.prepare(scheduler)\n\n        setattr(self, f'optim{unet_index}', optimizer)\n        setattr(self, f'scheduler{unet_index}', scheduler)\n\n        self.one_unet_wrapped = True\n\n    # hacking accelerator due to not having separate gradscaler per optimizer\n\n    def set_accelerator_scaler(self, unet_number):\n        unet_number = self.validate_unet_number(unet_number)\n        scaler = getattr(self, f'scaler{unet_number - 1}')\n\n        self.accelerator.scaler = scaler\n        for optimizer in self.accelerator._optimizers:\n            optimizer.scaler = scaler\n\n    # helper print\n\n    def print(self, msg):\n        if not self.is_main:\n            return\n\n        if not self.verbose:\n            return\n\n        return self.accelerator.print(msg)\n\n    # validating the unet number\n\n    def validate_unet_number(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        assert 0 < unet_number <= self.num_unets, f'unet number should be in between 1 and {self.num_unets}'\n        return unet_number\n\n    # number of training steps taken\n\n    def num_steps_taken(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        return self.steps[unet_number - 1].item()\n\n    def print_untrained_unets(self):\n        print_final_error = False\n\n        for ind, (steps, unet) in enumerate(zip(self.steps.tolist(), self.imagen.unets)):\n            if steps > 0 or isinstance(unet, NullUnet):\n                continue\n\n            self.print(f'unet {ind + 1} has not been trained')\n            print_final_error = True\n\n        if print_final_error:\n            self.print('when sampling, you can pass stop_at_unet_number to stop early in the cascade, so it does not try to generate with untrained unets')\n\n    # data related functions\n\n    def add_train_dataloader(self, dl = None):"
  },
  {
    "id": "61",
    "text": "alingLR(optimizer, T_max = unet_cosine_decay_max_steps)\n\n            if exists(unet_warmup_steps):\n                warmup_scheduler = warmup.LinearWarmup(optimizer, warmup_period = unet_warmup_steps)\n\n                if not exists(scheduler):\n                    scheduler = LambdaLR(optimizer, lr_lambda = lambda step: 1.0)\n\n            # set on object\n\n            setattr(self, f'optim{ind}', optimizer) # cannot use pytorch ModuleList for some reason with optimizers\n            setattr(self, f'scaler{ind}', scaler)\n            setattr(self, f'scheduler{ind}', scheduler)\n            setattr(self, f'warmup{ind}', warmup_scheduler)\n\n        # gradient clipping if needed\n\n        self.max_grad_norm = max_grad_norm\n\n        # step tracker and misc\n\n        self.register_buffer('steps', torch.tensor([0] * self.num_unets))\n\n        self.verbose = verbose\n\n        # automatic set devices based on what accelerator decided\n\n        self.imagen.to(self.device)\n        self.to(self.device)\n\n        # checkpointing\n\n        assert not (exists(checkpoint_path) ^ exists(checkpoint_every))\n        self.checkpoint_path = checkpoint_path\n        self.checkpoint_every = checkpoint_every\n        self.max_checkpoints_keep = max_checkpoints_keep\n\n        self.can_checkpoint = self.is_local_main if isinstance(checkpoint_fs, LocalFileSystem) else self.is_main\n\n        if exists(checkpoint_path) and self.can_checkpoint:\n            bucket = url_to_bucket(checkpoint_path)\n\n            if not self.fs.exists(bucket):\n                self.fs.mkdir(bucket)\n\n            self.load_from_checkpoint_folder()\n\n        # only allowing training for unet\n\n        self.only_train_unet_number = only_train_unet_number\n        self.prepared = False\n\n\n    def prepare(self):\n        assert not self.prepared, f'The trainer is allready prepared'\n        self.validate_and_set_unet_being_trained(self.only_train_unet_number)\n        self.prepared = True\n    # computed values\n\n    @property\n    def device(self):\n        return self.accelerator.device\n\n    @property\n    def is_distributed(self):\n        return not (self.accelerator.distributed_type == DistributedType.NO and self.accelerator.num_processes == 1)\n\n    @property\n    def is_main(self):\n        return self.accelerator.is_main_process\n\n    @property\n    def is_local_main(self):\n        return self.accelerator.is_local_main_process\n\n    @property\n    def unwrapped_unet(self):\n        return self.accelerator.unwrap_model(self.unet_being_trained)\n\n    # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):\n        if exists(unet_number):\n            self.validate_unet_number(unet_number)\n\n        assert not exists(self.only_train_unet_number) or self.only_train_unet_number == unet_number, 'you cannot only train on one unet at a time. you will need to save the trainer into a checkpoint, and resume training on a new unet'\n\n        self.only_train_unet_number = unet_number\n        self.imagen.only_train_unet_number = unet_number\n\n        if not exists(unet_number):\n            return\n\n        self.wrap_unet(unet_number)\n\n    def wrap_unet(self, unet_number):\n        if hasattr(self, 'one_unet_wrapped'):\n            return\n\n        unet = self.imagen.get_unet(unet_number)\n        unet_index = unet_number - 1\n\n        optimizer = getattr(self, f'optim{unet_index}')\n        scheduler = getattr(self, f'scheduler{unet_index}')\n\n        if self.train_dl:\n            self.unet_being_trained, self.train_dl, optimizer = self.accelerator.prepare(unet, self.train_dl, optimizer)\n        else:\n            self.unet_being_trained, optimizer = self.accelerator.prepare(unet, optimizer)\n\n        if exists(scheduler):\n            scheduler = self.accelerator.prepare(scheduler)\n\n        setattr(self, f'optim{unet_index}', optimizer)\n        setattr(self, f'scheduler{unet_index}', scheduler)\n\n        self.one_unet_wrapped = True\n\n    # hacking accelerator due to not having separate gradscaler per optimizer\n\n    def set_accelerator_scaler(self, unet_number):\n        unet_number = self.validate_unet_number(unet_number)\n        scaler = getattr(self, f'scaler{unet_number - 1}')\n\n        self.accelerator.scaler = scaler\n        for optimizer in self.accelerator._optimizers:\n            optimizer.scaler = scaler\n\n    # helper print\n\n    def print(self, msg):\n        if not self.is_main:\n            return\n\n        if not self.verbose:\n            return\n\n        return self.accelerator.print(msg)\n\n    # validating the unet number\n\n    def validate_unet_number(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        assert 0 < unet_number <= self.num_unets, f'unet number should be in between 1 and {self.num_unets}'\n        return unet_number\n\n    # number of training steps taken\n\n    def num_steps_taken(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        return self.steps[unet_number - 1].item()\n\n    def print_untrained_unets(self):\n        print_final_error = False\n\n        for ind, (steps, unet) in enumerate(zip(self.steps.tolist(), self.imagen.unets)):\n            if steps > 0 or isinstance(unet, NullUnet):\n                continue\n\n            self.print(f'unet {ind + 1} has not been trained')\n            print_final_error = True\n\n        if print_final_error:\n            self.print('when sampling, you can pass stop_at_unet_number to stop early in the cascade, so it does not try to generate with untrained unets')\n\n    # data related functions\n\n    def add_train_dataloader(self, dl = None):\n        if not exists(dl):\n            return\n\n        assert not exists(self.train_dl), 'training dataloader was already added'\n        assert not self.prepared, f'You need to add the dataset before preperation'\n        self.train_dl = dl\n\n    def add_valid_dataloader(self, dl):\n        if not exists(dl):\n            return\n\n        assert not exists(self.valid_dl), 'validation dataloader was already added'\n        assert not self.prepared, f'You need to add the dataset before preperation'\n        self.valid_dl = dl\n\n    def add_train_dataset(self, ds = None, *, batch_size, **dl_kwargs):"
  },
  {
    "id": "62",
    "text": "can_checkpoint = self.is_local_main if isinstance(checkpoint_fs, LocalFileSystem) else self.is_main\n\n        if exists(checkpoint_path) and self.can_checkpoint:\n            bucket = url_to_bucket(checkpoint_path)\n\n            if not self.fs.exists(bucket):\n                self.fs.mkdir(bucket)\n\n            self.load_from_checkpoint_folder()\n\n        # only allowing training for unet\n\n        self.only_train_unet_number = only_train_unet_number\n        self.prepared = False\n\n\n    def prepare(self):\n        assert not self.prepared, f'The trainer is allready prepared'\n        self.validate_and_set_unet_being_trained(self.only_train_unet_number)\n        self.prepared = True\n    # computed values\n\n    @property\n    def device(self):\n        return self.accelerator.device\n\n    @property\n    def is_distributed(self):\n        return not (self.accelerator.distributed_type == DistributedType.NO and self.accelerator.num_processes == 1)\n\n    @property\n    def is_main(self):\n        return self.accelerator.is_main_process\n\n    @property\n    def is_local_main(self):\n        return self.accelerator.is_local_main_process\n\n    @property\n    def unwrapped_unet(self):\n        return self.accelerator.unwrap_model(self.unet_being_trained)\n\n    # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):\n        if exists(unet_number):\n            self.validate_unet_number(unet_number)\n\n        assert not exists(self.only_train_unet_number) or self.only_train_unet_number == unet_number, 'you cannot only train on one unet at a time. you will need to save the trainer into a checkpoint, and resume training on a new unet'\n\n        self.only_train_unet_number = unet_number\n        self.imagen.only_train_unet_number = unet_number\n\n        if not exists(unet_number):\n            return\n\n        self.wrap_unet(unet_number)\n\n    def wrap_unet(self, unet_number):\n        if hasattr(self, 'one_unet_wrapped'):\n            return\n\n        unet = self.imagen.get_unet(unet_number)\n        unet_index = unet_number - 1\n\n        optimizer = getattr(self, f'optim{unet_index}')\n        scheduler = getattr(self, f'scheduler{unet_index}')\n\n        if self.train_dl:\n            self.unet_being_trained, self.train_dl, optimizer = self.accelerator.prepare(unet, self.train_dl, optimizer)\n        else:\n            self.unet_being_trained, optimizer = self.accelerator.prepare(unet, optimizer)\n\n        if exists(scheduler):\n            scheduler = self.accelerator.prepare(scheduler)\n\n        setattr(self, f'optim{unet_index}', optimizer)\n        setattr(self, f'scheduler{unet_index}', scheduler)\n\n        self.one_unet_wrapped = True\n\n    # hacking accelerator due to not having separate gradscaler per optimizer\n\n    def set_accelerator_scaler(self, unet_number):\n        unet_number = self.validate_unet_number(unet_number)\n        scaler = getattr(self, f'scaler{unet_number - 1}')\n\n        self.accelerator.scaler = scaler\n        for optimizer in self.accelerator._optimizers:\n            optimizer.scaler = scaler\n\n    # helper print\n\n    def print(self, msg):\n        if not self.is_main:\n            return\n\n        if not self.verbose:\n            return\n\n        return self.accelerator.print(msg)\n\n    # validating the unet number\n\n    def validate_unet_number(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        assert 0 < unet_number <= self.num_unets, f'unet number should be in between 1 and {self.num_unets}'\n        return unet_number\n\n    # number of training steps taken\n\n    def num_steps_taken(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        return self.steps[unet_number - 1].item()\n\n    def print_untrained_unets(self):\n        print_final_error = False\n\n        for ind, (steps, unet) in enumerate(zip(self.steps.tolist(), self.imagen.unets)):\n            if steps > 0 or isinstance(unet, NullUnet):\n                continue\n\n            self.print(f'unet {ind + 1} has not been trained')\n            print_final_error = True\n\n        if print_final_error:\n            self.print('when sampling, you can pass stop_at_unet_number to stop early in the cascade, so it does not try to generate with untrained unets')\n\n    # data related functions\n\n    def add_train_dataloader(self, dl = None):\n        if not exists(dl):\n            return\n\n        assert not exists(self.train_dl), 'training dataloader was already added'\n        assert not self.prepared, f'You need to add the dataset before preperation'\n        self.train_dl = dl\n\n    def add_valid_dataloader(self, dl):\n        if not exists(dl):\n            return\n\n        assert not exists(self.valid_dl), 'validation dataloader was already added'\n        assert not self.prepared, f'You need to add the dataset before preperation'\n        self.valid_dl = dl\n\n    def add_train_dataset(self, ds = None, *, batch_size, **dl_kwargs):\n        if not exists(ds):\n            return\n\n        assert not exists(self.train_dl), 'training dataloader was already added'\n\n        valid_ds = None\n        if self.split_valid_from_train:\n            train_size = int((1 - self.split_valid_fraction) * len(ds))\n            valid_size = len(ds) - train_size\n\n            ds, valid_ds = random_split(ds, [train_size, valid_size], generator = torch.Generator().manual_seed(self.split_random_seed))\n            self.print(f'training with dataset of {len(ds)} samples and validating with randomly splitted {len(valid_ds)} samples')\n\n        dl = DataLoader(ds, batch_size = batch_size, **dl_kwargs)\n        self.add_train_dataloader(dl)\n\n        if not self.split_valid_from_train:\n            return\n\n        self.add_valid_dataset(valid_ds, batch_size = batch_size, **dl_kwargs)\n\n    def add_valid_dataset(self, ds, *, batch_size, **dl_kwargs):\n        if not exists(ds):\n            return\n\n        assert not exists(self.valid_dl), 'validation dataloader was already added'\n\n        dl = DataLoader(ds, batch_size = batch_size, **dl_kwargs)\n        self.add_valid_dataloader(dl)\n\n    def create_train_iter(self):"
  },
  {
    "id": "63",
    "text": " assert not self.prepared, f'The trainer is allready prepared'\n        self.validate_and_set_unet_being_trained(self.only_train_unet_number)\n        self.prepared = True\n    # computed values\n\n    @property\n    def device(self):\n        return self.accelerator.device\n\n    @property\n    def is_distributed(self):\n        return not (self.accelerator.distributed_type == DistributedType.NO and self.accelerator.num_processes == 1)\n\n    @property\n    def is_main(self):\n        return self.accelerator.is_main_process\n\n    @property\n    def is_local_main(self):\n        return self.accelerator.is_local_main_process\n\n    @property\n    def unwrapped_unet(self):\n        return self.accelerator.unwrap_model(self.unet_being_trained)\n\n    # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):\n        if exists(unet_number):\n            self.validate_unet_number(unet_number)\n\n        assert not exists(self.only_train_unet_number) or self.only_train_unet_number == unet_number, 'you cannot only train on one unet at a time. you will need to save the trainer into a checkpoint, and resume training on a new unet'\n\n        self.only_train_unet_number = unet_number\n        self.imagen.only_train_unet_number = unet_number\n\n        if not exists(unet_number):\n            return\n\n        self.wrap_unet(unet_number)\n\n    def wrap_unet(self, unet_number):\n        if hasattr(self, 'one_unet_wrapped'):\n            return\n\n        unet = self.imagen.get_unet(unet_number)\n        unet_index = unet_number - 1\n\n        optimizer = getattr(self, f'optim{unet_index}')\n        scheduler = getattr(self, f'scheduler{unet_index}')\n\n        if self.train_dl:\n            self.unet_being_trained, self.train_dl, optimizer = self.accelerator.prepare(unet, self.train_dl, optimizer)\n        else:\n            self.unet_being_trained, optimizer = self.accelerator.prepare(unet, optimizer)\n\n        if exists(scheduler):\n            scheduler = self.accelerator.prepare(scheduler)\n\n        setattr(self, f'optim{unet_index}', optimizer)\n        setattr(self, f'scheduler{unet_index}', scheduler)\n\n        self.one_unet_wrapped = True\n\n    # hacking accelerator due to not having separate gradscaler per optimizer\n\n    def set_accelerator_scaler(self, unet_number):\n        unet_number = self.validate_unet_number(unet_number)\n        scaler = getattr(self, f'scaler{unet_number - 1}')\n\n        self.accelerator.scaler = scaler\n        for optimizer in self.accelerator._optimizers:\n            optimizer.scaler = scaler\n\n    # helper print\n\n    def print(self, msg):\n        if not self.is_main:\n            return\n\n        if not self.verbose:\n            return\n\n        return self.accelerator.print(msg)\n\n    # validating the unet number\n\n    def validate_unet_number(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        assert 0 < unet_number <= self.num_unets, f'unet number should be in between 1 and {self.num_unets}'\n        return unet_number\n\n    # number of training steps taken\n\n    def num_steps_taken(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        return self.steps[unet_number - 1].item()\n\n    def print_untrained_unets(self):\n        print_final_error = False\n\n        for ind, (steps, unet) in enumerate(zip(self.steps.tolist(), self.imagen.unets)):\n            if steps > 0 or isinstance(unet, NullUnet):\n                continue\n\n            self.print(f'unet {ind + 1} has not been trained')\n            print_final_error = True\n\n        if print_final_error:\n            self.print('when sampling, you can pass stop_at_unet_number to stop early in the cascade, so it does not try to generate with untrained unets')\n\n    # data related functions\n\n    def add_train_dataloader(self, dl = None):\n        if not exists(dl):\n            return\n\n        assert not exists(self.train_dl), 'training dataloader was already added'\n        assert not self.prepared, f'You need to add the dataset before preperation'\n        self.train_dl = dl\n\n    def add_valid_dataloader(self, dl):\n        if not exists(dl):\n            return\n\n        assert not exists(self.valid_dl), 'validation dataloader was already added'\n        assert not self.prepared, f'You need to add the dataset before preperation'\n        self.valid_dl = dl\n\n    def add_train_dataset(self, ds = None, *, batch_size, **dl_kwargs):\n        if not exists(ds):\n            return\n\n        assert not exists(self.train_dl), 'training dataloader was already added'\n\n        valid_ds = None\n        if self.split_valid_from_train:\n            train_size = int((1 - self.split_valid_fraction) * len(ds))\n            valid_size = len(ds) - train_size\n\n            ds, valid_ds = random_split(ds, [train_size, valid_size], generator = torch.Generator().manual_seed(self.split_random_seed))\n            self.print(f'training with dataset of {len(ds)} samples and validating with randomly splitted {len(valid_ds)} samples')\n\n        dl = DataLoader(ds, batch_size = batch_size, **dl_kwargs)\n        self.add_train_dataloader(dl)\n\n        if not self.split_valid_from_train:\n            return\n\n        self.add_valid_dataset(valid_ds, batch_size = batch_size, **dl_kwargs)\n\n    def add_valid_dataset(self, ds, *, batch_size, **dl_kwargs):\n        if not exists(ds):\n            return\n\n        assert not exists(self.valid_dl), 'validation dataloader was already added'\n\n        dl = DataLoader(ds, batch_size = batch_size, **dl_kwargs)\n        self.add_valid_dataloader(dl)\n\n    def create_train_iter(self):\n        assert exists(self.train_dl), 'training dataloader has not been registered with the trainer yet'\n\n        if exists(self.train_dl_iter):\n            return\n\n        self.train_dl_iter = cycle(self.train_dl)\n\n    def create_valid_iter(self):\n        assert exists(self.valid_dl), 'validation dataloader has not been registered with the trainer yet'\n\n        if exists(self.valid_dl_iter):\n            return\n\n        self.valid_dl_iter = cycle(self.valid_dl)\n\n    def train_step(self, unet_number = None, **kwargs):"
  },
  {
    "id": "64",
    "text": " # optimizer helper functions\n\n    def get_lr(self, unet_number):\n        self.validate_unet_number(unet_number)\n        unet_index = unet_number - 1\n\n        optim = getattr(self, f'optim{unet_index}')\n\n        return optim.param_groups[0]['lr']\n\n    # function for allowing only one unet from being trained at a time\n\n    def validate_and_set_unet_being_trained(self, unet_number = None):\n        if exists(unet_number):\n            self.validate_unet_number(unet_number)\n\n        assert not exists(self.only_train_unet_number) or self.only_train_unet_number == unet_number, 'you cannot only train on one unet at a time. you will need to save the trainer into a checkpoint, and resume training on a new unet'\n\n        self.only_train_unet_number = unet_number\n        self.imagen.only_train_unet_number = unet_number\n\n        if not exists(unet_number):\n            return\n\n        self.wrap_unet(unet_number)\n\n    def wrap_unet(self, unet_number):\n        if hasattr(self, 'one_unet_wrapped'):\n            return\n\n        unet = self.imagen.get_unet(unet_number)\n        unet_index = unet_number - 1\n\n        optimizer = getattr(self, f'optim{unet_index}')\n        scheduler = getattr(self, f'scheduler{unet_index}')\n\n        if self.train_dl:\n            self.unet_being_trained, self.train_dl, optimizer = self.accelerator.prepare(unet, self.train_dl, optimizer)\n        else:\n            self.unet_being_trained, optimizer = self.accelerator.prepare(unet, optimizer)\n\n        if exists(scheduler):\n            scheduler = self.accelerator.prepare(scheduler)\n\n        setattr(self, f'optim{unet_index}', optimizer)\n        setattr(self, f'scheduler{unet_index}', scheduler)\n\n        self.one_unet_wrapped = True\n\n    # hacking accelerator due to not having separate gradscaler per optimizer\n\n    def set_accelerator_scaler(self, unet_number):\n        unet_number = self.validate_unet_number(unet_number)\n        scaler = getattr(self, f'scaler{unet_number - 1}')\n\n        self.accelerator.scaler = scaler\n        for optimizer in self.accelerator._optimizers:\n            optimizer.scaler = scaler\n\n    # helper print\n\n    def print(self, msg):\n        if not self.is_main:\n            return\n\n        if not self.verbose:\n            return\n\n        return self.accelerator.print(msg)\n\n    # validating the unet number\n\n    def validate_unet_number(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        assert 0 < unet_number <= self.num_unets, f'unet number should be in between 1 and {self.num_unets}'\n        return unet_number\n\n    # number of training steps taken\n\n    def num_steps_taken(self, unet_number = None):\n        if self.num_unets == 1:\n            unet_number = default(unet_number, 1)\n\n        return self.steps[unet_number - 1].item()\n\n    def print_untrained_unets(self):\n        print_final_error = False\n\n        for ind, (steps, unet) in enumerate(zip(self.steps.tolist(), self.imagen.unets)):\n            if steps > 0 or isinstance(unet, NullUnet):\n                continue\n\n            self.print(f'unet {ind + 1} has not been trained')\n            print_final_error = True\n\n        if print_final_error:\n            self.print('when sampling, you can pass stop_at_unet_number to stop early in the cascade, so it does not try to generate with untrained unets')\n\n    # data related functions\n\n    def add_train_dataloader(self, dl = None):\n        if not exists(dl):\n            return\n\n        assert not exists(self.train_dl), 'training dataloader was already added'\n        assert not self.prepared, f'You need to add the dataset before preperation'\n        self.train_dl = dl\n\n    def add_valid_dataloader(self, dl):\n        if not exists(dl):\n            return\n\n        assert not exists(self.valid_dl), 'validation dataloader was already added'\n        assert not self.prepared, f'You need to add the dataset before preperation'\n        self.valid_dl = dl\n\n    def add_train_dataset(self, ds = None, *, batch_size, **dl_kwargs):\n        if not exists(ds):\n            return\n\n        assert not exists(self.train_dl), 'training dataloader was already added'\n\n        valid_ds = None\n        if self.split_valid_from_train:\n            train_size = int((1 - self.split_valid_fraction) * len(ds))\n            valid_size = len(ds) - train_size\n\n            ds, valid_ds = random_split(ds, [train_size, valid_size], generator = torch.Generator().manual_seed(self.split_random_seed))\n            self.print(f'training with dataset of {len(ds)} samples and validating with randomly splitted {len(valid_ds)} samples')\n\n        dl = DataLoader(ds, batch_size = batch_size, **dl_kwargs)\n        self.add_train_dataloader(dl)\n\n        if not self.split_valid_from_train:\n            return\n\n        self.add_valid_dataset(valid_ds, batch_size = batch_size, **dl_kwargs)\n\n    def add_valid_dataset(self, ds, *, batch_size, **dl_kwargs):\n        if not exists(ds):\n            return\n\n        assert not exists(self.valid_dl), 'validation dataloader was already added'\n\n        dl = DataLoader(ds, batch_size = batch_size, **dl_kwargs)\n        self.add_valid_dataloader(dl)\n\n    def create_train_iter(self):\n        assert exists(self.train_dl), 'training dataloader has not been registered with the trainer yet'\n\n        if exists(self.train_dl_iter):\n            return\n\n        self.train_dl_iter = cycle(self.train_dl)\n\n    def create_valid_iter(self):\n        assert exists(self.valid_dl), 'validation dataloader has not been registered with the trainer yet'\n\n        if exists(self.valid_dl_iter):\n            return\n\n        self.valid_dl_iter = cycle(self.valid_dl)\n\n    def train_step(self, unet_number = None, **kwargs):\n        if not self.prepared:\n            self.prepare()\n        self.create_train_iter()\n        loss = self.step_with_dl_iter(self.train_dl_iter, unet_number = unet_number, **kwargs)\n        self.update(unet_number = unet_number)\n        return loss\n\n    @torch.no_grad()\n    @eval_decorator\n    def valid_step(self, **kwargs):\n        if not self.prepared:\n            self.prepare()\n        self.create_valid_iter()\n        context = self.use_ema_unets if kwargs.pop('use_ema_unets', False) else nullcontext\n        with context():\n            loss = self.step_with_dl_iter(self.valid_dl_iter, **kwargs)\n        return loss\n\n    def step_with_dl_iter(self, dl_iter, **kwargs):"
  },
  {
    "id": "65",
    "text": "uple_output)))\n        loss = self.forward(**{**kwargs, **model_input})\n        return loss\n\n    # checkpointing functions\n\n    @property\n    def all_checkpoints_sorted(self):\n        glob_pattern = os.path.join(self.checkpoint_path, '*.pt')\n        checkpoints = self.fs.glob(glob_pattern)\n        sorted_checkpoints = sorted(checkpoints, key = lambda x: int(str(x).split('.')[-2]), reverse = True)\n        return sorted_checkpoints\n\n    def load_from_checkpoint_folder(self, last_total_steps = -1):\n        if last_total_steps != -1:\n            filepath = os.path.join(self.checkpoint_path, f'checkpoint.{last_total_steps}.pt')\n            self.load(filepath)\n            return\n\n        sorted_checkpoints = self.all_checkpoints_sorted\n\n        if len(sorted_checkpoints) == 0:\n            self.print(f'no checkpoints found to load from at {self.checkpoint_path}')\n            return\n\n        last_checkpoint = sorted_checkpoints[0]\n        self.load(last_checkpoint)\n\n    def save_to_checkpoint_folder(self):\n        self.accelerator.wait_for_everyone()\n\n        if not self.can_checkpoint:\n            return\n\n        total_steps = int(self.steps.sum().item())\n        filepath = os.path.join(self.checkpoint_path, f'checkpoint.{total_steps}.pt')\n\n        self.save(filepath)\n\n        if self.max_checkpoints_keep <= 0:\n            return\n\n        sorted_checkpoints = self.all_checkpoints_sorted\n        checkpoints_to_discard = sorted_checkpoints[self.max_checkpoints_keep:]\n\n        for checkpoint in checkpoints_to_discard:\n            self.fs.rm(checkpoint)\n\n    # saving and loading functions\n\n    def save(\n        self,\n        path,\n        overwrite = True,\n        without_optim_and_sched = False,\n        **kwargs\n    ):\n        self.accelerator.wait_for_everyone()\n\n        if not self.can_checkpoint:\n            return\n\n        fs = self.fs\n\n        assert not (fs.exists(path) and not overwrite)\n\n        self.reset_ema_unets_all_one_device()\n\n        save_obj = dict(\n            model = self.imagen.state_dict(),\n            version = __version__,\n            steps = self.steps.cpu(),\n            **kwargs\n        )\n\n        save_optim_and_sched_iter = range(0, self.num_unets) if not without_optim_and_sched else tuple()\n\n        for ind in save_optim_and_sched_iter:\n            scaler_key = f'scaler{ind}'\n            optimizer_key = f'optim{ind}'\n            scheduler_key = f'scheduler{ind}'\n            warmup_scheduler_key = f'warmup{ind}'\n\n            scaler = getattr(self, scaler_key)\n            optimizer = getattr(self, optimizer_key)\n            scheduler = getattr(self, scheduler_key)\n            warmup_scheduler = getattr(self, warmup_scheduler_key)\n\n            if exists(scheduler):\n                save_obj = {**save_obj, scheduler_key: scheduler.state_dict()}\n\n            if exists(warmup_scheduler):\n                save_obj = {**save_obj, warmup_scheduler_key: warmup_scheduler.state_dict()}\n\n            save_obj = {**save_obj, scaler_key: scaler.state_dict(), optimizer_key: optimizer.state_dict()}\n\n        if self.use_ema:\n            save_obj = {**save_obj, 'ema': self.ema_unets.state_dict()}\n\n        # determine if imagen config is available\n\n        if hasattr(self.imagen, '_config'):\n            self.print(f'this checkpoint is commandable from the CLI - \"imagen --model {str(path)} \\\"<prompt>\\\"\"')\n\n            save_obj = {\n                **save_obj,\n                'imagen_type': 'elucidated' if self.is_elucidated else 'original',\n                'imagen_params': self.imagen._config\n            }\n\n        #save to path\n\n        with fs.open(path, 'wb') as f:\n            torch.save(save_obj, f)\n\n        self.print(f'checkpoint saved to {path}')\n\n    def load(self, path, only_model = False, strict = True, noop_if_not_exist = False):\n        fs = self.fs\n\n        if noop_if_not_exist and not fs.exists(path):\n            self.print(f'trainer checkpoint not found at {str(path)}')\n            return\n\n        assert fs.exists(path), f'{path} does not exist'\n\n        self.reset_ema_unets_all_one_device()\n\n        # to avoid extra GPU memory usage in main process when using Accelerate\n\n        with fs.open(path) as f:\n            loaded_obj = torch.load(f, map_location='cpu')\n\n        if version.parse(__version__) != version.parse(loaded_obj['version']):\n            self.print(f'loading saved imagen at version {loaded_obj[\"version\"]}, but current package version is {__version__}')\n\n        try:\n            self.imagen.load_state_dict(loaded_obj['model'], strict = strict)\n        except RuntimeError:\n            print(\"Failed loading state dict. Trying partial load\")\n            self.imagen.load_state_dict(restore_parts(self.imagen.state_dict(),\n                                                      loaded_obj['model']))\n\n        if only_model:\n            return loaded_obj\n\n        self.steps.copy_(loaded_obj['steps'])\n\n        for ind in range(0, self.num_unets):\n            scaler_key = f'scaler{ind}'\n            optimizer_key = f'optim{ind}'\n            scheduler_key = f'scheduler{ind}'\n            warmup_scheduler_key = f'warmup{ind}'\n\n            scaler = getattr(self, scaler_key)\n            optimizer = getattr(self, optimizer_key)\n            scheduler = getattr(self, scheduler_key)\n            warmup_scheduler = getattr(self, warmup_scheduler_key)\n\n            if exists(scheduler) and scheduler_key in loaded_obj:\n                scheduler.load_state_dict(loaded_obj[scheduler_key])\n\n            if exists(warmup_scheduler) and warmup_scheduler_key in loaded_obj:\n                warmup_scheduler.load_state_dict(loaded_obj[warmup_scheduler_key])\n\n            if exists(optimizer):\n                try:\n                    optimizer.load_state_dict(loaded_obj[optimizer_key])\n                    scaler.load_state_dict(loaded_obj[scaler_key])\n                except:\n                    self.print('could not load optimizer and scaler, possibly because you have turned on mixed precision training since the last run. resuming with new optimizer and scalers')\n\n        if self.use_ema:\n            assert 'ema' in loaded_obj\n            try:\n                self.ema_unets.load_state_dict(loaded_obj['ema'], strict = strict)\n            except RuntimeError:\n                print(\"Failed loading state dict. Trying partial load\")\n                self.ema_unets.load_state_dict(restore_parts(self.ema_unets.state_dict(),\n                                                             loaded_obj['ema']))\n\n        self.print(f'checkpoint loaded from {path}')\n        return loaded_obj\n\n    # managing ema unets and their devices\n\n    @property\n    def unets(self):\n        return nn.ModuleList([ema.ema_model for ema in self.ema_unets])\n\n    def get_ema_unet(self, unet_number = None):"
  },
  {
    "id": "66",
    "text": "uler_key = f'scheduler{ind}'\n            warmup_scheduler_key = f'warmup{ind}'\n\n            scaler = getattr(self, scaler_key)\n            optimizer = getattr(self, optimizer_key)\n            scheduler = getattr(self, scheduler_key)\n            warmup_scheduler = getattr(self, warmup_scheduler_key)\n\n            if exists(scheduler) and scheduler_key in loaded_obj:\n                scheduler.load_state_dict(loaded_obj[scheduler_key])\n\n            if exists(warmup_scheduler) and warmup_scheduler_key in loaded_obj:\n                warmup_scheduler.load_state_dict(loaded_obj[warmup_scheduler_key])\n\n            if exists(optimizer):\n                try:\n                    optimizer.load_state_dict(loaded_obj[optimizer_key])\n                    scaler.load_state_dict(loaded_obj[scaler_key])\n                except:\n                    self.print('could not load optimizer and scaler, possibly because you have turned on mixed precision training since the last run. resuming with new optimizer and scalers')\n\n        if self.use_ema:\n            assert 'ema' in loaded_obj\n            try:\n                self.ema_unets.load_state_dict(loaded_obj['ema'], strict = strict)\n            except RuntimeError:\n                print(\"Failed loading state dict. Trying partial load\")\n                self.ema_unets.load_state_dict(restore_parts(self.ema_unets.state_dict(),\n                                                             loaded_obj['ema']))\n\n        self.print(f'checkpoint loaded from {path}')\n        return loaded_obj\n\n    # managing ema unets and their devices\n\n    @property\n    def unets(self):\n        return nn.ModuleList([ema.ema_model for ema in self.ema_unets])\n\n    def get_ema_unet(self, unet_number = None):\n        if not self.use_ema:\n            return\n\n        unet_number = self.validate_unet_number(unet_number)\n        index = unet_number - 1\n\n        if isinstance(self.unets, nn.ModuleList):\n            unets_list = [unet for unet in self.ema_unets]\n            delattr(self, 'ema_unets')\n            self.ema_unets = unets_list\n\n        if index != self.ema_unet_being_trained_index:\n            for unet_index, unet in enumerate(self.ema_unets):\n                unet.to(self.device if unet_index == index else 'cpu')\n\n        self.ema_unet_being_trained_index = index\n        return self.ema_unets[index]\n\n    def reset_ema_unets_all_one_device(self, device = None):\n        if not self.use_ema:\n            return\n\n        device = default(device, self.device)\n        self.ema_unets = nn.ModuleList([*self.ema_unets])\n        self.ema_unets.to(device)\n\n        self.ema_unet_being_trained_index = -1\n\n    @torch.no_grad()\n    @contextmanager\n    def use_ema_unets(self):\n        if not self.use_ema:\n            output = yield\n            return output\n\n        self.reset_ema_unets_all_one_device()\n        self.imagen.reset_unets_all_one_device()\n\n        self.unets.eval()\n\n        trainable_unets = self.imagen.unets\n        self.imagen.unets = self.unets                  # swap in exponential moving averaged unets for sampling\n\n        output = yield\n\n        self.imagen.unets = trainable_unets             # restore original training unets\n\n        # cast the ema_model unets back to original device\n        for ema in self.ema_unets:\n            ema.restore_ema_model_device()\n\n        return output\n\n    def print_unet_devices(self):\n        self.print('unet devices:')\n        for i, unet in enumerate(self.imagen.unets):\n            device = next(unet.parameters()).device\n            self.print(f'\\tunet {i}: {device}')\n\n        if not self.use_ema:\n            return\n\n        self.print('\\nema unet devices:')\n        for i, ema_unet in enumerate(self.ema_unets):\n            device = next(ema_unet.parameters()).device\n            self.print(f'\\tema unet {i}: {device}')\n\n    # overriding state dict functions\n\n    def state_dict(self, *args, **kwargs):\n        self.reset_ema_unets_all_one_device()\n        return super().state_dict(*args, **kwargs)\n\n    def load_state_dict(self, *args, **kwargs):\n        self.reset_ema_unets_all_one_device()\n        return super().load_state_dict(*args, **kwargs)\n\n    # encoding text functions\n\n    def encode_text(self, text, **kwargs):\n        return self.imagen.encode_text(text, **kwargs)\n\n    # forwarding functions and gradient step updates\n\n    def update(self, unet_number = None):\n        unet_number = self.validate_unet_number(unet_number)\n        self.validate_and_set_unet_being_trained(unet_number)\n        self.set_accelerator_scaler(unet_number)\n\n        index = unet_number - 1\n        unet = self.unet_being_trained\n\n        optimizer = getattr(self, f'optim{index}')\n        scaler = getattr(self, f'scaler{index}')\n        scheduler = getattr(self, f'scheduler{index}')\n        warmup_scheduler = getattr(self, f'warmup{index}')\n\n        # set the grad scaler on the accelerator, since we are managing one per u-net\n\n        if exists(self.max_grad_norm):\n            self.accelerator.clip_grad_norm_(unet.parameters(), self.max_grad_norm)\n\n        optimizer.step()\n        optimizer.zero_grad()\n\n        if self.use_ema:\n            ema_unet = self.get_ema_unet(unet_number)\n            ema_unet.update()\n\n        # scheduler, if needed\n\n        maybe_warmup_context = nullcontext() if not exists(warmup_scheduler) else warmup_scheduler.dampening()\n\n        with maybe_warmup_context:\n            if exists(scheduler) and not self.accelerator.optimizer_step_was_skipped: # recommended in the docs\n                scheduler.step()\n\n        self.steps += F.one_hot(torch.tensor(unet_number - 1, device = self.steps.device), num_classes = len(self.steps))\n\n        if not exists(self.checkpoint_path):\n            return\n\n        total_steps = int(self.steps.sum().item())\n\n        if total_steps % self.checkpoint_every:\n            return\n\n        self.save_to_checkpoint_folder()\n\n    @torch.no_grad()\n    @cast_torch_tensor\n    @imagen_sample_in_chunks\n    def sample(self, *args, **kwargs):\n        context = nullcontext if  kwargs.pop('use_non_ema', False) else self.use_ema_unets\n\n        self.print_untrained_unets()\n\n        if not self.is_main:\n            kwargs['use_tqdm'] = False\n\n        with context():\n            output = self.imagen.sample(*args, device = self.device, **kwargs)\n\n        return output\n\n    @partial(cast_torch_tensor, cast_fp16 = True)\n    def forward(\n        self,\n        *args,\n        unet_number = None,\n        max_batch_size = None,\n        **kwargs\n    ):"
  },
  {
    "id": "67",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP Evaluator which applies causal masks to selectors.\"\"\"\n\nfrom typing import Sequence, Union\n\nimport numpy as np\nfrom tracr.rasp import rasp\n\n\nclass CausalEvaluator(rasp.DefaultRASPEvaluator):\n  \"\"\"Evaluates RASP with causal masking.\"\"\"\n\n  def evaluate(\n      self, expr: rasp.RASPExpr, xs: Sequence[rasp.Value]\n  ) -> Union[Sequence[rasp.Value], rasp.SelectorValue]:"
  },
  {
    "id": "68",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP program objects.\n\nEvery object in the RASP language is a function.\n\nThe most important type is S-Op, which is a function List[Value] -> List[Value].\n\nAn S-Op represents a state inside the residual stream of the transformer.\nTherefore, any RASP program that represents a transformer computation must\ndefine a final S-Op that represents the state of the residual stream at the\nend of the computation. In particular, given an S-Op `x`,\n`x([1, 2, 3])` represents something like the state of the residual stream\nat location `x` when the transformer is fed [1, 2, 3] as input.\n\nA secondary (but still important) type is Selector, which is a function\nList[Value] -> List[List[bool]]. Given a Selector `sel`, sel([1, 2, 3])\nrepresents something like an attention matrix in the transformer.\n\nFor a full reference on RASP, see https://arxiv.org/abs/2106.06981.\n\"\"\"\n\nimport abc\nimport collections.abc\nimport copy\nimport enum\nimport functools\nimport itertools\nfrom typing import (Any, Callable, Dict, Generic, List, Mapping, Optional,\n                    Sequence, TypeVar, Union)\n\nfrom absl import logging\nimport numpy as np\nfrom typing_extensions import Protocol\n\nSelectorValue = List[List[bool]]\nNumericValue = Union[int, float]\nValue = Union[None, int, float, str, bool]\nVT = TypeVar(\"VT\", bound=Value)\nRASPExprT = TypeVar(\"RASPExprT\", bound=\"RASPExpr\")\nSOpT = TypeVar(\"SOpT\", bound=\"SOp\")\nT = TypeVar(\"T\")\n\n_NAME_KEY = \"name\"\n_ENCODING_KEY = \"encoding\"\n\n# These are run on every expression when it's initialised.\n# Add your own annotators to this dict to add custom default annotations.\n#\n# For example, DEFAULT_ANNOTATORS['foo'] will provide the default value for\n# expr.annotations['foo]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:"
  },
  {
    "id": "69",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP program objects.\n\nEvery object in the RASP language is a function.\n\nThe most important type is S-Op, which is a function List[Value] -> List[Value].\n\nAn S-Op represents a state inside the residual stream of the transformer.\nTherefore, any RASP program that represents a transformer computation must\ndefine a final S-Op that represents the state of the residual stream at the\nend of the computation. In particular, given an S-Op `x`,\n`x([1, 2, 3])` represents something like the state of the residual stream\nat location `x` when the transformer is fed [1, 2, 3] as input.\n\nA secondary (but still important) type is Selector, which is a function\nList[Value] -> List[List[bool]]. Given a Selector `sel`, sel([1, 2, 3])\nrepresents something like an attention matrix in the transformer.\n\nFor a full reference on RASP, see https://arxiv.org/abs/2106.06981.\n\"\"\"\n\nimport abc\nimport collections.abc\nimport copy\nimport enum\nimport functools\nimport itertools\nfrom typing import (Any, Callable, Dict, Generic, List, Mapping, Optional,\n                    Sequence, TypeVar, Union)\n\nfrom absl import logging\nimport numpy as np\nfrom typing_extensions import Protocol\n\nSelectorValue = List[List[bool]]\nNumericValue = Union[int, float]\nValue = Union[None, int, float, str, bool]\nVT = TypeVar(\"VT\", bound=Value)\nRASPExprT = TypeVar(\"RASPExprT\", bound=\"RASPExpr\")\nSOpT = TypeVar(\"SOpT\", bound=\"SOp\")\nT = TypeVar(\"T\")\n\n_NAME_KEY = \"name\"\n_ENCODING_KEY = \"encoding\"\n\n# These are run on every expression when it's initialised.\n# Add your own annotators to this dict to add custom default annotations.\n#\n# For example, DEFAULT_ANNOTATORS['foo'] will provide the default value for\n# expr.annotations['foo]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\""
  },
  {
    "id": "70",
    "text": ".\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP program objects.\n\nEvery object in the RASP language is a function.\n\nThe most important type is S-Op, which is a function List[Value] -> List[Value].\n\nAn S-Op represents a state inside the residual stream of the transformer.\nTherefore, any RASP program that represents a transformer computation must\ndefine a final S-Op that represents the state of the residual stream at the\nend of the computation. In particular, given an S-Op `x`,\n`x([1, 2, 3])` represents something like the state of the residual stream\nat location `x` when the transformer is fed [1, 2, 3] as input.\n\nA secondary (but still important) type is Selector, which is a function\nList[Value] -> List[List[bool]]. Given a Selector `sel`, sel([1, 2, 3])\nrepresents something like an attention matrix in the transformer.\n\nFor a full reference on RASP, see https://arxiv.org/abs/2106.06981.\n\"\"\"\n\nimport abc\nimport collections.abc\nimport copy\nimport enum\nimport functools\nimport itertools\nfrom typing import (Any, Callable, Dict, Generic, List, Mapping, Optional,\n                    Sequence, TypeVar, Union)\n\nfrom absl import logging\nimport numpy as np\nfrom typing_extensions import Protocol\n\nSelectorValue = List[List[bool]]\nNumericValue = Union[int, float]\nValue = Union[None, int, float, str, bool]\nVT = TypeVar(\"VT\", bound=Value)\nRASPExprT = TypeVar(\"RASPExprT\", bound=\"RASPExpr\")\nSOpT = TypeVar(\"SOpT\", bound=\"SOp\")\nT = TypeVar(\"T\")\n\n_NAME_KEY = \"name\"\n_ENCODING_KEY = \"encoding\"\n\n# These are run on every expression when it's initialised.\n# Add your own annotators to this dict to add custom default annotations.\n#\n# For example, DEFAULT_ANNOTATORS['foo'] will provide the default value for\n# expr.annotations['foo]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\""
  },
  {
    "id": "71",
    "text": " applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP program objects.\n\nEvery object in the RASP language is a function.\n\nThe most important type is S-Op, which is a function List[Value] -> List[Value].\n\nAn S-Op represents a state inside the residual stream of the transformer.\nTherefore, any RASP program that represents a transformer computation must\ndefine a final S-Op that represents the state of the residual stream at the\nend of the computation. In particular, given an S-Op `x`,\n`x([1, 2, 3])` represents something like the state of the residual stream\nat location `x` when the transformer is fed [1, 2, 3] as input.\n\nA secondary (but still important) type is Selector, which is a function\nList[Value] -> List[List[bool]]. Given a Selector `sel`, sel([1, 2, 3])\nrepresents something like an attention matrix in the transformer.\n\nFor a full reference on RASP, see https://arxiv.org/abs/2106.06981.\n\"\"\"\n\nimport abc\nimport collections.abc\nimport copy\nimport enum\nimport functools\nimport itertools\nfrom typing import (Any, Callable, Dict, Generic, List, Mapping, Optional,\n                    Sequence, TypeVar, Union)\n\nfrom absl import logging\nimport numpy as np\nfrom typing_extensions import Protocol\n\nSelectorValue = List[List[bool]]\nNumericValue = Union[int, float]\nValue = Union[None, int, float, str, bool]\nVT = TypeVar(\"VT\", bound=Value)\nRASPExprT = TypeVar(\"RASPExprT\", bound=\"RASPExpr\")\nSOpT = TypeVar(\"SOpT\", bound=\"SOp\")\nT = TypeVar(\"T\")\n\n_NAME_KEY = \"name\"\n_ENCODING_KEY = \"encoding\"\n\n# These are run on every expression when it's initialised.\n# Add your own annotators to this dict to add custom default annotations.\n#\n# For example, DEFAULT_ANNOTATORS['foo'] will provide the default value for\n# expr.annotations['foo]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\""
  },
  {
    "id": "72",
    "text": "\n\nEvery object in the RASP language is a function.\n\nThe most important type is S-Op, which is a function List[Value] -> List[Value].\n\nAn S-Op represents a state inside the residual stream of the transformer.\nTherefore, any RASP program that represents a transformer computation must\ndefine a final S-Op that represents the state of the residual stream at the\nend of the computation. In particular, given an S-Op `x`,\n`x([1, 2, 3])` represents something like the state of the residual stream\nat location `x` when the transformer is fed [1, 2, 3] as input.\n\nA secondary (but still important) type is Selector, which is a function\nList[Value] -> List[List[bool]]. Given a Selector `sel`, sel([1, 2, 3])\nrepresents something like an attention matrix in the transformer.\n\nFor a full reference on RASP, see https://arxiv.org/abs/2106.06981.\n\"\"\"\n\nimport abc\nimport collections.abc\nimport copy\nimport enum\nimport functools\nimport itertools\nfrom typing import (Any, Callable, Dict, Generic, List, Mapping, Optional,\n                    Sequence, TypeVar, Union)\n\nfrom absl import logging\nimport numpy as np\nfrom typing_extensions import Protocol\n\nSelectorValue = List[List[bool]]\nNumericValue = Union[int, float]\nValue = Union[None, int, float, str, bool]\nVT = TypeVar(\"VT\", bound=Value)\nRASPExprT = TypeVar(\"RASPExprT\", bound=\"RASPExpr\")\nSOpT = TypeVar(\"SOpT\", bound=\"SOp\")\nT = TypeVar(\"T\")\n\n_NAME_KEY = \"name\"\n_ENCODING_KEY = \"encoding\"\n\n# These are run on every expression when it's initialised.\n# Add your own annotators to this dict to add custom default annotations.\n#\n# For example, DEFAULT_ANNOTATORS['foo'] will provide the default value for\n# expr.annotations['foo]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\""
  },
  {
    "id": "73",
    "text": " the state of the residual stream at the\nend of the computation. In particular, given an S-Op `x`,\n`x([1, 2, 3])` represents something like the state of the residual stream\nat location `x` when the transformer is fed [1, 2, 3] as input.\n\nA secondary (but still important) type is Selector, which is a function\nList[Value] -> List[List[bool]]. Given a Selector `sel`, sel([1, 2, 3])\nrepresents something like an attention matrix in the transformer.\n\nFor a full reference on RASP, see https://arxiv.org/abs/2106.06981.\n\"\"\"\n\nimport abc\nimport collections.abc\nimport copy\nimport enum\nimport functools\nimport itertools\nfrom typing import (Any, Callable, Dict, Generic, List, Mapping, Optional,\n                    Sequence, TypeVar, Union)\n\nfrom absl import logging\nimport numpy as np\nfrom typing_extensions import Protocol\n\nSelectorValue = List[List[bool]]\nNumericValue = Union[int, float]\nValue = Union[None, int, float, str, bool]\nVT = TypeVar(\"VT\", bound=Value)\nRASPExprT = TypeVar(\"RASPExprT\", bound=\"RASPExpr\")\nSOpT = TypeVar(\"SOpT\", bound=\"SOp\")\nT = TypeVar(\"T\")\n\n_NAME_KEY = \"name\"\n_ENCODING_KEY = \"encoding\"\n\n# These are run on every expression when it's initialised.\n# Add your own annotators to this dict to add custom default annotations.\n#\n# For example, DEFAULT_ANNOTATORS['foo'] will provide the default value for\n# expr.annotations['foo]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\""
  },
  {
    "id": "74",
    "text": "or, which is a function\nList[Value] -> List[List[bool]]. Given a Selector `sel`, sel([1, 2, 3])\nrepresents something like an attention matrix in the transformer.\n\nFor a full reference on RASP, see https://arxiv.org/abs/2106.06981.\n\"\"\"\n\nimport abc\nimport collections.abc\nimport copy\nimport enum\nimport functools\nimport itertools\nfrom typing import (Any, Callable, Dict, Generic, List, Mapping, Optional,\n                    Sequence, TypeVar, Union)\n\nfrom absl import logging\nimport numpy as np\nfrom typing_extensions import Protocol\n\nSelectorValue = List[List[bool]]\nNumericValue = Union[int, float]\nValue = Union[None, int, float, str, bool]\nVT = TypeVar(\"VT\", bound=Value)\nRASPExprT = TypeVar(\"RASPExprT\", bound=\"RASPExpr\")\nSOpT = TypeVar(\"SOpT\", bound=\"SOp\")\nT = TypeVar(\"T\")\n\n_NAME_KEY = \"name\"\n_ENCODING_KEY = \"encoding\"\n\n# These are run on every expression when it's initialised.\n# Add your own annotators to this dict to add custom default annotations.\n#\n# For example, DEFAULT_ANNOTATORS['foo'] will provide the default value for\n# expr.annotations['foo]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\""
  },
  {
    "id": "75",
    "text": "\n\nimport abc\nimport collections.abc\nimport copy\nimport enum\nimport functools\nimport itertools\nfrom typing import (Any, Callable, Dict, Generic, List, Mapping, Optional,\n                    Sequence, TypeVar, Union)\n\nfrom absl import logging\nimport numpy as np\nfrom typing_extensions import Protocol\n\nSelectorValue = List[List[bool]]\nNumericValue = Union[int, float]\nValue = Union[None, int, float, str, bool]\nVT = TypeVar(\"VT\", bound=Value)\nRASPExprT = TypeVar(\"RASPExprT\", bound=\"RASPExpr\")\nSOpT = TypeVar(\"SOpT\", bound=\"SOp\")\nT = TypeVar(\"T\")\n\n_NAME_KEY = \"name\"\n_ENCODING_KEY = \"encoding\"\n\n# These are run on every expression when it's initialised.\n# Add your own annotators to this dict to add custom default annotations.\n#\n# For example, DEFAULT_ANNOTATORS['foo'] will provide the default value for\n# expr.annotations['foo]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\""
  },
  {
    "id": "76",
    "text": "\nSelectorValue = List[List[bool]]\nNumericValue = Union[int, float]\nValue = Union[None, int, float, str, bool]\nVT = TypeVar(\"VT\", bound=Value)\nRASPExprT = TypeVar(\"RASPExprT\", bound=\"RASPExpr\")\nSOpT = TypeVar(\"SOpT\", bound=\"SOp\")\nT = TypeVar(\"T\")\n\n_NAME_KEY = \"name\"\n_ENCODING_KEY = \"encoding\"\n\n# These are run on every expression when it's initialised.\n# Add your own annotators to this dict to add custom default annotations.\n#\n# For example, DEFAULT_ANNOTATORS['foo'] will provide the default value for\n# expr.annotations['foo]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\""
  },
  {
    "id": "77",
    "text": "]. The annotator will get called lazily the first time\n# that key is accessed.\n#\n# See the `default_name` annotator for a full example.\nDEFAULT_ANNOTATORS: Dict[str, \"Annotator\"] = {}\n\n\nclass Annotator(Protocol):\n\n  def __call__(self, expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, self, other)\n    return Map(lambda x: x / other, self)\n\n  def __rtruediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other / self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, other, self)\n    return Map(lambda x: other / x, self)\n\n  def __invert__(self) -> \"SOp\":\n    return Map(lambda x: not x, self)\n\n  def __and__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self & other.\"\"\""
  },
  {
    "id": "78",
    "text": " expr: \"RASPExpr\") -> Any:\n    \"\"\"What annotation to add to `expr`.\"\"\"\n\n\nclass _Annotations(collections.abc.Mapping):\n  \"\"\"Holds the expression's annotations.\n\n  It's immutable to the user, but will attempt to generate default values\n  lazily when missing keys are requested.\n  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, self, other)\n    return Map(lambda x: x / other, self)\n\n  def __rtruediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other / self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, other, self)\n    return Map(lambda x: other / x, self)\n\n  def __invert__(self) -> \"SOp\":\n    return Map(lambda x: not x, self)\n\n  def __and__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self & other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, self, other)\n    return Map(lambda x: x and other, self)\n\n  def __or__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self | other.\"\"\""
  },
  {
    "id": "79",
    "text": "  \"\"\"\n\n  def __init__(self, expr, **kwargs: Any):\n    self._expr = expr\n    self._inner_dict: Dict[str, Any] = {**kwargs}\n\n  def __getitem__(self, key: str) -> Any:\n    if key not in self._inner_dict:\n      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, self, other)\n    return Map(lambda x: x / other, self)\n\n  def __rtruediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other / self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, other, self)\n    return Map(lambda x: other / x, self)\n\n  def __invert__(self) -> \"SOp\":\n    return Map(lambda x: not x, self)\n\n  def __and__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self & other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, self, other)\n    return Map(lambda x: x and other, self)\n\n  def __or__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self | other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, self, other)\n    return Map(lambda x: x or other, self)\n\n  def __rand__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other & self.\"\"\""
  },
  {
    "id": "80",
    "text": "      if key not in DEFAULT_ANNOTATORS:\n        raise KeyError(\n            f\"No annotation exists for key '{key}'. \"\n            f\"Available keys: {list(*self.keys(), *DEFAULT_ANNOTATORS.keys())}\")\n      self._inner_dict[key] = DEFAULT_ANNOTATORS[key](self._expr)\n\n    return self._inner_dict[key]\n\n  def __iter__(self):\n    return iter(self._inner_dict)\n\n  def __len__(self):\n    return len(self._inner_dict)\n\n\nclass RASPExpr(abc.ABC):\n  \"\"\"A class distinguishing RASP expressions from other objects.\"\"\"\n  _ids = itertools.count(1)\n\n  def __init__(self):\n    self._annotations: Mapping[str, Any] = _Annotations(self)\n\n  @abc.abstractmethod\n  def __call__(self,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASPExpr using the standard evaluator.\"\"\"\n\n  @property\n  def annotations(self) -> Mapping[str, Any]:\n    \"\"\"The annotations of this expression instance.\"\"\"\n    return self._annotations\n\n  @annotations.setter\n  def annotations(self, annotations: Mapping[str, Any]):\n    self._annotations = _Annotations(self, **annotations)\n\n  @property\n  def name(self) -> str:\n    \"\"\"The name of this expression.\"\"\"\n    return self.annotations[_NAME_KEY]\n\n  @property\n  @abc.abstractmethod\n  def children(self) -> Sequence[\"RASPExpr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, self, other)\n    return Map(lambda x: x / other, self)\n\n  def __rtruediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other / self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, other, self)\n    return Map(lambda x: other / x, self)\n\n  def __invert__(self) -> \"SOp\":\n    return Map(lambda x: not x, self)\n\n  def __and__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self & other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, self, other)\n    return Map(lambda x: x and other, self)\n\n  def __or__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self | other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, self, other)\n    return Map(lambda x: x or other, self)\n\n  def __rand__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other & self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, other, self)\n    return Map(lambda x: other and x, self)\n\n  def __ror__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other | self.\"\"\""
  },
  {
    "id": "81",
    "text": "pr\"]:\n    \"\"\"Direct dependencies of this expression.\"\"\"\n\n  @functools.cached_property\n  def unique_id(self):\n    \"\"\"A unique id for every expression instance.\"\"\"\n    return next(self._ids)\n\n  def copy(self: RASPExprT) -> RASPExprT:\n    \"\"\"Returns a shallow copy of this RASPExpr with a new ID.\"\"\"\n    return copy.copy(self)\n\n  @property\n  def label(self) -> str:\n    return f\"{self.name}_{self.unique_id}\"\n\n  def named(self: RASPExprT, name: str) -> RASPExprT:\n    \"\"\"Convenience method for adding a name.\"\"\"\n    return annotate(self, name=name)\n\n  def annotated(self: RASPExprT, **annotations) -> RASPExprT:\n    \"\"\"Convenience method for adding annotations.\"\"\"\n    return annotate(self, **annotations)\n\n\ndef annotate(expr: RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, self, other)\n    return Map(lambda x: x / other, self)\n\n  def __rtruediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other / self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, other, self)\n    return Map(lambda x: other / x, self)\n\n  def __invert__(self) -> \"SOp\":\n    return Map(lambda x: not x, self)\n\n  def __and__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self & other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, self, other)\n    return Map(lambda x: x and other, self)\n\n  def __or__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self | other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, self, other)\n    return Map(lambda x: x or other, self)\n\n  def __rand__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other & self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, other, self)\n    return Map(lambda x: other and x, self)\n\n  def __ror__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other | self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, other, self)\n    return Map(lambda x: x or other, self)\n\n\nclass TokensType(SOp):\n  \"\"\"Primitive SOp returning the original input tokens.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"tokens\"\n\n  def __repr__(self):\n    return \"tokens\"\n\n\nclass IndicesType(SOp):\n  \"\"\"Primitive SOp returning the position index at each token.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"indices\"\n\n  def __repr__(self):\n    return \"indices\"\n\n\nclass LengthType(SOp):\n  \"\"\"Primitive SOp returning the total length of the input.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"length\"\n\n  def __repr__(self):\n    return \"length\"\n\n\ntokens = TokensType()\nindices = IndicesType()\nlength = LengthType()\n\n\nclass Map(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the input SOp.\n\n  Map(lambda x: x + 1, tokens).eval([1, 2, 3]) == [2, 3, 4]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value], Value], inner: SOp):"
  },
  {
    "id": "82",
    "text": " RASPExprT, **annotations) -> RASPExprT:\n  \"\"\"Creates a new expr with added annotations.\"\"\"\n  new = expr.copy()\n  # Note that new annotations will overwrite existing ones with matching keys.\n  new.annotations = {**expr.annotations, **annotations}\n  return new\n\n\n### S-Ops.\n\n\nclass SOp(RASPExpr):\n  \"\"\"A Sequence Operation.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> Sequence[Value]:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of SOps using numeric operators with constant values.\n  # Note: if inheriting SOp by a dataclass, make sure to disable eq and order,\n  # as they will override these.\n\n  def __lt__(self, other: Value) -> \"SOp\":\n    \"\"\"self < other.\"\"\"\n    return Map(lambda x: x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, self, other)\n    return Map(lambda x: x / other, self)\n\n  def __rtruediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other / self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, other, self)\n    return Map(lambda x: other / x, self)\n\n  def __invert__(self) -> \"SOp\":\n    return Map(lambda x: not x, self)\n\n  def __and__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self & other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, self, other)\n    return Map(lambda x: x and other, self)\n\n  def __or__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self | other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, self, other)\n    return Map(lambda x: x or other, self)\n\n  def __rand__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other & self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, other, self)\n    return Map(lambda x: other and x, self)\n\n  def __ror__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other | self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, other, self)\n    return Map(lambda x: x or other, self)\n\n\nclass TokensType(SOp):\n  \"\"\"Primitive SOp returning the original input tokens.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"tokens\"\n\n  def __repr__(self):\n    return \"tokens\"\n\n\nclass IndicesType(SOp):\n  \"\"\"Primitive SOp returning the position index at each token.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"indices\"\n\n  def __repr__(self):\n    return \"indices\"\n\n\nclass LengthType(SOp):\n  \"\"\"Primitive SOp returning the total length of the input.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"length\"\n\n  def __repr__(self):\n    return \"length\"\n\n\ntokens = TokensType()\nindices = IndicesType()\nlength = LengthType()\n\n\nclass Map(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the input SOp.\n\n  Map(lambda x: x + 1, tokens).eval([1, 2, 3]) == [2, 3, 4]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value], Value], inner: SOp):\n    super().__init__()\n    self.f = f\n    self.inner = inner\n\n    assert isinstance(self.inner, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n    if isinstance(self.inner, Map):\n      # Combine the functions into just one.\n      inner_f = self.inner.f\n      self.f = lambda t: f(inner_f(t))\n      self.inner = self.inner.inner\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\nclass SequenceMap(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the two given SOp's.\n\n  SequenceMap(lambda x, y: x - y, length, tokens).eval([1, 2, 3]) == [2, 1, 0]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value, Value], Value], fst: SOp, snd: SOp):"
  },
  {
    "id": "83",
    "text": " x < other, self)\n\n  def __le__(self, other: Value) -> \"SOp\":\n    \"\"\"self <= other.\"\"\"\n    return Map(lambda x: x <= other, self)\n\n  def __eq__(self, other: Value) -> \"SOp\":\n    \"\"\"self == other.\"\"\"\n    return Map(lambda x: x == other, self)\n\n  def __ne__(self, other: Value) -> \"SOp\":\n    \"\"\"self != other.\"\"\"\n    return Map(lambda x: x != other, self)\n\n  def __gt__(self, other: Value) -> \"SOp\":\n    \"\"\"self > other.\"\"\"\n    return Map(lambda x: x > other, self)\n\n  def __ge__(self, other: Value) -> \"SOp\":\n    \"\"\"self >= other.\"\"\"\n    return Map(lambda x: x >= other, self)\n\n  def __add__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, self, other)\n    return Map(lambda x: x / other, self)\n\n  def __rtruediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other / self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, other, self)\n    return Map(lambda x: other / x, self)\n\n  def __invert__(self) -> \"SOp\":\n    return Map(lambda x: not x, self)\n\n  def __and__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self & other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, self, other)\n    return Map(lambda x: x and other, self)\n\n  def __or__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self | other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, self, other)\n    return Map(lambda x: x or other, self)\n\n  def __rand__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other & self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, other, self)\n    return Map(lambda x: other and x, self)\n\n  def __ror__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other | self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, other, self)\n    return Map(lambda x: x or other, self)\n\n\nclass TokensType(SOp):\n  \"\"\"Primitive SOp returning the original input tokens.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"tokens\"\n\n  def __repr__(self):\n    return \"tokens\"\n\n\nclass IndicesType(SOp):\n  \"\"\"Primitive SOp returning the position index at each token.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"indices\"\n\n  def __repr__(self):\n    return \"indices\"\n\n\nclass LengthType(SOp):\n  \"\"\"Primitive SOp returning the total length of the input.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"length\"\n\n  def __repr__(self):\n    return \"length\"\n\n\ntokens = TokensType()\nindices = IndicesType()\nlength = LengthType()\n\n\nclass Map(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the input SOp.\n\n  Map(lambda x: x + 1, tokens).eval([1, 2, 3]) == [2, 3, 4]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value], Value], inner: SOp):\n    super().__init__()\n    self.f = f\n    self.inner = inner\n\n    assert isinstance(self.inner, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n    if isinstance(self.inner, Map):\n      # Combine the functions into just one.\n      inner_f = self.inner.f\n      self.f = lambda t: f(inner_f(t))\n      self.inner = self.inner.inner\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\nclass SequenceMap(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the two given SOp's.\n\n  SequenceMap(lambda x, y: x - y, length, tokens).eval([1, 2, 3]) == [2, 1, 0]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value, Value], Value], fst: SOp, snd: SOp):\n    super().__init__()\n\n    if fst == snd:\n      logging.warning(\"Creating a SequenceMap with both inputs being the same \"\n                      \"SOp is discouraged. You should use a Map instead.\")\n\n    self.f = f\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, SOp)\n    assert isinstance(self.snd, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass LinearSequenceMap(SequenceMap):\n  \"\"\"SOp that evaluates a linear function elementwise on the two given SOp's.\"\"\"\n\n  def __init__(self, fst: SOp, snd: SOp, fst_fac: float, snd_fac: float):"
  },
  {
    "id": "84",
    "text": "\n    \"\"\"self + other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, self, other)\n    return Map(lambda x: x + other, self)\n\n  def __radd__(self, other: Union[\"SOp\", Value]) -> \"SOp\":\n    \"\"\"other + self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x + y, other, self)\n    return Map(lambda x: other + x, self)\n\n  def __sub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self - other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, self, other)\n    return Map(lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, self, other)\n    return Map(lambda x: x / other, self)\n\n  def __rtruediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other / self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, other, self)\n    return Map(lambda x: other / x, self)\n\n  def __invert__(self) -> \"SOp\":\n    return Map(lambda x: not x, self)\n\n  def __and__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self & other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, self, other)\n    return Map(lambda x: x and other, self)\n\n  def __or__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self | other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, self, other)\n    return Map(lambda x: x or other, self)\n\n  def __rand__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other & self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, other, self)\n    return Map(lambda x: other and x, self)\n\n  def __ror__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other | self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, other, self)\n    return Map(lambda x: x or other, self)\n\n\nclass TokensType(SOp):\n  \"\"\"Primitive SOp returning the original input tokens.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"tokens\"\n\n  def __repr__(self):\n    return \"tokens\"\n\n\nclass IndicesType(SOp):\n  \"\"\"Primitive SOp returning the position index at each token.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"indices\"\n\n  def __repr__(self):\n    return \"indices\"\n\n\nclass LengthType(SOp):\n  \"\"\"Primitive SOp returning the total length of the input.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"length\"\n\n  def __repr__(self):\n    return \"length\"\n\n\ntokens = TokensType()\nindices = IndicesType()\nlength = LengthType()\n\n\nclass Map(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the input SOp.\n\n  Map(lambda x: x + 1, tokens).eval([1, 2, 3]) == [2, 3, 4]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value], Value], inner: SOp):\n    super().__init__()\n    self.f = f\n    self.inner = inner\n\n    assert isinstance(self.inner, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n    if isinstance(self.inner, Map):\n      # Combine the functions into just one.\n      inner_f = self.inner.f\n      self.f = lambda t: f(inner_f(t))\n      self.inner = self.inner.inner\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\nclass SequenceMap(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the two given SOp's.\n\n  SequenceMap(lambda x, y: x - y, length, tokens).eval([1, 2, 3]) == [2, 1, 0]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value, Value], Value], fst: SOp, snd: SOp):\n    super().__init__()\n\n    if fst == snd:\n      logging.warning(\"Creating a SequenceMap with both inputs being the same \"\n                      \"SOp is discouraged. You should use a Map instead.\")\n\n    self.f = f\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, SOp)\n    assert isinstance(self.snd, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass LinearSequenceMap(SequenceMap):\n  \"\"\"SOp that evaluates a linear function elementwise on the two given SOp's.\"\"\"\n\n  def __init__(self, fst: SOp, snd: SOp, fst_fac: float, snd_fac: float):\n    super().__init__(fst=fst, snd=snd, f=lambda x, y: fst_fac * x + snd_fac * y)\n    self.fst_fac = fst_fac\n    self.snd_fac = snd_fac\n\n\nclass Full(SOp):\n  \"\"\"A SOp evaluating to [fill]*len(input_values).\"\"\"\n\n  def __init__(self, fill: Value):\n    super().__init__()\n    self.fill = fill\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\ndef sop_not(sop: SOp) -> SOp:\n  return Map(lambda t: not t, sop)\n\n\nclass ConstantSOp(SOp, Generic[VT]):\n  \"\"\"A constant S-Op for testing purposes.\"\"\"\n\n  def __init__(self, value: Sequence[VT], check_length: bool = True):"
  },
  {
    "id": "85",
    "text": "lambda x: x - other, self)\n\n  def __rsub__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other - self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x - y, other, self)\n    return Map(lambda x: other - x, self)\n\n  def __mul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self * other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, self, other)\n    return Map(lambda x: x * other, self)\n\n  def __rmul__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other * self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x * y, other, self)\n    return Map(lambda x: other * x, self)\n\n  def __truediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self / other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, self, other)\n    return Map(lambda x: x / other, self)\n\n  def __rtruediv__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other / self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x / y, other, self)\n    return Map(lambda x: other / x, self)\n\n  def __invert__(self) -> \"SOp\":\n    return Map(lambda x: not x, self)\n\n  def __and__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self & other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, self, other)\n    return Map(lambda x: x and other, self)\n\n  def __or__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self | other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, self, other)\n    return Map(lambda x: x or other, self)\n\n  def __rand__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other & self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, other, self)\n    return Map(lambda x: other and x, self)\n\n  def __ror__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other | self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, other, self)\n    return Map(lambda x: x or other, self)\n\n\nclass TokensType(SOp):\n  \"\"\"Primitive SOp returning the original input tokens.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"tokens\"\n\n  def __repr__(self):\n    return \"tokens\"\n\n\nclass IndicesType(SOp):\n  \"\"\"Primitive SOp returning the position index at each token.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"indices\"\n\n  def __repr__(self):\n    return \"indices\"\n\n\nclass LengthType(SOp):\n  \"\"\"Primitive SOp returning the total length of the input.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"length\"\n\n  def __repr__(self):\n    return \"length\"\n\n\ntokens = TokensType()\nindices = IndicesType()\nlength = LengthType()\n\n\nclass Map(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the input SOp.\n\n  Map(lambda x: x + 1, tokens).eval([1, 2, 3]) == [2, 3, 4]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value], Value], inner: SOp):\n    super().__init__()\n    self.f = f\n    self.inner = inner\n\n    assert isinstance(self.inner, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n    if isinstance(self.inner, Map):\n      # Combine the functions into just one.\n      inner_f = self.inner.f\n      self.f = lambda t: f(inner_f(t))\n      self.inner = self.inner.inner\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\nclass SequenceMap(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the two given SOp's.\n\n  SequenceMap(lambda x, y: x - y, length, tokens).eval([1, 2, 3]) == [2, 1, 0]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value, Value], Value], fst: SOp, snd: SOp):\n    super().__init__()\n\n    if fst == snd:\n      logging.warning(\"Creating a SequenceMap with both inputs being the same \"\n                      \"SOp is discouraged. You should use a Map instead.\")\n\n    self.f = f\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, SOp)\n    assert isinstance(self.snd, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass LinearSequenceMap(SequenceMap):\n  \"\"\"SOp that evaluates a linear function elementwise on the two given SOp's.\"\"\"\n\n  def __init__(self, fst: SOp, snd: SOp, fst_fac: float, snd_fac: float):\n    super().__init__(fst=fst, snd=snd, f=lambda x, y: fst_fac * x + snd_fac * y)\n    self.fst_fac = fst_fac\n    self.snd_fac = snd_fac\n\n\nclass Full(SOp):\n  \"\"\"A SOp evaluating to [fill]*len(input_values).\"\"\"\n\n  def __init__(self, fill: Value):\n    super().__init__()\n    self.fill = fill\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\ndef sop_not(sop: SOp) -> SOp:\n  return Map(lambda t: not t, sop)\n\n\nclass ConstantSOp(SOp, Generic[VT]):\n  \"\"\"A constant S-Op for testing purposes.\"\"\"\n\n  def __init__(self, value: Sequence[VT], check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\n### Selectors.\n\n\nclass Predicate(Protocol):\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    \"\"\"Applies the predicate.\"\"\"\n\n\nclass Comparison(enum.Enum):\n  \"\"\"A two-place boolean comparison predicate for use in Select.\"\"\"\n  EQ = \"==\"\n  LT = \"<\"\n  LEQ = \"<=\"\n  GT = \">\"\n  GEQ = \">=\"\n  NEQ = \"!=\"\n  TRUE = \"True\"\n  FALSE = \"False\"\n\n  def __call__(self, key: Value, query: Value) -> bool:"
  },
  {
    "id": "86",
    "text": "\n\n  def __or__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"self | other.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, self, other)\n    return Map(lambda x: x or other, self)\n\n  def __rand__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other & self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x and y, other, self)\n    return Map(lambda x: other and x, self)\n\n  def __ror__(self, other: Union[\"SOp\", NumericValue]) -> \"SOp\":\n    \"\"\"other | self.\"\"\"\n    if isinstance(other, SOp):\n      return SequenceMap(lambda x, y: x or y, other, self)\n    return Map(lambda x: x or other, self)\n\n\nclass TokensType(SOp):\n  \"\"\"Primitive SOp returning the original input tokens.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"tokens\"\n\n  def __repr__(self):\n    return \"tokens\"\n\n\nclass IndicesType(SOp):\n  \"\"\"Primitive SOp returning the position index at each token.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"indices\"\n\n  def __repr__(self):\n    return \"indices\"\n\n\nclass LengthType(SOp):\n  \"\"\"Primitive SOp returning the total length of the input.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"length\"\n\n  def __repr__(self):\n    return \"length\"\n\n\ntokens = TokensType()\nindices = IndicesType()\nlength = LengthType()\n\n\nclass Map(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the input SOp.\n\n  Map(lambda x: x + 1, tokens).eval([1, 2, 3]) == [2, 3, 4]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value], Value], inner: SOp):\n    super().__init__()\n    self.f = f\n    self.inner = inner\n\n    assert isinstance(self.inner, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n    if isinstance(self.inner, Map):\n      # Combine the functions into just one.\n      inner_f = self.inner.f\n      self.f = lambda t: f(inner_f(t))\n      self.inner = self.inner.inner\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\nclass SequenceMap(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the two given SOp's.\n\n  SequenceMap(lambda x, y: x - y, length, tokens).eval([1, 2, 3]) == [2, 1, 0]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value, Value], Value], fst: SOp, snd: SOp):\n    super().__init__()\n\n    if fst == snd:\n      logging.warning(\"Creating a SequenceMap with both inputs being the same \"\n                      \"SOp is discouraged. You should use a Map instead.\")\n\n    self.f = f\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, SOp)\n    assert isinstance(self.snd, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass LinearSequenceMap(SequenceMap):\n  \"\"\"SOp that evaluates a linear function elementwise on the two given SOp's.\"\"\"\n\n  def __init__(self, fst: SOp, snd: SOp, fst_fac: float, snd_fac: float):\n    super().__init__(fst=fst, snd=snd, f=lambda x, y: fst_fac * x + snd_fac * y)\n    self.fst_fac = fst_fac\n    self.snd_fac = snd_fac\n\n\nclass Full(SOp):\n  \"\"\"A SOp evaluating to [fill]*len(input_values).\"\"\"\n\n  def __init__(self, fill: Value):\n    super().__init__()\n    self.fill = fill\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\ndef sop_not(sop: SOp) -> SOp:\n  return Map(lambda t: not t, sop)\n\n\nclass ConstantSOp(SOp, Generic[VT]):\n  \"\"\"A constant S-Op for testing purposes.\"\"\"\n\n  def __init__(self, value: Sequence[VT], check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\n### Selectors.\n\n\nclass Predicate(Protocol):\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    \"\"\"Applies the predicate.\"\"\"\n\n\nclass Comparison(enum.Enum):\n  \"\"\"A two-place boolean comparison predicate for use in Select.\"\"\"\n  EQ = \"==\"\n  LT = \"<\"\n  LEQ = \"<=\"\n  GT = \">\"\n  GEQ = \">=\"\n  NEQ = \"!=\"\n  TRUE = \"True\"\n  FALSE = \"False\"\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    if key is None:\n      raise ValueError(\"key is None!\")\n    if query is None:\n      raise ValueError(\"query is None!\")\n    return _comparison_table[self](key, query)\n\n\n_comparison_table = {\n    Comparison.EQ: lambda key, query: key == query,\n    Comparison.LT: lambda key, query: key < query,\n    Comparison.LEQ: lambda key, query: key <= query,\n    Comparison.GT: lambda key, query: key > query,\n    Comparison.GEQ: lambda key, query: key >= query,\n    Comparison.NEQ: lambda key, query: key != query,\n    Comparison.TRUE: lambda key, query: True,\n    Comparison.FALSE: lambda key, query: False,\n}\n\n\nclass Selector(RASPExpr):\n  \"\"\"RASP Selector. Represents something like an attention head's weights.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> SelectorValue:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of Selector combinations using Python logical operators.\n  def __and__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self & other.\"\"\"\n    return selector_and(self, other)\n\n  def __rand__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other & self.\"\"\"\n    return selector_and(other, self)\n\n  def __or__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self | other.\"\"\"\n    return selector_or(self, other)\n\n  def __ror__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other | self.\"\"\"\n    return selector_or(other, self)\n\n  def __invert__(self) -> \"Selector\":\n    \"\"\"~self.\"\"\"\n    return selector_not(self)\n\n\nclass Select(Selector):\n  \"\"\"Primitive that creates a Selector.\"\"\"\n\n  def __init__(self, keys: SOp, queries: SOp, predicate: Predicate):"
  },
  {
    "id": "87",
    "text": "    return Map(lambda x: x or other, self)\n\n\nclass TokensType(SOp):\n  \"\"\"Primitive SOp returning the original input tokens.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"tokens\"\n\n  def __repr__(self):\n    return \"tokens\"\n\n\nclass IndicesType(SOp):\n  \"\"\"Primitive SOp returning the position index at each token.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"indices\"\n\n  def __repr__(self):\n    return \"indices\"\n\n\nclass LengthType(SOp):\n  \"\"\"Primitive SOp returning the total length of the input.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"length\"\n\n  def __repr__(self):\n    return \"length\"\n\n\ntokens = TokensType()\nindices = IndicesType()\nlength = LengthType()\n\n\nclass Map(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the input SOp.\n\n  Map(lambda x: x + 1, tokens).eval([1, 2, 3]) == [2, 3, 4]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value], Value], inner: SOp):\n    super().__init__()\n    self.f = f\n    self.inner = inner\n\n    assert isinstance(self.inner, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n    if isinstance(self.inner, Map):\n      # Combine the functions into just one.\n      inner_f = self.inner.f\n      self.f = lambda t: f(inner_f(t))\n      self.inner = self.inner.inner\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\nclass SequenceMap(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the two given SOp's.\n\n  SequenceMap(lambda x, y: x - y, length, tokens).eval([1, 2, 3]) == [2, 1, 0]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value, Value], Value], fst: SOp, snd: SOp):\n    super().__init__()\n\n    if fst == snd:\n      logging.warning(\"Creating a SequenceMap with both inputs being the same \"\n                      \"SOp is discouraged. You should use a Map instead.\")\n\n    self.f = f\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, SOp)\n    assert isinstance(self.snd, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass LinearSequenceMap(SequenceMap):\n  \"\"\"SOp that evaluates a linear function elementwise on the two given SOp's.\"\"\"\n\n  def __init__(self, fst: SOp, snd: SOp, fst_fac: float, snd_fac: float):\n    super().__init__(fst=fst, snd=snd, f=lambda x, y: fst_fac * x + snd_fac * y)\n    self.fst_fac = fst_fac\n    self.snd_fac = snd_fac\n\n\nclass Full(SOp):\n  \"\"\"A SOp evaluating to [fill]*len(input_values).\"\"\"\n\n  def __init__(self, fill: Value):\n    super().__init__()\n    self.fill = fill\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\ndef sop_not(sop: SOp) -> SOp:\n  return Map(lambda t: not t, sop)\n\n\nclass ConstantSOp(SOp, Generic[VT]):\n  \"\"\"A constant S-Op for testing purposes.\"\"\"\n\n  def __init__(self, value: Sequence[VT], check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\n### Selectors.\n\n\nclass Predicate(Protocol):\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    \"\"\"Applies the predicate.\"\"\"\n\n\nclass Comparison(enum.Enum):\n  \"\"\"A two-place boolean comparison predicate for use in Select.\"\"\"\n  EQ = \"==\"\n  LT = \"<\"\n  LEQ = \"<=\"\n  GT = \">\"\n  GEQ = \">=\"\n  NEQ = \"!=\"\n  TRUE = \"True\"\n  FALSE = \"False\"\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    if key is None:\n      raise ValueError(\"key is None!\")\n    if query is None:\n      raise ValueError(\"query is None!\")\n    return _comparison_table[self](key, query)\n\n\n_comparison_table = {\n    Comparison.EQ: lambda key, query: key == query,\n    Comparison.LT: lambda key, query: key < query,\n    Comparison.LEQ: lambda key, query: key <= query,\n    Comparison.GT: lambda key, query: key > query,\n    Comparison.GEQ: lambda key, query: key >= query,\n    Comparison.NEQ: lambda key, query: key != query,\n    Comparison.TRUE: lambda key, query: True,\n    Comparison.FALSE: lambda key, query: False,\n}\n\n\nclass Selector(RASPExpr):\n  \"\"\"RASP Selector. Represents something like an attention head's weights.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> SelectorValue:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of Selector combinations using Python logical operators.\n  def __and__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self & other.\"\"\"\n    return selector_and(self, other)\n\n  def __rand__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other & self.\"\"\"\n    return selector_and(other, self)\n\n  def __or__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self | other.\"\"\"\n    return selector_or(self, other)\n\n  def __ror__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other | self.\"\"\"\n    return selector_or(other, self)\n\n  def __invert__(self) -> \"Selector\":\n    \"\"\"~self.\"\"\"\n    return selector_not(self)\n\n\nclass Select(Selector):\n  \"\"\"Primitive that creates a Selector.\"\"\"\n\n  def __init__(self, keys: SOp, queries: SOp, predicate: Predicate):\n    super().__init__()\n    self.keys = keys\n    self.queries = queries\n    self.predicate = predicate\n    assert isinstance(self.keys, SOp)\n    assert isinstance(self.queries, SOp)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.keys, self.queries]\n\n\nclass ConstantSelector(Selector):\n  \"\"\"A constant selector for testing purposes.\"\"\"\n\n  def __init__(self, value: SelectorValue, check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\nclass SelectorWidth(SOp):\n  \"\"\"SelectorWidth primitive.\"\"\"\n\n  def __init__(self, selector: Selector):"
  },
  {
    "id": "88",
    "text": "(SOp):\n  \"\"\"Primitive SOp returning the position index at each token.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"indices\"\n\n  def __repr__(self):\n    return \"indices\"\n\n\nclass LengthType(SOp):\n  \"\"\"Primitive SOp returning the total length of the input.\"\"\"\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n  @property\n  def label(self) -> str:\n    return \"length\"\n\n  def __repr__(self):\n    return \"length\"\n\n\ntokens = TokensType()\nindices = IndicesType()\nlength = LengthType()\n\n\nclass Map(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the input SOp.\n\n  Map(lambda x: x + 1, tokens).eval([1, 2, 3]) == [2, 3, 4]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value], Value], inner: SOp):\n    super().__init__()\n    self.f = f\n    self.inner = inner\n\n    assert isinstance(self.inner, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n    if isinstance(self.inner, Map):\n      # Combine the functions into just one.\n      inner_f = self.inner.f\n      self.f = lambda t: f(inner_f(t))\n      self.inner = self.inner.inner\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\nclass SequenceMap(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the two given SOp's.\n\n  SequenceMap(lambda x, y: x - y, length, tokens).eval([1, 2, 3]) == [2, 1, 0]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value, Value], Value], fst: SOp, snd: SOp):\n    super().__init__()\n\n    if fst == snd:\n      logging.warning(\"Creating a SequenceMap with both inputs being the same \"\n                      \"SOp is discouraged. You should use a Map instead.\")\n\n    self.f = f\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, SOp)\n    assert isinstance(self.snd, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass LinearSequenceMap(SequenceMap):\n  \"\"\"SOp that evaluates a linear function elementwise on the two given SOp's.\"\"\"\n\n  def __init__(self, fst: SOp, snd: SOp, fst_fac: float, snd_fac: float):\n    super().__init__(fst=fst, snd=snd, f=lambda x, y: fst_fac * x + snd_fac * y)\n    self.fst_fac = fst_fac\n    self.snd_fac = snd_fac\n\n\nclass Full(SOp):\n  \"\"\"A SOp evaluating to [fill]*len(input_values).\"\"\"\n\n  def __init__(self, fill: Value):\n    super().__init__()\n    self.fill = fill\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\ndef sop_not(sop: SOp) -> SOp:\n  return Map(lambda t: not t, sop)\n\n\nclass ConstantSOp(SOp, Generic[VT]):\n  \"\"\"A constant S-Op for testing purposes.\"\"\"\n\n  def __init__(self, value: Sequence[VT], check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\n### Selectors.\n\n\nclass Predicate(Protocol):\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    \"\"\"Applies the predicate.\"\"\"\n\n\nclass Comparison(enum.Enum):\n  \"\"\"A two-place boolean comparison predicate for use in Select.\"\"\"\n  EQ = \"==\"\n  LT = \"<\"\n  LEQ = \"<=\"\n  GT = \">\"\n  GEQ = \">=\"\n  NEQ = \"!=\"\n  TRUE = \"True\"\n  FALSE = \"False\"\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    if key is None:\n      raise ValueError(\"key is None!\")\n    if query is None:\n      raise ValueError(\"query is None!\")\n    return _comparison_table[self](key, query)\n\n\n_comparison_table = {\n    Comparison.EQ: lambda key, query: key == query,\n    Comparison.LT: lambda key, query: key < query,\n    Comparison.LEQ: lambda key, query: key <= query,\n    Comparison.GT: lambda key, query: key > query,\n    Comparison.GEQ: lambda key, query: key >= query,\n    Comparison.NEQ: lambda key, query: key != query,\n    Comparison.TRUE: lambda key, query: True,\n    Comparison.FALSE: lambda key, query: False,\n}\n\n\nclass Selector(RASPExpr):\n  \"\"\"RASP Selector. Represents something like an attention head's weights.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> SelectorValue:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of Selector combinations using Python logical operators.\n  def __and__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self & other.\"\"\"\n    return selector_and(self, other)\n\n  def __rand__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other & self.\"\"\"\n    return selector_and(other, self)\n\n  def __or__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self | other.\"\"\"\n    return selector_or(self, other)\n\n  def __ror__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other | self.\"\"\"\n    return selector_or(other, self)\n\n  def __invert__(self) -> \"Selector\":\n    \"\"\"~self.\"\"\"\n    return selector_not(self)\n\n\nclass Select(Selector):\n  \"\"\"Primitive that creates a Selector.\"\"\"\n\n  def __init__(self, keys: SOp, queries: SOp, predicate: Predicate):\n    super().__init__()\n    self.keys = keys\n    self.queries = queries\n    self.predicate = predicate\n    assert isinstance(self.keys, SOp)\n    assert isinstance(self.queries, SOp)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.keys, self.queries]\n\n\nclass ConstantSelector(Selector):\n  \"\"\"A constant selector for testing purposes.\"\"\"\n\n  def __init__(self, value: SelectorValue, check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\nclass SelectorWidth(SOp):\n  \"\"\"SelectorWidth primitive.\"\"\"\n\n  def __init__(self, selector: Selector):\n    super().__init__()\n    self.selector = selector\n    assert isinstance(self.selector, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector]\n\n\nclass SelectorAnd(Selector):\n  \"\"\"Implements elementwise `and` between selectors.\"\"\"\n\n  def __init__(self, fst: Selector, snd: Selector):"
  },
  {
    "id": "89",
    "text": " Value], inner: SOp):\n    super().__init__()\n    self.f = f\n    self.inner = inner\n\n    assert isinstance(self.inner, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n    if isinstance(self.inner, Map):\n      # Combine the functions into just one.\n      inner_f = self.inner.f\n      self.f = lambda t: f(inner_f(t))\n      self.inner = self.inner.inner\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\nclass SequenceMap(SOp):\n  \"\"\"SOp that evaluates the function elementwise on the two given SOp's.\n\n  SequenceMap(lambda x, y: x - y, length, tokens).eval([1, 2, 3]) == [2, 1, 0]\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value, Value], Value], fst: SOp, snd: SOp):\n    super().__init__()\n\n    if fst == snd:\n      logging.warning(\"Creating a SequenceMap with both inputs being the same \"\n                      \"SOp is discouraged. You should use a Map instead.\")\n\n    self.f = f\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, SOp)\n    assert isinstance(self.snd, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass LinearSequenceMap(SequenceMap):\n  \"\"\"SOp that evaluates a linear function elementwise on the two given SOp's.\"\"\"\n\n  def __init__(self, fst: SOp, snd: SOp, fst_fac: float, snd_fac: float):\n    super().__init__(fst=fst, snd=snd, f=lambda x, y: fst_fac * x + snd_fac * y)\n    self.fst_fac = fst_fac\n    self.snd_fac = snd_fac\n\n\nclass Full(SOp):\n  \"\"\"A SOp evaluating to [fill]*len(input_values).\"\"\"\n\n  def __init__(self, fill: Value):\n    super().__init__()\n    self.fill = fill\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\ndef sop_not(sop: SOp) -> SOp:\n  return Map(lambda t: not t, sop)\n\n\nclass ConstantSOp(SOp, Generic[VT]):\n  \"\"\"A constant S-Op for testing purposes.\"\"\"\n\n  def __init__(self, value: Sequence[VT], check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\n### Selectors.\n\n\nclass Predicate(Protocol):\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    \"\"\"Applies the predicate.\"\"\"\n\n\nclass Comparison(enum.Enum):\n  \"\"\"A two-place boolean comparison predicate for use in Select.\"\"\"\n  EQ = \"==\"\n  LT = \"<\"\n  LEQ = \"<=\"\n  GT = \">\"\n  GEQ = \">=\"\n  NEQ = \"!=\"\n  TRUE = \"True\"\n  FALSE = \"False\"\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    if key is None:\n      raise ValueError(\"key is None!\")\n    if query is None:\n      raise ValueError(\"query is None!\")\n    return _comparison_table[self](key, query)\n\n\n_comparison_table = {\n    Comparison.EQ: lambda key, query: key == query,\n    Comparison.LT: lambda key, query: key < query,\n    Comparison.LEQ: lambda key, query: key <= query,\n    Comparison.GT: lambda key, query: key > query,\n    Comparison.GEQ: lambda key, query: key >= query,\n    Comparison.NEQ: lambda key, query: key != query,\n    Comparison.TRUE: lambda key, query: True,\n    Comparison.FALSE: lambda key, query: False,\n}\n\n\nclass Selector(RASPExpr):\n  \"\"\"RASP Selector. Represents something like an attention head's weights.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> SelectorValue:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of Selector combinations using Python logical operators.\n  def __and__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self & other.\"\"\"\n    return selector_and(self, other)\n\n  def __rand__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other & self.\"\"\"\n    return selector_and(other, self)\n\n  def __or__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self | other.\"\"\"\n    return selector_or(self, other)\n\n  def __ror__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other | self.\"\"\"\n    return selector_or(other, self)\n\n  def __invert__(self) -> \"Selector\":\n    \"\"\"~self.\"\"\"\n    return selector_not(self)\n\n\nclass Select(Selector):\n  \"\"\"Primitive that creates a Selector.\"\"\"\n\n  def __init__(self, keys: SOp, queries: SOp, predicate: Predicate):\n    super().__init__()\n    self.keys = keys\n    self.queries = queries\n    self.predicate = predicate\n    assert isinstance(self.keys, SOp)\n    assert isinstance(self.queries, SOp)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.keys, self.queries]\n\n\nclass ConstantSelector(Selector):\n  \"\"\"A constant selector for testing purposes.\"\"\"\n\n  def __init__(self, value: SelectorValue, check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\nclass SelectorWidth(SOp):\n  \"\"\"SelectorWidth primitive.\"\"\"\n\n  def __init__(self, selector: Selector):\n    super().__init__()\n    self.selector = selector\n    assert isinstance(self.selector, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector]\n\n\nclass SelectorAnd(Selector):\n  \"\"\"Implements elementwise `and` between selectors.\"\"\"\n\n  def __init__(self, fst: Selector, snd: Selector):\n    super().__init__()\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, Selector)\n    assert isinstance(self.snd, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass SelectorOr(Selector):\n  \"\"\"Implements elementwise `or` between selectors.\"\"\"\n\n  def __init__(self, fst: Selector, snd: Selector):\n    super().__init__()\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, Selector)\n    assert isinstance(self.snd, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass SelectorNot(Selector):\n  \"\"\"Implements elementwise `not` on a selector.\"\"\"\n\n  def __init__(self, inner: Selector):"
  },
  {
    "id": "90",
    "text": "\n  \"\"\"\n\n  def __init__(self, f: Callable[[Value, Value], Value], fst: SOp, snd: SOp):\n    super().__init__()\n\n    if fst == snd:\n      logging.warning(\"Creating a SequenceMap with both inputs being the same \"\n                      \"SOp is discouraged. You should use a Map instead.\")\n\n    self.f = f\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, SOp)\n    assert isinstance(self.snd, SOp)\n    assert callable(self.f) and not isinstance(self.f, RASPExpr)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass LinearSequenceMap(SequenceMap):\n  \"\"\"SOp that evaluates a linear function elementwise on the two given SOp's.\"\"\"\n\n  def __init__(self, fst: SOp, snd: SOp, fst_fac: float, snd_fac: float):\n    super().__init__(fst=fst, snd=snd, f=lambda x, y: fst_fac * x + snd_fac * y)\n    self.fst_fac = fst_fac\n    self.snd_fac = snd_fac\n\n\nclass Full(SOp):\n  \"\"\"A SOp evaluating to [fill]*len(input_values).\"\"\"\n\n  def __init__(self, fill: Value):\n    super().__init__()\n    self.fill = fill\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\ndef sop_not(sop: SOp) -> SOp:\n  return Map(lambda t: not t, sop)\n\n\nclass ConstantSOp(SOp, Generic[VT]):\n  \"\"\"A constant S-Op for testing purposes.\"\"\"\n\n  def __init__(self, value: Sequence[VT], check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\n### Selectors.\n\n\nclass Predicate(Protocol):\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    \"\"\"Applies the predicate.\"\"\"\n\n\nclass Comparison(enum.Enum):\n  \"\"\"A two-place boolean comparison predicate for use in Select.\"\"\"\n  EQ = \"==\"\n  LT = \"<\"\n  LEQ = \"<=\"\n  GT = \">\"\n  GEQ = \">=\"\n  NEQ = \"!=\"\n  TRUE = \"True\"\n  FALSE = \"False\"\n\n  def __call__(self, key: Value, query: Value) -> bool:\n    if key is None:\n      raise ValueError(\"key is None!\")\n    if query is None:\n      raise ValueError(\"query is None!\")\n    return _comparison_table[self](key, query)\n\n\n_comparison_table = {\n    Comparison.EQ: lambda key, query: key == query,\n    Comparison.LT: lambda key, query: key < query,\n    Comparison.LEQ: lambda key, query: key <= query,\n    Comparison.GT: lambda key, query: key > query,\n    Comparison.GEQ: lambda key, query: key >= query,\n    Comparison.NEQ: lambda key, query: key != query,\n    Comparison.TRUE: lambda key, query: True,\n    Comparison.FALSE: lambda key, query: False,\n}\n\n\nclass Selector(RASPExpr):\n  \"\"\"RASP Selector. Represents something like an attention head's weights.\"\"\"\n\n  def __call__(self, xs: Sequence[Value]) -> SelectorValue:\n    return evaluate(self, xs)  # pytype: disable=bad-return-type\n\n  # Allow construction of Selector combinations using Python logical operators.\n  def __and__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self & other.\"\"\"\n    return selector_and(self, other)\n\n  def __rand__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other & self.\"\"\"\n    return selector_and(other, self)\n\n  def __or__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self | other.\"\"\"\n    return selector_or(self, other)\n\n  def __ror__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other | self.\"\"\"\n    return selector_or(other, self)\n\n  def __invert__(self) -> \"Selector\":\n    \"\"\"~self.\"\"\"\n    return selector_not(self)\n\n\nclass Select(Selector):\n  \"\"\"Primitive that creates a Selector.\"\"\"\n\n  def __init__(self, keys: SOp, queries: SOp, predicate: Predicate):\n    super().__init__()\n    self.keys = keys\n    self.queries = queries\n    self.predicate = predicate\n    assert isinstance(self.keys, SOp)\n    assert isinstance(self.queries, SOp)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.keys, self.queries]\n\n\nclass ConstantSelector(Selector):\n  \"\"\"A constant selector for testing purposes.\"\"\"\n\n  def __init__(self, value: SelectorValue, check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\nclass SelectorWidth(SOp):\n  \"\"\"SelectorWidth primitive.\"\"\"\n\n  def __init__(self, selector: Selector):\n    super().__init__()\n    self.selector = selector\n    assert isinstance(self.selector, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector]\n\n\nclass SelectorAnd(Selector):\n  \"\"\"Implements elementwise `and` between selectors.\"\"\"\n\n  def __init__(self, fst: Selector, snd: Selector):\n    super().__init__()\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, Selector)\n    assert isinstance(self.snd, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass SelectorOr(Selector):\n  \"\"\"Implements elementwise `or` between selectors.\"\"\"\n\n  def __init__(self, fst: Selector, snd: Selector):\n    super().__init__()\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, Selector)\n    assert isinstance(self.snd, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass SelectorNot(Selector):\n  \"\"\"Implements elementwise `not` on a selector.\"\"\"\n\n  def __init__(self, inner: Selector):\n    self.inner = inner\n    super().__init__()\n    assert isinstance(self.inner, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\ndef selector_not(\n    inner: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorNot, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(inner, Select):\n    predicate = lambda k, q: not inner.predicate(k, q)\n    return Select(inner.keys, inner.queries, predicate=predicate)\n\n  return SelectorNot(inner)\n\n\ndef selector_and(\n    fst: Selector,\n    snd: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorAnd, or a Select if simplifying is possible.\"\"\""
  },
  {
    "id": "91",
    "text": "=bad-return-type\n\n  # Allow construction of Selector combinations using Python logical operators.\n  def __and__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self & other.\"\"\"\n    return selector_and(self, other)\n\n  def __rand__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other & self.\"\"\"\n    return selector_and(other, self)\n\n  def __or__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"self | other.\"\"\"\n    return selector_or(self, other)\n\n  def __ror__(self, other: \"Selector\") -> \"Selector\":\n    \"\"\"other | self.\"\"\"\n    return selector_or(other, self)\n\n  def __invert__(self) -> \"Selector\":\n    \"\"\"~self.\"\"\"\n    return selector_not(self)\n\n\nclass Select(Selector):\n  \"\"\"Primitive that creates a Selector.\"\"\"\n\n  def __init__(self, keys: SOp, queries: SOp, predicate: Predicate):\n    super().__init__()\n    self.keys = keys\n    self.queries = queries\n    self.predicate = predicate\n    assert isinstance(self.keys, SOp)\n    assert isinstance(self.queries, SOp)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.keys, self.queries]\n\n\nclass ConstantSelector(Selector):\n  \"\"\"A constant selector for testing purposes.\"\"\"\n\n  def __init__(self, value: SelectorValue, check_length: bool = True):\n    super().__init__()\n    self.value = value\n    self.check_length = check_length\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return []\n\n\nclass SelectorWidth(SOp):\n  \"\"\"SelectorWidth primitive.\"\"\"\n\n  def __init__(self, selector: Selector):\n    super().__init__()\n    self.selector = selector\n    assert isinstance(self.selector, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector]\n\n\nclass SelectorAnd(Selector):\n  \"\"\"Implements elementwise `and` between selectors.\"\"\"\n\n  def __init__(self, fst: Selector, snd: Selector):\n    super().__init__()\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, Selector)\n    assert isinstance(self.snd, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass SelectorOr(Selector):\n  \"\"\"Implements elementwise `or` between selectors.\"\"\"\n\n  def __init__(self, fst: Selector, snd: Selector):\n    super().__init__()\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, Selector)\n    assert isinstance(self.snd, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass SelectorNot(Selector):\n  \"\"\"Implements elementwise `not` on a selector.\"\"\"\n\n  def __init__(self, inner: Selector):\n    self.inner = inner\n    super().__init__()\n    assert isinstance(self.inner, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\ndef selector_not(\n    inner: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorNot, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(inner, Select):\n    predicate = lambda k, q: not inner.predicate(k, q)\n    return Select(inner.keys, inner.queries, predicate=predicate)\n\n  return SelectorNot(inner)\n\n\ndef selector_and(\n    fst: Selector,\n    snd: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorAnd, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(fst, Select) and isinstance(snd, Select):\n    simplified = _attempt_simplify(fst, snd, lambda l, r: l and r)\n    if simplified:\n      return simplified\n\n  return SelectorAnd(fst, snd)\n\n\ndef selector_or(\n    fst: Selector,\n    snd: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorOr, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(fst, Select) and isinstance(snd, Select):\n    simplified = _attempt_simplify(fst, snd, lambda l, r: l or r)\n    if simplified:\n      return simplified\n\n  return SelectorOr(fst, snd)\n\n\ndef _attempt_simplify(\n    fst: Select,\n    snd: Select,\n    combine: Callable[[bool, bool], bool],\n) -> Optional[Select]:\n  \"\"\"Simplifies two Selects if possible.\n\n  If two Selects in a compound Selector have matching keys and queries, they can\n  be simplified into one Select with a compound predicate:\n\n  lambda k,q: combine(fst.predicate(k,q), snd.predicate(k,q))\n\n  This function returns a Select with this predicate if possible,\n  and None otherwise.\n\n  A Full SOp in a key or query position is a special case that always matches\n  any SOp in the corresponding position in the other selector. In that case,\n  we bake in the fill value into the corresponding Select's predicate before\n  combining. This allows us to use the other SOp as the input to the simplified\n  Select.\n\n  Args:\n    fst: the first Select.\n    snd: the second Select.\n    combine: how to combine the outputs of the individual predicates.\n\n  Returns:\n    A combined Select, if possible.\n  \"\"\"\n  fst_predicate = fst.predicate\n  snd_predicate = snd.predicate\n  common_keys = None\n  common_queries = None\n\n  if isinstance(fst.keys, Full):\n    common_keys = snd.keys\n    # We pass the predicate in as a default arg to avoid unintended recursion.\n    fst_predicate = lambda key, query, p=fst_predicate: p(fst.keys.fill, query)\n  if isinstance(snd.keys, Full):\n    common_keys = fst.keys\n    snd_predicate = lambda key, query, p=snd_predicate: p(snd.keys.fill, query)\n  if isinstance(fst.queries, Full):\n    common_queries = snd.queries\n    fst_predicate = lambda key, query, p=fst_predicate: p(key, fst.queries.fill)\n  if isinstance(snd.queries, Full):\n    common_queries = fst.queries\n    snd_predicate = lambda key, query, p=snd_predicate: p(key, snd.queries.fill)\n  if fst.keys is snd.keys:\n    common_keys = fst.keys\n  if fst.queries is snd.queries:\n    common_queries = fst.queries\n\n  if not common_keys or not common_queries:\n    return None\n\n  def predicate(key, query):\n    return combine(fst_predicate(key, query), snd_predicate(key, query))\n\n  return Select(common_keys, common_queries, predicate=predicate)\n\n\nclass Aggregate(SOp, Generic[VT]):\n  \"\"\"Aggregate primitive.\"\"\"\n\n  def __init__(self,\n               selector: Selector,\n               sop: SOp,\n               default: Optional[VT] = None):\n    \"\"\"Initialises. The default is used where nothing is selected.\"\"\""
  },
  {
    "id": "92",
    "text": " return []\n\n\nclass SelectorWidth(SOp):\n  \"\"\"SelectorWidth primitive.\"\"\"\n\n  def __init__(self, selector: Selector):\n    super().__init__()\n    self.selector = selector\n    assert isinstance(self.selector, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector]\n\n\nclass SelectorAnd(Selector):\n  \"\"\"Implements elementwise `and` between selectors.\"\"\"\n\n  def __init__(self, fst: Selector, snd: Selector):\n    super().__init__()\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, Selector)\n    assert isinstance(self.snd, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass SelectorOr(Selector):\n  \"\"\"Implements elementwise `or` between selectors.\"\"\"\n\n  def __init__(self, fst: Selector, snd: Selector):\n    super().__init__()\n    self.fst = fst\n    self.snd = snd\n    assert isinstance(self.fst, Selector)\n    assert isinstance(self.snd, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass SelectorNot(Selector):\n  \"\"\"Implements elementwise `not` on a selector.\"\"\"\n\n  def __init__(self, inner: Selector):\n    self.inner = inner\n    super().__init__()\n    assert isinstance(self.inner, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\ndef selector_not(\n    inner: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorNot, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(inner, Select):\n    predicate = lambda k, q: not inner.predicate(k, q)\n    return Select(inner.keys, inner.queries, predicate=predicate)\n\n  return SelectorNot(inner)\n\n\ndef selector_and(\n    fst: Selector,\n    snd: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorAnd, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(fst, Select) and isinstance(snd, Select):\n    simplified = _attempt_simplify(fst, snd, lambda l, r: l and r)\n    if simplified:\n      return simplified\n\n  return SelectorAnd(fst, snd)\n\n\ndef selector_or(\n    fst: Selector,\n    snd: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorOr, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(fst, Select) and isinstance(snd, Select):\n    simplified = _attempt_simplify(fst, snd, lambda l, r: l or r)\n    if simplified:\n      return simplified\n\n  return SelectorOr(fst, snd)\n\n\ndef _attempt_simplify(\n    fst: Select,\n    snd: Select,\n    combine: Callable[[bool, bool], bool],\n) -> Optional[Select]:\n  \"\"\"Simplifies two Selects if possible.\n\n  If two Selects in a compound Selector have matching keys and queries, they can\n  be simplified into one Select with a compound predicate:\n\n  lambda k,q: combine(fst.predicate(k,q), snd.predicate(k,q))\n\n  This function returns a Select with this predicate if possible,\n  and None otherwise.\n\n  A Full SOp in a key or query position is a special case that always matches\n  any SOp in the corresponding position in the other selector. In that case,\n  we bake in the fill value into the corresponding Select's predicate before\n  combining. This allows us to use the other SOp as the input to the simplified\n  Select.\n\n  Args:\n    fst: the first Select.\n    snd: the second Select.\n    combine: how to combine the outputs of the individual predicates.\n\n  Returns:\n    A combined Select, if possible.\n  \"\"\"\n  fst_predicate = fst.predicate\n  snd_predicate = snd.predicate\n  common_keys = None\n  common_queries = None\n\n  if isinstance(fst.keys, Full):\n    common_keys = snd.keys\n    # We pass the predicate in as a default arg to avoid unintended recursion.\n    fst_predicate = lambda key, query, p=fst_predicate: p(fst.keys.fill, query)\n  if isinstance(snd.keys, Full):\n    common_keys = fst.keys\n    snd_predicate = lambda key, query, p=snd_predicate: p(snd.keys.fill, query)\n  if isinstance(fst.queries, Full):\n    common_queries = snd.queries\n    fst_predicate = lambda key, query, p=fst_predicate: p(key, fst.queries.fill)\n  if isinstance(snd.queries, Full):\n    common_queries = fst.queries\n    snd_predicate = lambda key, query, p=snd_predicate: p(key, snd.queries.fill)\n  if fst.keys is snd.keys:\n    common_keys = fst.keys\n  if fst.queries is snd.queries:\n    common_queries = fst.queries\n\n  if not common_keys or not common_queries:\n    return None\n\n  def predicate(key, query):\n    return combine(fst_predicate(key, query), snd_predicate(key, query))\n\n  return Select(common_keys, common_queries, predicate=predicate)\n\n\nclass Aggregate(SOp, Generic[VT]):\n  \"\"\"Aggregate primitive.\"\"\"\n\n  def __init__(self,\n               selector: Selector,\n               sop: SOp,\n               default: Optional[VT] = None):\n    \"\"\"Initialises. The default is used where nothing is selected.\"\"\"\n    super().__init__()\n    self.selector = selector\n    self.sop = sop\n    self.default = default\n    assert isinstance(self.selector, Selector)\n    assert isinstance(self.sop, SOp)\n    assert (self.default is None or isinstance(self.default,\n                                               (str, float, bool, int)))\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector, self.sop]\n\n\n### SOp encodings.\n\n\nclass Encoding(enum.Enum):\n  \"\"\"The encoding used by a SOp. Only number-valued SOps support numerical.\"\"\"\n  CATEGORICAL = \"categorical\"\n  NUMERICAL = \"numerical\"\n\n\ndef numerical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.NUMERICAL)\n\n\ndef categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\""
  },
  {
    "id": "93",
    "text": "    assert isinstance(self.snd, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.fst, self.snd]\n\n\nclass SelectorNot(Selector):\n  \"\"\"Implements elementwise `not` on a selector.\"\"\"\n\n  def __init__(self, inner: Selector):\n    self.inner = inner\n    super().__init__()\n    assert isinstance(self.inner, Selector)\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.inner]\n\n\ndef selector_not(\n    inner: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorNot, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(inner, Select):\n    predicate = lambda k, q: not inner.predicate(k, q)\n    return Select(inner.keys, inner.queries, predicate=predicate)\n\n  return SelectorNot(inner)\n\n\ndef selector_and(\n    fst: Selector,\n    snd: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorAnd, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(fst, Select) and isinstance(snd, Select):\n    simplified = _attempt_simplify(fst, snd, lambda l, r: l and r)\n    if simplified:\n      return simplified\n\n  return SelectorAnd(fst, snd)\n\n\ndef selector_or(\n    fst: Selector,\n    snd: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorOr, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(fst, Select) and isinstance(snd, Select):\n    simplified = _attempt_simplify(fst, snd, lambda l, r: l or r)\n    if simplified:\n      return simplified\n\n  return SelectorOr(fst, snd)\n\n\ndef _attempt_simplify(\n    fst: Select,\n    snd: Select,\n    combine: Callable[[bool, bool], bool],\n) -> Optional[Select]:\n  \"\"\"Simplifies two Selects if possible.\n\n  If two Selects in a compound Selector have matching keys and queries, they can\n  be simplified into one Select with a compound predicate:\n\n  lambda k,q: combine(fst.predicate(k,q), snd.predicate(k,q))\n\n  This function returns a Select with this predicate if possible,\n  and None otherwise.\n\n  A Full SOp in a key or query position is a special case that always matches\n  any SOp in the corresponding position in the other selector. In that case,\n  we bake in the fill value into the corresponding Select's predicate before\n  combining. This allows us to use the other SOp as the input to the simplified\n  Select.\n\n  Args:\n    fst: the first Select.\n    snd: the second Select.\n    combine: how to combine the outputs of the individual predicates.\n\n  Returns:\n    A combined Select, if possible.\n  \"\"\"\n  fst_predicate = fst.predicate\n  snd_predicate = snd.predicate\n  common_keys = None\n  common_queries = None\n\n  if isinstance(fst.keys, Full):\n    common_keys = snd.keys\n    # We pass the predicate in as a default arg to avoid unintended recursion.\n    fst_predicate = lambda key, query, p=fst_predicate: p(fst.keys.fill, query)\n  if isinstance(snd.keys, Full):\n    common_keys = fst.keys\n    snd_predicate = lambda key, query, p=snd_predicate: p(snd.keys.fill, query)\n  if isinstance(fst.queries, Full):\n    common_queries = snd.queries\n    fst_predicate = lambda key, query, p=fst_predicate: p(key, fst.queries.fill)\n  if isinstance(snd.queries, Full):\n    common_queries = fst.queries\n    snd_predicate = lambda key, query, p=snd_predicate: p(key, snd.queries.fill)\n  if fst.keys is snd.keys:\n    common_keys = fst.keys\n  if fst.queries is snd.queries:\n    common_queries = fst.queries\n\n  if not common_keys or not common_queries:\n    return None\n\n  def predicate(key, query):\n    return combine(fst_predicate(key, query), snd_predicate(key, query))\n\n  return Select(common_keys, common_queries, predicate=predicate)\n\n\nclass Aggregate(SOp, Generic[VT]):\n  \"\"\"Aggregate primitive.\"\"\"\n\n  def __init__(self,\n               selector: Selector,\n               sop: SOp,\n               default: Optional[VT] = None):\n    \"\"\"Initialises. The default is used where nothing is selected.\"\"\"\n    super().__init__()\n    self.selector = selector\n    self.sop = sop\n    self.default = default\n    assert isinstance(self.selector, Selector)\n    assert isinstance(self.sop, SOp)\n    assert (self.default is None or isinstance(self.default,\n                                               (str, float, bool, int)))\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector, self.sop]\n\n\n### SOp encodings.\n\n\nclass Encoding(enum.Enum):\n  \"\"\"The encoding used by a SOp. Only number-valued SOps support numerical.\"\"\"\n  CATEGORICAL = \"categorical\"\n  NUMERICAL = \"numerical\"\n\n\ndef numerical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.NUMERICAL)\n\n\ndef categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\"\n  if not isinstance(expr, SOp):\n    raise TypeError(f\"expr {expr} is not a SOp.\")\n\n  return Encoding.CATEGORICAL\n\n\nDEFAULT_ANNOTATORS[_ENCODING_KEY] = default_encoding\n\n### naming.\n\n# Subclasses must appear here before superclasses in order for\n# the most specific entry to be used.\n\n_default_name_by_class = {\n    # Primitives\n    TokensType: \"tokens\",\n    IndicesType: \"indices\",\n    LengthType: \"length\",\n    # SOps\n    LinearSequenceMap: \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:"
  },
  {
    "id": "94",
    "text": "or:\n  \"\"\"Returns a SelectorAnd, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(fst, Select) and isinstance(snd, Select):\n    simplified = _attempt_simplify(fst, snd, lambda l, r: l and r)\n    if simplified:\n      return simplified\n\n  return SelectorAnd(fst, snd)\n\n\ndef selector_or(\n    fst: Selector,\n    snd: Selector,\n    simplify: bool = True,\n) -> Selector:\n  \"\"\"Returns a SelectorOr, or a Select if simplifying is possible.\"\"\"\n  if simplify and isinstance(fst, Select) and isinstance(snd, Select):\n    simplified = _attempt_simplify(fst, snd, lambda l, r: l or r)\n    if simplified:\n      return simplified\n\n  return SelectorOr(fst, snd)\n\n\ndef _attempt_simplify(\n    fst: Select,\n    snd: Select,\n    combine: Callable[[bool, bool], bool],\n) -> Optional[Select]:\n  \"\"\"Simplifies two Selects if possible.\n\n  If two Selects in a compound Selector have matching keys and queries, they can\n  be simplified into one Select with a compound predicate:\n\n  lambda k,q: combine(fst.predicate(k,q), snd.predicate(k,q))\n\n  This function returns a Select with this predicate if possible,\n  and None otherwise.\n\n  A Full SOp in a key or query position is a special case that always matches\n  any SOp in the corresponding position in the other selector. In that case,\n  we bake in the fill value into the corresponding Select's predicate before\n  combining. This allows us to use the other SOp as the input to the simplified\n  Select.\n\n  Args:\n    fst: the first Select.\n    snd: the second Select.\n    combine: how to combine the outputs of the individual predicates.\n\n  Returns:\n    A combined Select, if possible.\n  \"\"\"\n  fst_predicate = fst.predicate\n  snd_predicate = snd.predicate\n  common_keys = None\n  common_queries = None\n\n  if isinstance(fst.keys, Full):\n    common_keys = snd.keys\n    # We pass the predicate in as a default arg to avoid unintended recursion.\n    fst_predicate = lambda key, query, p=fst_predicate: p(fst.keys.fill, query)\n  if isinstance(snd.keys, Full):\n    common_keys = fst.keys\n    snd_predicate = lambda key, query, p=snd_predicate: p(snd.keys.fill, query)\n  if isinstance(fst.queries, Full):\n    common_queries = snd.queries\n    fst_predicate = lambda key, query, p=fst_predicate: p(key, fst.queries.fill)\n  if isinstance(snd.queries, Full):\n    common_queries = fst.queries\n    snd_predicate = lambda key, query, p=snd_predicate: p(key, snd.queries.fill)\n  if fst.keys is snd.keys:\n    common_keys = fst.keys\n  if fst.queries is snd.queries:\n    common_queries = fst.queries\n\n  if not common_keys or not common_queries:\n    return None\n\n  def predicate(key, query):\n    return combine(fst_predicate(key, query), snd_predicate(key, query))\n\n  return Select(common_keys, common_queries, predicate=predicate)\n\n\nclass Aggregate(SOp, Generic[VT]):\n  \"\"\"Aggregate primitive.\"\"\"\n\n  def __init__(self,\n               selector: Selector,\n               sop: SOp,\n               default: Optional[VT] = None):\n    \"\"\"Initialises. The default is used where nothing is selected.\"\"\"\n    super().__init__()\n    self.selector = selector\n    self.sop = sop\n    self.default = default\n    assert isinstance(self.selector, Selector)\n    assert isinstance(self.sop, SOp)\n    assert (self.default is None or isinstance(self.default,\n                                               (str, float, bool, int)))\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector, self.sop]\n\n\n### SOp encodings.\n\n\nclass Encoding(enum.Enum):\n  \"\"\"The encoding used by a SOp. Only number-valued SOps support numerical.\"\"\"\n  CATEGORICAL = \"categorical\"\n  NUMERICAL = \"numerical\"\n\n\ndef numerical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.NUMERICAL)\n\n\ndef categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\"\n  if not isinstance(expr, SOp):\n    raise TypeError(f\"expr {expr} is not a SOp.\")\n\n  return Encoding.CATEGORICAL\n\n\nDEFAULT_ANNOTATORS[_ENCODING_KEY] = default_encoding\n\n### naming.\n\n# Subclasses must appear here before superclasses in order for\n# the most specific entry to be used.\n\n_default_name_by_class = {\n    # Primitives\n    TokensType: \"tokens\",\n    IndicesType: \"indices\",\n    LengthType: \"length\",\n    # SOps\n    LinearSequenceMap: \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:\n  for cls, name in _default_name_by_class.items():\n    if isinstance(expr, cls):\n      return name\n\n  raise NotImplementedError(f\"{expr} was not given a default name!\")\n\n\nDEFAULT_ANNOTATORS[_NAME_KEY] = default_name\n\n### evaluation.\n\n\nclass RASPEvaluator(abc.ABC):\n  \"\"\"ABC for RASP evaluators.\"\"\"\n\n  @abc.abstractmethod\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n\n\nclass DefaultRASPEvaluator(abc.ABC):\n  \"\"\"Default evaluator for RASP.\"\"\"\n\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n    return self._eval_fn_by_expr_type[type(expr)](expr, xs)\n\n  def __init__(self):"
  },
  {
    "id": "95",
    "text": "\n  Select.\n\n  Args:\n    fst: the first Select.\n    snd: the second Select.\n    combine: how to combine the outputs of the individual predicates.\n\n  Returns:\n    A combined Select, if possible.\n  \"\"\"\n  fst_predicate = fst.predicate\n  snd_predicate = snd.predicate\n  common_keys = None\n  common_queries = None\n\n  if isinstance(fst.keys, Full):\n    common_keys = snd.keys\n    # We pass the predicate in as a default arg to avoid unintended recursion.\n    fst_predicate = lambda key, query, p=fst_predicate: p(fst.keys.fill, query)\n  if isinstance(snd.keys, Full):\n    common_keys = fst.keys\n    snd_predicate = lambda key, query, p=snd_predicate: p(snd.keys.fill, query)\n  if isinstance(fst.queries, Full):\n    common_queries = snd.queries\n    fst_predicate = lambda key, query, p=fst_predicate: p(key, fst.queries.fill)\n  if isinstance(snd.queries, Full):\n    common_queries = fst.queries\n    snd_predicate = lambda key, query, p=snd_predicate: p(key, snd.queries.fill)\n  if fst.keys is snd.keys:\n    common_keys = fst.keys\n  if fst.queries is snd.queries:\n    common_queries = fst.queries\n\n  if not common_keys or not common_queries:\n    return None\n\n  def predicate(key, query):\n    return combine(fst_predicate(key, query), snd_predicate(key, query))\n\n  return Select(common_keys, common_queries, predicate=predicate)\n\n\nclass Aggregate(SOp, Generic[VT]):\n  \"\"\"Aggregate primitive.\"\"\"\n\n  def __init__(self,\n               selector: Selector,\n               sop: SOp,\n               default: Optional[VT] = None):\n    \"\"\"Initialises. The default is used where nothing is selected.\"\"\"\n    super().__init__()\n    self.selector = selector\n    self.sop = sop\n    self.default = default\n    assert isinstance(self.selector, Selector)\n    assert isinstance(self.sop, SOp)\n    assert (self.default is None or isinstance(self.default,\n                                               (str, float, bool, int)))\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector, self.sop]\n\n\n### SOp encodings.\n\n\nclass Encoding(enum.Enum):\n  \"\"\"The encoding used by a SOp. Only number-valued SOps support numerical.\"\"\"\n  CATEGORICAL = \"categorical\"\n  NUMERICAL = \"numerical\"\n\n\ndef numerical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.NUMERICAL)\n\n\ndef categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\"\n  if not isinstance(expr, SOp):\n    raise TypeError(f\"expr {expr} is not a SOp.\")\n\n  return Encoding.CATEGORICAL\n\n\nDEFAULT_ANNOTATORS[_ENCODING_KEY] = default_encoding\n\n### naming.\n\n# Subclasses must appear here before superclasses in order for\n# the most specific entry to be used.\n\n_default_name_by_class = {\n    # Primitives\n    TokensType: \"tokens\",\n    IndicesType: \"indices\",\n    LengthType: \"length\",\n    # SOps\n    LinearSequenceMap: \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:\n  for cls, name in _default_name_by_class.items():\n    if isinstance(expr, cls):\n      return name\n\n  raise NotImplementedError(f\"{expr} was not given a default name!\")\n\n\nDEFAULT_ANNOTATORS[_NAME_KEY] = default_name\n\n### evaluation.\n\n\nclass RASPEvaluator(abc.ABC):\n  \"\"\"ABC for RASP evaluators.\"\"\"\n\n  @abc.abstractmethod\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n\n\nclass DefaultRASPEvaluator(abc.ABC):\n  \"\"\"Default evaluator for RASP.\"\"\"\n\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n    return self._eval_fn_by_expr_type[type(expr)](expr, xs)\n\n  def __init__(self):\n    self._eval_fn_by_expr_type = {\n        # Primitives\n        TokensType: self.eval_tokens,\n        IndicesType: self.eval_indices,\n        LengthType: self.eval_length,\n        # SOps\n        LinearSequenceMap: self.eval_sequence_map,\n        SequenceMap: self.eval_sequence_map,\n        Map: self.eval_map,\n        Full: self.eval_full,\n        ConstantSOp: self.eval_constant_sop,\n        SelectorWidth: self.eval_selector_width,\n        Aggregate: self.eval_aggregate,\n        SOp: _raise_not_implemented,\n        # Selectors\n        Select: self.eval_select,\n        SelectorAnd: self.eval_selector_and,\n        SelectorOr: self.eval_selector_or,\n        SelectorNot: self.eval_selector_not,\n        ConstantSelector: self.eval_constant_selector,\n        Selector: _raise_not_implemented,\n    }\n\n  def eval_tokens(self, sop: TokensType,\n                  xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(xs)\n\n  def eval_indices(self, sop: IndicesType,\n                   xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(range(len(xs)))\n\n  def eval_length(self, sop: LengthType, xs: Sequence[Value]) -> Sequence[int]:\n    del sop\n    return [len(xs)] * len(xs)\n\n  def eval_sequence_map(self, sop: SequenceMap,\n                        xs: Sequence[Value]) -> Sequence[Value]:"
  },
  {
    "id": "96",
    "text": " common_keys = snd.keys\n    # We pass the predicate in as a default arg to avoid unintended recursion.\n    fst_predicate = lambda key, query, p=fst_predicate: p(fst.keys.fill, query)\n  if isinstance(snd.keys, Full):\n    common_keys = fst.keys\n    snd_predicate = lambda key, query, p=snd_predicate: p(snd.keys.fill, query)\n  if isinstance(fst.queries, Full):\n    common_queries = snd.queries\n    fst_predicate = lambda key, query, p=fst_predicate: p(key, fst.queries.fill)\n  if isinstance(snd.queries, Full):\n    common_queries = fst.queries\n    snd_predicate = lambda key, query, p=snd_predicate: p(key, snd.queries.fill)\n  if fst.keys is snd.keys:\n    common_keys = fst.keys\n  if fst.queries is snd.queries:\n    common_queries = fst.queries\n\n  if not common_keys or not common_queries:\n    return None\n\n  def predicate(key, query):\n    return combine(fst_predicate(key, query), snd_predicate(key, query))\n\n  return Select(common_keys, common_queries, predicate=predicate)\n\n\nclass Aggregate(SOp, Generic[VT]):\n  \"\"\"Aggregate primitive.\"\"\"\n\n  def __init__(self,\n               selector: Selector,\n               sop: SOp,\n               default: Optional[VT] = None):\n    \"\"\"Initialises. The default is used where nothing is selected.\"\"\"\n    super().__init__()\n    self.selector = selector\n    self.sop = sop\n    self.default = default\n    assert isinstance(self.selector, Selector)\n    assert isinstance(self.sop, SOp)\n    assert (self.default is None or isinstance(self.default,\n                                               (str, float, bool, int)))\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector, self.sop]\n\n\n### SOp encodings.\n\n\nclass Encoding(enum.Enum):\n  \"\"\"The encoding used by a SOp. Only number-valued SOps support numerical.\"\"\"\n  CATEGORICAL = \"categorical\"\n  NUMERICAL = \"numerical\"\n\n\ndef numerical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.NUMERICAL)\n\n\ndef categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\"\n  if not isinstance(expr, SOp):\n    raise TypeError(f\"expr {expr} is not a SOp.\")\n\n  return Encoding.CATEGORICAL\n\n\nDEFAULT_ANNOTATORS[_ENCODING_KEY] = default_encoding\n\n### naming.\n\n# Subclasses must appear here before superclasses in order for\n# the most specific entry to be used.\n\n_default_name_by_class = {\n    # Primitives\n    TokensType: \"tokens\",\n    IndicesType: \"indices\",\n    LengthType: \"length\",\n    # SOps\n    LinearSequenceMap: \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:\n  for cls, name in _default_name_by_class.items():\n    if isinstance(expr, cls):\n      return name\n\n  raise NotImplementedError(f\"{expr} was not given a default name!\")\n\n\nDEFAULT_ANNOTATORS[_NAME_KEY] = default_name\n\n### evaluation.\n\n\nclass RASPEvaluator(abc.ABC):\n  \"\"\"ABC for RASP evaluators.\"\"\"\n\n  @abc.abstractmethod\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n\n\nclass DefaultRASPEvaluator(abc.ABC):\n  \"\"\"Default evaluator for RASP.\"\"\"\n\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n    return self._eval_fn_by_expr_type[type(expr)](expr, xs)\n\n  def __init__(self):\n    self._eval_fn_by_expr_type = {\n        # Primitives\n        TokensType: self.eval_tokens,\n        IndicesType: self.eval_indices,\n        LengthType: self.eval_length,\n        # SOps\n        LinearSequenceMap: self.eval_sequence_map,\n        SequenceMap: self.eval_sequence_map,\n        Map: self.eval_map,\n        Full: self.eval_full,\n        ConstantSOp: self.eval_constant_sop,\n        SelectorWidth: self.eval_selector_width,\n        Aggregate: self.eval_aggregate,\n        SOp: _raise_not_implemented,\n        # Selectors\n        Select: self.eval_select,\n        SelectorAnd: self.eval_selector_and,\n        SelectorOr: self.eval_selector_or,\n        SelectorNot: self.eval_selector_not,\n        ConstantSelector: self.eval_constant_selector,\n        Selector: _raise_not_implemented,\n    }\n\n  def eval_tokens(self, sop: TokensType,\n                  xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(xs)\n\n  def eval_indices(self, sop: IndicesType,\n                   xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(range(len(xs)))\n\n  def eval_length(self, sop: LengthType, xs: Sequence[Value]) -> Sequence[int]:\n    del sop\n    return [len(xs)] * len(xs)\n\n  def eval_sequence_map(self, sop: SequenceMap,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    fst_values = self.evaluate(sop.fst, xs)\n    snd_values = self.evaluate(sop.snd, xs)\n    return [\n        sop.f(x, y) if None not in [x, y] else None\n        for x, y in zip(fst_values, snd_values)\n    ]\n\n  def eval_map(self, sop: Map, xs: Sequence[Value]) -> Sequence[Value]:"
  },
  {
    "id": "97",
    "text": "  if isinstance(fst.queries, Full):\n    common_queries = snd.queries\n    fst_predicate = lambda key, query, p=fst_predicate: p(key, fst.queries.fill)\n  if isinstance(snd.queries, Full):\n    common_queries = fst.queries\n    snd_predicate = lambda key, query, p=snd_predicate: p(key, snd.queries.fill)\n  if fst.keys is snd.keys:\n    common_keys = fst.keys\n  if fst.queries is snd.queries:\n    common_queries = fst.queries\n\n  if not common_keys or not common_queries:\n    return None\n\n  def predicate(key, query):\n    return combine(fst_predicate(key, query), snd_predicate(key, query))\n\n  return Select(common_keys, common_queries, predicate=predicate)\n\n\nclass Aggregate(SOp, Generic[VT]):\n  \"\"\"Aggregate primitive.\"\"\"\n\n  def __init__(self,\n               selector: Selector,\n               sop: SOp,\n               default: Optional[VT] = None):\n    \"\"\"Initialises. The default is used where nothing is selected.\"\"\"\n    super().__init__()\n    self.selector = selector\n    self.sop = sop\n    self.default = default\n    assert isinstance(self.selector, Selector)\n    assert isinstance(self.sop, SOp)\n    assert (self.default is None or isinstance(self.default,\n                                               (str, float, bool, int)))\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector, self.sop]\n\n\n### SOp encodings.\n\n\nclass Encoding(enum.Enum):\n  \"\"\"The encoding used by a SOp. Only number-valued SOps support numerical.\"\"\"\n  CATEGORICAL = \"categorical\"\n  NUMERICAL = \"numerical\"\n\n\ndef numerical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.NUMERICAL)\n\n\ndef categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\"\n  if not isinstance(expr, SOp):\n    raise TypeError(f\"expr {expr} is not a SOp.\")\n\n  return Encoding.CATEGORICAL\n\n\nDEFAULT_ANNOTATORS[_ENCODING_KEY] = default_encoding\n\n### naming.\n\n# Subclasses must appear here before superclasses in order for\n# the most specific entry to be used.\n\n_default_name_by_class = {\n    # Primitives\n    TokensType: \"tokens\",\n    IndicesType: \"indices\",\n    LengthType: \"length\",\n    # SOps\n    LinearSequenceMap: \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:\n  for cls, name in _default_name_by_class.items():\n    if isinstance(expr, cls):\n      return name\n\n  raise NotImplementedError(f\"{expr} was not given a default name!\")\n\n\nDEFAULT_ANNOTATORS[_NAME_KEY] = default_name\n\n### evaluation.\n\n\nclass RASPEvaluator(abc.ABC):\n  \"\"\"ABC for RASP evaluators.\"\"\"\n\n  @abc.abstractmethod\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n\n\nclass DefaultRASPEvaluator(abc.ABC):\n  \"\"\"Default evaluator for RASP.\"\"\"\n\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n    return self._eval_fn_by_expr_type[type(expr)](expr, xs)\n\n  def __init__(self):\n    self._eval_fn_by_expr_type = {\n        # Primitives\n        TokensType: self.eval_tokens,\n        IndicesType: self.eval_indices,\n        LengthType: self.eval_length,\n        # SOps\n        LinearSequenceMap: self.eval_sequence_map,\n        SequenceMap: self.eval_sequence_map,\n        Map: self.eval_map,\n        Full: self.eval_full,\n        ConstantSOp: self.eval_constant_sop,\n        SelectorWidth: self.eval_selector_width,\n        Aggregate: self.eval_aggregate,\n        SOp: _raise_not_implemented,\n        # Selectors\n        Select: self.eval_select,\n        SelectorAnd: self.eval_selector_and,\n        SelectorOr: self.eval_selector_or,\n        SelectorNot: self.eval_selector_not,\n        ConstantSelector: self.eval_constant_selector,\n        Selector: _raise_not_implemented,\n    }\n\n  def eval_tokens(self, sop: TokensType,\n                  xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(xs)\n\n  def eval_indices(self, sop: IndicesType,\n                   xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(range(len(xs)))\n\n  def eval_length(self, sop: LengthType, xs: Sequence[Value]) -> Sequence[int]:\n    del sop\n    return [len(xs)] * len(xs)\n\n  def eval_sequence_map(self, sop: SequenceMap,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    fst_values = self.evaluate(sop.fst, xs)\n    snd_values = self.evaluate(sop.snd, xs)\n    return [\n        sop.f(x, y) if None not in [x, y] else None\n        for x, y in zip(fst_values, snd_values)\n    ]\n\n  def eval_map(self, sop: Map, xs: Sequence[Value]) -> Sequence[Value]:\n    return [\n        sop.f(x) if x is not None else None\n        for x in self.evaluate(sop.inner, xs)\n    ]\n\n  def eval_full(self, sop: Full, xs: Sequence[Value]) -> Sequence[Value]:\n    return [sop.fill] * len(xs)\n\n  def eval_constant_sop(self, sop: ConstantSOp,\n                        xs: Sequence[Value]) -> Sequence[Value]:"
  },
  {
    "id": "98",
    "text": "eries = fst.queries\n\n  if not common_keys or not common_queries:\n    return None\n\n  def predicate(key, query):\n    return combine(fst_predicate(key, query), snd_predicate(key, query))\n\n  return Select(common_keys, common_queries, predicate=predicate)\n\n\nclass Aggregate(SOp, Generic[VT]):\n  \"\"\"Aggregate primitive.\"\"\"\n\n  def __init__(self,\n               selector: Selector,\n               sop: SOp,\n               default: Optional[VT] = None):\n    \"\"\"Initialises. The default is used where nothing is selected.\"\"\"\n    super().__init__()\n    self.selector = selector\n    self.sop = sop\n    self.default = default\n    assert isinstance(self.selector, Selector)\n    assert isinstance(self.sop, SOp)\n    assert (self.default is None or isinstance(self.default,\n                                               (str, float, bool, int)))\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector, self.sop]\n\n\n### SOp encodings.\n\n\nclass Encoding(enum.Enum):\n  \"\"\"The encoding used by a SOp. Only number-valued SOps support numerical.\"\"\"\n  CATEGORICAL = \"categorical\"\n  NUMERICAL = \"numerical\"\n\n\ndef numerical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.NUMERICAL)\n\n\ndef categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\"\n  if not isinstance(expr, SOp):\n    raise TypeError(f\"expr {expr} is not a SOp.\")\n\n  return Encoding.CATEGORICAL\n\n\nDEFAULT_ANNOTATORS[_ENCODING_KEY] = default_encoding\n\n### naming.\n\n# Subclasses must appear here before superclasses in order for\n# the most specific entry to be used.\n\n_default_name_by_class = {\n    # Primitives\n    TokensType: \"tokens\",\n    IndicesType: \"indices\",\n    LengthType: \"length\",\n    # SOps\n    LinearSequenceMap: \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:\n  for cls, name in _default_name_by_class.items():\n    if isinstance(expr, cls):\n      return name\n\n  raise NotImplementedError(f\"{expr} was not given a default name!\")\n\n\nDEFAULT_ANNOTATORS[_NAME_KEY] = default_name\n\n### evaluation.\n\n\nclass RASPEvaluator(abc.ABC):\n  \"\"\"ABC for RASP evaluators.\"\"\"\n\n  @abc.abstractmethod\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n\n\nclass DefaultRASPEvaluator(abc.ABC):\n  \"\"\"Default evaluator for RASP.\"\"\"\n\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n    return self._eval_fn_by_expr_type[type(expr)](expr, xs)\n\n  def __init__(self):\n    self._eval_fn_by_expr_type = {\n        # Primitives\n        TokensType: self.eval_tokens,\n        IndicesType: self.eval_indices,\n        LengthType: self.eval_length,\n        # SOps\n        LinearSequenceMap: self.eval_sequence_map,\n        SequenceMap: self.eval_sequence_map,\n        Map: self.eval_map,\n        Full: self.eval_full,\n        ConstantSOp: self.eval_constant_sop,\n        SelectorWidth: self.eval_selector_width,\n        Aggregate: self.eval_aggregate,\n        SOp: _raise_not_implemented,\n        # Selectors\n        Select: self.eval_select,\n        SelectorAnd: self.eval_selector_and,\n        SelectorOr: self.eval_selector_or,\n        SelectorNot: self.eval_selector_not,\n        ConstantSelector: self.eval_constant_selector,\n        Selector: _raise_not_implemented,\n    }\n\n  def eval_tokens(self, sop: TokensType,\n                  xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(xs)\n\n  def eval_indices(self, sop: IndicesType,\n                   xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(range(len(xs)))\n\n  def eval_length(self, sop: LengthType, xs: Sequence[Value]) -> Sequence[int]:\n    del sop\n    return [len(xs)] * len(xs)\n\n  def eval_sequence_map(self, sop: SequenceMap,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    fst_values = self.evaluate(sop.fst, xs)\n    snd_values = self.evaluate(sop.snd, xs)\n    return [\n        sop.f(x, y) if None not in [x, y] else None\n        for x, y in zip(fst_values, snd_values)\n    ]\n\n  def eval_map(self, sop: Map, xs: Sequence[Value]) -> Sequence[Value]:\n    return [\n        sop.f(x) if x is not None else None\n        for x in self.evaluate(sop.inner, xs)\n    ]\n\n  def eval_full(self, sop: Full, xs: Sequence[Value]) -> Sequence[Value]:\n    return [sop.fill] * len(xs)\n\n  def eval_constant_sop(self, sop: ConstantSOp,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    if sop.check_length and (len(xs) != len(sop.value)):\n      raise ValueError(\n          f\"Constant len {len(sop.value)} doesn't match input len {len(xs)}.\")\n    return sop.value\n\n  def eval_selector_width(self, sop: SelectorWidth,\n                          xs: Sequence[Value]) -> Sequence[Value]:\n    selector_values = self.evaluate(sop.selector, xs)\n    return [sum(row) for row in selector_values]\n\n  def eval_aggregate(self, sop: Aggregate,\n                     xs: Sequence[Value]) -> Sequence[Value]:"
  },
  {
    "id": "99",
    "text": ": Selector,\n               sop: SOp,\n               default: Optional[VT] = None):\n    \"\"\"Initialises. The default is used where nothing is selected.\"\"\"\n    super().__init__()\n    self.selector = selector\n    self.sop = sop\n    self.default = default\n    assert isinstance(self.selector, Selector)\n    assert isinstance(self.sop, SOp)\n    assert (self.default is None or isinstance(self.default,\n                                               (str, float, bool, int)))\n\n  @property\n  def children(self) -> Sequence[RASPExpr]:\n    return [self.selector, self.sop]\n\n\n### SOp encodings.\n\n\nclass Encoding(enum.Enum):\n  \"\"\"The encoding used by a SOp. Only number-valued SOps support numerical.\"\"\"\n  CATEGORICAL = \"categorical\"\n  NUMERICAL = \"numerical\"\n\n\ndef numerical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.NUMERICAL)\n\n\ndef categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\"\n  if not isinstance(expr, SOp):\n    raise TypeError(f\"expr {expr} is not a SOp.\")\n\n  return Encoding.CATEGORICAL\n\n\nDEFAULT_ANNOTATORS[_ENCODING_KEY] = default_encoding\n\n### naming.\n\n# Subclasses must appear here before superclasses in order for\n# the most specific entry to be used.\n\n_default_name_by_class = {\n    # Primitives\n    TokensType: \"tokens\",\n    IndicesType: \"indices\",\n    LengthType: \"length\",\n    # SOps\n    LinearSequenceMap: \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:\n  for cls, name in _default_name_by_class.items():\n    if isinstance(expr, cls):\n      return name\n\n  raise NotImplementedError(f\"{expr} was not given a default name!\")\n\n\nDEFAULT_ANNOTATORS[_NAME_KEY] = default_name\n\n### evaluation.\n\n\nclass RASPEvaluator(abc.ABC):\n  \"\"\"ABC for RASP evaluators.\"\"\"\n\n  @abc.abstractmethod\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n\n\nclass DefaultRASPEvaluator(abc.ABC):\n  \"\"\"Default evaluator for RASP.\"\"\"\n\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n    return self._eval_fn_by_expr_type[type(expr)](expr, xs)\n\n  def __init__(self):\n    self._eval_fn_by_expr_type = {\n        # Primitives\n        TokensType: self.eval_tokens,\n        IndicesType: self.eval_indices,\n        LengthType: self.eval_length,\n        # SOps\n        LinearSequenceMap: self.eval_sequence_map,\n        SequenceMap: self.eval_sequence_map,\n        Map: self.eval_map,\n        Full: self.eval_full,\n        ConstantSOp: self.eval_constant_sop,\n        SelectorWidth: self.eval_selector_width,\n        Aggregate: self.eval_aggregate,\n        SOp: _raise_not_implemented,\n        # Selectors\n        Select: self.eval_select,\n        SelectorAnd: self.eval_selector_and,\n        SelectorOr: self.eval_selector_or,\n        SelectorNot: self.eval_selector_not,\n        ConstantSelector: self.eval_constant_selector,\n        Selector: _raise_not_implemented,\n    }\n\n  def eval_tokens(self, sop: TokensType,\n                  xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(xs)\n\n  def eval_indices(self, sop: IndicesType,\n                   xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(range(len(xs)))\n\n  def eval_length(self, sop: LengthType, xs: Sequence[Value]) -> Sequence[int]:\n    del sop\n    return [len(xs)] * len(xs)\n\n  def eval_sequence_map(self, sop: SequenceMap,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    fst_values = self.evaluate(sop.fst, xs)\n    snd_values = self.evaluate(sop.snd, xs)\n    return [\n        sop.f(x, y) if None not in [x, y] else None\n        for x, y in zip(fst_values, snd_values)\n    ]\n\n  def eval_map(self, sop: Map, xs: Sequence[Value]) -> Sequence[Value]:\n    return [\n        sop.f(x) if x is not None else None\n        for x in self.evaluate(sop.inner, xs)\n    ]\n\n  def eval_full(self, sop: Full, xs: Sequence[Value]) -> Sequence[Value]:\n    return [sop.fill] * len(xs)\n\n  def eval_constant_sop(self, sop: ConstantSOp,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    if sop.check_length and (len(xs) != len(sop.value)):\n      raise ValueError(\n          f\"Constant len {len(sop.value)} doesn't match input len {len(xs)}.\")\n    return sop.value\n\n  def eval_selector_width(self, sop: SelectorWidth,\n                          xs: Sequence[Value]) -> Sequence[Value]:\n    selector_values = self.evaluate(sop.selector, xs)\n    return [sum(row) for row in selector_values]\n\n  def eval_aggregate(self, sop: Aggregate,\n                     xs: Sequence[Value]) -> Sequence[Value]:\n    selector_value = self.evaluate(sop.selector, xs)\n    values = self.evaluate(sop.sop, xs)\n    default = sop.default\n\n    return [\n        _mean(_get_selected(row, values), default) for row in selector_value\n    ]\n\n  def eval_select(self, sel: Select, xs: Sequence[Value]) -> SelectorValue:\n    \"\"\"Evaluates a Select on `xs`.\"\"\""
  },
  {
    "id": "100",
    "text": "\n\n\nclass Encoding(enum.Enum):\n  \"\"\"The encoding used by a SOp. Only number-valued SOps support numerical.\"\"\"\n  CATEGORICAL = \"categorical\"\n  NUMERICAL = \"numerical\"\n\n\ndef numerical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.NUMERICAL)\n\n\ndef categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\"\n  if not isinstance(expr, SOp):\n    raise TypeError(f\"expr {expr} is not a SOp.\")\n\n  return Encoding.CATEGORICAL\n\n\nDEFAULT_ANNOTATORS[_ENCODING_KEY] = default_encoding\n\n### naming.\n\n# Subclasses must appear here before superclasses in order for\n# the most specific entry to be used.\n\n_default_name_by_class = {\n    # Primitives\n    TokensType: \"tokens\",\n    IndicesType: \"indices\",\n    LengthType: \"length\",\n    # SOps\n    LinearSequenceMap: \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:\n  for cls, name in _default_name_by_class.items():\n    if isinstance(expr, cls):\n      return name\n\n  raise NotImplementedError(f\"{expr} was not given a default name!\")\n\n\nDEFAULT_ANNOTATORS[_NAME_KEY] = default_name\n\n### evaluation.\n\n\nclass RASPEvaluator(abc.ABC):\n  \"\"\"ABC for RASP evaluators.\"\"\"\n\n  @abc.abstractmethod\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n\n\nclass DefaultRASPEvaluator(abc.ABC):\n  \"\"\"Default evaluator for RASP.\"\"\"\n\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n    return self._eval_fn_by_expr_type[type(expr)](expr, xs)\n\n  def __init__(self):\n    self._eval_fn_by_expr_type = {\n        # Primitives\n        TokensType: self.eval_tokens,\n        IndicesType: self.eval_indices,\n        LengthType: self.eval_length,\n        # SOps\n        LinearSequenceMap: self.eval_sequence_map,\n        SequenceMap: self.eval_sequence_map,\n        Map: self.eval_map,\n        Full: self.eval_full,\n        ConstantSOp: self.eval_constant_sop,\n        SelectorWidth: self.eval_selector_width,\n        Aggregate: self.eval_aggregate,\n        SOp: _raise_not_implemented,\n        # Selectors\n        Select: self.eval_select,\n        SelectorAnd: self.eval_selector_and,\n        SelectorOr: self.eval_selector_or,\n        SelectorNot: self.eval_selector_not,\n        ConstantSelector: self.eval_constant_selector,\n        Selector: _raise_not_implemented,\n    }\n\n  def eval_tokens(self, sop: TokensType,\n                  xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(xs)\n\n  def eval_indices(self, sop: IndicesType,\n                   xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(range(len(xs)))\n\n  def eval_length(self, sop: LengthType, xs: Sequence[Value]) -> Sequence[int]:\n    del sop\n    return [len(xs)] * len(xs)\n\n  def eval_sequence_map(self, sop: SequenceMap,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    fst_values = self.evaluate(sop.fst, xs)\n    snd_values = self.evaluate(sop.snd, xs)\n    return [\n        sop.f(x, y) if None not in [x, y] else None\n        for x, y in zip(fst_values, snd_values)\n    ]\n\n  def eval_map(self, sop: Map, xs: Sequence[Value]) -> Sequence[Value]:\n    return [\n        sop.f(x) if x is not None else None\n        for x in self.evaluate(sop.inner, xs)\n    ]\n\n  def eval_full(self, sop: Full, xs: Sequence[Value]) -> Sequence[Value]:\n    return [sop.fill] * len(xs)\n\n  def eval_constant_sop(self, sop: ConstantSOp,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    if sop.check_length and (len(xs) != len(sop.value)):\n      raise ValueError(\n          f\"Constant len {len(sop.value)} doesn't match input len {len(xs)}.\")\n    return sop.value\n\n  def eval_selector_width(self, sop: SelectorWidth,\n                          xs: Sequence[Value]) -> Sequence[Value]:\n    selector_values = self.evaluate(sop.selector, xs)\n    return [sum(row) for row in selector_values]\n\n  def eval_aggregate(self, sop: Aggregate,\n                     xs: Sequence[Value]) -> Sequence[Value]:\n    selector_value = self.evaluate(sop.selector, xs)\n    values = self.evaluate(sop.sop, xs)\n    default = sop.default\n\n    return [\n        _mean(_get_selected(row, values), default) for row in selector_value\n    ]\n\n  def eval_select(self, sel: Select, xs: Sequence[Value]) -> SelectorValue:\n    \"\"\"Evaluates a Select on `xs`.\"\"\"\n    key_values = self.evaluate(sel.keys, xs)\n    query_values = self.evaluate(sel.queries, xs)\n\n    key_len = len(key_values)\n    query_len = len(query_values)\n    out = np.zeros((query_len, key_len), dtype=bool).tolist()\n    for row, query in enumerate(query_values):\n      for col, key in enumerate(key_values):\n        out[row][col] = bool(sel.predicate(key, query))\n    return out\n\n  def eval_constant_selector(self, sel: ConstantSelector,\n                             xs: Sequence[Value]) -> SelectorValue:"
  },
  {
    "id": "101",
    "text": " categorical(sop: SOpT) -> SOpT:\n  return annotate(sop, encoding=Encoding.CATEGORICAL)\n\n\ndef get_encoding(sop: SOp) -> Encoding:\n  return sop.annotations[\"encoding\"]\n\n\ndef is_numerical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is numerically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.NUMERICAL\n\n\ndef is_categorical(sop: SOp) -> bool:\n  \"\"\"Check if the SOp is categorically encoded.\"\"\"\n  return get_encoding(sop) == Encoding.CATEGORICAL\n\n\ndef default_encoding(expr: RASPExpr) -> Optional[Encoding]:\n  \"\"\"Adds an 'encoding' annotation, default is Categorical.\"\"\"\n  if not isinstance(expr, SOp):\n    raise TypeError(f\"expr {expr} is not a SOp.\")\n\n  return Encoding.CATEGORICAL\n\n\nDEFAULT_ANNOTATORS[_ENCODING_KEY] = default_encoding\n\n### naming.\n\n# Subclasses must appear here before superclasses in order for\n# the most specific entry to be used.\n\n_default_name_by_class = {\n    # Primitives\n    TokensType: \"tokens\",\n    IndicesType: \"indices\",\n    LengthType: \"length\",\n    # SOps\n    LinearSequenceMap: \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:\n  for cls, name in _default_name_by_class.items():\n    if isinstance(expr, cls):\n      return name\n\n  raise NotImplementedError(f\"{expr} was not given a default name!\")\n\n\nDEFAULT_ANNOTATORS[_NAME_KEY] = default_name\n\n### evaluation.\n\n\nclass RASPEvaluator(abc.ABC):\n  \"\"\"ABC for RASP evaluators.\"\"\"\n\n  @abc.abstractmethod\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n\n\nclass DefaultRASPEvaluator(abc.ABC):\n  \"\"\"Default evaluator for RASP.\"\"\"\n\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n    return self._eval_fn_by_expr_type[type(expr)](expr, xs)\n\n  def __init__(self):\n    self._eval_fn_by_expr_type = {\n        # Primitives\n        TokensType: self.eval_tokens,\n        IndicesType: self.eval_indices,\n        LengthType: self.eval_length,\n        # SOps\n        LinearSequenceMap: self.eval_sequence_map,\n        SequenceMap: self.eval_sequence_map,\n        Map: self.eval_map,\n        Full: self.eval_full,\n        ConstantSOp: self.eval_constant_sop,\n        SelectorWidth: self.eval_selector_width,\n        Aggregate: self.eval_aggregate,\n        SOp: _raise_not_implemented,\n        # Selectors\n        Select: self.eval_select,\n        SelectorAnd: self.eval_selector_and,\n        SelectorOr: self.eval_selector_or,\n        SelectorNot: self.eval_selector_not,\n        ConstantSelector: self.eval_constant_selector,\n        Selector: _raise_not_implemented,\n    }\n\n  def eval_tokens(self, sop: TokensType,\n                  xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(xs)\n\n  def eval_indices(self, sop: IndicesType,\n                   xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(range(len(xs)))\n\n  def eval_length(self, sop: LengthType, xs: Sequence[Value]) -> Sequence[int]:\n    del sop\n    return [len(xs)] * len(xs)\n\n  def eval_sequence_map(self, sop: SequenceMap,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    fst_values = self.evaluate(sop.fst, xs)\n    snd_values = self.evaluate(sop.snd, xs)\n    return [\n        sop.f(x, y) if None not in [x, y] else None\n        for x, y in zip(fst_values, snd_values)\n    ]\n\n  def eval_map(self, sop: Map, xs: Sequence[Value]) -> Sequence[Value]:\n    return [\n        sop.f(x) if x is not None else None\n        for x in self.evaluate(sop.inner, xs)\n    ]\n\n  def eval_full(self, sop: Full, xs: Sequence[Value]) -> Sequence[Value]:\n    return [sop.fill] * len(xs)\n\n  def eval_constant_sop(self, sop: ConstantSOp,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    if sop.check_length and (len(xs) != len(sop.value)):\n      raise ValueError(\n          f\"Constant len {len(sop.value)} doesn't match input len {len(xs)}.\")\n    return sop.value\n\n  def eval_selector_width(self, sop: SelectorWidth,\n                          xs: Sequence[Value]) -> Sequence[Value]:\n    selector_values = self.evaluate(sop.selector, xs)\n    return [sum(row) for row in selector_values]\n\n  def eval_aggregate(self, sop: Aggregate,\n                     xs: Sequence[Value]) -> Sequence[Value]:\n    selector_value = self.evaluate(sop.selector, xs)\n    values = self.evaluate(sop.sop, xs)\n    default = sop.default\n\n    return [\n        _mean(_get_selected(row, values), default) for row in selector_value\n    ]\n\n  def eval_select(self, sel: Select, xs: Sequence[Value]) -> SelectorValue:\n    \"\"\"Evaluates a Select on `xs`.\"\"\"\n    key_values = self.evaluate(sel.keys, xs)\n    query_values = self.evaluate(sel.queries, xs)\n\n    key_len = len(key_values)\n    query_len = len(query_values)\n    out = np.zeros((query_len, key_len), dtype=bool).tolist()\n    for row, query in enumerate(query_values):\n      for col, key in enumerate(key_values):\n        out[row][col] = bool(sel.predicate(key, query))\n    return out\n\n  def eval_constant_selector(self, sel: ConstantSelector,\n                             xs: Sequence[Value]) -> SelectorValue:\n    if sel.check_length and (len(xs) != len(sel.value)):\n      raise ValueError(\n          f\"Constant len {len(xs)} doesn't match input len {len(sel.value)}.\")\n    return sel.value\n\n  def eval_selector_and(self, sel: SelectorAnd,\n                        xs: Sequence[Value]) -> SelectorValue:"
  },
  {
    "id": "102",
    "text": ": \"linear_sequence_map\",\n    SequenceMap: \"sequence_map\",\n    Map: \"map\",\n    Full: \"full\",\n    ConstantSOp: \"constant_sop\",\n    SelectorWidth: \"selector_width\",\n    Aggregate: \"aggregate\",\n    SOp: \"sop\",\n    # Selectors\n    Select: \"select\",\n    SelectorAnd: \"selector_and\",\n    SelectorOr: \"selector_or\",\n    SelectorNot: \"selector_not\",\n    ConstantSelector: \"constant_selector\",\n    Selector: \"selector\",\n}\n\n\ndef default_name(expr: RASPExpr) -> Dict[str, str]:\n  for cls, name in _default_name_by_class.items():\n    if isinstance(expr, cls):\n      return name\n\n  raise NotImplementedError(f\"{expr} was not given a default name!\")\n\n\nDEFAULT_ANNOTATORS[_NAME_KEY] = default_name\n\n### evaluation.\n\n\nclass RASPEvaluator(abc.ABC):\n  \"\"\"ABC for RASP evaluators.\"\"\"\n\n  @abc.abstractmethod\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n\n\nclass DefaultRASPEvaluator(abc.ABC):\n  \"\"\"Default evaluator for RASP.\"\"\"\n\n  def evaluate(self, expr: RASPExpr,\n               xs: Sequence[Value]) -> Union[Sequence[Value], SelectorValue]:\n    \"\"\"Evaluates the RASP expression on input `xs`.\"\"\"\n    return self._eval_fn_by_expr_type[type(expr)](expr, xs)\n\n  def __init__(self):\n    self._eval_fn_by_expr_type = {\n        # Primitives\n        TokensType: self.eval_tokens,\n        IndicesType: self.eval_indices,\n        LengthType: self.eval_length,\n        # SOps\n        LinearSequenceMap: self.eval_sequence_map,\n        SequenceMap: self.eval_sequence_map,\n        Map: self.eval_map,\n        Full: self.eval_full,\n        ConstantSOp: self.eval_constant_sop,\n        SelectorWidth: self.eval_selector_width,\n        Aggregate: self.eval_aggregate,\n        SOp: _raise_not_implemented,\n        # Selectors\n        Select: self.eval_select,\n        SelectorAnd: self.eval_selector_and,\n        SelectorOr: self.eval_selector_or,\n        SelectorNot: self.eval_selector_not,\n        ConstantSelector: self.eval_constant_selector,\n        Selector: _raise_not_implemented,\n    }\n\n  def eval_tokens(self, sop: TokensType,\n                  xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(xs)\n\n  def eval_indices(self, sop: IndicesType,\n                   xs: Sequence[Value]) -> Sequence[Value]:\n    del sop\n    return list(range(len(xs)))\n\n  def eval_length(self, sop: LengthType, xs: Sequence[Value]) -> Sequence[int]:\n    del sop\n    return [len(xs)] * len(xs)\n\n  def eval_sequence_map(self, sop: SequenceMap,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    fst_values = self.evaluate(sop.fst, xs)\n    snd_values = self.evaluate(sop.snd, xs)\n    return [\n        sop.f(x, y) if None not in [x, y] else None\n        for x, y in zip(fst_values, snd_values)\n    ]\n\n  def eval_map(self, sop: Map, xs: Sequence[Value]) -> Sequence[Value]:\n    return [\n        sop.f(x) if x is not None else None\n        for x in self.evaluate(sop.inner, xs)\n    ]\n\n  def eval_full(self, sop: Full, xs: Sequence[Value]) -> Sequence[Value]:\n    return [sop.fill] * len(xs)\n\n  def eval_constant_sop(self, sop: ConstantSOp,\n                        xs: Sequence[Value]) -> Sequence[Value]:\n    if sop.check_length and (len(xs) != len(sop.value)):\n      raise ValueError(\n          f\"Constant len {len(sop.value)} doesn't match input len {len(xs)}.\")\n    return sop.value\n\n  def eval_selector_width(self, sop: SelectorWidth,\n                          xs: Sequence[Value]) -> Sequence[Value]:\n    selector_values = self.evaluate(sop.selector, xs)\n    return [sum(row) for row in selector_values]\n\n  def eval_aggregate(self, sop: Aggregate,\n                     xs: Sequence[Value]) -> Sequence[Value]:\n    selector_value = self.evaluate(sop.selector, xs)\n    values = self.evaluate(sop.sop, xs)\n    default = sop.default\n\n    return [\n        _mean(_get_selected(row, values), default) for row in selector_value\n    ]\n\n  def eval_select(self, sel: Select, xs: Sequence[Value]) -> SelectorValue:\n    \"\"\"Evaluates a Select on `xs`.\"\"\"\n    key_values = self.evaluate(sel.keys, xs)\n    query_values = self.evaluate(sel.queries, xs)\n\n    key_len = len(key_values)\n    query_len = len(query_values)\n    out = np.zeros((query_len, key_len), dtype=bool).tolist()\n    for row, query in enumerate(query_values):\n      for col, key in enumerate(key_values):\n        out[row][col] = bool(sel.predicate(key, query))\n    return out\n\n  def eval_constant_selector(self, sel: ConstantSelector,\n                             xs: Sequence[Value]) -> SelectorValue:\n    if sel.check_length and (len(xs) != len(sel.value)):\n      raise ValueError(\n          f\"Constant len {len(xs)} doesn't match input len {len(sel.value)}.\")\n    return sel.value\n\n  def eval_selector_and(self, sel: SelectorAnd,\n                        xs: Sequence[Value]) -> SelectorValue:\n    fst_values = self.evaluate(sel.fst, xs)\n    snd_values = self.evaluate(sel.snd, xs)\n    return np.logical_and(np.array(fst_values), np.array(snd_values)).tolist()\n\n  def eval_selector_or(self, sel: SelectorOr,\n                       xs: Sequence[Value]) -> SelectorValue:\n    fst_values = self.evaluate(sel.fst, xs)\n    snd_values = self.evaluate(sel.snd, xs)\n    return np.logical_or(np.array(fst_values), np.array(snd_values)).tolist()\n\n  def eval_selector_not(self, sel: SelectorNot,\n                        xs: Sequence[Value]) -> SelectorValue:\n    values = self.evaluate(sel.inner, xs)\n    return np.logical_not(np.array(values)).tolist()\n\n\ndef _get_selected(\n    selector_row: List[bool],\n    values: Sequence[VT],\n) -> Sequence[VT]:\n  \"\"\"Helper for aggregate. [T T F], [a b c] -> [a b].\"\"\"\n  return [v for s, v in zip(selector_row, values) if s]\n\n\ndef _mean(xs: Sequence[VT], default: VT) -> VT:\n  \"\"\"Takes the mean for numbers and concats for strings.\"\"\""
  },
  {
    "id": "103",
    "text": "indices, rasp.Comparison.GEQ),\n        rasp.Select(rasp.indices, rasp.tokens, rasp.Comparison.LEQ),\n    )\n    self.assertIsInstance(selector, rasp.SelectorAnd)\n\n  def test_selector_and_gets_simplified_when_keys_are_full(self):\n    selector = rasp.selector_and(\n        rasp.Select(rasp.Full(1), rasp.indices, rasp.Comparison.GEQ),\n        rasp.Select(rasp.tokens, rasp.indices, rasp.Comparison.LEQ),\n    )\n    self.assertIsInstance(selector, rasp.Select)\n    self.assertIs(selector.keys, rasp.tokens)\n    self.assertIs(selector.queries, rasp.indices)\n\n  def test_selector_and_gets_simplified_when_queries_are_full(self):\n    selector = rasp.selector_and(\n        rasp.Select(rasp.tokens, rasp.indices, rasp.Comparison.GEQ),\n        rasp.Select(rasp.tokens, rasp.Full(1), rasp.Comparison.LEQ),\n    )\n    self.assertIsInstance(selector, rasp.Select)\n    self.assertIs(selector.keys, rasp.tokens)\n    self.assertIs(selector.queries, rasp.indices)\n\n  @parameterized.parameters(\n      itertools.product(\n          (rasp.tokens, rasp.indices, rasp.Full(1)),\n          (rasp.tokens, rasp.indices, rasp.Full(1)),\n          list(rasp.Comparison),\n          (rasp.tokens, rasp.indices, rasp.Full(1)),\n          (rasp.tokens, rasp.indices, rasp.Full(1)),\n          list(rasp.Comparison),\n      ))\n  def test_simplified_selector_and_works_the_same_way_as_not(\n      self, fst_k, fst_q, fst_p, snd_k, snd_q, snd_p):\n    fst = rasp.Select(fst_k, fst_q, fst_p)\n    snd = rasp.Select(snd_k, snd_q, snd_p)\n\n    simplified = rasp.selector_and(fst, snd)([0, 1, 2, 3])\n    not_simplified = rasp.selector_and(fst, snd, simplify=False)([0, 1, 2, 3])\n\n    np.testing.assert_array_equal(\n        np.array(simplified),\n        np.array(not_simplified),\n    )\n\n  def test_select_is_selector(self):\n    self.assertIsInstance(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ),\n        rasp.Selector,\n    )\n\n  def test_select_is_raspexpr(self):\n    self.assertIsInstance(\n        rasp.Select(rasp.tokens, rasp.tokens, rasp.Comparison.EQ),\n        rasp.RASPExpr,\n    )\n\n  def test_constant_selector(self):\n    self.assertEqual(\n        rasp.ConstantSelector([[True, True], [False, False]])([1, 2]),\n        [[True, True], [False, False]],\n    )\n\n\nclass CopyTest(parameterized.TestCase):\n\n  @parameterized.named_parameters(*_ALL_EXAMPLES())\n  def test_copy_preserves_name(self, expr: rasp.RASPExpr):\n    expr = expr.named(\"foo\")\n    self.assertEqual(expr.copy().name, expr.name)\n\n  @parameterized.named_parameters(*_ALL_EXAMPLES())\n  def test_renaming_copy_doesnt_rename_original(self, expr: rasp.RASPExpr):\n    expr = expr.named(\"foo\")\n    expr.copy().named(\"bar\")\n    self.assertEqual(expr.name, \"foo\")\n\n  @parameterized.named_parameters(*_ALL_EXAMPLES())\n  def test_renaming_original_doesnt_rename_copy(self, expr: rasp.RASPExpr):\n    expr = expr.named(\"foo\")\n    copy = expr.copy()\n    expr.named(\"bar\")\n    self.assertEqual(copy.name, \"foo\")\n\n  @parameterized.named_parameters(*_ALL_EXAMPLES())\n  def test_copy_changes_id(self, expr: rasp.RASPExpr):\n    self.assertNotEqual(expr.copy().unique_id, expr.unique_id)\n\n  @parameterized.named_parameters(*_ALL_EXAMPLES())\n  def test_copy_preserves_child_ids(self, expr: rasp.RASPExpr):\n    copy_child_ids = [c.unique_id for c in expr.copy().children]\n    child_ids = [c.unique_id for c in expr.children]\n    for child_id, copy_child_id in zip(child_ids, copy_child_ids):\n      self.assertEqual(child_id, copy_child_id)\n\n\nclass AggregateTest(parameterized.TestCase):\n  \"\"\"Tests for Aggregate.\"\"\"\n\n  @parameterized.parameters(\n      dict(\n          selector=rasp.ConstantSelector([\n              [True, False],\n              [False, True],\n          ]),\n          sop=rasp.ConstantSOp([\"h\", \"e\"]),\n          default=None,\n          expected_value=[\"h\", \"e\"],\n      ),\n      dict(\n          selector=rasp.ConstantSelector([\n              [False, True],\n              [False, False],\n          ]),\n          sop=rasp.ConstantSOp([\"h\", \"e\"]),\n          default=None,\n          expected_value=[\"e\", None],\n      ),\n      dict(\n          selector=rasp.ConstantSelector([\n              [True, False],\n              [False, False],\n          ]),\n          sop=rasp.ConstantSOp([\"h\", \"e\"]),\n          default=None,\n          expected_value=[\"h\", None],\n      ),\n      dict(\n          selector=rasp.ConstantSelector([\n              [True, True],\n              [False, True],\n          ]),\n          sop=rasp.ConstantSOp([0, 1]),\n          default=0,\n          expected_value=[0.5, 1],\n      ),\n      dict(\n          selector=rasp.ConstantSelector([\n              [False, False],\n              [True, True],\n          ]),\n          sop=rasp.ConstantSOp([0, 1]),\n          default=0,\n          expected_value=[0, 0.5],\n      ),\n      dict(\n          selector=rasp.ConstantSelector([\n              [False, False],\n              [True, True],\n          ]),\n          sop=rasp.ConstantSOp([0, 1]),\n          default=None,\n          expected_value=[None, 0.5],\n      ),\n  )\n  def test_aggregate_on_size_2_inputs(self, selector, sop, default,\n                                      expected_value):\n    # The 0, 0 input is ignored as it's overridden by the constant SOps.\n    self.assertEqual(\n        rasp.Aggregate(selector, sop, default)([0, 0]),\n        expected_value,\n    )\n\n\nclass RaspProgramTest(parameterized.TestCase):\n  \"\"\"Each testcase implements and tests a RASP program.\"\"\"\n\n  def test_has_prev(self):\n\n    def has_prev(seq: rasp.SOp) -> rasp.SOp:"
  },
  {
    "id": "104",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Assemble weights of a transformer model from a craft residual stack.\"\"\"\n\nimport dataclasses\nfrom typing import Any, Callable, Optional, List, Tuple\n\nimport chex\nimport einops\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\nfrom tracr.transformer import encoder\nfrom tracr.transformer import model\nfrom typing_extensions import Protocol\n\n\n@chex.dataclass\nclass AssembledTransformerModelOutput:\n  decoded: List[Any]  # length T.\n  unembedded: jax.Array  # [B, T]     B = 1 always.\n  layer_outputs: List[jax.Array]  # [B, T, D]\n  residuals: List[jax.Array]  # [B, T, D]\n  attn_logits: List[jax.Array]  # [B, T, T, H]\n  transformer_output: jax.Array  # [B, T, D]\n  input_embeddings: jax.Array\n\n\nclass ModelForward(Protocol):\n\n  def __call__(\n      self,\n      params: hk.Params,\n      emb: jax.Array,\n  ) -> model.CompiledTransformerModelOutput:\n    \"\"\"A hk-transformed forward pass through the compiled model.\"\"\"\n\n\n@dataclasses.dataclass\nclass AssembledTransformerModel:\n  \"\"\"Model architecture and parameters from assembling a model.\"\"\"\n  forward: ModelForward\n  get_compiled_model: Callable[[], model.CompiledTransformerModel]\n  params: hk.Params\n  model_config: model.TransformerConfig\n  residual_labels: List[str]\n  input_encoder: Optional[encoder.Encoder] = None\n  output_encoder: Optional[encoder.Encoder] = None\n\n  def apply(self, tokens: List[bases.Value]) -> AssembledTransformerModelOutput:\n    \"\"\"Returns output from running the model on a set of input tokens.\"\"\""
  },
  {
    "id": "105",
    "text": "chex.dataclass\nclass AssembledTransformerModelOutput:\n  decoded: List[Any]  # length T.\n  unembedded: jax.Array  # [B, T]     B = 1 always.\n  layer_outputs: List[jax.Array]  # [B, T, D]\n  residuals: List[jax.Array]  # [B, T, D]\n  attn_logits: List[jax.Array]  # [B, T, T, H]\n  transformer_output: jax.Array  # [B, T, D]\n  input_embeddings: jax.Array\n\n\nclass ModelForward(Protocol):\n\n  def __call__(\n      self,\n      params: hk.Params,\n      emb: jax.Array,\n  ) -> model.CompiledTransformerModelOutput:\n    \"\"\"A hk-transformed forward pass through the compiled model.\"\"\"\n\n\n@dataclasses.dataclass\nclass AssembledTransformerModel:\n  \"\"\"Model architecture and parameters from assembling a model.\"\"\"\n  forward: ModelForward\n  get_compiled_model: Callable[[], model.CompiledTransformerModel]\n  params: hk.Params\n  model_config: model.TransformerConfig\n  residual_labels: List[str]\n  input_encoder: Optional[encoder.Encoder] = None\n  output_encoder: Optional[encoder.Encoder] = None\n\n  def apply(self, tokens: List[bases.Value]) -> AssembledTransformerModelOutput:\n    \"\"\"Returns output from running the model on a set of input tokens.\"\"\"\n    if self.input_encoder:\n      tokens = self.input_encoder.encode(tokens)\n    tokens = jnp.array([tokens])\n    output = self.forward(self.params, tokens)\n    decoded = output.unembedded_output[0].tolist()\n    if self.output_encoder:\n      decoded = self.output_encoder.decode(decoded)\n\n    if self.input_encoder.bos_token:\n      # Special case for decoding the bos token position, for which the output\n      # decoder might have unspecified behavior.\n      decoded = [self.input_encoder.bos_token] + decoded[1:]\n\n    return AssembledTransformerModelOutput(\n        decoded=decoded,\n        unembedded=output.unembedded_output,\n        layer_outputs=output.transformer_output.layer_outputs,\n        residuals=output.transformer_output.residuals,\n        attn_logits=output.transformer_output.attn_logits,\n        transformer_output=output.transformer_output.output,\n        input_embeddings=output.transformer_output.input_embeddings)\n\n\n@dataclasses.dataclass\nclass EmbeddingModules:\n  \"\"\"Modules for embedding and tokens and positions and unembedding results.\"\"\"\n  token_embed: model.CallableHaikuModule\n  pos_embed: model.CallableHaikuModule\n  unembed: model.CallableHaikuModule\n\n\ndef _get_model_config_and_module_names(\n    craft_model: transformers.SeriesWithResiduals\n) -> Tuple[model.TransformerConfig, List[str]]:\n  \"\"\"Returns model config and locations (in params) for halflayers.\"\"\"\n\n  multi_attn_heads: List[List[transformers.AttentionHead]] = []\n  mlps: List[transformers.MLP] = []\n  module_names: List[str] = []\n\n  candidate_module_names = []\n  for layer in range(len(craft_model.blocks)):\n    candidate_module_names.append(f\"transformer/layer_{layer}/attn\")\n    candidate_module_names.append(f\"transformer/layer_{layer}/mlp\")\n  candidate_module_names = iter(candidate_module_names)\n\n  for module in craft_model.blocks:\n    if isinstance(module, transformers.MLP):\n      mlps.append(module)\n      layer_type = \"mlp\"\n    else:\n      multi_attn_heads.append(list(module.as_multi().heads()))\n      layer_type = \"attn\"\n    # Find next layer with the necessary type. Modules in-between, that are not\n    # added to module_names will be disabled later by setting all weights to 0.\n    module_name = next(candidate_module_names)\n    while layer_type not in module_name:\n      module_name = next(candidate_module_names)\n    module_names.append(module_name)\n\n  num_layers = int(module_names[-1].split(\"_\")[1].split(\"/\")[0]) + 1\n  heads = sum(multi_attn_heads, [])\n\n  if multi_attn_heads:\n    num_heads = max(len(heads) for heads in multi_attn_heads)\n    key_size = max(max(head.w_qk.matrix.shape) for head in heads)\n  else:\n    num_heads, key_size = 1, 1\n\n  if mlps:\n    mlp_hidden_size = max(mlp.fst.output_space.num_dims for mlp in mlps)\n  else:\n    mlp_hidden_size = 1\n\n  model_config = model.TransformerConfig(\n      num_heads=num_heads,\n      num_layers=num_layers,\n      key_size=key_size,\n      mlp_hidden_size=mlp_hidden_size,\n      dropout_rate=0.,\n      activation_function=jax.nn.relu,\n      layer_norm=False,\n      causal=False,\n  )\n\n  return model_config, module_names\n\n\ndef _make_embedding_modules(\n    residual_space: bases.VectorSpaceWithBasis,\n    tokens_space: bases.VectorSpaceWithBasis,\n    indices_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis) -> EmbeddingModules:\n  \"\"\"Creates embedding and unembedding modules from vector spaces.\n\n  Args:\n    residual_space: Full residual space of the model.\n    tokens_space: Subspace to embed tokens to.\n    indices_space: Subspace to embed indices/position embeddings to.\n    output_space: Subspace to unembed outputs from.\n\n  Returns:\n    EmbeddingModules containing modules for token embeddings, position\n      embeddings and unembeddings.\n  \"\"\"\n  tokens_to_res = vectorspace_fns.project(tokens_space, residual_space)\n\n  # If we use the 'one' direction, make sure all inputs have a 1 here\n  one_dir = bases.BasisDirection(\"one\")\n  if one_dir in residual_space:\n    one_to_res = vectorspace_fns.Linear.from_action(\n        tokens_space, residual_space,\n        lambda x: residual_space.vector_from_basis_direction(one_dir))\n    tokens_to_res = vectorspace_fns.Linear.combine_in_parallel(\n        [tokens_to_res, one_to_res])\n\n  # Token embeddings.\n  res_to_out = vectorspace_fns.project(residual_space, output_space)\n  token_embed = hk.Embed(\n      embedding_matrix=tokens_to_res.matrix, name=\"token_embed\")\n\n  # Positional embeddings.\n  index_to_res = vectorspace_fns.project(indices_space, residual_space)\n  # The zeroth position should not have any positional embeddings,\n  # so we add one line of padding at the zeroth position.\n  pos_matrix = np.concatenate(\n      [np.zeros((1, residual_space.num_dims)), index_to_res.matrix], axis=0)\n  pos_embed = hk.Embed(embedding_matrix=pos_matrix, name=\"pos_embed\")\n\n  def unembed(x, use_unembed_argmax):"
  },
  {
    "id": "106",
    "text": "\n        unembedded=output.unembedded_output,\n        layer_outputs=output.transformer_output.layer_outputs,\n        residuals=output.transformer_output.residuals,\n        attn_logits=output.transformer_output.attn_logits,\n        transformer_output=output.transformer_output.output,\n        input_embeddings=output.transformer_output.input_embeddings)\n\n\n@dataclasses.dataclass\nclass EmbeddingModules:\n  \"\"\"Modules for embedding and tokens and positions and unembedding results.\"\"\"\n  token_embed: model.CallableHaikuModule\n  pos_embed: model.CallableHaikuModule\n  unembed: model.CallableHaikuModule\n\n\ndef _get_model_config_and_module_names(\n    craft_model: transformers.SeriesWithResiduals\n) -> Tuple[model.TransformerConfig, List[str]]:\n  \"\"\"Returns model config and locations (in params) for halflayers.\"\"\"\n\n  multi_attn_heads: List[List[transformers.AttentionHead]] = []\n  mlps: List[transformers.MLP] = []\n  module_names: List[str] = []\n\n  candidate_module_names = []\n  for layer in range(len(craft_model.blocks)):\n    candidate_module_names.append(f\"transformer/layer_{layer}/attn\")\n    candidate_module_names.append(f\"transformer/layer_{layer}/mlp\")\n  candidate_module_names = iter(candidate_module_names)\n\n  for module in craft_model.blocks:\n    if isinstance(module, transformers.MLP):\n      mlps.append(module)\n      layer_type = \"mlp\"\n    else:\n      multi_attn_heads.append(list(module.as_multi().heads()))\n      layer_type = \"attn\"\n    # Find next layer with the necessary type. Modules in-between, that are not\n    # added to module_names will be disabled later by setting all weights to 0.\n    module_name = next(candidate_module_names)\n    while layer_type not in module_name:\n      module_name = next(candidate_module_names)\n    module_names.append(module_name)\n\n  num_layers = int(module_names[-1].split(\"_\")[1].split(\"/\")[0]) + 1\n  heads = sum(multi_attn_heads, [])\n\n  if multi_attn_heads:\n    num_heads = max(len(heads) for heads in multi_attn_heads)\n    key_size = max(max(head.w_qk.matrix.shape) for head in heads)\n  else:\n    num_heads, key_size = 1, 1\n\n  if mlps:\n    mlp_hidden_size = max(mlp.fst.output_space.num_dims for mlp in mlps)\n  else:\n    mlp_hidden_size = 1\n\n  model_config = model.TransformerConfig(\n      num_heads=num_heads,\n      num_layers=num_layers,\n      key_size=key_size,\n      mlp_hidden_size=mlp_hidden_size,\n      dropout_rate=0.,\n      activation_function=jax.nn.relu,\n      layer_norm=False,\n      causal=False,\n  )\n\n  return model_config, module_names\n\n\ndef _make_embedding_modules(\n    residual_space: bases.VectorSpaceWithBasis,\n    tokens_space: bases.VectorSpaceWithBasis,\n    indices_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis) -> EmbeddingModules:\n  \"\"\"Creates embedding and unembedding modules from vector spaces.\n\n  Args:\n    residual_space: Full residual space of the model.\n    tokens_space: Subspace to embed tokens to.\n    indices_space: Subspace to embed indices/position embeddings to.\n    output_space: Subspace to unembed outputs from.\n\n  Returns:\n    EmbeddingModules containing modules for token embeddings, position\n      embeddings and unembeddings.\n  \"\"\"\n  tokens_to_res = vectorspace_fns.project(tokens_space, residual_space)\n\n  # If we use the 'one' direction, make sure all inputs have a 1 here\n  one_dir = bases.BasisDirection(\"one\")\n  if one_dir in residual_space:\n    one_to_res = vectorspace_fns.Linear.from_action(\n        tokens_space, residual_space,\n        lambda x: residual_space.vector_from_basis_direction(one_dir))\n    tokens_to_res = vectorspace_fns.Linear.combine_in_parallel(\n        [tokens_to_res, one_to_res])\n\n  # Token embeddings.\n  res_to_out = vectorspace_fns.project(residual_space, output_space)\n  token_embed = hk.Embed(\n      embedding_matrix=tokens_to_res.matrix, name=\"token_embed\")\n\n  # Positional embeddings.\n  index_to_res = vectorspace_fns.project(indices_space, residual_space)\n  # The zeroth position should not have any positional embeddings,\n  # so we add one line of padding at the zeroth position.\n  pos_matrix = np.concatenate(\n      [np.zeros((1, residual_space.num_dims)), index_to_res.matrix], axis=0)\n  pos_embed = hk.Embed(embedding_matrix=pos_matrix, name=\"pos_embed\")\n\n  def unembed(x, use_unembed_argmax):\n    out = x @ res_to_out.matrix\n    if use_unembed_argmax:\n      return jnp.argmax(out, axis=-1)\n    elif out.shape[-1] == 1:\n      return out.squeeze(-1)\n    return out\n\n  unembed_mod = hk.to_module(unembed)()\n  return EmbeddingModules(\n      token_embed=token_embed, pos_embed=pos_embed, unembed=unembed_mod)\n\n\ndef assemble_craft_model(\n    craft_model: transformers.SeriesWithResiduals,\n    tokens_space: bases.VectorSpaceWithBasis,\n    indices_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    categorical_output: bool,\n    causal: bool = False,\n) -> AssembledTransformerModel:\n  \"\"\"Assembles the given components into a Haiku model with parameters.\n\n  Args:\n    craft_model: Model to assemble weights for.\n    tokens_space: Vectorspace to embed the input tokens to.\n    indices_space: Vectorspace to embed the indices to (position encodings).\n    output_space: Vectorspace that the model will write outputs to that should\n      be unembedded.\n    categorical_output: Whether the output is categorical. If True, we take an\n      argmax when unembedding.\n    causal: Whether to output a causally-masked model.\n\n  Returns:\n    An AssembledTransformerModel that contains the model and parameters of the\n      assembled transformer.\n  \"\"\"\n  # TODO(b/255936413): Make embeddings only retain the tokens and indices that\n  #   are actually used.\n  # TODO(b/255936496): Think about enabling layer norm and reversing it somehow\n\n  model_config, module_names = _get_model_config_and_module_names(craft_model)\n  model_config.causal = causal\n\n  residual_space = bases.join_vector_spaces(craft_model.residual_space,\n                                            tokens_space, indices_space,\n                                            output_space)\n  residual_labels = [str(basis_dir) for basis_dir in residual_space.basis]\n\n  # Build model with embedding and unembedding layers\n  def get_compiled_model():"
  },
  {
    "id": "107",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Integration tests for the full RASP -> transformer compilation.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport numpy as np\n\nfrom tracr.compiler import compiling\nfrom tracr.compiler import lib\nfrom tracr.compiler import test_cases\nfrom tracr.craft import tests_common\nfrom tracr.rasp import rasp\n\n_COMPILER_BOS = \"rasp_to_transformer_integration_test_BOS\"\n_COMPILER_PAD = \"rasp_to_transformer_integration_test_PAD\"\n\n# Force float32 precision on TPU, which otherwise defaults to float16.\njax.config.update(\"jax_default_matmul_precision\", \"float32\")\n\n\nclass CompilerIntegrationTest(tests_common.VectorFnTestCase):\n\n  def assertSequenceEqualWhenExpectedIsNotNone(self, actual_seq, expected_seq):"
  },
  {
    "id": "108",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for compiler.expr_to_craft_graph.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nfrom tracr.compiler import basis_inference\nfrom tracr.compiler import expr_to_craft_graph\nfrom tracr.compiler import lib\nfrom tracr.compiler import nodes\nfrom tracr.compiler import rasp_to_graph\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.rasp import rasp\n\n\nclass ExprToCraftGraphTest(parameterized.TestCase):\n\n  def _check_block_types_are_correct(self, graph):"
  },
  {
    "id": "109",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for compiler.expr_to_craft_graph.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nfrom tracr.compiler import basis_inference\nfrom tracr.compiler import expr_to_craft_graph\nfrom tracr.compiler import lib\nfrom tracr.compiler import nodes\nfrom tracr.compiler import rasp_to_graph\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.rasp import rasp\n\n\nclass ExprToCraftGraphTest(parameterized.TestCase):\n\n  def _check_block_types_are_correct(self, graph):\n    for _, node in graph.nodes.items():\n      expr = node[nodes.EXPR]\n      if isinstance(expr, rasp.SOp):\n        block = node[nodes.MODEL_BLOCK]\n        if isinstance(expr, (rasp.Map, rasp.SequenceMap)):\n          self.assertIsInstance(block, transformers.MLP)\n        elif isinstance(expr, rasp.Aggregate):\n          self.assertIsInstance(block, transformers.AttentionHead)\n\n  def _get_input_space_from_node(self, node):"
  },
  {
    "id": "110",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for compiler.expr_to_craft_graph.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nfrom tracr.compiler import basis_inference\nfrom tracr.compiler import expr_to_craft_graph\nfrom tracr.compiler import lib\nfrom tracr.compiler import nodes\nfrom tracr.compiler import rasp_to_graph\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.rasp import rasp\n\n\nclass ExprToCraftGraphTest(parameterized.TestCase):\n\n  def _check_block_types_are_correct(self, graph):\n    for _, node in graph.nodes.items():\n      expr = node[nodes.EXPR]\n      if isinstance(expr, rasp.SOp):\n        block = node[nodes.MODEL_BLOCK]\n        if isinstance(expr, (rasp.Map, rasp.SequenceMap)):\n          self.assertIsInstance(block, transformers.MLP)\n        elif isinstance(expr, rasp.Aggregate):\n          self.assertIsInstance(block, transformers.AttentionHead)\n\n  def _get_input_space_from_node(self, node):\n    block = node[nodes.MODEL_BLOCK]\n    if isinstance(block, transformers.MLP):\n      return block.fst.input_space\n    elif isinstance(block, transformers.AttentionHead):\n      return bases.join_vector_spaces(block.w_qk.left_space,\n                                      block.w_qk.right_space,\n                                      block.w_ov.input_space)\n    else:\n      return None\n\n  def _check_spaces_are_consistent(self, graph):\n    \"\"\"Check that for each edge the output is a subspace of the input.\"\"\""
  },
  {
    "id": "111",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Create a craft model from a computational graph.\"\"\"\n\nimport collections\nfrom typing import Dict, List, Sequence\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.rasp import rasp\n\nNode = nodes.Node\nNodeID = nodes.NodeID\n\n\ndef _get_longest_path_length_to_node(graph: nx.DiGraph, sources: Sequence[Node],\n                                     node: Node) -> int:\n  \"\"\"Returns the lengths of the longest path from sources to node.\n\n  Only SOps count towards the length of a path.\n\n  Args:\n    graph: DAG to compute longest path in.\n    sources: List of starting nodes, longest path will be a maximum over all.\n    node: Target node.\n\n  Returns:\n    Number of steps needed for the longest path from the source to the node, or\n    -1 if there is no path from any of the sources to the target node.\n  \"\"\""
  },
  {
    "id": "112",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Create a craft model from a computational graph.\"\"\"\n\nimport collections\nfrom typing import Dict, List, Sequence\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.rasp import rasp\n\nNode = nodes.Node\nNodeID = nodes.NodeID\n\n\ndef _get_longest_path_length_to_node(graph: nx.DiGraph, sources: Sequence[Node],\n                                     node: Node) -> int:\n  \"\"\"Returns the lengths of the longest path from sources to node.\n\n  Only SOps count towards the length of a path.\n\n  Args:\n    graph: DAG to compute longest path in.\n    sources: List of starting nodes, longest path will be a maximum over all.\n    node: Target node.\n\n  Returns:\n    Number of steps needed for the longest path from the source to the node, or\n    -1 if there is no path from any of the sources to the target node.\n  \"\"\"\n  if node in sources:\n    return 0\n\n  def num_sops(path: Sequence[NodeID]) -> int:"
  },
  {
    "id": "113",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Create a craft model from a computational graph.\"\"\"\n\nimport collections\nfrom typing import Dict, List, Sequence\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.rasp import rasp\n\nNode = nodes.Node\nNodeID = nodes.NodeID\n\n\ndef _get_longest_path_length_to_node(graph: nx.DiGraph, sources: Sequence[Node],\n                                     node: Node) -> int:\n  \"\"\"Returns the lengths of the longest path from sources to node.\n\n  Only SOps count towards the length of a path.\n\n  Args:\n    graph: DAG to compute longest path in.\n    sources: List of starting nodes, longest path will be a maximum over all.\n    node: Target node.\n\n  Returns:\n    Number of steps needed for the longest path from the source to the node, or\n    -1 if there is no path from any of the sources to the target node.\n  \"\"\"\n  if node in sources:\n    return 0\n\n  def num_sops(path: Sequence[NodeID]) -> int:\n    num = 0\n    for node_id in path:\n      if isinstance(graph.nodes[node_id][nodes.EXPR], rasp.SOp):\n        num += 1\n    return num\n\n  result = -1\n  for source in sources:\n    all_paths = nx.all_simple_paths(graph, source[nodes.ID], node[nodes.ID])\n    longest_path_len = max(map(num_sops, all_paths), default=-1) - 1\n    if longest_path_len > result:\n      result = longest_path_len\n  return result\n\n\ndef _node_is_attn(node: Node) -> bool:\n  \"\"\"Returns True if node is an attention layer.\"\"\""
  },
  {
    "id": "114",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Create a craft model from a computational graph.\"\"\"\n\nimport collections\nfrom typing import Dict, List, Sequence\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.rasp import rasp\n\nNode = nodes.Node\nNodeID = nodes.NodeID\n\n\ndef _get_longest_path_length_to_node(graph: nx.DiGraph, sources: Sequence[Node],\n                                     node: Node) -> int:\n  \"\"\"Returns the lengths of the longest path from sources to node.\n\n  Only SOps count towards the length of a path.\n\n  Args:\n    graph: DAG to compute longest path in.\n    sources: List of starting nodes, longest path will be a maximum over all.\n    node: Target node.\n\n  Returns:\n    Number of steps needed for the longest path from the source to the node, or\n    -1 if there is no path from any of the sources to the target node.\n  \"\"\"\n  if node in sources:\n    return 0\n\n  def num_sops(path: Sequence[NodeID]) -> int:\n    num = 0\n    for node_id in path:\n      if isinstance(graph.nodes[node_id][nodes.EXPR], rasp.SOp):\n        num += 1\n    return num\n\n  result = -1\n  for source in sources:\n    all_paths = nx.all_simple_paths(graph, source[nodes.ID], node[nodes.ID])\n    longest_path_len = max(map(num_sops, all_paths), default=-1) - 1\n    if longest_path_len > result:\n      result = longest_path_len\n  return result\n\n\ndef _node_is_attn(node: Node) -> bool:\n  \"\"\"Returns True if node is an attention layer.\"\"\"\n  return nodes.MODEL_BLOCK in node and isinstance(\n      node[nodes.MODEL_BLOCK],\n      (transformers.AttentionHead, transformers.MultiAttentionHead))\n\n\ndef _node_is_mlp(node: Node) -> bool:\n  \"\"\"Returns True if node is an MLP layer.\"\"\"\n  return nodes.MODEL_BLOCK in node and isinstance(node[nodes.MODEL_BLOCK],\n                                                  transformers.MLP)\n\n\ndef _node_is_residual_block(node: Node) -> bool:\n  \"\"\"Returns True if node is a valid residual block (Attn followed by MLP).\"\"\""
  },
  {
    "id": "115",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Create a craft model from a computational graph.\"\"\"\n\nimport collections\nfrom typing import Dict, List, Sequence\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.rasp import rasp\n\nNode = nodes.Node\nNodeID = nodes.NodeID\n\n\ndef _get_longest_path_length_to_node(graph: nx.DiGraph, sources: Sequence[Node],\n                                     node: Node) -> int:\n  \"\"\"Returns the lengths of the longest path from sources to node.\n\n  Only SOps count towards the length of a path.\n\n  Args:\n    graph: DAG to compute longest path in.\n    sources: List of starting nodes, longest path will be a maximum over all.\n    node: Target node.\n\n  Returns:\n    Number of steps needed for the longest path from the source to the node, or\n    -1 if there is no path from any of the sources to the target node.\n  \"\"\"\n  if node in sources:\n    return 0\n\n  def num_sops(path: Sequence[NodeID]) -> int:\n    num = 0\n    for node_id in path:\n      if isinstance(graph.nodes[node_id][nodes.EXPR], rasp.SOp):\n        num += 1\n    return num\n\n  result = -1\n  for source in sources:\n    all_paths = nx.all_simple_paths(graph, source[nodes.ID], node[nodes.ID])\n    longest_path_len = max(map(num_sops, all_paths), default=-1) - 1\n    if longest_path_len > result:\n      result = longest_path_len\n  return result\n\n\ndef _node_is_attn(node: Node) -> bool:\n  \"\"\"Returns True if node is an attention layer.\"\"\"\n  return nodes.MODEL_BLOCK in node and isinstance(\n      node[nodes.MODEL_BLOCK],\n      (transformers.AttentionHead, transformers.MultiAttentionHead))\n\n\ndef _node_is_mlp(node: Node) -> bool:\n  \"\"\"Returns True if node is an MLP layer.\"\"\"\n  return nodes.MODEL_BLOCK in node and isinstance(node[nodes.MODEL_BLOCK],\n                                                  transformers.MLP)\n\n\ndef _node_is_residual_block(node: Node) -> bool:\n  \"\"\"Returns True if node is a valid residual block (Attn followed by MLP).\"\"\"\n  block = node[nodes.MODEL_BLOCK] if nodes.MODEL_BLOCK in node else None\n  if block and isinstance(block, transformers.SeriesWithResiduals):\n    if len(block.blocks) == 2:\n      attn, mlp = block.blocks\n      if (isinstance(\n          attn,\n          (transformers.AttentionHead, transformers.MultiAttentionHead)) and\n          isinstance(mlp, transformers.MLP)):\n        return True\n  return False\n\n\ndef _all_attn_nodes(node_list: Sequence[Node]) -> bool:\n  \"\"\"Returns True iff all nodes are attention layers (or nodes is empty).\"\"\""
  },
  {
    "id": "116",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Create a craft model from a computational graph.\"\"\"\n\nimport collections\nfrom typing import Dict, List, Sequence\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.rasp import rasp\n\nNode = nodes.Node\nNodeID = nodes.NodeID\n\n\ndef _get_longest_path_length_to_node(graph: nx.DiGraph, sources: Sequence[Node],\n                                     node: Node) -> int:\n  \"\"\"Returns the lengths of the longest path from sources to node.\n\n  Only SOps count towards the length of a path.\n\n  Args:\n    graph: DAG to compute longest path in.\n    sources: List of starting nodes, longest path will be a maximum over all.\n    node: Target node.\n\n  Returns:\n    Number of steps needed for the longest path from the source to the node, or\n    -1 if there is no path from any of the sources to the target node.\n  \"\"\"\n  if node in sources:\n    return 0\n\n  def num_sops(path: Sequence[NodeID]) -> int:\n    num = 0\n    for node_id in path:\n      if isinstance(graph.nodes[node_id][nodes.EXPR], rasp.SOp):\n        num += 1\n    return num\n\n  result = -1\n  for source in sources:\n    all_paths = nx.all_simple_paths(graph, source[nodes.ID], node[nodes.ID])\n    longest_path_len = max(map(num_sops, all_paths), default=-1) - 1\n    if longest_path_len > result:\n      result = longest_path_len\n  return result\n\n\ndef _node_is_attn(node: Node) -> bool:\n  \"\"\"Returns True if node is an attention layer.\"\"\"\n  return nodes.MODEL_BLOCK in node and isinstance(\n      node[nodes.MODEL_BLOCK],\n      (transformers.AttentionHead, transformers.MultiAttentionHead))\n\n\ndef _node_is_mlp(node: Node) -> bool:\n  \"\"\"Returns True if node is an MLP layer.\"\"\"\n  return nodes.MODEL_BLOCK in node and isinstance(node[nodes.MODEL_BLOCK],\n                                                  transformers.MLP)\n\n\ndef _node_is_residual_block(node: Node) -> bool:\n  \"\"\"Returns True if node is a valid residual block (Attn followed by MLP).\"\"\"\n  block = node[nodes.MODEL_BLOCK] if nodes.MODEL_BLOCK in node else None\n  if block and isinstance(block, transformers.SeriesWithResiduals):\n    if len(block.blocks) == 2:\n      attn, mlp = block.blocks\n      if (isinstance(\n          attn,\n          (transformers.AttentionHead, transformers.MultiAttentionHead)) and\n          isinstance(mlp, transformers.MLP)):\n        return True\n  return False\n\n\ndef _all_attn_nodes(node_list: Sequence[Node]) -> bool:\n  \"\"\"Returns True iff all nodes are attention layers (or nodes is empty).\"\"\"\n  for node in node_list:\n    if not _node_is_attn(node):\n      return False\n  return True\n\n\ndef _all_mlp_nodes(node_list: Sequence[Node]) -> bool:\n  \"\"\"Returns True iff all nodes are MLP layers (or nodes is empty).\"\"\""
  },
  {
    "id": "117",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Add craft model blocks to graph of RASPExpr.\"\"\"\n\nfrom typing import Any, Callable, Optional\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.craft import bases\nfrom tracr.craft.chamber import categorical_attn\nfrom tracr.craft.chamber import categorical_mlp\nfrom tracr.craft.chamber import numerical_mlp\nfrom tracr.craft.chamber import selector_width\nfrom tracr.rasp import rasp\n\n\ndef _transform_fun_to_basis_fun(\n    fun: Callable[..., Any],\n    output_direction_name: Optional[str] = None) -> Callable[..., Any]:\n  \"\"\"Transforms a function acting on values into one acting on directions.\"\"\""
  },
  {
    "id": "118",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Add craft model blocks to graph of RASPExpr.\"\"\"\n\nfrom typing import Any, Callable, Optional\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.craft import bases\nfrom tracr.craft.chamber import categorical_attn\nfrom tracr.craft.chamber import categorical_mlp\nfrom tracr.craft.chamber import numerical_mlp\nfrom tracr.craft.chamber import selector_width\nfrom tracr.rasp import rasp\n\n\ndef _transform_fun_to_basis_fun(\n    fun: Callable[..., Any],\n    output_direction_name: Optional[str] = None) -> Callable[..., Any]:\n  \"\"\"Transforms a function acting on values into one acting on directions.\"\"\"\n\n  def bases_fun(*args):"
  },
  {
    "id": "119",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for compiler.craft_graph_to_model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport networkx as nx\nfrom tracr.compiler import craft_graph_to_model\nfrom tracr.compiler import nodes\nfrom tracr.compiler import rasp_to_graph\nfrom tracr.craft import bases\nfrom tracr.craft.chamber import categorical_attn\nfrom tracr.craft.chamber import categorical_mlp\nfrom tracr.rasp import rasp\n\n\nclass CraftAllocateModulesToLayersTest(parameterized.TestCase):\n\n  def _get_dummy_block(self, block_type):"
  },
  {
    "id": "120",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Converting a RaspExpr to a graph.\"\"\"\n\nimport dataclasses\nimport queue\nfrom typing import List\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.rasp import rasp\n\nNode = nodes.Node\nNodeID = nodes.NodeID\n\n\n@dataclasses.dataclass\nclass ExtractRaspGraphOutput:\n  graph: nx.DiGraph\n  sink: Node  # the program's output.\n  sources: List[Node]  # the primitive S-Ops.\n\n\ndef extract_rasp_graph(tip: rasp.SOp) -> ExtractRaspGraphOutput:\n  \"\"\"Converts a RASP program into a graph representation.\"\"\"\n  expr_queue = queue.Queue()\n  graph = nx.DiGraph()\n  sources: List[NodeID] = []\n\n  def ensure_node(expr: rasp.RASPExpr) -> NodeID:\n    \"\"\"Finds or creates a graph node corresponding to expr; returns its ID.\"\"\""
  },
  {
    "id": "121",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Converting a RaspExpr to a graph.\"\"\"\n\nimport dataclasses\nimport queue\nfrom typing import List\n\nimport networkx as nx\nfrom tracr.compiler import nodes\nfrom tracr.rasp import rasp\n\nNode = nodes.Node\nNodeID = nodes.NodeID\n\n\n@dataclasses.dataclass\nclass ExtractRaspGraphOutput:\n  graph: nx.DiGraph\n  sink: Node  # the program's output.\n  sources: List[Node]  # the primitive S-Ops.\n\n\ndef extract_rasp_graph(tip: rasp.SOp) -> ExtractRaspGraphOutput:\n  \"\"\"Converts a RASP program into a graph representation.\"\"\"\n  expr_queue = queue.Queue()\n  graph = nx.DiGraph()\n  sources: List[NodeID] = []\n\n  def ensure_node(expr: rasp.RASPExpr) -> NodeID:\n    \"\"\"Finds or creates a graph node corresponding to expr; returns its ID.\"\"\"\n    node_id = expr.label\n    if node_id not in graph:\n      graph.add_node(node_id, **{nodes.ID: node_id, nodes.EXPR: expr})\n\n    return node_id\n\n  # Breadth-first search over the RASP expression graph.\n\n  def visit_raspexpr(expr: rasp.RASPExpr):"
  },
  {
    "id": "122",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Integration tests for the RASP -> craft stages of the compiler.\"\"\"\n\nimport unittest\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport numpy as np\nfrom tracr.compiler import basis_inference\nfrom tracr.compiler import craft_graph_to_model\nfrom tracr.compiler import expr_to_craft_graph\nfrom tracr.compiler import nodes\nfrom tracr.compiler import rasp_to_graph\nfrom tracr.compiler import test_cases\nfrom tracr.craft import bases\nfrom tracr.craft import tests_common\nfrom tracr.rasp import rasp\n\n_BOS_DIRECTION = \"rasp_to_transformer_integration_test_BOS\"\n_ONE_DIRECTION = \"rasp_to_craft_integration_test_ONE\"\n\n\ndef _make_input_space(vocab, max_seq_len):"
  },
  {
    "id": "123",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Integration tests for the RASP -> craft stages of the compiler.\"\"\"\n\nimport unittest\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport numpy as np\nfrom tracr.compiler import basis_inference\nfrom tracr.compiler import craft_graph_to_model\nfrom tracr.compiler import expr_to_craft_graph\nfrom tracr.compiler import nodes\nfrom tracr.compiler import rasp_to_graph\nfrom tracr.compiler import test_cases\nfrom tracr.craft import bases\nfrom tracr.craft import tests_common\nfrom tracr.rasp import rasp\n\n_BOS_DIRECTION = \"rasp_to_transformer_integration_test_BOS\"\n_ONE_DIRECTION = \"rasp_to_craft_integration_test_ONE\"\n\n\ndef _make_input_space(vocab, max_seq_len):\n  tokens_space = bases.VectorSpaceWithBasis.from_values(\"tokens\", vocab)\n  indices_space = bases.VectorSpaceWithBasis.from_values(\n      \"indices\", range(max_seq_len))\n  one_space = bases.VectorSpaceWithBasis.from_names([_ONE_DIRECTION])\n  bos_space = bases.VectorSpaceWithBasis.from_names([_BOS_DIRECTION])\n  input_space = bases.join_vector_spaces(tokens_space, indices_space, one_space,\n                                         bos_space)\n\n  return input_space\n\n\ndef _embed_input(input_seq, input_space):"
  },
  {
    "id": "124",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Integration tests for the RASP -> craft stages of the compiler.\"\"\"\n\nimport unittest\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport numpy as np\nfrom tracr.compiler import basis_inference\nfrom tracr.compiler import craft_graph_to_model\nfrom tracr.compiler import expr_to_craft_graph\nfrom tracr.compiler import nodes\nfrom tracr.compiler import rasp_to_graph\nfrom tracr.compiler import test_cases\nfrom tracr.craft import bases\nfrom tracr.craft import tests_common\nfrom tracr.rasp import rasp\n\n_BOS_DIRECTION = \"rasp_to_transformer_integration_test_BOS\"\n_ONE_DIRECTION = \"rasp_to_craft_integration_test_ONE\"\n\n\ndef _make_input_space(vocab, max_seq_len):\n  tokens_space = bases.VectorSpaceWithBasis.from_values(\"tokens\", vocab)\n  indices_space = bases.VectorSpaceWithBasis.from_values(\n      \"indices\", range(max_seq_len))\n  one_space = bases.VectorSpaceWithBasis.from_names([_ONE_DIRECTION])\n  bos_space = bases.VectorSpaceWithBasis.from_names([_BOS_DIRECTION])\n  input_space = bases.join_vector_spaces(tokens_space, indices_space, one_space,\n                                         bos_space)\n\n  return input_space\n\n\ndef _embed_input(input_seq, input_space):\n  bos_vec = input_space.vector_from_basis_direction(\n      bases.BasisDirection(_BOS_DIRECTION))\n  one_vec = input_space.vector_from_basis_direction(\n      bases.BasisDirection(_ONE_DIRECTION))\n  embedded_input = [bos_vec + one_vec]\n  for i, val in enumerate(input_seq):\n    i_vec = input_space.vector_from_basis_direction(\n        bases.BasisDirection(\"indices\", i))\n    val_vec = input_space.vector_from_basis_direction(\n        bases.BasisDirection(\"tokens\", val))\n    embedded_input.append(i_vec + val_vec + one_vec)\n  return bases.VectorInBasis.stack(embedded_input)\n\n\ndef _embed_output(output_seq, output_space, categorical_output):"
  },
  {
    "id": "125",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP programs only using the subset of RASP supported by the compiler.\"\"\"\n\nfrom typing import List, Sequence\n\nfrom tracr.rasp import rasp\n\n### Programs that work only under non-causal evaluation.\n\n\ndef make_length() -> rasp.SOp:\n  \"\"\"Creates the `length` SOp using selector width primitive.\n\n  Example usage:\n    length = make_length()\n    length(\"abcdefg\")\n    >> [7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0]\n\n  Returns:\n    length: SOp mapping an input to a sequence, where every element\n      is the length of that sequence.\n  \"\"\""
  },
  {
    "id": "126",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP programs only using the subset of RASP supported by the compiler.\"\"\"\n\nfrom typing import List, Sequence\n\nfrom tracr.rasp import rasp\n\n### Programs that work only under non-causal evaluation.\n\n\ndef make_length() -> rasp.SOp:\n  \"\"\"Creates the `length` SOp using selector width primitive.\n\n  Example usage:\n    length = make_length()\n    length(\"abcdefg\")\n    >> [7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0]\n\n  Returns:\n    length: SOp mapping an input to a sequence, where every element\n      is the length of that sequence.\n  \"\"\"\n  all_true_selector = rasp.Select(\n      rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n  return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n\nlength = make_length()\n\n\ndef make_reverse(sop: rasp.SOp) -> rasp.SOp:\n  \"\"\"Create an SOp that reverses a sequence, using length primitive.\n\n  Example usage:\n    reverse = make_reverse(rasp.tokens)\n    reverse(\"Hello\")\n    >> ['o', 'l', 'l', 'e', 'H']\n\n  Args:\n    sop: an SOp\n\n  Returns:\n    reverse : SOp that reverses the input sequence.\n  \"\"\""
  },
  {
    "id": "127",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP programs only using the subset of RASP supported by the compiler.\"\"\"\n\nfrom typing import List, Sequence\n\nfrom tracr.rasp import rasp\n\n### Programs that work only under non-causal evaluation.\n\n\ndef make_length() -> rasp.SOp:\n  \"\"\"Creates the `length` SOp using selector width primitive.\n\n  Example usage:\n    length = make_length()\n    length(\"abcdefg\")\n    >> [7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0]\n\n  Returns:\n    length: SOp mapping an input to a sequence, where every element\n      is the length of that sequence.\n  \"\"\"\n  all_true_selector = rasp.Select(\n      rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n  return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n\nlength = make_length()\n\n\ndef make_reverse(sop: rasp.SOp) -> rasp.SOp:\n  \"\"\"Create an SOp that reverses a sequence, using length primitive.\n\n  Example usage:\n    reverse = make_reverse(rasp.tokens)\n    reverse(\"Hello\")\n    >> ['o', 'l', 'l', 'e', 'H']\n\n  Args:\n    sop: an SOp\n\n  Returns:\n    reverse : SOp that reverses the input sequence.\n  \"\"\"\n  opp_idx = (length - rasp.indices).named(\"opp_idx\")\n  opp_idx = (opp_idx - 1).named(\"opp_idx-1\")\n  reverse_selector = rasp.Select(rasp.indices, opp_idx,\n                                 rasp.Comparison.EQ).named(\"reverse_selector\")\n  return rasp.Aggregate(reverse_selector, sop).named(\"reverse\")\n\n\ndef make_pair_balance(sop: rasp.SOp, open_token: str,\n                      close_token: str) -> rasp.SOp:\n  \"\"\"Return fraction of previous open tokens minus the fraction of close tokens.\n\n   (As implemented in the RASP paper.)\n\n  If the outputs are always non-negative and end in 0, that implies the input\n  has balanced parentheses.\n\n  Example usage:\n    num_l = make_pair_balance(rasp.tokens, \"(\", \")\")\n    num_l(\"a()b(c))\")\n    >> [0, 1/2, 0, 0, 1/5, 1/6, 0, -1/8]\n\n  Args:\n    sop: Input SOp.\n    open_token: Token that counts positive.\n    close_token: Token that counts negative.\n\n  Returns:\n    pair_balance: SOp mapping an input to a sequence, where every element\n      is the fraction of previous open tokens minus previous close tokens.\n  \"\"\""
  },
  {
    "id": "128",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP programs only using the subset of RASP supported by the compiler.\"\"\"\n\nfrom typing import List, Sequence\n\nfrom tracr.rasp import rasp\n\n### Programs that work only under non-causal evaluation.\n\n\ndef make_length() -> rasp.SOp:\n  \"\"\"Creates the `length` SOp using selector width primitive.\n\n  Example usage:\n    length = make_length()\n    length(\"abcdefg\")\n    >> [7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0]\n\n  Returns:\n    length: SOp mapping an input to a sequence, where every element\n      is the length of that sequence.\n  \"\"\"\n  all_true_selector = rasp.Select(\n      rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n  return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n\nlength = make_length()\n\n\ndef make_reverse(sop: rasp.SOp) -> rasp.SOp:\n  \"\"\"Create an SOp that reverses a sequence, using length primitive.\n\n  Example usage:\n    reverse = make_reverse(rasp.tokens)\n    reverse(\"Hello\")\n    >> ['o', 'l', 'l', 'e', 'H']\n\n  Args:\n    sop: an SOp\n\n  Returns:\n    reverse : SOp that reverses the input sequence.\n  \"\"\"\n  opp_idx = (length - rasp.indices).named(\"opp_idx\")\n  opp_idx = (opp_idx - 1).named(\"opp_idx-1\")\n  reverse_selector = rasp.Select(rasp.indices, opp_idx,\n                                 rasp.Comparison.EQ).named(\"reverse_selector\")\n  return rasp.Aggregate(reverse_selector, sop).named(\"reverse\")\n\n\ndef make_pair_balance(sop: rasp.SOp, open_token: str,\n                      close_token: str) -> rasp.SOp:\n  \"\"\"Return fraction of previous open tokens minus the fraction of close tokens.\n\n   (As implemented in the RASP paper.)\n\n  If the outputs are always non-negative and end in 0, that implies the input\n  has balanced parentheses.\n\n  Example usage:\n    num_l = make_pair_balance(rasp.tokens, \"(\", \")\")\n    num_l(\"a()b(c))\")\n    >> [0, 1/2, 0, 0, 1/5, 1/6, 0, -1/8]\n\n  Args:\n    sop: Input SOp.\n    open_token: Token that counts positive.\n    close_token: Token that counts negative.\n\n  Returns:\n    pair_balance: SOp mapping an input to a sequence, where every element\n      is the fraction of previous open tokens minus previous close tokens.\n  \"\"\"\n  bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n  opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n\n  bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n  closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n\n  pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n  return pair_balance.named(\"pair_balance\")\n\n\ndef make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n  \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n    shuffle_dyck2(\"({)}\")\n    >> [1, 1, 1, 1]\n    shuffle_dyck2(\"(){)}\")\n    >> [0, 0, 0, 0, 0]\n\n  Args:\n    pairs: List of pairs of open and close tokens that each should be balanced.\n  \"\"\"\n  assert len(pairs) >= 1\n\n  # Compute running balance of each type of parenthesis\n  balances = []\n  for pair in pairs:\n    assert len(pair) == 2\n    open_token, close_token = pair\n    balance = make_pair_balance(\n        rasp.tokens, open_token=open_token,\n        close_token=close_token).named(f\"balance_{pair}\")\n    balances.append(balance)\n\n  # Check if balances where negative anywhere -> parentheses not balanced\n  any_negative = balances[0] < 0\n  for balance in balances[1:]:\n    any_negative = any_negative | (balance < 0)\n\n  # Convert to numerical SOp\n  any_negative = rasp.numerical(rasp.Map(lambda x: x,\n                                         any_negative)).named(\"any_negative\")\n\n  select_all = rasp.Select(rasp.indices, rasp.indices,\n                           rasp.Comparison.TRUE).named(\"select_all\")\n  has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative,\n                                          default=0)).named(\"has_neg\")\n\n  # Check if all balances are 0 at the end -> closed all parentheses\n  all_zero = balances[0] == 0\n  for balance in balances[1:]:\n    all_zero = all_zero & (balance == 0)\n\n  select_last = rasp.Select(rasp.indices, length - 1,\n                            rasp.Comparison.EQ).named(\"select_last\")\n  last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n\n  not_has_neg = (~has_neg).named(\"not_has_neg\")\n  return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n\n\ndef make_shuffle_dyck2() -> rasp.SOp:\n  return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n\n\ndef make_hist() -> rasp.SOp:\n  \"\"\"Returns the number of times each token occurs in the input.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    hist = make_hist()\n    hist(\"abac\")\n    >> [2, 1, 2, 1]\n  \"\"\""
  },
  {
    "id": "129",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"RASP programs only using the subset of RASP supported by the compiler.\"\"\"\n\nfrom typing import List, Sequence\n\nfrom tracr.rasp import rasp\n\n### Programs that work only under non-causal evaluation.\n\n\ndef make_length() -> rasp.SOp:\n  \"\"\"Creates the `length` SOp using selector width primitive.\n\n  Example usage:\n    length = make_length()\n    length(\"abcdefg\")\n    >> [7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0]\n\n  Returns:\n    length: SOp mapping an input to a sequence, where every element\n      is the length of that sequence.\n  \"\"\"\n  all_true_selector = rasp.Select(\n      rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n  return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n\nlength = make_length()\n\n\ndef make_reverse(sop: rasp.SOp) -> rasp.SOp:\n  \"\"\"Create an SOp that reverses a sequence, using length primitive.\n\n  Example usage:\n    reverse = make_reverse(rasp.tokens)\n    reverse(\"Hello\")\n    >> ['o', 'l', 'l', 'e', 'H']\n\n  Args:\n    sop: an SOp\n\n  Returns:\n    reverse : SOp that reverses the input sequence.\n  \"\"\"\n  opp_idx = (length - rasp.indices).named(\"opp_idx\")\n  opp_idx = (opp_idx - 1).named(\"opp_idx-1\")\n  reverse_selector = rasp.Select(rasp.indices, opp_idx,\n                                 rasp.Comparison.EQ).named(\"reverse_selector\")\n  return rasp.Aggregate(reverse_selector, sop).named(\"reverse\")\n\n\ndef make_pair_balance(sop: rasp.SOp, open_token: str,\n                      close_token: str) -> rasp.SOp:\n  \"\"\"Return fraction of previous open tokens minus the fraction of close tokens.\n\n   (As implemented in the RASP paper.)\n\n  If the outputs are always non-negative and end in 0, that implies the input\n  has balanced parentheses.\n\n  Example usage:\n    num_l = make_pair_balance(rasp.tokens, \"(\", \")\")\n    num_l(\"a()b(c))\")\n    >> [0, 1/2, 0, 0, 1/5, 1/6, 0, -1/8]\n\n  Args:\n    sop: Input SOp.\n    open_token: Token that counts positive.\n    close_token: Token that counts negative.\n\n  Returns:\n    pair_balance: SOp mapping an input to a sequence, where every element\n      is the fraction of previous open tokens minus previous close tokens.\n  \"\"\"\n  bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n  opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n\n  bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n  closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n\n  pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n  return pair_balance.named(\"pair_balance\")\n\n\ndef make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n  \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n    shuffle_dyck2(\"({)}\")\n    >> [1, 1, 1, 1]\n    shuffle_dyck2(\"(){)}\")\n    >> [0, 0, 0, 0, 0]\n\n  Args:\n    pairs: List of pairs of open and close tokens that each should be balanced.\n  \"\"\"\n  assert len(pairs) >= 1\n\n  # Compute running balance of each type of parenthesis\n  balances = []\n  for pair in pairs:\n    assert len(pair) == 2\n    open_token, close_token = pair\n    balance = make_pair_balance(\n        rasp.tokens, open_token=open_token,\n        close_token=close_token).named(f\"balance_{pair}\")\n    balances.append(balance)\n\n  # Check if balances where negative anywhere -> parentheses not balanced\n  any_negative = balances[0] < 0\n  for balance in balances[1:]:\n    any_negative = any_negative | (balance < 0)\n\n  # Convert to numerical SOp\n  any_negative = rasp.numerical(rasp.Map(lambda x: x,\n                                         any_negative)).named(\"any_negative\")\n\n  select_all = rasp.Select(rasp.indices, rasp.indices,\n                           rasp.Comparison.TRUE).named(\"select_all\")\n  has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative,\n                                          default=0)).named(\"has_neg\")\n\n  # Check if all balances are 0 at the end -> closed all parentheses\n  all_zero = balances[0] == 0\n  for balance in balances[1:]:\n    all_zero = all_zero & (balance == 0)\n\n  select_last = rasp.Select(rasp.indices, length - 1,\n                            rasp.Comparison.EQ).named(\"select_last\")\n  last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n\n  not_has_neg = (~has_neg).named(\"not_has_neg\")\n  return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n\n\ndef make_shuffle_dyck2() -> rasp.SOp:\n  return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n\n\ndef make_hist() -> rasp.SOp:\n  \"\"\"Returns the number of times each token occurs in the input.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    hist = make_hist()\n    hist(\"abac\")\n    >> [2, 1, 2, 1]\n  \"\"\"\n  same_tok = rasp.Select(rasp.tokens, rasp.tokens,\n                         rasp.Comparison.EQ).named(\"same_tok\")\n  return rasp.SelectorWidth(same_tok).named(\"hist\")\n\n\ndef make_sort_unique(vals: rasp.SOp, keys: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys.\n\n  Only supports unique keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n  \"\"\""
  },
  {
    "id": "130",
    "text": " \"\"\"\n  all_true_selector = rasp.Select(\n      rasp.tokens, rasp.tokens, rasp.Comparison.TRUE).named(\"all_true_selector\")\n  return rasp.SelectorWidth(all_true_selector).named(\"length\")\n\n\nlength = make_length()\n\n\ndef make_reverse(sop: rasp.SOp) -> rasp.SOp:\n  \"\"\"Create an SOp that reverses a sequence, using length primitive.\n\n  Example usage:\n    reverse = make_reverse(rasp.tokens)\n    reverse(\"Hello\")\n    >> ['o', 'l', 'l', 'e', 'H']\n\n  Args:\n    sop: an SOp\n\n  Returns:\n    reverse : SOp that reverses the input sequence.\n  \"\"\"\n  opp_idx = (length - rasp.indices).named(\"opp_idx\")\n  opp_idx = (opp_idx - 1).named(\"opp_idx-1\")\n  reverse_selector = rasp.Select(rasp.indices, opp_idx,\n                                 rasp.Comparison.EQ).named(\"reverse_selector\")\n  return rasp.Aggregate(reverse_selector, sop).named(\"reverse\")\n\n\ndef make_pair_balance(sop: rasp.SOp, open_token: str,\n                      close_token: str) -> rasp.SOp:\n  \"\"\"Return fraction of previous open tokens minus the fraction of close tokens.\n\n   (As implemented in the RASP paper.)\n\n  If the outputs are always non-negative and end in 0, that implies the input\n  has balanced parentheses.\n\n  Example usage:\n    num_l = make_pair_balance(rasp.tokens, \"(\", \")\")\n    num_l(\"a()b(c))\")\n    >> [0, 1/2, 0, 0, 1/5, 1/6, 0, -1/8]\n\n  Args:\n    sop: Input SOp.\n    open_token: Token that counts positive.\n    close_token: Token that counts negative.\n\n  Returns:\n    pair_balance: SOp mapping an input to a sequence, where every element\n      is the fraction of previous open tokens minus previous close tokens.\n  \"\"\"\n  bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n  opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n\n  bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n  closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n\n  pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n  return pair_balance.named(\"pair_balance\")\n\n\ndef make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n  \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n    shuffle_dyck2(\"({)}\")\n    >> [1, 1, 1, 1]\n    shuffle_dyck2(\"(){)}\")\n    >> [0, 0, 0, 0, 0]\n\n  Args:\n    pairs: List of pairs of open and close tokens that each should be balanced.\n  \"\"\"\n  assert len(pairs) >= 1\n\n  # Compute running balance of each type of parenthesis\n  balances = []\n  for pair in pairs:\n    assert len(pair) == 2\n    open_token, close_token = pair\n    balance = make_pair_balance(\n        rasp.tokens, open_token=open_token,\n        close_token=close_token).named(f\"balance_{pair}\")\n    balances.append(balance)\n\n  # Check if balances where negative anywhere -> parentheses not balanced\n  any_negative = balances[0] < 0\n  for balance in balances[1:]:\n    any_negative = any_negative | (balance < 0)\n\n  # Convert to numerical SOp\n  any_negative = rasp.numerical(rasp.Map(lambda x: x,\n                                         any_negative)).named(\"any_negative\")\n\n  select_all = rasp.Select(rasp.indices, rasp.indices,\n                           rasp.Comparison.TRUE).named(\"select_all\")\n  has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative,\n                                          default=0)).named(\"has_neg\")\n\n  # Check if all balances are 0 at the end -> closed all parentheses\n  all_zero = balances[0] == 0\n  for balance in balances[1:]:\n    all_zero = all_zero & (balance == 0)\n\n  select_last = rasp.Select(rasp.indices, length - 1,\n                            rasp.Comparison.EQ).named(\"select_last\")\n  last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n\n  not_has_neg = (~has_neg).named(\"not_has_neg\")\n  return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n\n\ndef make_shuffle_dyck2() -> rasp.SOp:\n  return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n\n\ndef make_hist() -> rasp.SOp:\n  \"\"\"Returns the number of times each token occurs in the input.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    hist = make_hist()\n    hist(\"abac\")\n    >> [2, 1, 2, 1]\n  \"\"\"\n  same_tok = rasp.Select(rasp.tokens, rasp.tokens,\n                         rasp.Comparison.EQ).named(\"same_tok\")\n  return rasp.SelectorWidth(same_tok).named(\"hist\")\n\n\ndef make_sort_unique(vals: rasp.SOp, keys: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys.\n\n  Only supports unique keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n  \"\"\"\n  smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n  target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n  sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n  return rasp.Aggregate(sel_new, vals).named(\"sort\")\n\n\ndef make_sort(vals: rasp.SOp, keys: rasp.SOp, *, max_seq_len: int,\n              min_key: float) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys, which don't need to be unique.\n\n  The implementation differs from the RASP paper, as it avoids using\n  compositions of selectors to break ties. Instead, it uses the arguments\n  max_seq_len and min_key to ensure the keys are unique.\n\n  Note that this approach only works for numerical keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens, 5, 1)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n    sort([2, 4, 1, 2])\n    >> [1, 2, 2, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n    min_key: Minimum key value (used to ensure keys are unique)\n\n  Returns:\n    Output SOp of sort program.\n  \"\"\""
  },
  {
    "id": "131",
    "text": "idx = (length - rasp.indices).named(\"opp_idx\")\n  opp_idx = (opp_idx - 1).named(\"opp_idx-1\")\n  reverse_selector = rasp.Select(rasp.indices, opp_idx,\n                                 rasp.Comparison.EQ).named(\"reverse_selector\")\n  return rasp.Aggregate(reverse_selector, sop).named(\"reverse\")\n\n\ndef make_pair_balance(sop: rasp.SOp, open_token: str,\n                      close_token: str) -> rasp.SOp:\n  \"\"\"Return fraction of previous open tokens minus the fraction of close tokens.\n\n   (As implemented in the RASP paper.)\n\n  If the outputs are always non-negative and end in 0, that implies the input\n  has balanced parentheses.\n\n  Example usage:\n    num_l = make_pair_balance(rasp.tokens, \"(\", \")\")\n    num_l(\"a()b(c))\")\n    >> [0, 1/2, 0, 0, 1/5, 1/6, 0, -1/8]\n\n  Args:\n    sop: Input SOp.\n    open_token: Token that counts positive.\n    close_token: Token that counts negative.\n\n  Returns:\n    pair_balance: SOp mapping an input to a sequence, where every element\n      is the fraction of previous open tokens minus previous close tokens.\n  \"\"\"\n  bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n  opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n\n  bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n  closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n\n  pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n  return pair_balance.named(\"pair_balance\")\n\n\ndef make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n  \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n    shuffle_dyck2(\"({)}\")\n    >> [1, 1, 1, 1]\n    shuffle_dyck2(\"(){)}\")\n    >> [0, 0, 0, 0, 0]\n\n  Args:\n    pairs: List of pairs of open and close tokens that each should be balanced.\n  \"\"\"\n  assert len(pairs) >= 1\n\n  # Compute running balance of each type of parenthesis\n  balances = []\n  for pair in pairs:\n    assert len(pair) == 2\n    open_token, close_token = pair\n    balance = make_pair_balance(\n        rasp.tokens, open_token=open_token,\n        close_token=close_token).named(f\"balance_{pair}\")\n    balances.append(balance)\n\n  # Check if balances where negative anywhere -> parentheses not balanced\n  any_negative = balances[0] < 0\n  for balance in balances[1:]:\n    any_negative = any_negative | (balance < 0)\n\n  # Convert to numerical SOp\n  any_negative = rasp.numerical(rasp.Map(lambda x: x,\n                                         any_negative)).named(\"any_negative\")\n\n  select_all = rasp.Select(rasp.indices, rasp.indices,\n                           rasp.Comparison.TRUE).named(\"select_all\")\n  has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative,\n                                          default=0)).named(\"has_neg\")\n\n  # Check if all balances are 0 at the end -> closed all parentheses\n  all_zero = balances[0] == 0\n  for balance in balances[1:]:\n    all_zero = all_zero & (balance == 0)\n\n  select_last = rasp.Select(rasp.indices, length - 1,\n                            rasp.Comparison.EQ).named(\"select_last\")\n  last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n\n  not_has_neg = (~has_neg).named(\"not_has_neg\")\n  return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n\n\ndef make_shuffle_dyck2() -> rasp.SOp:\n  return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n\n\ndef make_hist() -> rasp.SOp:\n  \"\"\"Returns the number of times each token occurs in the input.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    hist = make_hist()\n    hist(\"abac\")\n    >> [2, 1, 2, 1]\n  \"\"\"\n  same_tok = rasp.Select(rasp.tokens, rasp.tokens,\n                         rasp.Comparison.EQ).named(\"same_tok\")\n  return rasp.SelectorWidth(same_tok).named(\"hist\")\n\n\ndef make_sort_unique(vals: rasp.SOp, keys: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys.\n\n  Only supports unique keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n  \"\"\"\n  smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n  target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n  sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n  return rasp.Aggregate(sel_new, vals).named(\"sort\")\n\n\ndef make_sort(vals: rasp.SOp, keys: rasp.SOp, *, max_seq_len: int,\n              min_key: float) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys, which don't need to be unique.\n\n  The implementation differs from the RASP paper, as it avoids using\n  compositions of selectors to break ties. Instead, it uses the arguments\n  max_seq_len and min_key to ensure the keys are unique.\n\n  Note that this approach only works for numerical keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens, 5, 1)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n    sort([2, 4, 1, 2])\n    >> [1, 2, 2, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n    min_key: Minimum key value (used to ensure keys are unique)\n\n  Returns:\n    Output SOp of sort program.\n  \"\"\"\n  keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, keys,\n                          rasp.indices)\n  return make_sort_unique(vals, keys)\n\n\ndef make_sort_freq(max_seq_len: int) -> rasp.SOp:\n  \"\"\"Returns tokens sorted by the frequency they appear in the input.\n\n  Tokens the appear the same amount of times are output in the same order as in\n  the input.\n\n  Example usage:\n    sort = make_sort_freq(rasp.tokens, rasp.tokens, 5)\n    sort([2, 4, 2, 1])\n    >> [2, 2, 4, 1]\n\n  Args:\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n  \"\"\""
  },
  {
    "id": "132",
    "text": " [0, 1/2, 0, 0, 1/5, 1/6, 0, -1/8]\n\n  Args:\n    sop: Input SOp.\n    open_token: Token that counts positive.\n    close_token: Token that counts negative.\n\n  Returns:\n    pair_balance: SOp mapping an input to a sequence, where every element\n      is the fraction of previous open tokens minus previous close tokens.\n  \"\"\"\n  bools_open = rasp.numerical(sop == open_token).named(\"bools_open\")\n  opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n\n  bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n  closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n\n  pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n  return pair_balance.named(\"pair_balance\")\n\n\ndef make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n  \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n    shuffle_dyck2(\"({)}\")\n    >> [1, 1, 1, 1]\n    shuffle_dyck2(\"(){)}\")\n    >> [0, 0, 0, 0, 0]\n\n  Args:\n    pairs: List of pairs of open and close tokens that each should be balanced.\n  \"\"\"\n  assert len(pairs) >= 1\n\n  # Compute running balance of each type of parenthesis\n  balances = []\n  for pair in pairs:\n    assert len(pair) == 2\n    open_token, close_token = pair\n    balance = make_pair_balance(\n        rasp.tokens, open_token=open_token,\n        close_token=close_token).named(f\"balance_{pair}\")\n    balances.append(balance)\n\n  # Check if balances where negative anywhere -> parentheses not balanced\n  any_negative = balances[0] < 0\n  for balance in balances[1:]:\n    any_negative = any_negative | (balance < 0)\n\n  # Convert to numerical SOp\n  any_negative = rasp.numerical(rasp.Map(lambda x: x,\n                                         any_negative)).named(\"any_negative\")\n\n  select_all = rasp.Select(rasp.indices, rasp.indices,\n                           rasp.Comparison.TRUE).named(\"select_all\")\n  has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative,\n                                          default=0)).named(\"has_neg\")\n\n  # Check if all balances are 0 at the end -> closed all parentheses\n  all_zero = balances[0] == 0\n  for balance in balances[1:]:\n    all_zero = all_zero & (balance == 0)\n\n  select_last = rasp.Select(rasp.indices, length - 1,\n                            rasp.Comparison.EQ).named(\"select_last\")\n  last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n\n  not_has_neg = (~has_neg).named(\"not_has_neg\")\n  return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n\n\ndef make_shuffle_dyck2() -> rasp.SOp:\n  return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n\n\ndef make_hist() -> rasp.SOp:\n  \"\"\"Returns the number of times each token occurs in the input.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    hist = make_hist()\n    hist(\"abac\")\n    >> [2, 1, 2, 1]\n  \"\"\"\n  same_tok = rasp.Select(rasp.tokens, rasp.tokens,\n                         rasp.Comparison.EQ).named(\"same_tok\")\n  return rasp.SelectorWidth(same_tok).named(\"hist\")\n\n\ndef make_sort_unique(vals: rasp.SOp, keys: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys.\n\n  Only supports unique keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n  \"\"\"\n  smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n  target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n  sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n  return rasp.Aggregate(sel_new, vals).named(\"sort\")\n\n\ndef make_sort(vals: rasp.SOp, keys: rasp.SOp, *, max_seq_len: int,\n              min_key: float) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys, which don't need to be unique.\n\n  The implementation differs from the RASP paper, as it avoids using\n  compositions of selectors to break ties. Instead, it uses the arguments\n  max_seq_len and min_key to ensure the keys are unique.\n\n  Note that this approach only works for numerical keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens, 5, 1)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n    sort([2, 4, 1, 2])\n    >> [1, 2, 2, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n    min_key: Minimum key value (used to ensure keys are unique)\n\n  Returns:\n    Output SOp of sort program.\n  \"\"\"\n  keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, keys,\n                          rasp.indices)\n  return make_sort_unique(vals, keys)\n\n\ndef make_sort_freq(max_seq_len: int) -> rasp.SOp:\n  \"\"\"Returns tokens sorted by the frequency they appear in the input.\n\n  Tokens the appear the same amount of times are output in the same order as in\n  the input.\n\n  Example usage:\n    sort = make_sort_freq(rasp.tokens, rasp.tokens, 5)\n    sort([2, 4, 2, 1])\n    >> [2, 2, 4, 1]\n\n  Args:\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n  \"\"\"\n  hist = -1 * make_hist().named(\"hist\")\n  return make_sort(\n      rasp.tokens, hist, max_seq_len=max_seq_len, min_key=1).named(\"sort_freq\")\n\n\n### Programs that work under both causal and regular evaluation.\n\n\ndef make_frac_prevs(bools: rasp.SOp) -> rasp.SOp:\n  \"\"\"Count the fraction of previous tokens where a specific condition was True.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    num_l = make_frac_prevs(rasp.tokens==\"l\")\n    num_l(\"hello\")\n    >> [0, 0, 1/3, 1/2, 2/5]\n\n  Args:\n    bools: SOp mapping a sequence to a sequence of booleans.\n\n  Returns:\n    frac_prevs: SOp mapping an input to a sequence, where every element\n      is the fraction of previous \"True\" tokens.\n  \"\"\""
  },
  {
    "id": "133",
    "text": "  opens = rasp.numerical(make_frac_prevs(bools_open)).named(\"opens\")\n\n  bools_close = rasp.numerical(sop == close_token).named(\"bools_close\")\n  closes = rasp.numerical(make_frac_prevs(bools_close)).named(\"closes\")\n\n  pair_balance = rasp.numerical(rasp.LinearSequenceMap(opens, closes, 1, -1))\n  return pair_balance.named(\"pair_balance\")\n\n\ndef make_shuffle_dyck(pairs: List[str]) -> rasp.SOp:\n  \"\"\"Returns 1 if a set of parentheses are balanced, 0 else.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    shuffle_dyck2 = make_shuffle_dyck(pairs=[\"()\", \"{}\"])\n    shuffle_dyck2(\"({)}\")\n    >> [1, 1, 1, 1]\n    shuffle_dyck2(\"(){)}\")\n    >> [0, 0, 0, 0, 0]\n\n  Args:\n    pairs: List of pairs of open and close tokens that each should be balanced.\n  \"\"\"\n  assert len(pairs) >= 1\n\n  # Compute running balance of each type of parenthesis\n  balances = []\n  for pair in pairs:\n    assert len(pair) == 2\n    open_token, close_token = pair\n    balance = make_pair_balance(\n        rasp.tokens, open_token=open_token,\n        close_token=close_token).named(f\"balance_{pair}\")\n    balances.append(balance)\n\n  # Check if balances where negative anywhere -> parentheses not balanced\n  any_negative = balances[0] < 0\n  for balance in balances[1:]:\n    any_negative = any_negative | (balance < 0)\n\n  # Convert to numerical SOp\n  any_negative = rasp.numerical(rasp.Map(lambda x: x,\n                                         any_negative)).named(\"any_negative\")\n\n  select_all = rasp.Select(rasp.indices, rasp.indices,\n                           rasp.Comparison.TRUE).named(\"select_all\")\n  has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative,\n                                          default=0)).named(\"has_neg\")\n\n  # Check if all balances are 0 at the end -> closed all parentheses\n  all_zero = balances[0] == 0\n  for balance in balances[1:]:\n    all_zero = all_zero & (balance == 0)\n\n  select_last = rasp.Select(rasp.indices, length - 1,\n                            rasp.Comparison.EQ).named(\"select_last\")\n  last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n\n  not_has_neg = (~has_neg).named(\"not_has_neg\")\n  return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n\n\ndef make_shuffle_dyck2() -> rasp.SOp:\n  return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n\n\ndef make_hist() -> rasp.SOp:\n  \"\"\"Returns the number of times each token occurs in the input.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    hist = make_hist()\n    hist(\"abac\")\n    >> [2, 1, 2, 1]\n  \"\"\"\n  same_tok = rasp.Select(rasp.tokens, rasp.tokens,\n                         rasp.Comparison.EQ).named(\"same_tok\")\n  return rasp.SelectorWidth(same_tok).named(\"hist\")\n\n\ndef make_sort_unique(vals: rasp.SOp, keys: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys.\n\n  Only supports unique keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n  \"\"\"\n  smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n  target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n  sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n  return rasp.Aggregate(sel_new, vals).named(\"sort\")\n\n\ndef make_sort(vals: rasp.SOp, keys: rasp.SOp, *, max_seq_len: int,\n              min_key: float) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys, which don't need to be unique.\n\n  The implementation differs from the RASP paper, as it avoids using\n  compositions of selectors to break ties. Instead, it uses the arguments\n  max_seq_len and min_key to ensure the keys are unique.\n\n  Note that this approach only works for numerical keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens, 5, 1)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n    sort([2, 4, 1, 2])\n    >> [1, 2, 2, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n    min_key: Minimum key value (used to ensure keys are unique)\n\n  Returns:\n    Output SOp of sort program.\n  \"\"\"\n  keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, keys,\n                          rasp.indices)\n  return make_sort_unique(vals, keys)\n\n\ndef make_sort_freq(max_seq_len: int) -> rasp.SOp:\n  \"\"\"Returns tokens sorted by the frequency they appear in the input.\n\n  Tokens the appear the same amount of times are output in the same order as in\n  the input.\n\n  Example usage:\n    sort = make_sort_freq(rasp.tokens, rasp.tokens, 5)\n    sort([2, 4, 2, 1])\n    >> [2, 2, 4, 1]\n\n  Args:\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n  \"\"\"\n  hist = -1 * make_hist().named(\"hist\")\n  return make_sort(\n      rasp.tokens, hist, max_seq_len=max_seq_len, min_key=1).named(\"sort_freq\")\n\n\n### Programs that work under both causal and regular evaluation.\n\n\ndef make_frac_prevs(bools: rasp.SOp) -> rasp.SOp:\n  \"\"\"Count the fraction of previous tokens where a specific condition was True.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    num_l = make_frac_prevs(rasp.tokens==\"l\")\n    num_l(\"hello\")\n    >> [0, 0, 1/3, 1/2, 2/5]\n\n  Args:\n    bools: SOp mapping a sequence to a sequence of booleans.\n\n  Returns:\n    frac_prevs: SOp mapping an input to a sequence, where every element\n      is the fraction of previous \"True\" tokens.\n  \"\"\"\n  bools = rasp.numerical(bools)\n  prevs = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LEQ)\n  return rasp.numerical(rasp.Aggregate(prevs, bools,\n                                       default=0)).named(\"frac_prevs\")\n\n\ndef shift_by(offset: int, /, sop: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns the sop, shifted by `offset`, None-padded.\"\"\""
  },
  {
    "id": "134",
    "text": " shuffle_dyck2(\"(){)}\")\n    >> [0, 0, 0, 0, 0]\n\n  Args:\n    pairs: List of pairs of open and close tokens that each should be balanced.\n  \"\"\"\n  assert len(pairs) >= 1\n\n  # Compute running balance of each type of parenthesis\n  balances = []\n  for pair in pairs:\n    assert len(pair) == 2\n    open_token, close_token = pair\n    balance = make_pair_balance(\n        rasp.tokens, open_token=open_token,\n        close_token=close_token).named(f\"balance_{pair}\")\n    balances.append(balance)\n\n  # Check if balances where negative anywhere -> parentheses not balanced\n  any_negative = balances[0] < 0\n  for balance in balances[1:]:\n    any_negative = any_negative | (balance < 0)\n\n  # Convert to numerical SOp\n  any_negative = rasp.numerical(rasp.Map(lambda x: x,\n                                         any_negative)).named(\"any_negative\")\n\n  select_all = rasp.Select(rasp.indices, rasp.indices,\n                           rasp.Comparison.TRUE).named(\"select_all\")\n  has_neg = rasp.numerical(rasp.Aggregate(select_all, any_negative,\n                                          default=0)).named(\"has_neg\")\n\n  # Check if all balances are 0 at the end -> closed all parentheses\n  all_zero = balances[0] == 0\n  for balance in balances[1:]:\n    all_zero = all_zero & (balance == 0)\n\n  select_last = rasp.Select(rasp.indices, length - 1,\n                            rasp.Comparison.EQ).named(\"select_last\")\n  last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n\n  not_has_neg = (~has_neg).named(\"not_has_neg\")\n  return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n\n\ndef make_shuffle_dyck2() -> rasp.SOp:\n  return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n\n\ndef make_hist() -> rasp.SOp:\n  \"\"\"Returns the number of times each token occurs in the input.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    hist = make_hist()\n    hist(\"abac\")\n    >> [2, 1, 2, 1]\n  \"\"\"\n  same_tok = rasp.Select(rasp.tokens, rasp.tokens,\n                         rasp.Comparison.EQ).named(\"same_tok\")\n  return rasp.SelectorWidth(same_tok).named(\"hist\")\n\n\ndef make_sort_unique(vals: rasp.SOp, keys: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys.\n\n  Only supports unique keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n  \"\"\"\n  smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n  target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n  sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n  return rasp.Aggregate(sel_new, vals).named(\"sort\")\n\n\ndef make_sort(vals: rasp.SOp, keys: rasp.SOp, *, max_seq_len: int,\n              min_key: float) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys, which don't need to be unique.\n\n  The implementation differs from the RASP paper, as it avoids using\n  compositions of selectors to break ties. Instead, it uses the arguments\n  max_seq_len and min_key to ensure the keys are unique.\n\n  Note that this approach only works for numerical keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens, 5, 1)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n    sort([2, 4, 1, 2])\n    >> [1, 2, 2, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n    min_key: Minimum key value (used to ensure keys are unique)\n\n  Returns:\n    Output SOp of sort program.\n  \"\"\"\n  keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, keys,\n                          rasp.indices)\n  return make_sort_unique(vals, keys)\n\n\ndef make_sort_freq(max_seq_len: int) -> rasp.SOp:\n  \"\"\"Returns tokens sorted by the frequency they appear in the input.\n\n  Tokens the appear the same amount of times are output in the same order as in\n  the input.\n\n  Example usage:\n    sort = make_sort_freq(rasp.tokens, rasp.tokens, 5)\n    sort([2, 4, 2, 1])\n    >> [2, 2, 4, 1]\n\n  Args:\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n  \"\"\"\n  hist = -1 * make_hist().named(\"hist\")\n  return make_sort(\n      rasp.tokens, hist, max_seq_len=max_seq_len, min_key=1).named(\"sort_freq\")\n\n\n### Programs that work under both causal and regular evaluation.\n\n\ndef make_frac_prevs(bools: rasp.SOp) -> rasp.SOp:\n  \"\"\"Count the fraction of previous tokens where a specific condition was True.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    num_l = make_frac_prevs(rasp.tokens==\"l\")\n    num_l(\"hello\")\n    >> [0, 0, 1/3, 1/2, 2/5]\n\n  Args:\n    bools: SOp mapping a sequence to a sequence of booleans.\n\n  Returns:\n    frac_prevs: SOp mapping an input to a sequence, where every element\n      is the fraction of previous \"True\" tokens.\n  \"\"\"\n  bools = rasp.numerical(bools)\n  prevs = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LEQ)\n  return rasp.numerical(rasp.Aggregate(prevs, bools,\n                                       default=0)).named(\"frac_prevs\")\n\n\ndef shift_by(offset: int, /, sop: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns the sop, shifted by `offset`, None-padded.\"\"\"\n  select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                     lambda k, q: q == k + offset)\n  out = rasp.Aggregate(select_off_by_offset, sop, default=None)\n  return out.named(f\"shift_by({offset})\")\n\n\ndef detect_pattern(sop: rasp.SOp, pattern: Sequence[rasp.Value]) -> rasp.SOp:\n  \"\"\"Returns an SOp which is True at the final element of the pattern.\n\n  The first len(pattern) - 1 elements of the output SOp are None-padded.\n\n  detect_pattern(tokens, \"abc\")(\"abcabc\") == [None, None, T, F, F, T]\n\n  Args:\n    sop: the SOp in which to look for patterns.\n    pattern: a sequence of values to look for.\n\n  Returns:\n    a sop which detects the pattern.\n  \"\"\""
  },
  {
    "id": "135",
    "text": "last = rasp.Select(rasp.indices, length - 1,\n                            rasp.Comparison.EQ).named(\"select_last\")\n  last_zero = rasp.Aggregate(select_last, all_zero).named(\"last_zero\")\n\n  not_has_neg = (~has_neg).named(\"not_has_neg\")\n  return (last_zero & not_has_neg).named(\"shuffle_dyck\")\n\n\ndef make_shuffle_dyck2() -> rasp.SOp:\n  return make_shuffle_dyck(pairs=[\"()\", \"{}\"]).named(\"shuffle_dyck2\")\n\n\ndef make_hist() -> rasp.SOp:\n  \"\"\"Returns the number of times each token occurs in the input.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    hist = make_hist()\n    hist(\"abac\")\n    >> [2, 1, 2, 1]\n  \"\"\"\n  same_tok = rasp.Select(rasp.tokens, rasp.tokens,\n                         rasp.Comparison.EQ).named(\"same_tok\")\n  return rasp.SelectorWidth(same_tok).named(\"hist\")\n\n\ndef make_sort_unique(vals: rasp.SOp, keys: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys.\n\n  Only supports unique keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n  \"\"\"\n  smaller = rasp.Select(keys, keys, rasp.Comparison.LT).named(\"smaller\")\n  target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n  sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n  return rasp.Aggregate(sel_new, vals).named(\"sort\")\n\n\ndef make_sort(vals: rasp.SOp, keys: rasp.SOp, *, max_seq_len: int,\n              min_key: float) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys, which don't need to be unique.\n\n  The implementation differs from the RASP paper, as it avoids using\n  compositions of selectors to break ties. Instead, it uses the arguments\n  max_seq_len and min_key to ensure the keys are unique.\n\n  Note that this approach only works for numerical keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens, 5, 1)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n    sort([2, 4, 1, 2])\n    >> [1, 2, 2, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n    min_key: Minimum key value (used to ensure keys are unique)\n\n  Returns:\n    Output SOp of sort program.\n  \"\"\"\n  keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, keys,\n                          rasp.indices)\n  return make_sort_unique(vals, keys)\n\n\ndef make_sort_freq(max_seq_len: int) -> rasp.SOp:\n  \"\"\"Returns tokens sorted by the frequency they appear in the input.\n\n  Tokens the appear the same amount of times are output in the same order as in\n  the input.\n\n  Example usage:\n    sort = make_sort_freq(rasp.tokens, rasp.tokens, 5)\n    sort([2, 4, 2, 1])\n    >> [2, 2, 4, 1]\n\n  Args:\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n  \"\"\"\n  hist = -1 * make_hist().named(\"hist\")\n  return make_sort(\n      rasp.tokens, hist, max_seq_len=max_seq_len, min_key=1).named(\"sort_freq\")\n\n\n### Programs that work under both causal and regular evaluation.\n\n\ndef make_frac_prevs(bools: rasp.SOp) -> rasp.SOp:\n  \"\"\"Count the fraction of previous tokens where a specific condition was True.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    num_l = make_frac_prevs(rasp.tokens==\"l\")\n    num_l(\"hello\")\n    >> [0, 0, 1/3, 1/2, 2/5]\n\n  Args:\n    bools: SOp mapping a sequence to a sequence of booleans.\n\n  Returns:\n    frac_prevs: SOp mapping an input to a sequence, where every element\n      is the fraction of previous \"True\" tokens.\n  \"\"\"\n  bools = rasp.numerical(bools)\n  prevs = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LEQ)\n  return rasp.numerical(rasp.Aggregate(prevs, bools,\n                                       default=0)).named(\"frac_prevs\")\n\n\ndef shift_by(offset: int, /, sop: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns the sop, shifted by `offset`, None-padded.\"\"\"\n  select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                     lambda k, q: q == k + offset)\n  out = rasp.Aggregate(select_off_by_offset, sop, default=None)\n  return out.named(f\"shift_by({offset})\")\n\n\ndef detect_pattern(sop: rasp.SOp, pattern: Sequence[rasp.Value]) -> rasp.SOp:\n  \"\"\"Returns an SOp which is True at the final element of the pattern.\n\n  The first len(pattern) - 1 elements of the output SOp are None-padded.\n\n  detect_pattern(tokens, \"abc\")(\"abcabc\") == [None, None, T, F, F, T]\n\n  Args:\n    sop: the SOp in which to look for patterns.\n    pattern: a sequence of values to look for.\n\n  Returns:\n    a sop which detects the pattern.\n  \"\"\"\n\n  if len(pattern) < 1:\n    raise ValueError(f\"Length of `pattern` must be at least 1. Got {pattern}\")\n\n  # detectors[i] will be a boolean-valued SOp which is true at position j iff\n  # the i'th (from the end) element of the pattern was detected at position j-i.\n  detectors = []\n  for i, element in enumerate(reversed(pattern)):\n    detector = sop == element\n    if i != 0:\n      detector = shift_by(i, detector)\n    detectors.append(detector)\n\n  # All that's left is to take the AND over all detectors.\n  pattern_detected = detectors.pop()\n  while detectors:\n    pattern_detected = pattern_detected & detectors.pop()\n\n  return pattern_detected.named(f\"detect_pattern({pattern})\")\n\n\ndef make_count_less_freq(n: int) -> rasp.SOp:\n  \"\"\"Returns how many tokens appear fewer than n times in the input.\n\n  The output sequence contains this count in each position.\n\n  Example usage:\n    count_less_freq = make_count_less_freq(2)\n    count_less_freq([\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"])\n    >> [3, 3, 3, 3, 3, 3]\n    count_less_freq([\"a\", \"a\", \"c\", \"b\", \"b\", \"c\"])\n    >> [6, 6, 6, 6, 6, 6]\n\n  Args:\n    n: Integer to compare token frequences to.\n  \"\"\""
  },
  {
    "id": "136",
    "text": ".LT).named(\"smaller\")\n  target_pos = rasp.SelectorWidth(smaller).named(\"target_pos\")\n  sel_new = rasp.Select(target_pos, rasp.indices, rasp.Comparison.EQ)\n  return rasp.Aggregate(sel_new, vals).named(\"sort\")\n\n\ndef make_sort(vals: rasp.SOp, keys: rasp.SOp, *, max_seq_len: int,\n              min_key: float) -> rasp.SOp:\n  \"\"\"Returns vals sorted by < relation on keys, which don't need to be unique.\n\n  The implementation differs from the RASP paper, as it avoids using\n  compositions of selectors to break ties. Instead, it uses the arguments\n  max_seq_len and min_key to ensure the keys are unique.\n\n  Note that this approach only works for numerical keys.\n\n  Example usage:\n    sort = make_sort(rasp.tokens, rasp.tokens, 5, 1)\n    sort([2, 4, 3, 1])\n    >> [1, 2, 3, 4]\n    sort([2, 4, 1, 2])\n    >> [1, 2, 2, 4]\n\n  Args:\n    vals: Values to sort.\n    keys: Keys for sorting.\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n    min_key: Minimum key value (used to ensure keys are unique)\n\n  Returns:\n    Output SOp of sort program.\n  \"\"\"\n  keys = rasp.SequenceMap(lambda x, i: x + min_key * i / max_seq_len, keys,\n                          rasp.indices)\n  return make_sort_unique(vals, keys)\n\n\ndef make_sort_freq(max_seq_len: int) -> rasp.SOp:\n  \"\"\"Returns tokens sorted by the frequency they appear in the input.\n\n  Tokens the appear the same amount of times are output in the same order as in\n  the input.\n\n  Example usage:\n    sort = make_sort_freq(rasp.tokens, rasp.tokens, 5)\n    sort([2, 4, 2, 1])\n    >> [2, 2, 4, 1]\n\n  Args:\n    max_seq_len: Maximum sequence length (used to ensure keys are unique)\n  \"\"\"\n  hist = -1 * make_hist().named(\"hist\")\n  return make_sort(\n      rasp.tokens, hist, max_seq_len=max_seq_len, min_key=1).named(\"sort_freq\")\n\n\n### Programs that work under both causal and regular evaluation.\n\n\ndef make_frac_prevs(bools: rasp.SOp) -> rasp.SOp:\n  \"\"\"Count the fraction of previous tokens where a specific condition was True.\n\n   (As implemented in the RASP paper.)\n\n  Example usage:\n    num_l = make_frac_prevs(rasp.tokens==\"l\")\n    num_l(\"hello\")\n    >> [0, 0, 1/3, 1/2, 2/5]\n\n  Args:\n    bools: SOp mapping a sequence to a sequence of booleans.\n\n  Returns:\n    frac_prevs: SOp mapping an input to a sequence, where every element\n      is the fraction of previous \"True\" tokens.\n  \"\"\"\n  bools = rasp.numerical(bools)\n  prevs = rasp.Select(rasp.indices, rasp.indices, rasp.Comparison.LEQ)\n  return rasp.numerical(rasp.Aggregate(prevs, bools,\n                                       default=0)).named(\"frac_prevs\")\n\n\ndef shift_by(offset: int, /, sop: rasp.SOp) -> rasp.SOp:\n  \"\"\"Returns the sop, shifted by `offset`, None-padded.\"\"\"\n  select_off_by_offset = rasp.Select(rasp.indices, rasp.indices,\n                                     lambda k, q: q == k + offset)\n  out = rasp.Aggregate(select_off_by_offset, sop, default=None)\n  return out.named(f\"shift_by({offset})\")\n\n\ndef detect_pattern(sop: rasp.SOp, pattern: Sequence[rasp.Value]) -> rasp.SOp:\n  \"\"\"Returns an SOp which is True at the final element of the pattern.\n\n  The first len(pattern) - 1 elements of the output SOp are None-padded.\n\n  detect_pattern(tokens, \"abc\")(\"abcabc\") == [None, None, T, F, F, T]\n\n  Args:\n    sop: the SOp in which to look for patterns.\n    pattern: a sequence of values to look for.\n\n  Returns:\n    a sop which detects the pattern.\n  \"\"\"\n\n  if len(pattern) < 1:\n    raise ValueError(f\"Length of `pattern` must be at least 1. Got {pattern}\")\n\n  # detectors[i] will be a boolean-valued SOp which is true at position j iff\n  # the i'th (from the end) element of the pattern was detected at position j-i.\n  detectors = []\n  for i, element in enumerate(reversed(pattern)):\n    detector = sop == element\n    if i != 0:\n      detector = shift_by(i, detector)\n    detectors.append(detector)\n\n  # All that's left is to take the AND over all detectors.\n  pattern_detected = detectors.pop()\n  while detectors:\n    pattern_detected = pattern_detected & detectors.pop()\n\n  return pattern_detected.named(f\"detect_pattern({pattern})\")\n\n\ndef make_count_less_freq(n: int) -> rasp.SOp:\n  \"\"\"Returns how many tokens appear fewer than n times in the input.\n\n  The output sequence contains this count in each position.\n\n  Example usage:\n    count_less_freq = make_count_less_freq(2)\n    count_less_freq([\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"])\n    >> [3, 3, 3, 3, 3, 3]\n    count_less_freq([\"a\", \"a\", \"c\", \"b\", \"b\", \"c\"])\n    >> [6, 6, 6, 6, 6, 6]\n\n  Args:\n    n: Integer to compare token frequences to.\n  \"\"\"\n  hist = make_hist().named(\"hist\")\n  select_less = rasp.Select(hist, hist,\n                            lambda x, y: x <= n).named(\"select_less\")\n  return rasp.SelectorWidth(select_less).named(\"count_less_freq\")\n\n\ndef make_count(sop, token):\n  \"\"\"Returns the count of `token` in `sop`.\n\n  The output sequence contains this count in each position.\n\n  Example usage:\n    count = make_count(tokens, \"a\")\n    count([\"a\", \"a\", \"a\", \"b\", \"b\", \"c\"])\n    >> [3, 3, 3, 3, 3, 3]\n    count([\"c\", \"a\", \"b\", \"c\"])\n    >> [1, 1, 1, 1]\n\n  Args:\n    sop: Sop to count tokens in.\n    token: Token to count.\n  \"\"\"\n  return rasp.SelectorWidth(rasp.Select(\n      sop, sop, lambda k, q: k == token)).named(f\"count_{token}\")\n\n\ndef make_nary_sequencemap(f, *sops):\n  \"\"\"Returns an SOp that simulates an n-ary SequenceMap.\n\n  Uses multiple binary SequenceMaps to convert n SOps x_1, x_2, ..., x_n\n  into a single SOp arguments that takes n-tuples as value. The n-ary sequence\n  map implementing f is then a Map on this resulting SOp.\n\n  Note that the intermediate variables representing tuples of varying length\n  will be encoded categorically, and can become very high-dimensional. So,\n  using this function might lead to very large compiled models.\n\n  Args:\n    f: Function with n arguments.\n    *sops: Sequence of SOps, one for each argument of f.\n  \"\"\""
  },
  {
    "id": "137",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.assemble.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.compiler import assemble\nfrom tracr.craft import bases\n\n\nclass AssembleTest(parameterized.TestCase):\n\n  def test_token_embedding_produces_correct_embedding(self):\n    # Token embeddings should be one-hot embeddings of the input integers\n    # into the token subspace of residual_space\n    input_space = bases.VectorSpaceWithBasis.from_values(\"0inp\", range(2))\n    indices_space = bases.VectorSpaceWithBasis.from_values(\"1ind\", range(3))\n    output_space = bases.VectorSpaceWithBasis.from_values(\"2out\", range(2))\n    residual_space = bases.join_vector_spaces(input_space, indices_space,\n                                              output_space)\n\n    @hk.without_apply_rng\n    @hk.transform\n    def token_pos_embed(tokens):"
  },
  {
    "id": "138",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.assemble.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.compiler import assemble\nfrom tracr.craft import bases\n\n\nclass AssembleTest(parameterized.TestCase):\n\n  def test_token_embedding_produces_correct_embedding(self):\n    # Token embeddings should be one-hot embeddings of the input integers\n    # into the token subspace of residual_space\n    input_space = bases.VectorSpaceWithBasis.from_values(\"0inp\", range(2))\n    indices_space = bases.VectorSpaceWithBasis.from_values(\"1ind\", range(3))\n    output_space = bases.VectorSpaceWithBasis.from_values(\"2out\", range(2))\n    residual_space = bases.join_vector_spaces(input_space, indices_space,\n                                              output_space)\n\n    @hk.without_apply_rng\n    @hk.transform\n    def token_pos_embed(tokens):\n      embed_modules = assemble._make_embedding_modules(\n          residual_space=residual_space,\n          tokens_space=input_space,\n          indices_space=indices_space,\n          output_space=output_space)\n      return embed_modules.token_embed(tokens)\n\n    tokens = jnp.array([0, 0, 1])\n    expected_token_embeddings = jnp.array([[1, 0, 0, 0, 0, 0, 0],\n                                           [1, 0, 0, 0, 0, 0, 0],\n                                           [0, 1, 0, 0, 0, 0, 0]])\n\n    params = token_pos_embed.init(jax.random.PRNGKey(0), tokens)\n    embeddings = token_pos_embed.apply(params, tokens)\n    np.testing.assert_allclose(embeddings, expected_token_embeddings)\n\n  def test_position_embedding_produces_correct_embedding(self):\n    # Position embeddings should be one-hot embeddings of the input integers\n    # (representing indices) into the indices subspace of residual_space\n    input_space = bases.VectorSpaceWithBasis.from_values(\"0inp\", range(2))\n    indices_space = bases.VectorSpaceWithBasis.from_values(\"1ind\", range(3))\n    output_space = bases.VectorSpaceWithBasis.from_values(\"2out\", range(2))\n    residual_space = bases.join_vector_spaces(input_space, indices_space,\n                                              output_space)\n\n    @hk.without_apply_rng\n    @hk.transform\n    def token_pos_embed(tokens):"
  },
  {
    "id": "139",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.assemble.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.compiler import assemble\nfrom tracr.craft import bases\n\n\nclass AssembleTest(parameterized.TestCase):\n\n  def test_token_embedding_produces_correct_embedding(self):\n    # Token embeddings should be one-hot embeddings of the input integers\n    # into the token subspace of residual_space\n    input_space = bases.VectorSpaceWithBasis.from_values(\"0inp\", range(2))\n    indices_space = bases.VectorSpaceWithBasis.from_values(\"1ind\", range(3))\n    output_space = bases.VectorSpaceWithBasis.from_values(\"2out\", range(2))\n    residual_space = bases.join_vector_spaces(input_space, indices_space,\n                                              output_space)\n\n    @hk.without_apply_rng\n    @hk.transform\n    def token_pos_embed(tokens):\n      embed_modules = assemble._make_embedding_modules(\n          residual_space=residual_space,\n          tokens_space=input_space,\n          indices_space=indices_space,\n          output_space=output_space)\n      return embed_modules.token_embed(tokens)\n\n    tokens = jnp.array([0, 0, 1])\n    expected_token_embeddings = jnp.array([[1, 0, 0, 0, 0, 0, 0],\n                                           [1, 0, 0, 0, 0, 0, 0],\n                                           [0, 1, 0, 0, 0, 0, 0]])\n\n    params = token_pos_embed.init(jax.random.PRNGKey(0), tokens)\n    embeddings = token_pos_embed.apply(params, tokens)\n    np.testing.assert_allclose(embeddings, expected_token_embeddings)\n\n  def test_position_embedding_produces_correct_embedding(self):\n    # Position embeddings should be one-hot embeddings of the input integers\n    # (representing indices) into the indices subspace of residual_space\n    input_space = bases.VectorSpaceWithBasis.from_values(\"0inp\", range(2))\n    indices_space = bases.VectorSpaceWithBasis.from_values(\"1ind\", range(3))\n    output_space = bases.VectorSpaceWithBasis.from_values(\"2out\", range(2))\n    residual_space = bases.join_vector_spaces(input_space, indices_space,\n                                              output_space)\n\n    @hk.without_apply_rng\n    @hk.transform\n    def token_pos_embed(tokens):\n      embed_modules = assemble._make_embedding_modules(\n          residual_space=residual_space,\n          tokens_space=input_space,\n          indices_space=indices_space,\n          output_space=output_space)\n      return embed_modules.pos_embed(jnp.indices(tokens.shape)[-1])\n\n    tokens = jnp.array([3, 0, 0, 1])\n    expected_pos_embeddings = jnp.array([[0, 0, 0, 0, 0, 0, 0],\n                                         [0, 0, 1, 0, 0, 0, 0],\n                                         [0, 0, 0, 1, 0, 0, 0],\n                                         [0, 0, 0, 0, 1, 0, 0]])\n\n    params = token_pos_embed.init(jax.random.PRNGKey(0), tokens)\n    embeddings = token_pos_embed.apply(params, tokens)\n    np.testing.assert_allclose(embeddings, expected_pos_embeddings)\n\n  def test_unembedding(self):\n    # Prepend numbers to preserve basis order [input, index, output]\n    input_space = bases.VectorSpaceWithBasis.from_values(\"0inp\", range(2))\n    indices_space = bases.VectorSpaceWithBasis.from_values(\"1ind\", range(3))\n    output_space = bases.VectorSpaceWithBasis.from_values(\"2out\", range(2))\n    residual_space = bases.join_vector_spaces(input_space, indices_space,\n                                              output_space)\n\n    @hk.without_apply_rng\n    @hk.transform\n    def unembed(embeddings):"
  },
  {
    "id": "140",
    "text": ".\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Attention head for categorical inputs.\"\"\"\n\nfrom typing import Optional\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\nfrom typing_extensions import Protocol\n\n\nclass QueryKeyToAttnLogit(Protocol):\n\n  def __call__(self, query: bases.BasisDirection,\n               key: bases.BasisDirection) -> bool:\n    pass\n\n\ndef categorical_attn(\n    query_space: bases.VectorSpaceWithBasis,\n    key_space: bases.VectorSpaceWithBasis,\n    value_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    bos_space: bases.VectorSpaceWithBasis,\n    one_space: bases.VectorSpaceWithBasis,\n    attn_fn: QueryKeyToAttnLogit,\n    default_output: Optional[bases.VectorInBasis] = None,\n    causal: bool = False,\n    always_attend_to_bos: bool = False,\n    use_bos_for_default_output: bool = True,\n    softmax_coldness: float = 100.,\n) -> transformers.AttentionHead:\n  \"\"\"Returns an attention head for categorical inputs.\n\n  Assumes the existence of a beginning of sequence token and attends to it\n  always with strength 0.5*softmax_coldness. This allows to implement an\n  arbitrary default value for rows in the attention pattern that are all-zero.\n\n  Attends to the BOS token if all other key-query pairs have zero attention.\n  Hence, the first value in the value sequence will be the default output for\n  such cases.\n\n  Args:\n    query_space: Vector space containing (categorical) query input.\n    key_space: Vector space containing (categorical) key input.\n    value_space: Vector space containing (numerical) value input.\n    output_space: Vector space which will contain (numerical) output.\n    bos_space: 1-d space used to identify the beginning of sequence token.\n    one_space: 1-d space which contains 1 at every position.\n    attn_fn: A selector function f(query, key) operating on the query/key basis\n      directions that defines the attention pattern.\n    default_output: Output to return if attention pattern is all zero.\n    causal: If True, use masked attention.\n    always_attend_to_bos: If True, always attend to the BOS token. If False,\n      only attend to BOS when attending to nothing else.\n    use_bos_for_default_output: If True, assume BOS is not in the value space\n      and output a default value when attending to BOS. If False, assume BOS is\n      in the value space, and map it to the output space like any other token.\n    softmax_coldness: The inverse temperature of the softmax. Default value is\n      high which makes the attention close to a hard maximum.\n  \"\"\"\n  bases.ensure_dims(bos_space, num_dims=1, name=\"bos_space\")\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n  bos_direction = bos_space.basis[0]\n  one_direction = one_space.basis[0]\n\n  # Add bos direction to query, key, and value spaces in case it is missing\n  query_space = bases.join_vector_spaces(query_space, bos_space, one_space)\n  key_space = bases.join_vector_spaces(key_space, bos_space)\n  value_space = bases.join_vector_spaces(value_space, bos_space)\n\n  if always_attend_to_bos:\n    value_basis = value_space.basis\n  else:\n    value_basis = [v for v in value_space.basis if v != bos_direction]\n  assert len(value_basis) == output_space.num_dims\n  value_to_output = dict(zip(value_basis, output_space.basis))\n\n  if default_output is None:\n    default_output = output_space.null_vector()\n  assert default_output in output_space\n\n  def qk_fun(query: bases.BasisDirection, key: bases.BasisDirection) -> float:\n\n    # We want to enforce the following property on our attention patterns:\n    # - if nothing else is attended to, attend to the BOS token.\n    # - otherwise, don't attend to the BOS token.\n    #\n    # We assume that the BOS position always only contains the vector bos + one,\n    # and that any other position has bos coefficient 0.\n    #\n    # We do this as follows:\n    # Let Q and K be subspaces of V containing the query and key vectors,\n    # both disjoint with the BOS space {bos} or the one space {one}.\n    # Suppose we have an attn_fn which defines a bilinear W_QK: V x V -> ,\n    # s.t. W_QK(q, k) = 0 whenever either q or k are bos or one.\n    #\n    # Then define W_new: V x V ->  st:\n    # W_new(one, bos) = 0.5, otherwise 0.\n    #\n    # Now set W_QK' = W_QK + W_new.\n    #\n    # To evaluate the attention to the BOS position:\n    # W_QK'(q, bos + one)\n    # = W_QK'(q, bos) + W_QK'(q, one)\n    # = W_QK(q, bos) + W_QK(q, one) + W_new(q, bos) + W_new(q, one)\n    # = 0            + 0            + W_new(q, bos) + W_new(q, one)\n    # = W_new(q, bos) + W_new(q, one)\n    # = W_new(q' + one, bos) + W_new(q' + one, one)  where q = one + q'\n    # = W_new(q', bos) + W_new(one, bos) + W_new(q', one) + W_new(one, one)\n    # = 0              + 0.5             + 0              + 0\n    # = 0.5\n    #\n    # To evaluate the attention to a non-BOS position:\n    # W_QK'(0 * bos + q, 0 * bos + k)  # s.t. q  Q+{one}, k  K+{one}\n    # = 0*W_QK'(bos, 0*bos + k) + W_QK'(q, 0*bos + k)\n    # = W_QK'(q, 0*bos + k)\n    # = 0*W_QK'(q, bos) + W_QK'(q, k)\n    # = W_QK'(q, k)\n    # = W_QK(q, k)    since W_QK' = W_QK on inputs not containing bos.\n    # = W_QK(q', k')  since W_QK(x, y) = 0 whenever x or y are one.\n    #\n    # Since W_QK(q, k) takes values in 0, 1, a sufficiently high softmax\n    # coldness will give us the desired property.                            QED\n    #\n    # The following implements this idea.\n    # By replacing 0.5 with 1, we can instead enforce a different property: that\n    # the BOS token is always attended to in addition to whatever else."
  },
  {
    "id": "141",
    "text": " typing import Optional\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\nfrom typing_extensions import Protocol\n\n\nclass QueryKeyToAttnLogit(Protocol):\n\n  def __call__(self, query: bases.BasisDirection,\n               key: bases.BasisDirection) -> bool:\n    pass\n\n\ndef categorical_attn(\n    query_space: bases.VectorSpaceWithBasis,\n    key_space: bases.VectorSpaceWithBasis,\n    value_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    bos_space: bases.VectorSpaceWithBasis,\n    one_space: bases.VectorSpaceWithBasis,\n    attn_fn: QueryKeyToAttnLogit,\n    default_output: Optional[bases.VectorInBasis] = None,\n    causal: bool = False,\n    always_attend_to_bos: bool = False,\n    use_bos_for_default_output: bool = True,\n    softmax_coldness: float = 100.,\n) -> transformers.AttentionHead:\n  \"\"\"Returns an attention head for categorical inputs.\n\n  Assumes the existence of a beginning of sequence token and attends to it\n  always with strength 0.5*softmax_coldness. This allows to implement an\n  arbitrary default value for rows in the attention pattern that are all-zero.\n\n  Attends to the BOS token if all other key-query pairs have zero attention.\n  Hence, the first value in the value sequence will be the default output for\n  such cases.\n\n  Args:\n    query_space: Vector space containing (categorical) query input.\n    key_space: Vector space containing (categorical) key input.\n    value_space: Vector space containing (numerical) value input.\n    output_space: Vector space which will contain (numerical) output.\n    bos_space: 1-d space used to identify the beginning of sequence token.\n    one_space: 1-d space which contains 1 at every position.\n    attn_fn: A selector function f(query, key) operating on the query/key basis\n      directions that defines the attention pattern.\n    default_output: Output to return if attention pattern is all zero.\n    causal: If True, use masked attention.\n    always_attend_to_bos: If True, always attend to the BOS token. If False,\n      only attend to BOS when attending to nothing else.\n    use_bos_for_default_output: If True, assume BOS is not in the value space\n      and output a default value when attending to BOS. If False, assume BOS is\n      in the value space, and map it to the output space like any other token.\n    softmax_coldness: The inverse temperature of the softmax. Default value is\n      high which makes the attention close to a hard maximum.\n  \"\"\"\n  bases.ensure_dims(bos_space, num_dims=1, name=\"bos_space\")\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n  bos_direction = bos_space.basis[0]\n  one_direction = one_space.basis[0]\n\n  # Add bos direction to query, key, and value spaces in case it is missing\n  query_space = bases.join_vector_spaces(query_space, bos_space, one_space)\n  key_space = bases.join_vector_spaces(key_space, bos_space)\n  value_space = bases.join_vector_spaces(value_space, bos_space)\n\n  if always_attend_to_bos:\n    value_basis = value_space.basis\n  else:\n    value_basis = [v for v in value_space.basis if v != bos_direction]\n  assert len(value_basis) == output_space.num_dims\n  value_to_output = dict(zip(value_basis, output_space.basis))\n\n  if default_output is None:\n    default_output = output_space.null_vector()\n  assert default_output in output_space\n\n  def qk_fun(query: bases.BasisDirection, key: bases.BasisDirection) -> float:\n\n    # We want to enforce the following property on our attention patterns:\n    # - if nothing else is attended to, attend to the BOS token.\n    # - otherwise, don't attend to the BOS token.\n    #\n    # We assume that the BOS position always only contains the vector bos + one,\n    # and that any other position has bos coefficient 0.\n    #\n    # We do this as follows:\n    # Let Q and K be subspaces of V containing the query and key vectors,\n    # both disjoint with the BOS space {bos} or the one space {one}.\n    # Suppose we have an attn_fn which defines a bilinear W_QK: V x V -> ,\n    # s.t. W_QK(q, k) = 0 whenever either q or k are bos or one.\n    #\n    # Then define W_new: V x V ->  st:\n    # W_new(one, bos) = 0.5, otherwise 0.\n    #\n    # Now set W_QK' = W_QK + W_new.\n    #\n    # To evaluate the attention to the BOS position:\n    # W_QK'(q, bos + one)\n    # = W_QK'(q, bos) + W_QK'(q, one)\n    # = W_QK(q, bos) + W_QK(q, one) + W_new(q, bos) + W_new(q, one)\n    # = 0            + 0            + W_new(q, bos) + W_new(q, one)\n    # = W_new(q, bos) + W_new(q, one)\n    # = W_new(q' + one, bos) + W_new(q' + one, one)  where q = one + q'\n    # = W_new(q', bos) + W_new(one, bos) + W_new(q', one) + W_new(one, one)\n    # = 0              + 0.5             + 0              + 0\n    # = 0.5\n    #\n    # To evaluate the attention to a non-BOS position:\n    # W_QK'(0 * bos + q, 0 * bos + k)  # s.t. q  Q+{one}, k  K+{one}\n    # = 0*W_QK'(bos, 0*bos + k) + W_QK'(q, 0*bos + k)\n    # = W_QK'(q, 0*bos + k)\n    # = 0*W_QK'(q, bos) + W_QK'(q, k)\n    # = W_QK'(q, k)\n    # = W_QK(q, k)    since W_QK' = W_QK on inputs not containing bos.\n    # = W_QK(q', k')  since W_QK(x, y) = 0 whenever x or y are one.\n    #\n    # Since W_QK(q, k) takes values in 0, 1, a sufficiently high softmax\n    # coldness will give us the desired property.                            QED\n    #\n    # The following implements this idea.\n    # By replacing 0.5 with 1, we can instead enforce a different property: that\n    # the BOS token is always attended to in addition to whatever else.\n\n    if key == bos_direction and query == one_direction:\n      c = 1. if always_attend_to_bos else 0.5\n      return c * softmax_coldness\n    elif {key, query}.intersection({one_direction, bos_direction}):\n      return 0\n\n    return softmax_coldness * attn_fn(query, key)\n\n  w_qk = vectorspace_fns.ScalarBilinear.from_action(\n      query_space,\n      key_space,\n      qk_fun,\n  )\n\n  def ov_fun(input_dir: bases.BasisDirection) -> bases.VectorInBasis:"
  },
  {
    "id": "142",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"MLPs to compute arbitrary numerical functions by discretising.\"\"\"\n\nimport dataclasses\n\nfrom typing import Callable, Iterable, List\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\nfrom tracr.utils import errors\n\n\n@dataclasses.dataclass\nclass DiscretisingLayerMaterials:\n  \"\"\"Provides components for a hidden layer that discretises the input.\n\n  Attributes:\n    action: Function acting on basis directions that defines the computation.\n    hidden_space: Vector space of the hidden representation of the layer.\n    output_values: Set of output values that correspond to the discretisation.\n  \"\"\"\n  action: Callable[[bases.BasisDirection], bases.VectorInBasis]\n  hidden_space: bases.VectorSpaceWithBasis\n  output_values: List[float]\n\n\ndef _get_discretising_layer(input_value_set: Iterable[float],\n                            f: Callable[[float],\n                                        float], hidden_name: bases.Name,\n                            one_direction: bases.BasisDirection,\n                            large_number: float) -> DiscretisingLayerMaterials:\n  \"\"\"Creates a hidden layer that discretises the input of f(x) into a value set.\n\n  The input is split up into a distinct region around each value in\n  `input_value_set`:\n\n  elements of value set:  v0   |  v1  |  v2  |  v3  |  v4  | ...\n  thresholds:                  t0     t1     t2     t3     t4\n\n  The hidden layer has two activations per threshold:\n    hidden_k_1 = ReLU(L * (x - threshold[k]) + 1)\n    hidden_k_2 = ReLU(L * (x - threshold[k]))\n\n  Note that hidden_k_1 - hidden_k_2 is:\n    1                 if x >= threshold[k] + 1/L\n    0                 if x <= threshold[k]\n    between 0 and 1   if threshold[k] < x < threshold[k] + 1/L\n\n  So as long as we choose L a big enough number, we have\n    hidden_k_1 - hidden_k_2 = 1 if x >= threshold[k].\n  i.e. we know in which region the input value is.\n\n  Args:\n    input_value_set: Set of discrete input values.\n    f: Function to approximate.\n    hidden_name: Name for hidden dimensions.\n    one_direction: Auxiliary dimension that must contain 1 in the input.\n    large_number: Large number L that determines accuracy of the computation.\n\n  Returns:\n    DiscretisingLayerMaterials containing all components for the layer.\n  \"\"\"\n  output_values, sorted_values = [], []\n  for x in sorted(input_value_set):\n    res = errors.ignoring_arithmetic_errors(f)(x)\n    if res is not None:\n      output_values.append(res)\n      sorted_values.append(x)\n\n  num_vals = len(sorted_values)\n  value_thresholds = [\n      (sorted_values[i] + sorted_values[i + 1]) / 2 for i in range(num_vals - 1)\n  ]\n\n  hidden_directions = [bases.BasisDirection(f\"{hidden_name}start\")]\n  for k in range(1, num_vals):\n    dir0 = bases.BasisDirection(hidden_name, (k, 0))\n    dir1 = bases.BasisDirection(hidden_name, (k, 1))\n    hidden_directions.extend([dir0, dir1])\n  hidden_space = bases.VectorSpaceWithBasis(hidden_directions)\n\n  def action(direction: bases.BasisDirection) -> bases.VectorInBasis:\n    # hidden_k_0 = ReLU(L * (x - threshold[k]) + 1)\n    # hidden_k_1 = ReLU(L * (x - threshold[k]))"
  },
  {
    "id": "143",
    "text": "                        float], hidden_name: bases.Name,\n                            one_direction: bases.BasisDirection,\n                            large_number: float) -> DiscretisingLayerMaterials:\n  \"\"\"Creates a hidden layer that discretises the input of f(x) into a value set.\n\n  The input is split up into a distinct region around each value in\n  `input_value_set`:\n\n  elements of value set:  v0   |  v1  |  v2  |  v3  |  v4  | ...\n  thresholds:                  t0     t1     t2     t3     t4\n\n  The hidden layer has two activations per threshold:\n    hidden_k_1 = ReLU(L * (x - threshold[k]) + 1)\n    hidden_k_2 = ReLU(L * (x - threshold[k]))\n\n  Note that hidden_k_1 - hidden_k_2 is:\n    1                 if x >= threshold[k] + 1/L\n    0                 if x <= threshold[k]\n    between 0 and 1   if threshold[k] < x < threshold[k] + 1/L\n\n  So as long as we choose L a big enough number, we have\n    hidden_k_1 - hidden_k_2 = 1 if x >= threshold[k].\n  i.e. we know in which region the input value is.\n\n  Args:\n    input_value_set: Set of discrete input values.\n    f: Function to approximate.\n    hidden_name: Name for hidden dimensions.\n    one_direction: Auxiliary dimension that must contain 1 in the input.\n    large_number: Large number L that determines accuracy of the computation.\n\n  Returns:\n    DiscretisingLayerMaterials containing all components for the layer.\n  \"\"\"\n  output_values, sorted_values = [], []\n  for x in sorted(input_value_set):\n    res = errors.ignoring_arithmetic_errors(f)(x)\n    if res is not None:\n      output_values.append(res)\n      sorted_values.append(x)\n\n  num_vals = len(sorted_values)\n  value_thresholds = [\n      (sorted_values[i] + sorted_values[i + 1]) / 2 for i in range(num_vals - 1)\n  ]\n\n  hidden_directions = [bases.BasisDirection(f\"{hidden_name}start\")]\n  for k in range(1, num_vals):\n    dir0 = bases.BasisDirection(hidden_name, (k, 0))\n    dir1 = bases.BasisDirection(hidden_name, (k, 1))\n    hidden_directions.extend([dir0, dir1])\n  hidden_space = bases.VectorSpaceWithBasis(hidden_directions)\n\n  def action(direction: bases.BasisDirection) -> bases.VectorInBasis:\n    # hidden_k_0 = ReLU(L * (x - threshold[k]) + 1)\n    # hidden_k_1 = ReLU(L * (x - threshold[k]))\n    if direction == one_direction:\n      hidden = hidden_space.vector_from_basis_direction(\n          bases.BasisDirection(f\"{hidden_name}start\"))\n    else:\n      hidden = hidden_space.null_vector()\n    for k in range(1, num_vals):\n      vec0 = hidden_space.vector_from_basis_direction(\n          bases.BasisDirection(hidden_name, (k, 0)))\n      vec1 = hidden_space.vector_from_basis_direction(\n          bases.BasisDirection(hidden_name, (k, 1)))\n      if direction == one_direction:\n        hidden += (1 - large_number * value_thresholds[k - 1]) * vec0\n        hidden -= large_number * value_thresholds[k - 1] * vec1\n      else:\n        hidden += large_number * vec0 + large_number * vec1\n    return hidden\n\n  return DiscretisingLayerMaterials(\n      action=action, hidden_space=hidden_space, output_values=output_values)\n\n\ndef map_numerical_mlp(\n    f: Callable[[float], float],\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    input_value_set: Iterable[float],\n    one_space: bases.VectorSpaceWithBasis,\n    large_number: float = 100,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes any function of a single variable f(x).\n\n  This is implemented by discretising the input according to input_value_set\n  and defining thresholds that determine which part of the input range will\n  is allocated to which value in input_value_set.\n\n  elements of value set:  v0   |  v1  |  v2  |  v3  |  v4  | ...\n  thresholds:                  t0     t1     t2     t3     t4\n\n  The MLP computes two hidden activations per threshold:\n    hidden_k_0 = ReLU(L * (x - threshold[k]) + 1)\n    hidden_k_1 = ReLU(L * (x - threshold[k]))\n\n  Note that hidden_k_1 - hidden_k_2 is:\n    1                 if x >= threshold[k] + 1/L\n    0                 if x <= threshold[k]\n    between 0 and 1   if threshold[k] < x < threshold[k] + 1/L\n\n  So as long as we choose L a big enough number, we have\n    hidden_k_0 - hidden_k_1 = 1 if x >= threshold[k].\n\n  The MLP then computes the output as:\n    output = f(input[0]) +\n      sum((hidden_k_0 - hidden_k_1) * (f(input[k]) - f(input[k-1]))\n        for all k=0,1,...)\n\n  This sum will be (by a telescoping sums argument)\n    f(input[0])      if x <= threshold[0]\n    f(input[k])      if threshold[k-1] < x <= threshold[k] for some other k\n    f(input[-1])     if x > threshold[-1]\n  which approximates f() up to an accuracy given by input_value_set and L.\n\n  Args:\n    f: Function to approximate.\n    input_space: 1-d vector space that encodes the input x.\n    output_space: 1-d vector space to write the output to.\n    input_value_set: Set of values the input can take.\n    one_space: Auxiliary 1-d vector space that must contain 1 in the input.\n    large_number: Large number L that determines accuracy of the computation.\n      Note that too large values of L can lead to numerical issues, particularly\n      during inference on GPU/TPU.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  bases.ensure_dims(input_space, num_dims=1, name=\"input_space\")\n  bases.ensure_dims(output_space, num_dims=1, name=\"output_space\")\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n\n  input_space = bases.join_vector_spaces(input_space, one_space)\n  out_vec = output_space.vector_from_basis_direction(output_space.basis[0])\n\n  discretising_layer = _get_discretising_layer(\n      input_value_set=input_value_set,\n      f=f,\n      hidden_name=hidden_name,\n      one_direction=one_space.basis[0],\n      large_number=large_number)\n  first_layer = vectorspace_fns.Linear.from_action(\n      input_space, discretising_layer.hidden_space, discretising_layer.action)\n\n  def second_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:\n    # output = sum(\n    #     (hidden_k_0 - hidden_k_1) * (f(input[k]) - f(input[k-1]))\n    #   for all k)"
  },
  {
    "id": "144",
    "text": " += (1 - large_number * value_thresholds[k - 1]) * vec0\n        hidden -= large_number * value_thresholds[k - 1] * vec1\n      else:\n        hidden += large_number * vec0 + large_number * vec1\n    return hidden\n\n  return DiscretisingLayerMaterials(\n      action=action, hidden_space=hidden_space, output_values=output_values)\n\n\ndef map_numerical_mlp(\n    f: Callable[[float], float],\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    input_value_set: Iterable[float],\n    one_space: bases.VectorSpaceWithBasis,\n    large_number: float = 100,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes any function of a single variable f(x).\n\n  This is implemented by discretising the input according to input_value_set\n  and defining thresholds that determine which part of the input range will\n  is allocated to which value in input_value_set.\n\n  elements of value set:  v0   |  v1  |  v2  |  v3  |  v4  | ...\n  thresholds:                  t0     t1     t2     t3     t4\n\n  The MLP computes two hidden activations per threshold:\n    hidden_k_0 = ReLU(L * (x - threshold[k]) + 1)\n    hidden_k_1 = ReLU(L * (x - threshold[k]))\n\n  Note that hidden_k_1 - hidden_k_2 is:\n    1                 if x >= threshold[k] + 1/L\n    0                 if x <= threshold[k]\n    between 0 and 1   if threshold[k] < x < threshold[k] + 1/L\n\n  So as long as we choose L a big enough number, we have\n    hidden_k_0 - hidden_k_1 = 1 if x >= threshold[k].\n\n  The MLP then computes the output as:\n    output = f(input[0]) +\n      sum((hidden_k_0 - hidden_k_1) * (f(input[k]) - f(input[k-1]))\n        for all k=0,1,...)\n\n  This sum will be (by a telescoping sums argument)\n    f(input[0])      if x <= threshold[0]\n    f(input[k])      if threshold[k-1] < x <= threshold[k] for some other k\n    f(input[-1])     if x > threshold[-1]\n  which approximates f() up to an accuracy given by input_value_set and L.\n\n  Args:\n    f: Function to approximate.\n    input_space: 1-d vector space that encodes the input x.\n    output_space: 1-d vector space to write the output to.\n    input_value_set: Set of values the input can take.\n    one_space: Auxiliary 1-d vector space that must contain 1 in the input.\n    large_number: Large number L that determines accuracy of the computation.\n      Note that too large values of L can lead to numerical issues, particularly\n      during inference on GPU/TPU.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  bases.ensure_dims(input_space, num_dims=1, name=\"input_space\")\n  bases.ensure_dims(output_space, num_dims=1, name=\"output_space\")\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n\n  input_space = bases.join_vector_spaces(input_space, one_space)\n  out_vec = output_space.vector_from_basis_direction(output_space.basis[0])\n\n  discretising_layer = _get_discretising_layer(\n      input_value_set=input_value_set,\n      f=f,\n      hidden_name=hidden_name,\n      one_direction=one_space.basis[0],\n      large_number=large_number)\n  first_layer = vectorspace_fns.Linear.from_action(\n      input_space, discretising_layer.hidden_space, discretising_layer.action)\n\n  def second_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:\n    # output = sum(\n    #     (hidden_k_0 - hidden_k_1) * (f(input[k]) - f(input[k-1]))\n    #   for all k)\n    if direction.name == f\"{hidden_name}start\":\n      return discretising_layer.output_values[0] * out_vec\n    k, i = direction.value\n    # add hidden_k_0 and subtract hidden_k_1\n    sign = {0: 1, 1: -1}[i]\n    return sign * (discretising_layer.output_values[k] -\n                   discretising_layer.output_values[k - 1]) * out_vec\n\n  second_layer = vectorspace_fns.Linear.from_action(\n      discretising_layer.hidden_space, output_space, second_layer_action)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef map_numerical_to_categorical_mlp(\n    f: Callable[[float], float],\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    input_value_set: Iterable[float],\n    one_space: bases.VectorSpaceWithBasis,\n    large_number: float = 100,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP to compute f(x) from a numerical to a categorical variable.\n\n  Uses a set of possible output values, and rounds f(x) to the closest value\n  in this set to create a categorical output variable.\n\n  The output is discretised the same way as in `map_numerical_mlp`.\n\n  Args:\n    f: Function to approximate.\n    input_space: 1-d vector space that encodes the input x.\n    output_space: n-d vector space to write categorical output to. The output\n      directions need to encode the possible output values.\n    input_value_set: Set of values the input can take.\n    one_space: Auxiliary 1-d space that must contain 1 in the input.\n    large_number: Large number L that determines accuracy of the computation.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  bases.ensure_dims(input_space, num_dims=1, name=\"input_space\")\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n\n  input_space = bases.join_vector_spaces(input_space, one_space)\n\n  vec_by_out_val = dict()\n  for d in output_space.basis:\n    # TODO(b/255937603): Do a similar assert in other places where we expect\n    # categorical basis directions to encode values.\n    assert d.value is not None, (\"output directions need to encode \"\n                                 \"possible output values\")\n    vec_by_out_val[d.value] = output_space.vector_from_basis_direction(d)\n\n  discretising_layer = _get_discretising_layer(\n      input_value_set=input_value_set,\n      f=f,\n      hidden_name=hidden_name,\n      one_direction=one_space.basis[0],\n      large_number=large_number)\n\n  assert set(discretising_layer.output_values).issubset(\n      set(vec_by_out_val.keys()))\n\n  first_layer = vectorspace_fns.Linear.from_action(\n      input_space, discretising_layer.hidden_space, discretising_layer.action)\n\n  def second_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:\n    \"\"\"Computes output value and returns corresponding output direction.\"\"\""
  },
  {
    "id": "145",
    "text": " contain 1 in the input.\n    large_number: Large number L that determines accuracy of the computation.\n      Note that too large values of L can lead to numerical issues, particularly\n      during inference on GPU/TPU.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  bases.ensure_dims(input_space, num_dims=1, name=\"input_space\")\n  bases.ensure_dims(output_space, num_dims=1, name=\"output_space\")\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n\n  input_space = bases.join_vector_spaces(input_space, one_space)\n  out_vec = output_space.vector_from_basis_direction(output_space.basis[0])\n\n  discretising_layer = _get_discretising_layer(\n      input_value_set=input_value_set,\n      f=f,\n      hidden_name=hidden_name,\n      one_direction=one_space.basis[0],\n      large_number=large_number)\n  first_layer = vectorspace_fns.Linear.from_action(\n      input_space, discretising_layer.hidden_space, discretising_layer.action)\n\n  def second_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:\n    # output = sum(\n    #     (hidden_k_0 - hidden_k_1) * (f(input[k]) - f(input[k-1]))\n    #   for all k)\n    if direction.name == f\"{hidden_name}start\":\n      return discretising_layer.output_values[0] * out_vec\n    k, i = direction.value\n    # add hidden_k_0 and subtract hidden_k_1\n    sign = {0: 1, 1: -1}[i]\n    return sign * (discretising_layer.output_values[k] -\n                   discretising_layer.output_values[k - 1]) * out_vec\n\n  second_layer = vectorspace_fns.Linear.from_action(\n      discretising_layer.hidden_space, output_space, second_layer_action)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef map_numerical_to_categorical_mlp(\n    f: Callable[[float], float],\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    input_value_set: Iterable[float],\n    one_space: bases.VectorSpaceWithBasis,\n    large_number: float = 100,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP to compute f(x) from a numerical to a categorical variable.\n\n  Uses a set of possible output values, and rounds f(x) to the closest value\n  in this set to create a categorical output variable.\n\n  The output is discretised the same way as in `map_numerical_mlp`.\n\n  Args:\n    f: Function to approximate.\n    input_space: 1-d vector space that encodes the input x.\n    output_space: n-d vector space to write categorical output to. The output\n      directions need to encode the possible output values.\n    input_value_set: Set of values the input can take.\n    one_space: Auxiliary 1-d space that must contain 1 in the input.\n    large_number: Large number L that determines accuracy of the computation.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  bases.ensure_dims(input_space, num_dims=1, name=\"input_space\")\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n\n  input_space = bases.join_vector_spaces(input_space, one_space)\n\n  vec_by_out_val = dict()\n  for d in output_space.basis:\n    # TODO(b/255937603): Do a similar assert in other places where we expect\n    # categorical basis directions to encode values.\n    assert d.value is not None, (\"output directions need to encode \"\n                                 \"possible output values\")\n    vec_by_out_val[d.value] = output_space.vector_from_basis_direction(d)\n\n  discretising_layer = _get_discretising_layer(\n      input_value_set=input_value_set,\n      f=f,\n      hidden_name=hidden_name,\n      one_direction=one_space.basis[0],\n      large_number=large_number)\n\n  assert set(discretising_layer.output_values).issubset(\n      set(vec_by_out_val.keys()))\n\n  first_layer = vectorspace_fns.Linear.from_action(\n      input_space, discretising_layer.hidden_space, discretising_layer.action)\n\n  def second_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:\n    \"\"\"Computes output value and returns corresponding output direction.\"\"\"\n    if direction.name == f\"{hidden_name}start\":\n      return vec_by_out_val[discretising_layer.output_values[0]]\n    else:\n      k, i = direction.value\n      # add hidden_k_0 and subtract hidden_k_1\n      sign = {0: 1, 1: -1}[i]\n      out_k = discretising_layer.output_values[k]\n      out_k_m_1 = discretising_layer.output_values[k - 1]\n      return sign * (vec_by_out_val[out_k] - vec_by_out_val[out_k_m_1])\n\n  second_layer = vectorspace_fns.Linear.from_action(\n      discretising_layer.hidden_space, output_space, second_layer_action)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef linear_sequence_map_numerical_mlp(\n    input1_basis_direction: bases.BasisDirection,\n    input2_basis_direction: bases.BasisDirection,\n    output_basis_direction: bases.BasisDirection,\n    input1_factor: float,\n    input2_factor: float,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes a linear function f(x, y) = a*x + b*y.\n\n  Args:\n    input1_basis_direction: Basis direction that encodes the input x.\n    input2_basis_direction: Basis direction that encodes the input y.\n    output_basis_direction: Basis direction to write the output to.\n    input1_factor: Linear factor a for input x.\n    input2_factor: Linear factor a for input y.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  input_space = bases.VectorSpaceWithBasis(\n      [input1_basis_direction, input2_basis_direction])\n  output_space = bases.VectorSpaceWithBasis([output_basis_direction])\n  out_vec = output_space.vector_from_basis_direction(output_basis_direction)\n\n  hidden_directions = [\n      bases.BasisDirection(f\"{hidden_name}x\", 1),\n      bases.BasisDirection(f\"{hidden_name}x\", -1),\n      bases.BasisDirection(f\"{hidden_name}y\", 1),\n      bases.BasisDirection(f\"{hidden_name}y\", -1)\n  ]\n  hidden_space = bases.VectorSpaceWithBasis(hidden_directions)\n  x_pos_vec, x_neg_vec, y_pos_vec, y_neg_vec = (\n      hidden_space.vector_from_basis_direction(d) for d in hidden_directions)\n\n  def first_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:"
  },
  {
    "id": "146",
    "text": " name=\"one_space\")\n\n  input_space = bases.join_vector_spaces(input_space, one_space)\n  out_vec = output_space.vector_from_basis_direction(output_space.basis[0])\n\n  discretising_layer = _get_discretising_layer(\n      input_value_set=input_value_set,\n      f=f,\n      hidden_name=hidden_name,\n      one_direction=one_space.basis[0],\n      large_number=large_number)\n  first_layer = vectorspace_fns.Linear.from_action(\n      input_space, discretising_layer.hidden_space, discretising_layer.action)\n\n  def second_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:\n    # output = sum(\n    #     (hidden_k_0 - hidden_k_1) * (f(input[k]) - f(input[k-1]))\n    #   for all k)\n    if direction.name == f\"{hidden_name}start\":\n      return discretising_layer.output_values[0] * out_vec\n    k, i = direction.value\n    # add hidden_k_0 and subtract hidden_k_1\n    sign = {0: 1, 1: -1}[i]\n    return sign * (discretising_layer.output_values[k] -\n                   discretising_layer.output_values[k - 1]) * out_vec\n\n  second_layer = vectorspace_fns.Linear.from_action(\n      discretising_layer.hidden_space, output_space, second_layer_action)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef map_numerical_to_categorical_mlp(\n    f: Callable[[float], float],\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    input_value_set: Iterable[float],\n    one_space: bases.VectorSpaceWithBasis,\n    large_number: float = 100,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP to compute f(x) from a numerical to a categorical variable.\n\n  Uses a set of possible output values, and rounds f(x) to the closest value\n  in this set to create a categorical output variable.\n\n  The output is discretised the same way as in `map_numerical_mlp`.\n\n  Args:\n    f: Function to approximate.\n    input_space: 1-d vector space that encodes the input x.\n    output_space: n-d vector space to write categorical output to. The output\n      directions need to encode the possible output values.\n    input_value_set: Set of values the input can take.\n    one_space: Auxiliary 1-d space that must contain 1 in the input.\n    large_number: Large number L that determines accuracy of the computation.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  bases.ensure_dims(input_space, num_dims=1, name=\"input_space\")\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n\n  input_space = bases.join_vector_spaces(input_space, one_space)\n\n  vec_by_out_val = dict()\n  for d in output_space.basis:\n    # TODO(b/255937603): Do a similar assert in other places where we expect\n    # categorical basis directions to encode values.\n    assert d.value is not None, (\"output directions need to encode \"\n                                 \"possible output values\")\n    vec_by_out_val[d.value] = output_space.vector_from_basis_direction(d)\n\n  discretising_layer = _get_discretising_layer(\n      input_value_set=input_value_set,\n      f=f,\n      hidden_name=hidden_name,\n      one_direction=one_space.basis[0],\n      large_number=large_number)\n\n  assert set(discretising_layer.output_values).issubset(\n      set(vec_by_out_val.keys()))\n\n  first_layer = vectorspace_fns.Linear.from_action(\n      input_space, discretising_layer.hidden_space, discretising_layer.action)\n\n  def second_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:\n    \"\"\"Computes output value and returns corresponding output direction.\"\"\"\n    if direction.name == f\"{hidden_name}start\":\n      return vec_by_out_val[discretising_layer.output_values[0]]\n    else:\n      k, i = direction.value\n      # add hidden_k_0 and subtract hidden_k_1\n      sign = {0: 1, 1: -1}[i]\n      out_k = discretising_layer.output_values[k]\n      out_k_m_1 = discretising_layer.output_values[k - 1]\n      return sign * (vec_by_out_val[out_k] - vec_by_out_val[out_k_m_1])\n\n  second_layer = vectorspace_fns.Linear.from_action(\n      discretising_layer.hidden_space, output_space, second_layer_action)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef linear_sequence_map_numerical_mlp(\n    input1_basis_direction: bases.BasisDirection,\n    input2_basis_direction: bases.BasisDirection,\n    output_basis_direction: bases.BasisDirection,\n    input1_factor: float,\n    input2_factor: float,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes a linear function f(x, y) = a*x + b*y.\n\n  Args:\n    input1_basis_direction: Basis direction that encodes the input x.\n    input2_basis_direction: Basis direction that encodes the input y.\n    output_basis_direction: Basis direction to write the output to.\n    input1_factor: Linear factor a for input x.\n    input2_factor: Linear factor a for input y.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  input_space = bases.VectorSpaceWithBasis(\n      [input1_basis_direction, input2_basis_direction])\n  output_space = bases.VectorSpaceWithBasis([output_basis_direction])\n  out_vec = output_space.vector_from_basis_direction(output_basis_direction)\n\n  hidden_directions = [\n      bases.BasisDirection(f\"{hidden_name}x\", 1),\n      bases.BasisDirection(f\"{hidden_name}x\", -1),\n      bases.BasisDirection(f\"{hidden_name}y\", 1),\n      bases.BasisDirection(f\"{hidden_name}y\", -1)\n  ]\n  hidden_space = bases.VectorSpaceWithBasis(hidden_directions)\n  x_pos_vec, x_neg_vec, y_pos_vec, y_neg_vec = (\n      hidden_space.vector_from_basis_direction(d) for d in hidden_directions)\n\n  def first_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:\n    output = hidden_space.null_vector()\n    if direction == input1_basis_direction:\n      output += x_pos_vec - x_neg_vec\n    if direction == input2_basis_direction:\n      output += y_pos_vec - y_neg_vec\n    return output\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, hidden_space,\n                                                   first_layer_action)\n\n  def second_layer_action(\n      direction: bases.BasisDirection) -> bases.VectorInBasis:"
  },
  {
    "id": "147",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for chamber.categorical_attn.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport numpy as np\nfrom tracr.craft import bases\nfrom tracr.craft import tests_common\nfrom tracr.craft.chamber import categorical_attn\n\n\nclass CategoricalAttnTest(tests_common.VectorFnTestCase):\n\n  @parameterized.parameters([\n      dict(causal=False, input_seq=[1, 2, 3, 4, 5], result_seq=[3, 3, 3, 3, 3]),\n      dict(\n          causal=True,\n          input_seq=[1, 2, 3, 4, 5],\n          result_seq=[1, 1.5, 2, 2.5, 3]),\n      dict(causal=False, input_seq=[10], result_seq=[10]),\n      dict(causal=True, input_seq=[10], result_seq=[10]),\n      dict(causal=False, input_seq=[-1, 0, 1], result_seq=[0, 0, 0]),\n      dict(causal=True, input_seq=[-1, 0, 1], result_seq=[-1, -0.5, 0]),\n  ])\n  def test_categorical_attn_can_implement_select_all(self, causal, input_seq,\n                                                     result_seq):\n    vocab = range(-20, 20)\n    input_space = bases.VectorSpaceWithBasis.from_values(\"input\", vocab)\n\n    output_dir = bases.BasisDirection(\"output\")\n    output_space = bases.VectorSpaceWithBasis([output_dir])\n    output_vec = output_space.vector_from_basis_direction(output_dir)\n\n    bos_dir = bases.BasisDirection(\"bos_dimension\")\n    bos_space = bases.VectorSpaceWithBasis([bos_dir])\n\n    one_dir = bases.BasisDirection(\"one\")\n    one_space = bases.VectorSpaceWithBasis([one_dir])\n\n    value_dir = bases.BasisDirection(\"value\")\n    value_space = bases.VectorSpaceWithBasis([value_dir])\n\n    input_space = bases.join_vector_spaces(input_space, bos_space, one_space)\n    value_space = bases.join_vector_spaces(value_space, bos_space)\n    residual_space = bases.join_vector_spaces(input_space, value_space,\n                                              output_space)\n    one_vec = residual_space.vector_from_basis_direction(one_dir)\n    bos_vec = residual_space.vector_from_basis_direction(bos_dir)\n    value_vec = residual_space.vector_from_basis_direction(value_dir)\n\n    attn = categorical_attn.categorical_attn(\n        key_space=input_space,\n        query_space=input_space,\n        value_space=value_space,\n        output_space=output_space,\n        bos_space=bos_space,\n        one_space=one_space,\n        attn_fn=lambda x, y: True,\n        causal=causal)\n\n    test_inputs = [bos_vec + one_vec]\n    for x in input_seq:\n      test_inputs.append(\n          residual_space.vector_from_basis_direction(\n              bases.BasisDirection(\"input\", x)) + x * value_vec)\n    test_inputs = bases.VectorInBasis.stack(test_inputs)\n\n    # Expect the average of all (previous) tokens\n    expected_results = [x * output_vec for x in result_seq]\n    expected_results = bases.VectorInBasis.stack(expected_results)\n\n    test_outputs = attn.apply(test_inputs).project(output_space)\n\n    self.assertVectorAllClose(\n        tests_common.strip_bos_token(test_outputs), expected_results)\n\n  @parameterized.parameters([\n      dict(causal=False, input_seq=[1, 2, 3, 4, 5], default=0),\n      dict(causal=True, input_seq=[1, 2, 3, 4, 5], default=1),\n      dict(causal=False, input_seq=[10], default=2),\n      dict(causal=True, input_seq=[10], default=-3),\n      dict(causal=False, input_seq=[-1, 0, 1], default=-2),\n      dict(causal=True, input_seq=[-1, 0, 1], default=-1),\n  ])\n  def test_categorical_attn_can_implement_select_none(self, causal, input_seq,\n                                                      default):\n    vocab = range(-20, 20)\n    input_space = bases.VectorSpaceWithBasis.from_values(\"input\", vocab)\n\n    output_dir = bases.BasisDirection(\"output\")\n    output_space = bases.VectorSpaceWithBasis([output_dir])\n    default_vec = default * output_space.vector_from_basis_direction(output_dir)\n\n    bos_dir = bases.BasisDirection(\"bos_dimension\")\n    bos_space = bases.VectorSpaceWithBasis([bos_dir])\n\n    one_dir = bases.BasisDirection(\"one\")\n    one_space = bases.VectorSpaceWithBasis([one_dir])\n\n    value_dir = bases.BasisDirection(\"value\")\n    value_space = bases.VectorSpaceWithBasis([value_dir])\n\n    input_space = bases.join_vector_spaces(input_space, bos_space, one_space)\n    value_space = bases.join_vector_spaces(value_space, bos_space)\n    residual_space = bases.join_vector_spaces(input_space, value_space,\n                                              output_space)\n    value_vec = residual_space.vector_from_basis_direction(value_dir)\n    bos_vec = residual_space.vector_from_basis_direction(bos_dir)\n    one_vec = residual_space.vector_from_basis_direction(one_dir)\n\n    attn = categorical_attn.categorical_attn(\n        key_space=input_space,\n        query_space=input_space,\n        value_space=value_space,\n        output_space=output_space,\n        bos_space=bos_space,\n        one_space=one_space,\n        attn_fn=lambda x, y: False,\n        default_output=default_vec,\n        causal=causal,\n        always_attend_to_bos=False,\n        use_bos_for_default_output=True)\n\n    def make_input(x):"
  },
  {
    "id": "148",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"MLP to compute basic linear functions of one-hot encoded integers.\"\"\"\n\nfrom typing import Callable\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\n\n_ONE_SPACE = bases.VectorSpaceWithBasis.from_names([\"one\"])\n\n\ndef map_categorical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection], bases.BasisDirection],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes any categorical function of a single variable f(x).\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output_k = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: space containing the input x.\n    output_space: space containing possible outputs.\n    operation: A function operating on basis directions.\n  \"\"\""
  },
  {
    "id": "149",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"MLP to compute basic linear functions of one-hot encoded integers.\"\"\"\n\nfrom typing import Callable\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\n\n_ONE_SPACE = bases.VectorSpaceWithBasis.from_names([\"one\"])\n\n\ndef map_categorical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection], bases.BasisDirection],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes any categorical function of a single variable f(x).\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output_k = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: space containing the input x.\n    output_space: space containing possible outputs.\n    operation: A function operating on basis directions.\n  \"\"\"\n\n  def operation_fn(direction):"
  },
  {
    "id": "150",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"MLP to compute basic linear functions of one-hot encoded integers.\"\"\"\n\nfrom typing import Callable\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\n\n_ONE_SPACE = bases.VectorSpaceWithBasis.from_names([\"one\"])\n\n\ndef map_categorical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection], bases.BasisDirection],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes any categorical function of a single variable f(x).\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output_k = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: space containing the input x.\n    output_space: space containing possible outputs.\n    operation: A function operating on basis directions.\n  \"\"\"\n\n  def operation_fn(direction):\n    if direction in input_space:\n      output_direction = operation(direction)\n      if output_direction in output_space:\n        return output_space.vector_from_basis_direction(output_direction)\n    return output_space.null_vector()\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, output_space,\n                                                   operation_fn)\n\n  second_layer = vectorspace_fns.project(output_space, output_space)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef map_categorical_to_numerical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.Value], float],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP to compute f(x) from a categorical to a numerical variable.\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: Vector space containing the input x.\n    output_space: Vector space to write the numerical output to.\n    operation: A function operating on basis directions.\n  \"\"\""
  },
  {
    "id": "151",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"MLP to compute basic linear functions of one-hot encoded integers.\"\"\"\n\nfrom typing import Callable\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\n\n_ONE_SPACE = bases.VectorSpaceWithBasis.from_names([\"one\"])\n\n\ndef map_categorical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection], bases.BasisDirection],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes any categorical function of a single variable f(x).\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output_k = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: space containing the input x.\n    output_space: space containing possible outputs.\n    operation: A function operating on basis directions.\n  \"\"\"\n\n  def operation_fn(direction):\n    if direction in input_space:\n      output_direction = operation(direction)\n      if output_direction in output_space:\n        return output_space.vector_from_basis_direction(output_direction)\n    return output_space.null_vector()\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, output_space,\n                                                   operation_fn)\n\n  second_layer = vectorspace_fns.project(output_space, output_space)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef map_categorical_to_numerical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.Value], float],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP to compute f(x) from a categorical to a numerical variable.\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: Vector space containing the input x.\n    output_space: Vector space to write the numerical output to.\n    operation: A function operating on basis directions.\n  \"\"\"\n  bases.ensure_dims(output_space, num_dims=1, name=\"output_space\")\n  out_vec = output_space.vector_from_basis_direction(output_space.basis[0])\n\n  def operation_fn(direction):"
  },
  {
    "id": "152",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"MLP to compute basic linear functions of one-hot encoded integers.\"\"\"\n\nfrom typing import Callable\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\n\n_ONE_SPACE = bases.VectorSpaceWithBasis.from_names([\"one\"])\n\n\ndef map_categorical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection], bases.BasisDirection],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes any categorical function of a single variable f(x).\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output_k = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: space containing the input x.\n    output_space: space containing possible outputs.\n    operation: A function operating on basis directions.\n  \"\"\"\n\n  def operation_fn(direction):\n    if direction in input_space:\n      output_direction = operation(direction)\n      if output_direction in output_space:\n        return output_space.vector_from_basis_direction(output_direction)\n    return output_space.null_vector()\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, output_space,\n                                                   operation_fn)\n\n  second_layer = vectorspace_fns.project(output_space, output_space)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef map_categorical_to_numerical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.Value], float],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP to compute f(x) from a categorical to a numerical variable.\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: Vector space containing the input x.\n    output_space: Vector space to write the numerical output to.\n    operation: A function operating on basis directions.\n  \"\"\"\n  bases.ensure_dims(output_space, num_dims=1, name=\"output_space\")\n  out_vec = output_space.vector_from_basis_direction(output_space.basis[0])\n\n  def operation_fn(direction):\n    if direction in input_space:\n      return operation(direction.value) * out_vec\n    return output_space.null_vector()\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, output_space,\n                                                   operation_fn)\n\n  second_layer = vectorspace_fns.project(output_space, output_space)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef sequence_map_categorical_mlp(\n    input1_space: bases.VectorSpaceWithBasis,\n    input2_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection, bases.BasisDirection],\n                        bases.BasisDirection],\n    one_space: bases.VectorSpaceWithBasis = _ONE_SPACE,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes a categorical function of two variables f(x, y).\n\n  The hidden layer of the MLP computes the logical and of all input directions\n    hidden_i_j = ReLU(x_i+x_j-1)\n\n  And the output combines this with a lookup table\n    output_k = sum(f(i, j)*hidden_i_j for all i,j in input space)\n\n  Args:\n    input1_space: Vector space containing the input x.\n    input2_space: Vector space containing the input y.\n    output_space: Vector space to write outputs to.\n    operation: A function operating on basis directions.\n    one_space: a reserved 1-d space that always contains a 1.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n\n  if not set(input1_space.basis).isdisjoint(input2_space.basis):\n    raise ValueError(\"Input spaces to a SequenceMap must be disjoint. \"\n                     \"If input spaces are the same, use Map instead!\")\n\n  input_space = bases.direct_sum(input1_space, input2_space, one_space)\n\n  def to_hidden(x, y):\n    return bases.BasisDirection(hidden_name, (x.name, x.value, y.name, y.value))\n\n  def from_hidden(h):"
  },
  {
    "id": "153",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"MLP to compute basic linear functions of one-hot encoded integers.\"\"\"\n\nfrom typing import Callable\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\n\n_ONE_SPACE = bases.VectorSpaceWithBasis.from_names([\"one\"])\n\n\ndef map_categorical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection], bases.BasisDirection],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes any categorical function of a single variable f(x).\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output_k = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: space containing the input x.\n    output_space: space containing possible outputs.\n    operation: A function operating on basis directions.\n  \"\"\"\n\n  def operation_fn(direction):\n    if direction in input_space:\n      output_direction = operation(direction)\n      if output_direction in output_space:\n        return output_space.vector_from_basis_direction(output_direction)\n    return output_space.null_vector()\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, output_space,\n                                                   operation_fn)\n\n  second_layer = vectorspace_fns.project(output_space, output_space)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef map_categorical_to_numerical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.Value], float],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP to compute f(x) from a categorical to a numerical variable.\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: Vector space containing the input x.\n    output_space: Vector space to write the numerical output to.\n    operation: A function operating on basis directions.\n  \"\"\"\n  bases.ensure_dims(output_space, num_dims=1, name=\"output_space\")\n  out_vec = output_space.vector_from_basis_direction(output_space.basis[0])\n\n  def operation_fn(direction):\n    if direction in input_space:\n      return operation(direction.value) * out_vec\n    return output_space.null_vector()\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, output_space,\n                                                   operation_fn)\n\n  second_layer = vectorspace_fns.project(output_space, output_space)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef sequence_map_categorical_mlp(\n    input1_space: bases.VectorSpaceWithBasis,\n    input2_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection, bases.BasisDirection],\n                        bases.BasisDirection],\n    one_space: bases.VectorSpaceWithBasis = _ONE_SPACE,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes a categorical function of two variables f(x, y).\n\n  The hidden layer of the MLP computes the logical and of all input directions\n    hidden_i_j = ReLU(x_i+x_j-1)\n\n  And the output combines this with a lookup table\n    output_k = sum(f(i, j)*hidden_i_j for all i,j in input space)\n\n  Args:\n    input1_space: Vector space containing the input x.\n    input2_space: Vector space containing the input y.\n    output_space: Vector space to write outputs to.\n    operation: A function operating on basis directions.\n    one_space: a reserved 1-d space that always contains a 1.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n\n  if not set(input1_space.basis).isdisjoint(input2_space.basis):\n    raise ValueError(\"Input spaces to a SequenceMap must be disjoint. \"\n                     \"If input spaces are the same, use Map instead!\")\n\n  input_space = bases.direct_sum(input1_space, input2_space, one_space)\n\n  def to_hidden(x, y):\n    return bases.BasisDirection(hidden_name, (x.name, x.value, y.name, y.value))\n\n  def from_hidden(h):\n    x_name, x_value, y_name, y_value = h.value\n    x_dir = bases.BasisDirection(x_name, x_value)\n    y_dir = bases.BasisDirection(y_name, y_value)\n    return x_dir, y_dir\n\n  hidden_dir = []\n  for dir1 in input1_space.basis:\n    for dir2 in input2_space.basis:\n      hidden_dir.append(to_hidden(dir1, dir2))\n  hidden_space = bases.VectorSpaceWithBasis(hidden_dir)\n\n  def logical_and(direction):"
  },
  {
    "id": "154",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"MLP to compute basic linear functions of one-hot encoded integers.\"\"\"\n\nfrom typing import Callable\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import transformers\nfrom tracr.craft import vectorspace_fns\n\n_ONE_SPACE = bases.VectorSpaceWithBasis.from_names([\"one\"])\n\n\ndef map_categorical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection], bases.BasisDirection],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes any categorical function of a single variable f(x).\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output_k = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: space containing the input x.\n    output_space: space containing possible outputs.\n    operation: A function operating on basis directions.\n  \"\"\"\n\n  def operation_fn(direction):\n    if direction in input_space:\n      output_direction = operation(direction)\n      if output_direction in output_space:\n        return output_space.vector_from_basis_direction(output_direction)\n    return output_space.null_vector()\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, output_space,\n                                                   operation_fn)\n\n  second_layer = vectorspace_fns.project(output_space, output_space)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef map_categorical_to_numerical_mlp(\n    input_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.Value], float],\n) -> transformers.MLP:\n  \"\"\"Returns an MLP to compute f(x) from a categorical to a numerical variable.\n\n  The hidden layer is the identity and output combines this with a lookup table\n    output = sum(f(i)*input_i for all i in input space)\n\n  Args:\n    input_space: Vector space containing the input x.\n    output_space: Vector space to write the numerical output to.\n    operation: A function operating on basis directions.\n  \"\"\"\n  bases.ensure_dims(output_space, num_dims=1, name=\"output_space\")\n  out_vec = output_space.vector_from_basis_direction(output_space.basis[0])\n\n  def operation_fn(direction):\n    if direction in input_space:\n      return operation(direction.value) * out_vec\n    return output_space.null_vector()\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, output_space,\n                                                   operation_fn)\n\n  second_layer = vectorspace_fns.project(output_space, output_space)\n\n  return transformers.MLP(first_layer, second_layer)\n\n\ndef sequence_map_categorical_mlp(\n    input1_space: bases.VectorSpaceWithBasis,\n    input2_space: bases.VectorSpaceWithBasis,\n    output_space: bases.VectorSpaceWithBasis,\n    operation: Callable[[bases.BasisDirection, bases.BasisDirection],\n                        bases.BasisDirection],\n    one_space: bases.VectorSpaceWithBasis = _ONE_SPACE,\n    hidden_name: bases.Name = \"__hidden__\",\n) -> transformers.MLP:\n  \"\"\"Returns an MLP that encodes a categorical function of two variables f(x, y).\n\n  The hidden layer of the MLP computes the logical and of all input directions\n    hidden_i_j = ReLU(x_i+x_j-1)\n\n  And the output combines this with a lookup table\n    output_k = sum(f(i, j)*hidden_i_j for all i,j in input space)\n\n  Args:\n    input1_space: Vector space containing the input x.\n    input2_space: Vector space containing the input y.\n    output_space: Vector space to write outputs to.\n    operation: A function operating on basis directions.\n    one_space: a reserved 1-d space that always contains a 1.\n    hidden_name: Name for hidden dimensions.\n  \"\"\"\n  bases.ensure_dims(one_space, num_dims=1, name=\"one_space\")\n\n  if not set(input1_space.basis).isdisjoint(input2_space.basis):\n    raise ValueError(\"Input spaces to a SequenceMap must be disjoint. \"\n                     \"If input spaces are the same, use Map instead!\")\n\n  input_space = bases.direct_sum(input1_space, input2_space, one_space)\n\n  def to_hidden(x, y):\n    return bases.BasisDirection(hidden_name, (x.name, x.value, y.name, y.value))\n\n  def from_hidden(h):\n    x_name, x_value, y_name, y_value = h.value\n    x_dir = bases.BasisDirection(x_name, x_value)\n    y_dir = bases.BasisDirection(y_name, y_value)\n    return x_dir, y_dir\n\n  hidden_dir = []\n  for dir1 in input1_space.basis:\n    for dir2 in input2_space.basis:\n      hidden_dir.append(to_hidden(dir1, dir2))\n  hidden_space = bases.VectorSpaceWithBasis(hidden_dir)\n\n  def logical_and(direction):\n    if direction in one_space:\n      out = bases.VectorInBasis(hidden_space.basis,\n                                -np.ones(hidden_space.num_dims))\n    elif direction in input1_space:\n      dir1 = direction\n      out = hidden_space.null_vector()\n      for dir2 in input2_space.basis:\n        out += hidden_space.vector_from_basis_direction(to_hidden(dir1, dir2))\n    else:\n      dir2 = direction\n      out = hidden_space.null_vector()\n      for dir1 in input1_space.basis:\n        out += hidden_space.vector_from_basis_direction(to_hidden(dir1, dir2))\n    return out\n\n  first_layer = vectorspace_fns.Linear.from_action(input_space, hidden_space,\n                                                   logical_and)\n\n  def operation_fn(direction):"
  },
  {
    "id": "155",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\""
  },
  {
    "id": "156",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\"\n    self.input_space = input_space\n    self.output_space = output_space\n    self.matrix = matrix\n\n  def __post_init__(self) -> None:\n    output_size, input_size = self.matrix.shape\n    assert input_size == self.input_space.num_dims\n    assert output_size == self.output_space.num_dims\n\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:"
  },
  {
    "id": "157",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\"\n    self.input_space = input_space\n    self.output_space = output_space\n    self.matrix = matrix\n\n  def __post_init__(self) -> None:\n    output_size, input_size = self.matrix.shape\n    assert input_size == self.input_space.num_dims\n    assert output_size == self.output_space.num_dims\n\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    if x not in self.input_space:\n      raise TypeError(f\"x={x} not in self.input_space={self.input_space}.\")\n    return VectorInBasis(\n        basis_directions=sorted(self.output_space.basis),\n        magnitudes=x.magnitudes @ self.matrix,\n    )\n\n  @classmethod\n  def from_action(\n      cls,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      action: Callable[[BasisDirection], VectorInBasis],\n  ) -> \"Linear\":\n    \"\"\"from_action(i, o)(action) creates a Linear.\"\"\""
  },
  {
    "id": "158",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\"\n    self.input_space = input_space\n    self.output_space = output_space\n    self.matrix = matrix\n\n  def __post_init__(self) -> None:\n    output_size, input_size = self.matrix.shape\n    assert input_size == self.input_space.num_dims\n    assert output_size == self.output_space.num_dims\n\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    if x not in self.input_space:\n      raise TypeError(f\"x={x} not in self.input_space={self.input_space}.\")\n    return VectorInBasis(\n        basis_directions=sorted(self.output_space.basis),\n        magnitudes=x.magnitudes @ self.matrix,\n    )\n\n  @classmethod\n  def from_action(\n      cls,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      action: Callable[[BasisDirection], VectorInBasis],\n  ) -> \"Linear\":\n    \"\"\"from_action(i, o)(action) creates a Linear.\"\"\"\n\n    matrix = np.zeros((input_space.num_dims, output_space.num_dims))\n    for i, direction in enumerate(input_space.basis):\n      out_vector = action(direction)\n      if out_vector not in output_space:\n        raise TypeError(f\"image of {direction} from input_space={input_space} \"\n                        f\"is not in output_space={output_space}\")\n      matrix[i, :] = out_vector.magnitudes\n\n    return Linear(input_space, output_space, matrix)\n\n  @classmethod\n  def combine_in_parallel(cls, fns: Sequence[\"Linear\"]) -> \"Linear\":\n    \"\"\"Combines multiple parallel linear functions into a single one.\"\"\""
  },
  {
    "id": "159",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\"\n    self.input_space = input_space\n    self.output_space = output_space\n    self.matrix = matrix\n\n  def __post_init__(self) -> None:\n    output_size, input_size = self.matrix.shape\n    assert input_size == self.input_space.num_dims\n    assert output_size == self.output_space.num_dims\n\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    if x not in self.input_space:\n      raise TypeError(f\"x={x} not in self.input_space={self.input_space}.\")\n    return VectorInBasis(\n        basis_directions=sorted(self.output_space.basis),\n        magnitudes=x.magnitudes @ self.matrix,\n    )\n\n  @classmethod\n  def from_action(\n      cls,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      action: Callable[[BasisDirection], VectorInBasis],\n  ) -> \"Linear\":\n    \"\"\"from_action(i, o)(action) creates a Linear.\"\"\"\n\n    matrix = np.zeros((input_space.num_dims, output_space.num_dims))\n    for i, direction in enumerate(input_space.basis):\n      out_vector = action(direction)\n      if out_vector not in output_space:\n        raise TypeError(f\"image of {direction} from input_space={input_space} \"\n                        f\"is not in output_space={output_space}\")\n      matrix[i, :] = out_vector.magnitudes\n\n    return Linear(input_space, output_space, matrix)\n\n  @classmethod\n  def combine_in_parallel(cls, fns: Sequence[\"Linear\"]) -> \"Linear\":\n    \"\"\"Combines multiple parallel linear functions into a single one.\"\"\"\n    joint_input_space = bases.join_vector_spaces(\n        *[fn.input_space for fn in fns])\n    joint_output_space = bases.join_vector_spaces(\n        *[fn.output_space for fn in fns])\n\n    def action(x: bases.BasisDirection) -> bases.VectorInBasis:"
  },
  {
    "id": "160",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\"\n    self.input_space = input_space\n    self.output_space = output_space\n    self.matrix = matrix\n\n  def __post_init__(self) -> None:\n    output_size, input_size = self.matrix.shape\n    assert input_size == self.input_space.num_dims\n    assert output_size == self.output_space.num_dims\n\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    if x not in self.input_space:\n      raise TypeError(f\"x={x} not in self.input_space={self.input_space}.\")\n    return VectorInBasis(\n        basis_directions=sorted(self.output_space.basis),\n        magnitudes=x.magnitudes @ self.matrix,\n    )\n\n  @classmethod\n  def from_action(\n      cls,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      action: Callable[[BasisDirection], VectorInBasis],\n  ) -> \"Linear\":\n    \"\"\"from_action(i, o)(action) creates a Linear.\"\"\"\n\n    matrix = np.zeros((input_space.num_dims, output_space.num_dims))\n    for i, direction in enumerate(input_space.basis):\n      out_vector = action(direction)\n      if out_vector not in output_space:\n        raise TypeError(f\"image of {direction} from input_space={input_space} \"\n                        f\"is not in output_space={output_space}\")\n      matrix[i, :] = out_vector.magnitudes\n\n    return Linear(input_space, output_space, matrix)\n\n  @classmethod\n  def combine_in_parallel(cls, fns: Sequence[\"Linear\"]) -> \"Linear\":\n    \"\"\"Combines multiple parallel linear functions into a single one.\"\"\"\n    joint_input_space = bases.join_vector_spaces(\n        *[fn.input_space for fn in fns])\n    joint_output_space = bases.join_vector_spaces(\n        *[fn.output_space for fn in fns])\n\n    def action(x: bases.BasisDirection) -> bases.VectorInBasis:\n      out = joint_output_space.null_vector()\n      for fn in fns:\n        if x in fn.input_space:\n          x_vec = fn.input_space.vector_from_basis_direction(x)\n          out += fn(x_vec).project(joint_output_space)\n      return out\n\n    return cls.from_action(joint_input_space, joint_output_space, action)\n\n\ndef project(\n    from_space: VectorSpaceWithBasis,\n    to_space: VectorSpaceWithBasis,\n) -> Linear:\n  \"\"\"Creates a projection.\"\"\""
  },
  {
    "id": "161",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\"\n    self.input_space = input_space\n    self.output_space = output_space\n    self.matrix = matrix\n\n  def __post_init__(self) -> None:\n    output_size, input_size = self.matrix.shape\n    assert input_size == self.input_space.num_dims\n    assert output_size == self.output_space.num_dims\n\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    if x not in self.input_space:\n      raise TypeError(f\"x={x} not in self.input_space={self.input_space}.\")\n    return VectorInBasis(\n        basis_directions=sorted(self.output_space.basis),\n        magnitudes=x.magnitudes @ self.matrix,\n    )\n\n  @classmethod\n  def from_action(\n      cls,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      action: Callable[[BasisDirection], VectorInBasis],\n  ) -> \"Linear\":\n    \"\"\"from_action(i, o)(action) creates a Linear.\"\"\"\n\n    matrix = np.zeros((input_space.num_dims, output_space.num_dims))\n    for i, direction in enumerate(input_space.basis):\n      out_vector = action(direction)\n      if out_vector not in output_space:\n        raise TypeError(f\"image of {direction} from input_space={input_space} \"\n                        f\"is not in output_space={output_space}\")\n      matrix[i, :] = out_vector.magnitudes\n\n    return Linear(input_space, output_space, matrix)\n\n  @classmethod\n  def combine_in_parallel(cls, fns: Sequence[\"Linear\"]) -> \"Linear\":\n    \"\"\"Combines multiple parallel linear functions into a single one.\"\"\"\n    joint_input_space = bases.join_vector_spaces(\n        *[fn.input_space for fn in fns])\n    joint_output_space = bases.join_vector_spaces(\n        *[fn.output_space for fn in fns])\n\n    def action(x: bases.BasisDirection) -> bases.VectorInBasis:\n      out = joint_output_space.null_vector()\n      for fn in fns:\n        if x in fn.input_space:\n          x_vec = fn.input_space.vector_from_basis_direction(x)\n          out += fn(x_vec).project(joint_output_space)\n      return out\n\n    return cls.from_action(joint_input_space, joint_output_space, action)\n\n\ndef project(\n    from_space: VectorSpaceWithBasis,\n    to_space: VectorSpaceWithBasis,\n) -> Linear:\n  \"\"\"Creates a projection.\"\"\"\n\n  def action(direction: bases.BasisDirection) -> VectorInBasis:"
  },
  {
    "id": "162",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\"\n    self.input_space = input_space\n    self.output_space = output_space\n    self.matrix = matrix\n\n  def __post_init__(self) -> None:\n    output_size, input_size = self.matrix.shape\n    assert input_size == self.input_space.num_dims\n    assert output_size == self.output_space.num_dims\n\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    if x not in self.input_space:\n      raise TypeError(f\"x={x} not in self.input_space={self.input_space}.\")\n    return VectorInBasis(\n        basis_directions=sorted(self.output_space.basis),\n        magnitudes=x.magnitudes @ self.matrix,\n    )\n\n  @classmethod\n  def from_action(\n      cls,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      action: Callable[[BasisDirection], VectorInBasis],\n  ) -> \"Linear\":\n    \"\"\"from_action(i, o)(action) creates a Linear.\"\"\"\n\n    matrix = np.zeros((input_space.num_dims, output_space.num_dims))\n    for i, direction in enumerate(input_space.basis):\n      out_vector = action(direction)\n      if out_vector not in output_space:\n        raise TypeError(f\"image of {direction} from input_space={input_space} \"\n                        f\"is not in output_space={output_space}\")\n      matrix[i, :] = out_vector.magnitudes\n\n    return Linear(input_space, output_space, matrix)\n\n  @classmethod\n  def combine_in_parallel(cls, fns: Sequence[\"Linear\"]) -> \"Linear\":\n    \"\"\"Combines multiple parallel linear functions into a single one.\"\"\"\n    joint_input_space = bases.join_vector_spaces(\n        *[fn.input_space for fn in fns])\n    joint_output_space = bases.join_vector_spaces(\n        *[fn.output_space for fn in fns])\n\n    def action(x: bases.BasisDirection) -> bases.VectorInBasis:\n      out = joint_output_space.null_vector()\n      for fn in fns:\n        if x in fn.input_space:\n          x_vec = fn.input_space.vector_from_basis_direction(x)\n          out += fn(x_vec).project(joint_output_space)\n      return out\n\n    return cls.from_action(joint_input_space, joint_output_space, action)\n\n\ndef project(\n    from_space: VectorSpaceWithBasis,\n    to_space: VectorSpaceWithBasis,\n) -> Linear:\n  \"\"\"Creates a projection.\"\"\"\n\n  def action(direction: bases.BasisDirection) -> VectorInBasis:\n    if direction in to_space:\n      return to_space.vector_from_basis_direction(direction)\n    else:\n      return to_space.null_vector()\n\n  return Linear.from_action(from_space, to_space, action=action)\n\n\n@dataclasses.dataclass\nclass ScalarBilinear:\n  \"\"\"A scalar-valued bilinear operator.\"\"\"\n  left_space: VectorSpaceWithBasis\n  right_space: VectorSpaceWithBasis\n  matrix: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Ensure matrix acts in sorted bases and typecheck sizes.\"\"\""
  },
  {
    "id": "163",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\"\n    self.input_space = input_space\n    self.output_space = output_space\n    self.matrix = matrix\n\n  def __post_init__(self) -> None:\n    output_size, input_size = self.matrix.shape\n    assert input_size == self.input_space.num_dims\n    assert output_size == self.output_space.num_dims\n\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    if x not in self.input_space:\n      raise TypeError(f\"x={x} not in self.input_space={self.input_space}.\")\n    return VectorInBasis(\n        basis_directions=sorted(self.output_space.basis),\n        magnitudes=x.magnitudes @ self.matrix,\n    )\n\n  @classmethod\n  def from_action(\n      cls,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      action: Callable[[BasisDirection], VectorInBasis],\n  ) -> \"Linear\":\n    \"\"\"from_action(i, o)(action) creates a Linear.\"\"\"\n\n    matrix = np.zeros((input_space.num_dims, output_space.num_dims))\n    for i, direction in enumerate(input_space.basis):\n      out_vector = action(direction)\n      if out_vector not in output_space:\n        raise TypeError(f\"image of {direction} from input_space={input_space} \"\n                        f\"is not in output_space={output_space}\")\n      matrix[i, :] = out_vector.magnitudes\n\n    return Linear(input_space, output_space, matrix)\n\n  @classmethod\n  def combine_in_parallel(cls, fns: Sequence[\"Linear\"]) -> \"Linear\":\n    \"\"\"Combines multiple parallel linear functions into a single one.\"\"\"\n    joint_input_space = bases.join_vector_spaces(\n        *[fn.input_space for fn in fns])\n    joint_output_space = bases.join_vector_spaces(\n        *[fn.output_space for fn in fns])\n\n    def action(x: bases.BasisDirection) -> bases.VectorInBasis:\n      out = joint_output_space.null_vector()\n      for fn in fns:\n        if x in fn.input_space:\n          x_vec = fn.input_space.vector_from_basis_direction(x)\n          out += fn(x_vec).project(joint_output_space)\n      return out\n\n    return cls.from_action(joint_input_space, joint_output_space, action)\n\n\ndef project(\n    from_space: VectorSpaceWithBasis,\n    to_space: VectorSpaceWithBasis,\n) -> Linear:\n  \"\"\"Creates a projection.\"\"\"\n\n  def action(direction: bases.BasisDirection) -> VectorInBasis:\n    if direction in to_space:\n      return to_space.vector_from_basis_direction(direction)\n    else:\n      return to_space.null_vector()\n\n  return Linear.from_action(from_space, to_space, action=action)\n\n\n@dataclasses.dataclass\nclass ScalarBilinear:\n  \"\"\"A scalar-valued bilinear operator.\"\"\"\n  left_space: VectorSpaceWithBasis\n  right_space: VectorSpaceWithBasis\n  matrix: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Ensure matrix acts in sorted bases and typecheck sizes.\"\"\"\n    left_size, right_size = self.matrix.shape\n    assert left_size == self.left_space.num_dims\n    assert right_size == self.right_space.num_dims\n\n  def __call__(self, x: VectorInBasis, y: VectorInBasis) -> float:\n    \"\"\"Describes the action of the operator on vectors.\"\"\""
  },
  {
    "id": "164",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functions on vector spaces.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence\n\nimport numpy as np\n\nfrom tracr.craft import bases\n\nVectorSpaceWithBasis = bases.VectorSpaceWithBasis\nVectorInBasis = bases.VectorInBasis\nBasisDirection = bases.BasisDirection\n\n\nclass VectorFunction(abc.ABC):\n  \"\"\"A function that acts on vectors.\"\"\"\n\n  input_space: VectorSpaceWithBasis\n  output_space: VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    \"\"\"Evaluates the function.\"\"\"\n\n\nclass Linear(VectorFunction):\n  \"\"\"A linear function.\"\"\"\n\n  def __init__(\n      self,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      matrix: np.ndarray,\n  ):\n    \"\"\"Initialises.\n\n    Args:\n      input_space: The input vector space.\n      output_space: The output vector space.\n      matrix: a [input, output] matrix acting in a (sorted) basis.\n    \"\"\"\n    self.input_space = input_space\n    self.output_space = output_space\n    self.matrix = matrix\n\n  def __post_init__(self) -> None:\n    output_size, input_size = self.matrix.shape\n    assert input_size == self.input_space.num_dims\n    assert output_size == self.output_space.num_dims\n\n  def __call__(self, x: VectorInBasis) -> VectorInBasis:\n    if x not in self.input_space:\n      raise TypeError(f\"x={x} not in self.input_space={self.input_space}.\")\n    return VectorInBasis(\n        basis_directions=sorted(self.output_space.basis),\n        magnitudes=x.magnitudes @ self.matrix,\n    )\n\n  @classmethod\n  def from_action(\n      cls,\n      input_space: VectorSpaceWithBasis,\n      output_space: VectorSpaceWithBasis,\n      action: Callable[[BasisDirection], VectorInBasis],\n  ) -> \"Linear\":\n    \"\"\"from_action(i, o)(action) creates a Linear.\"\"\"\n\n    matrix = np.zeros((input_space.num_dims, output_space.num_dims))\n    for i, direction in enumerate(input_space.basis):\n      out_vector = action(direction)\n      if out_vector not in output_space:\n        raise TypeError(f\"image of {direction} from input_space={input_space} \"\n                        f\"is not in output_space={output_space}\")\n      matrix[i, :] = out_vector.magnitudes\n\n    return Linear(input_space, output_space, matrix)\n\n  @classmethod\n  def combine_in_parallel(cls, fns: Sequence[\"Linear\"]) -> \"Linear\":\n    \"\"\"Combines multiple parallel linear functions into a single one.\"\"\"\n    joint_input_space = bases.join_vector_spaces(\n        *[fn.input_space for fn in fns])\n    joint_output_space = bases.join_vector_spaces(\n        *[fn.output_space for fn in fns])\n\n    def action(x: bases.BasisDirection) -> bases.VectorInBasis:\n      out = joint_output_space.null_vector()\n      for fn in fns:\n        if x in fn.input_space:\n          x_vec = fn.input_space.vector_from_basis_direction(x)\n          out += fn(x_vec).project(joint_output_space)\n      return out\n\n    return cls.from_action(joint_input_space, joint_output_space, action)\n\n\ndef project(\n    from_space: VectorSpaceWithBasis,\n    to_space: VectorSpaceWithBasis,\n) -> Linear:\n  \"\"\"Creates a projection.\"\"\"\n\n  def action(direction: bases.BasisDirection) -> VectorInBasis:\n    if direction in to_space:\n      return to_space.vector_from_basis_direction(direction)\n    else:\n      return to_space.null_vector()\n\n  return Linear.from_action(from_space, to_space, action=action)\n\n\n@dataclasses.dataclass\nclass ScalarBilinear:\n  \"\"\"A scalar-valued bilinear operator.\"\"\"\n  left_space: VectorSpaceWithBasis\n  right_space: VectorSpaceWithBasis\n  matrix: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Ensure matrix acts in sorted bases and typecheck sizes.\"\"\"\n    left_size, right_size = self.matrix.shape\n    assert left_size == self.left_space.num_dims\n    assert right_size == self.right_space.num_dims\n\n  def __call__(self, x: VectorInBasis, y: VectorInBasis) -> float:\n    \"\"\"Describes the action of the operator on vectors.\"\"\"\n    if x not in self.left_space:\n      raise TypeError(f\"x={x} not in self.left_space={self.left_space}.\")\n    if y not in self.right_space:\n      raise TypeError(f\"y={y} not in self.right_space={self.right_space}.\")\n    return (x.magnitudes.T @ self.matrix @ y.magnitudes).item()\n\n  @classmethod\n  def from_action(\n      cls,\n      left_space: VectorSpaceWithBasis,\n      right_space: VectorSpaceWithBasis,\n      action: Callable[[BasisDirection, BasisDirection], float],\n  ) -> \"ScalarBilinear\":\n    \"\"\"from_action(l, r)(action) creates a ScalarBilinear.\"\"\""
  },
  {
    "id": "165",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Vectors and bases.\"\"\"\n\nimport dataclasses\nfrom typing import Sequence, Union, Optional, Iterable\n\nimport numpy as np\n\nName = Union[int, str]\nValue = Union[int, float, bool, str, tuple]\n\n\n@dataclasses.dataclass(frozen=True)\nclass BasisDirection:\n  \"\"\"Represents a basis direction (no magnitude) in a vector space.\n\n  Attributes:\n    name: a unique name for this direction.\n    value: used to hold a value one-hot-encoded by this direction. e.g.,\n      [BasisDirection(\"vs_1\", True), BasisDirection(\"vs_1\", False)] would be\n      basis directions of a subspace called \"vs_1\" which one-hot-encodes the\n      values True and False. If provided, considered part of the name for the\n      purpose of disambiguating directions.\n  \"\"\"\n  name: Name\n  value: Optional[Value] = None\n\n  def __str__(self):"
  },
  {
    "id": "166",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Vectors and bases.\"\"\"\n\nimport dataclasses\nfrom typing import Sequence, Union, Optional, Iterable\n\nimport numpy as np\n\nName = Union[int, str]\nValue = Union[int, float, bool, str, tuple]\n\n\n@dataclasses.dataclass(frozen=True)\nclass BasisDirection:\n  \"\"\"Represents a basis direction (no magnitude) in a vector space.\n\n  Attributes:\n    name: a unique name for this direction.\n    value: used to hold a value one-hot-encoded by this direction. e.g.,\n      [BasisDirection(\"vs_1\", True), BasisDirection(\"vs_1\", False)] would be\n      basis directions of a subspace called \"vs_1\" which one-hot-encodes the\n      values True and False. If provided, considered part of the name for the\n      purpose of disambiguating directions.\n  \"\"\"\n  name: Name\n  value: Optional[Value] = None\n\n  def __str__(self):\n    if self.value is None:\n      return str(self.name)\n    return f\"{self.name}:{self.value}\"\n\n  def __lt__(self, other: \"BasisDirection\") -> bool:"
  },
  {
    "id": "167",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Vectors and bases.\"\"\"\n\nimport dataclasses\nfrom typing import Sequence, Union, Optional, Iterable\n\nimport numpy as np\n\nName = Union[int, str]\nValue = Union[int, float, bool, str, tuple]\n\n\n@dataclasses.dataclass(frozen=True)\nclass BasisDirection:\n  \"\"\"Represents a basis direction (no magnitude) in a vector space.\n\n  Attributes:\n    name: a unique name for this direction.\n    value: used to hold a value one-hot-encoded by this direction. e.g.,\n      [BasisDirection(\"vs_1\", True), BasisDirection(\"vs_1\", False)] would be\n      basis directions of a subspace called \"vs_1\" which one-hot-encodes the\n      values True and False. If provided, considered part of the name for the\n      purpose of disambiguating directions.\n  \"\"\"\n  name: Name\n  value: Optional[Value] = None\n\n  def __str__(self):\n    if self.value is None:\n      return str(self.name)\n    return f\"{self.name}:{self.value}\"\n\n  def __lt__(self, other: \"BasisDirection\") -> bool:\n    try:\n      return (self.name, self.value) < (other.name, other.value)\n    except TypeError:\n      return str(self) < str(other)\n\n\n@dataclasses.dataclass\nclass VectorInBasis:\n  \"\"\"A vector (or array of vectors) in a given basis.\n\n  When magnitudes are 1-d, this is a vector.\n  When magnitudes are (n+1)-d, this is an array of vectors,\n  where the -1th dimension is the basis dimension.\n  \"\"\"\n  basis_directions: Sequence[BasisDirection]\n  magnitudes: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Sort basis directions.\"\"\""
  },
  {
    "id": "168",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Vectors and bases.\"\"\"\n\nimport dataclasses\nfrom typing import Sequence, Union, Optional, Iterable\n\nimport numpy as np\n\nName = Union[int, str]\nValue = Union[int, float, bool, str, tuple]\n\n\n@dataclasses.dataclass(frozen=True)\nclass BasisDirection:\n  \"\"\"Represents a basis direction (no magnitude) in a vector space.\n\n  Attributes:\n    name: a unique name for this direction.\n    value: used to hold a value one-hot-encoded by this direction. e.g.,\n      [BasisDirection(\"vs_1\", True), BasisDirection(\"vs_1\", False)] would be\n      basis directions of a subspace called \"vs_1\" which one-hot-encodes the\n      values True and False. If provided, considered part of the name for the\n      purpose of disambiguating directions.\n  \"\"\"\n  name: Name\n  value: Optional[Value] = None\n\n  def __str__(self):\n    if self.value is None:\n      return str(self.name)\n    return f\"{self.name}:{self.value}\"\n\n  def __lt__(self, other: \"BasisDirection\") -> bool:\n    try:\n      return (self.name, self.value) < (other.name, other.value)\n    except TypeError:\n      return str(self) < str(other)\n\n\n@dataclasses.dataclass\nclass VectorInBasis:\n  \"\"\"A vector (or array of vectors) in a given basis.\n\n  When magnitudes are 1-d, this is a vector.\n  When magnitudes are (n+1)-d, this is an array of vectors,\n  where the -1th dimension is the basis dimension.\n  \"\"\"\n  basis_directions: Sequence[BasisDirection]\n  magnitudes: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Sort basis directions.\"\"\"\n    if len(self.basis_directions) != self.magnitudes.shape[-1]:\n      raise ValueError(\n          \"Last dimension of magnitudes must be the same as number \"\n          f\"of basis directions. Was {len(self.basis_directions)} \"\n          f\"and {self.magnitudes.shape[-1]}.\")\n\n    sort_idx = np.argsort(self.basis_directions)\n    self.basis_directions = [self.basis_directions[i] for i in sort_idx]\n    self.magnitudes = np.take(self.magnitudes, sort_idx, -1)\n\n  def __add__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":"
  },
  {
    "id": "169",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Vectors and bases.\"\"\"\n\nimport dataclasses\nfrom typing import Sequence, Union, Optional, Iterable\n\nimport numpy as np\n\nName = Union[int, str]\nValue = Union[int, float, bool, str, tuple]\n\n\n@dataclasses.dataclass(frozen=True)\nclass BasisDirection:\n  \"\"\"Represents a basis direction (no magnitude) in a vector space.\n\n  Attributes:\n    name: a unique name for this direction.\n    value: used to hold a value one-hot-encoded by this direction. e.g.,\n      [BasisDirection(\"vs_1\", True), BasisDirection(\"vs_1\", False)] would be\n      basis directions of a subspace called \"vs_1\" which one-hot-encodes the\n      values True and False. If provided, considered part of the name for the\n      purpose of disambiguating directions.\n  \"\"\"\n  name: Name\n  value: Optional[Value] = None\n\n  def __str__(self):\n    if self.value is None:\n      return str(self.name)\n    return f\"{self.name}:{self.value}\"\n\n  def __lt__(self, other: \"BasisDirection\") -> bool:\n    try:\n      return (self.name, self.value) < (other.name, other.value)\n    except TypeError:\n      return str(self) < str(other)\n\n\n@dataclasses.dataclass\nclass VectorInBasis:\n  \"\"\"A vector (or array of vectors) in a given basis.\n\n  When magnitudes are 1-d, this is a vector.\n  When magnitudes are (n+1)-d, this is an array of vectors,\n  where the -1th dimension is the basis dimension.\n  \"\"\"\n  basis_directions: Sequence[BasisDirection]\n  magnitudes: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Sort basis directions.\"\"\"\n    if len(self.basis_directions) != self.magnitudes.shape[-1]:\n      raise ValueError(\n          \"Last dimension of magnitudes must be the same as number \"\n          f\"of basis directions. Was {len(self.basis_directions)} \"\n          f\"and {self.magnitudes.shape[-1]}.\")\n\n    sort_idx = np.argsort(self.basis_directions)\n    self.basis_directions = [self.basis_directions[i] for i in sort_idx]\n    self.magnitudes = np.take(self.magnitudes, sort_idx, -1)\n\n  def __add__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {self} + {other}\")\n    magnitudes = self.magnitudes + other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __radd__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {other} + {self}\")\n    return self + other\n\n  def __sub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":"
  },
  {
    "id": "170",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Vectors and bases.\"\"\"\n\nimport dataclasses\nfrom typing import Sequence, Union, Optional, Iterable\n\nimport numpy as np\n\nName = Union[int, str]\nValue = Union[int, float, bool, str, tuple]\n\n\n@dataclasses.dataclass(frozen=True)\nclass BasisDirection:\n  \"\"\"Represents a basis direction (no magnitude) in a vector space.\n\n  Attributes:\n    name: a unique name for this direction.\n    value: used to hold a value one-hot-encoded by this direction. e.g.,\n      [BasisDirection(\"vs_1\", True), BasisDirection(\"vs_1\", False)] would be\n      basis directions of a subspace called \"vs_1\" which one-hot-encodes the\n      values True and False. If provided, considered part of the name for the\n      purpose of disambiguating directions.\n  \"\"\"\n  name: Name\n  value: Optional[Value] = None\n\n  def __str__(self):\n    if self.value is None:\n      return str(self.name)\n    return f\"{self.name}:{self.value}\"\n\n  def __lt__(self, other: \"BasisDirection\") -> bool:\n    try:\n      return (self.name, self.value) < (other.name, other.value)\n    except TypeError:\n      return str(self) < str(other)\n\n\n@dataclasses.dataclass\nclass VectorInBasis:\n  \"\"\"A vector (or array of vectors) in a given basis.\n\n  When magnitudes are 1-d, this is a vector.\n  When magnitudes are (n+1)-d, this is an array of vectors,\n  where the -1th dimension is the basis dimension.\n  \"\"\"\n  basis_directions: Sequence[BasisDirection]\n  magnitudes: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Sort basis directions.\"\"\"\n    if len(self.basis_directions) != self.magnitudes.shape[-1]:\n      raise ValueError(\n          \"Last dimension of magnitudes must be the same as number \"\n          f\"of basis directions. Was {len(self.basis_directions)} \"\n          f\"and {self.magnitudes.shape[-1]}.\")\n\n    sort_idx = np.argsort(self.basis_directions)\n    self.basis_directions = [self.basis_directions[i] for i in sort_idx]\n    self.magnitudes = np.take(self.magnitudes, sort_idx, -1)\n\n  def __add__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {self} + {other}\")\n    magnitudes = self.magnitudes + other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __radd__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {other} + {self}\")\n    return self + other\n\n  def __sub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {self} - {other}\")\n    magnitudes = self.magnitudes - other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __rsub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {other} - {self}\")\n    magnitudes = other.magnitudes - self.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __mul__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes * scalar)\n\n  def __rmul__(self, scalar: float) -> \"VectorInBasis\":\n    return self * scalar\n\n  def __truediv__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes / scalar)\n\n  def __neg__(self) -> \"VectorInBasis\":\n    return (-1) * self\n\n  def __eq__(self, other: \"VectorInBasis\") -> bool:"
  },
  {
    "id": "171",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Vectors and bases.\"\"\"\n\nimport dataclasses\nfrom typing import Sequence, Union, Optional, Iterable\n\nimport numpy as np\n\nName = Union[int, str]\nValue = Union[int, float, bool, str, tuple]\n\n\n@dataclasses.dataclass(frozen=True)\nclass BasisDirection:\n  \"\"\"Represents a basis direction (no magnitude) in a vector space.\n\n  Attributes:\n    name: a unique name for this direction.\n    value: used to hold a value one-hot-encoded by this direction. e.g.,\n      [BasisDirection(\"vs_1\", True), BasisDirection(\"vs_1\", False)] would be\n      basis directions of a subspace called \"vs_1\" which one-hot-encodes the\n      values True and False. If provided, considered part of the name for the\n      purpose of disambiguating directions.\n  \"\"\"\n  name: Name\n  value: Optional[Value] = None\n\n  def __str__(self):\n    if self.value is None:\n      return str(self.name)\n    return f\"{self.name}:{self.value}\"\n\n  def __lt__(self, other: \"BasisDirection\") -> bool:\n    try:\n      return (self.name, self.value) < (other.name, other.value)\n    except TypeError:\n      return str(self) < str(other)\n\n\n@dataclasses.dataclass\nclass VectorInBasis:\n  \"\"\"A vector (or array of vectors) in a given basis.\n\n  When magnitudes are 1-d, this is a vector.\n  When magnitudes are (n+1)-d, this is an array of vectors,\n  where the -1th dimension is the basis dimension.\n  \"\"\"\n  basis_directions: Sequence[BasisDirection]\n  magnitudes: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Sort basis directions.\"\"\"\n    if len(self.basis_directions) != self.magnitudes.shape[-1]:\n      raise ValueError(\n          \"Last dimension of magnitudes must be the same as number \"\n          f\"of basis directions. Was {len(self.basis_directions)} \"\n          f\"and {self.magnitudes.shape[-1]}.\")\n\n    sort_idx = np.argsort(self.basis_directions)\n    self.basis_directions = [self.basis_directions[i] for i in sort_idx]\n    self.magnitudes = np.take(self.magnitudes, sort_idx, -1)\n\n  def __add__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {self} + {other}\")\n    magnitudes = self.magnitudes + other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __radd__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {other} + {self}\")\n    return self + other\n\n  def __sub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {self} - {other}\")\n    magnitudes = self.magnitudes - other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __rsub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {other} - {self}\")\n    magnitudes = other.magnitudes - self.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __mul__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes * scalar)\n\n  def __rmul__(self, scalar: float) -> \"VectorInBasis\":\n    return self * scalar\n\n  def __truediv__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes / scalar)\n\n  def __neg__(self) -> \"VectorInBasis\":\n    return (-1) * self\n\n  def __eq__(self, other: \"VectorInBasis\") -> bool:\n    return ((self.basis_directions == other.basis_directions) and\n            (self.magnitudes.shape == other.magnitudes.shape) and\n            (np.all(self.magnitudes == other.magnitudes)))\n\n  @classmethod\n  def sum(cls, vectors: Sequence[\"VectorInBasis\"]) -> \"VectorInBasis\":\n    return cls(vectors[0].basis_directions,\n               np.sum([x.magnitudes for x in vectors], axis=0))\n\n  @classmethod\n  def stack(cls,\n            vectors: Sequence[\"VectorInBasis\"],\n            axis: int = 0) -> \"VectorInBasis\":"
  },
  {
    "id": "172",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Vectors and bases.\"\"\"\n\nimport dataclasses\nfrom typing import Sequence, Union, Optional, Iterable\n\nimport numpy as np\n\nName = Union[int, str]\nValue = Union[int, float, bool, str, tuple]\n\n\n@dataclasses.dataclass(frozen=True)\nclass BasisDirection:\n  \"\"\"Represents a basis direction (no magnitude) in a vector space.\n\n  Attributes:\n    name: a unique name for this direction.\n    value: used to hold a value one-hot-encoded by this direction. e.g.,\n      [BasisDirection(\"vs_1\", True), BasisDirection(\"vs_1\", False)] would be\n      basis directions of a subspace called \"vs_1\" which one-hot-encodes the\n      values True and False. If provided, considered part of the name for the\n      purpose of disambiguating directions.\n  \"\"\"\n  name: Name\n  value: Optional[Value] = None\n\n  def __str__(self):\n    if self.value is None:\n      return str(self.name)\n    return f\"{self.name}:{self.value}\"\n\n  def __lt__(self, other: \"BasisDirection\") -> bool:\n    try:\n      return (self.name, self.value) < (other.name, other.value)\n    except TypeError:\n      return str(self) < str(other)\n\n\n@dataclasses.dataclass\nclass VectorInBasis:\n  \"\"\"A vector (or array of vectors) in a given basis.\n\n  When magnitudes are 1-d, this is a vector.\n  When magnitudes are (n+1)-d, this is an array of vectors,\n  where the -1th dimension is the basis dimension.\n  \"\"\"\n  basis_directions: Sequence[BasisDirection]\n  magnitudes: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Sort basis directions.\"\"\"\n    if len(self.basis_directions) != self.magnitudes.shape[-1]:\n      raise ValueError(\n          \"Last dimension of magnitudes must be the same as number \"\n          f\"of basis directions. Was {len(self.basis_directions)} \"\n          f\"and {self.magnitudes.shape[-1]}.\")\n\n    sort_idx = np.argsort(self.basis_directions)\n    self.basis_directions = [self.basis_directions[i] for i in sort_idx]\n    self.magnitudes = np.take(self.magnitudes, sort_idx, -1)\n\n  def __add__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {self} + {other}\")\n    magnitudes = self.magnitudes + other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __radd__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {other} + {self}\")\n    return self + other\n\n  def __sub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {self} - {other}\")\n    magnitudes = self.magnitudes - other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __rsub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {other} - {self}\")\n    magnitudes = other.magnitudes - self.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __mul__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes * scalar)\n\n  def __rmul__(self, scalar: float) -> \"VectorInBasis\":\n    return self * scalar\n\n  def __truediv__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes / scalar)\n\n  def __neg__(self) -> \"VectorInBasis\":\n    return (-1) * self\n\n  def __eq__(self, other: \"VectorInBasis\") -> bool:\n    return ((self.basis_directions == other.basis_directions) and\n            (self.magnitudes.shape == other.magnitudes.shape) and\n            (np.all(self.magnitudes == other.magnitudes)))\n\n  @classmethod\n  def sum(cls, vectors: Sequence[\"VectorInBasis\"]) -> \"VectorInBasis\":\n    return cls(vectors[0].basis_directions,\n               np.sum([x.magnitudes for x in vectors], axis=0))\n\n  @classmethod\n  def stack(cls,\n            vectors: Sequence[\"VectorInBasis\"],\n            axis: int = 0) -> \"VectorInBasis\":\n    for v in vectors[1:]:\n      if v.basis_directions != vectors[0].basis_directions:\n        raise TypeError(f\"Stacking incompatible bases: {vectors[0]} + {v}\")\n    return cls(vectors[0].basis_directions,\n               np.stack([v.magnitudes for v in vectors], axis=axis))\n\n  def project(\n      self, basis: Union[\"VectorSpaceWithBasis\", Sequence[BasisDirection]]\n  ) -> \"VectorInBasis\":\n    \"\"\"Projects to the basis.\"\"\""
  },
  {
    "id": "173",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Vectors and bases.\"\"\"\n\nimport dataclasses\nfrom typing import Sequence, Union, Optional, Iterable\n\nimport numpy as np\n\nName = Union[int, str]\nValue = Union[int, float, bool, str, tuple]\n\n\n@dataclasses.dataclass(frozen=True)\nclass BasisDirection:\n  \"\"\"Represents a basis direction (no magnitude) in a vector space.\n\n  Attributes:\n    name: a unique name for this direction.\n    value: used to hold a value one-hot-encoded by this direction. e.g.,\n      [BasisDirection(\"vs_1\", True), BasisDirection(\"vs_1\", False)] would be\n      basis directions of a subspace called \"vs_1\" which one-hot-encodes the\n      values True and False. If provided, considered part of the name for the\n      purpose of disambiguating directions.\n  \"\"\"\n  name: Name\n  value: Optional[Value] = None\n\n  def __str__(self):\n    if self.value is None:\n      return str(self.name)\n    return f\"{self.name}:{self.value}\"\n\n  def __lt__(self, other: \"BasisDirection\") -> bool:\n    try:\n      return (self.name, self.value) < (other.name, other.value)\n    except TypeError:\n      return str(self) < str(other)\n\n\n@dataclasses.dataclass\nclass VectorInBasis:\n  \"\"\"A vector (or array of vectors) in a given basis.\n\n  When magnitudes are 1-d, this is a vector.\n  When magnitudes are (n+1)-d, this is an array of vectors,\n  where the -1th dimension is the basis dimension.\n  \"\"\"\n  basis_directions: Sequence[BasisDirection]\n  magnitudes: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Sort basis directions.\"\"\"\n    if len(self.basis_directions) != self.magnitudes.shape[-1]:\n      raise ValueError(\n          \"Last dimension of magnitudes must be the same as number \"\n          f\"of basis directions. Was {len(self.basis_directions)} \"\n          f\"and {self.magnitudes.shape[-1]}.\")\n\n    sort_idx = np.argsort(self.basis_directions)\n    self.basis_directions = [self.basis_directions[i] for i in sort_idx]\n    self.magnitudes = np.take(self.magnitudes, sort_idx, -1)\n\n  def __add__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {self} + {other}\")\n    magnitudes = self.magnitudes + other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __radd__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {other} + {self}\")\n    return self + other\n\n  def __sub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {self} - {other}\")\n    magnitudes = self.magnitudes - other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __rsub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {other} - {self}\")\n    magnitudes = other.magnitudes - self.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __mul__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes * scalar)\n\n  def __rmul__(self, scalar: float) -> \"VectorInBasis\":\n    return self * scalar\n\n  def __truediv__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes / scalar)\n\n  def __neg__(self) -> \"VectorInBasis\":\n    return (-1) * self\n\n  def __eq__(self, other: \"VectorInBasis\") -> bool:\n    return ((self.basis_directions == other.basis_directions) and\n            (self.magnitudes.shape == other.magnitudes.shape) and\n            (np.all(self.magnitudes == other.magnitudes)))\n\n  @classmethod\n  def sum(cls, vectors: Sequence[\"VectorInBasis\"]) -> \"VectorInBasis\":\n    return cls(vectors[0].basis_directions,\n               np.sum([x.magnitudes for x in vectors], axis=0))\n\n  @classmethod\n  def stack(cls,\n            vectors: Sequence[\"VectorInBasis\"],\n            axis: int = 0) -> \"VectorInBasis\":\n    for v in vectors[1:]:\n      if v.basis_directions != vectors[0].basis_directions:\n        raise TypeError(f\"Stacking incompatible bases: {vectors[0]} + {v}\")\n    return cls(vectors[0].basis_directions,\n               np.stack([v.magnitudes for v in vectors], axis=axis))\n\n  def project(\n      self, basis: Union[\"VectorSpaceWithBasis\", Sequence[BasisDirection]]\n  ) -> \"VectorInBasis\":\n    \"\"\"Projects to the basis.\"\"\"\n    if isinstance(basis, VectorSpaceWithBasis):\n      basis = basis.basis\n    components = []\n    for direction in basis:\n      if direction in self.basis_directions:\n        components.append(\n            self.magnitudes[..., self.basis_directions.index(direction)])\n      else:\n        components.append(np.zeros_like(self.magnitudes[..., 0]))\n    return VectorInBasis(list(basis), np.stack(components, axis=-1))\n\n\n@dataclasses.dataclass\nclass VectorSpaceWithBasis:\n  \"\"\"A vector subspace in a given basis.\"\"\"\n  basis: Sequence[BasisDirection]\n\n  def __post_init__(self):\n    \"\"\"Keep basis directions sorted.\"\"\"\n    self.basis = sorted(self.basis)\n\n  @property\n  def num_dims(self) -> int:\n    return len(self.basis)\n\n  def __contains__(self, item: Union[VectorInBasis, BasisDirection]) -> bool:"
  },
  {
    "id": "174",
    "text": " return f\"{self.name}:{self.value}\"\n\n  def __lt__(self, other: \"BasisDirection\") -> bool:\n    try:\n      return (self.name, self.value) < (other.name, other.value)\n    except TypeError:\n      return str(self) < str(other)\n\n\n@dataclasses.dataclass\nclass VectorInBasis:\n  \"\"\"A vector (or array of vectors) in a given basis.\n\n  When magnitudes are 1-d, this is a vector.\n  When magnitudes are (n+1)-d, this is an array of vectors,\n  where the -1th dimension is the basis dimension.\n  \"\"\"\n  basis_directions: Sequence[BasisDirection]\n  magnitudes: np.ndarray\n\n  def __post_init__(self):\n    \"\"\"Sort basis directions.\"\"\"\n    if len(self.basis_directions) != self.magnitudes.shape[-1]:\n      raise ValueError(\n          \"Last dimension of magnitudes must be the same as number \"\n          f\"of basis directions. Was {len(self.basis_directions)} \"\n          f\"and {self.magnitudes.shape[-1]}.\")\n\n    sort_idx = np.argsort(self.basis_directions)\n    self.basis_directions = [self.basis_directions[i] for i in sort_idx]\n    self.magnitudes = np.take(self.magnitudes, sort_idx, -1)\n\n  def __add__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {self} + {other}\")\n    magnitudes = self.magnitudes + other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __radd__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {other} + {self}\")\n    return self + other\n\n  def __sub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {self} - {other}\")\n    magnitudes = self.magnitudes - other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __rsub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {other} - {self}\")\n    magnitudes = other.magnitudes - self.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __mul__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes * scalar)\n\n  def __rmul__(self, scalar: float) -> \"VectorInBasis\":\n    return self * scalar\n\n  def __truediv__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes / scalar)\n\n  def __neg__(self) -> \"VectorInBasis\":\n    return (-1) * self\n\n  def __eq__(self, other: \"VectorInBasis\") -> bool:\n    return ((self.basis_directions == other.basis_directions) and\n            (self.magnitudes.shape == other.magnitudes.shape) and\n            (np.all(self.magnitudes == other.magnitudes)))\n\n  @classmethod\n  def sum(cls, vectors: Sequence[\"VectorInBasis\"]) -> \"VectorInBasis\":\n    return cls(vectors[0].basis_directions,\n               np.sum([x.magnitudes for x in vectors], axis=0))\n\n  @classmethod\n  def stack(cls,\n            vectors: Sequence[\"VectorInBasis\"],\n            axis: int = 0) -> \"VectorInBasis\":\n    for v in vectors[1:]:\n      if v.basis_directions != vectors[0].basis_directions:\n        raise TypeError(f\"Stacking incompatible bases: {vectors[0]} + {v}\")\n    return cls(vectors[0].basis_directions,\n               np.stack([v.magnitudes for v in vectors], axis=axis))\n\n  def project(\n      self, basis: Union[\"VectorSpaceWithBasis\", Sequence[BasisDirection]]\n  ) -> \"VectorInBasis\":\n    \"\"\"Projects to the basis.\"\"\"\n    if isinstance(basis, VectorSpaceWithBasis):\n      basis = basis.basis\n    components = []\n    for direction in basis:\n      if direction in self.basis_directions:\n        components.append(\n            self.magnitudes[..., self.basis_directions.index(direction)])\n      else:\n        components.append(np.zeros_like(self.magnitudes[..., 0]))\n    return VectorInBasis(list(basis), np.stack(components, axis=-1))\n\n\n@dataclasses.dataclass\nclass VectorSpaceWithBasis:\n  \"\"\"A vector subspace in a given basis.\"\"\"\n  basis: Sequence[BasisDirection]\n\n  def __post_init__(self):\n    \"\"\"Keep basis directions sorted.\"\"\"\n    self.basis = sorted(self.basis)\n\n  @property\n  def num_dims(self) -> int:\n    return len(self.basis)\n\n  def __contains__(self, item: Union[VectorInBasis, BasisDirection]) -> bool:\n    if isinstance(item, BasisDirection):\n      return item in self.basis\n\n    return set(self.basis) == set(item.basis_directions)\n\n  def issubspace(self, other: \"VectorSpaceWithBasis\") -> bool:\n    return set(self.basis).issubset(set(other.basis))\n\n  def basis_vectors(self) -> Sequence[VectorInBasis]:\n    basis_vector_magnitudes = list(np.eye(self.num_dims))\n    return [VectorInBasis(self.basis, m) for m in basis_vector_magnitudes]\n\n  def vector_from_basis_direction(\n      self, basis_direction: BasisDirection) -> VectorInBasis:\n    i = self.basis.index(basis_direction)\n    return VectorInBasis(self.basis, np.eye(self.num_dims)[i])\n\n  def null_vector(self) -> VectorInBasis:\n    return VectorInBasis(self.basis, np.zeros(self.num_dims))\n\n  @classmethod\n  def from_names(cls, names: Sequence[Name]) -> \"VectorSpaceWithBasis\":\n    \"\"\"Creates a VectorSpace from a list of names for its basis directions.\"\"\"\n    return cls([BasisDirection(n) for n in names])\n\n  @classmethod\n  def from_values(\n      cls,\n      name: Name,\n      values: Iterable[Value],\n  ) -> \"VectorSpaceWithBasis\":\n    \"\"\"Creates a VectorSpace from a list of values for its basis directions.\"\"\"\n    return cls([BasisDirection(name, v) for v in values])\n\n\ndef direct_sum(*vs: VectorSpaceWithBasis) -> VectorSpaceWithBasis:\n  \"\"\"Create a direct sum of the vector spaces.\n\n  Assumes the basis elements of all input vector spaces are\n  orthogonal to each other. Maintains the order of the bases.\n\n  Args:\n    *vs: the vector spaces to sum.\n\n  Returns:\n    the combined vector space.\n\n  Raises:\n    Value error in case of overlapping bases.\n  \"\"\"\n  # Take the union of all the bases:"
  },
  {
    "id": "175",
    "text": "\n\n  def __post_init__(self):\n    \"\"\"Sort basis directions.\"\"\"\n    if len(self.basis_directions) != self.magnitudes.shape[-1]:\n      raise ValueError(\n          \"Last dimension of magnitudes must be the same as number \"\n          f\"of basis directions. Was {len(self.basis_directions)} \"\n          f\"and {self.magnitudes.shape[-1]}.\")\n\n    sort_idx = np.argsort(self.basis_directions)\n    self.basis_directions = [self.basis_directions[i] for i in sort_idx]\n    self.magnitudes = np.take(self.magnitudes, sort_idx, -1)\n\n  def __add__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {self} + {other}\")\n    magnitudes = self.magnitudes + other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __radd__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Adding incompatible bases: {other} + {self}\")\n    return self + other\n\n  def __sub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {self} - {other}\")\n    magnitudes = self.magnitudes - other.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __rsub__(self, other: \"VectorInBasis\") -> \"VectorInBasis\":\n    if self.basis_directions != other.basis_directions:\n      raise TypeError(f\"Subtracting incompatible bases: {other} - {self}\")\n    magnitudes = other.magnitudes - self.magnitudes\n    return VectorInBasis(self.basis_directions, magnitudes)\n\n  def __mul__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes * scalar)\n\n  def __rmul__(self, scalar: float) -> \"VectorInBasis\":\n    return self * scalar\n\n  def __truediv__(self, scalar: float) -> \"VectorInBasis\":\n    return VectorInBasis(self.basis_directions, self.magnitudes / scalar)\n\n  def __neg__(self) -> \"VectorInBasis\":\n    return (-1) * self\n\n  def __eq__(self, other: \"VectorInBasis\") -> bool:\n    return ((self.basis_directions == other.basis_directions) and\n            (self.magnitudes.shape == other.magnitudes.shape) and\n            (np.all(self.magnitudes == other.magnitudes)))\n\n  @classmethod\n  def sum(cls, vectors: Sequence[\"VectorInBasis\"]) -> \"VectorInBasis\":\n    return cls(vectors[0].basis_directions,\n               np.sum([x.magnitudes for x in vectors], axis=0))\n\n  @classmethod\n  def stack(cls,\n            vectors: Sequence[\"VectorInBasis\"],\n            axis: int = 0) -> \"VectorInBasis\":\n    for v in vectors[1:]:\n      if v.basis_directions != vectors[0].basis_directions:\n        raise TypeError(f\"Stacking incompatible bases: {vectors[0]} + {v}\")\n    return cls(vectors[0].basis_directions,\n               np.stack([v.magnitudes for v in vectors], axis=axis))\n\n  def project(\n      self, basis: Union[\"VectorSpaceWithBasis\", Sequence[BasisDirection]]\n  ) -> \"VectorInBasis\":\n    \"\"\"Projects to the basis.\"\"\"\n    if isinstance(basis, VectorSpaceWithBasis):\n      basis = basis.basis\n    components = []\n    for direction in basis:\n      if direction in self.basis_directions:\n        components.append(\n            self.magnitudes[..., self.basis_directions.index(direction)])\n      else:\n        components.append(np.zeros_like(self.magnitudes[..., 0]))\n    return VectorInBasis(list(basis), np.stack(components, axis=-1))\n\n\n@dataclasses.dataclass\nclass VectorSpaceWithBasis:\n  \"\"\"A vector subspace in a given basis.\"\"\"\n  basis: Sequence[BasisDirection]\n\n  def __post_init__(self):\n    \"\"\"Keep basis directions sorted.\"\"\"\n    self.basis = sorted(self.basis)\n\n  @property\n  def num_dims(self) -> int:\n    return len(self.basis)\n\n  def __contains__(self, item: Union[VectorInBasis, BasisDirection]) -> bool:\n    if isinstance(item, BasisDirection):\n      return item in self.basis\n\n    return set(self.basis) == set(item.basis_directions)\n\n  def issubspace(self, other: \"VectorSpaceWithBasis\") -> bool:\n    return set(self.basis).issubset(set(other.basis))\n\n  def basis_vectors(self) -> Sequence[VectorInBasis]:\n    basis_vector_magnitudes = list(np.eye(self.num_dims))\n    return [VectorInBasis(self.basis, m) for m in basis_vector_magnitudes]\n\n  def vector_from_basis_direction(\n      self, basis_direction: BasisDirection) -> VectorInBasis:\n    i = self.basis.index(basis_direction)\n    return VectorInBasis(self.basis, np.eye(self.num_dims)[i])\n\n  def null_vector(self) -> VectorInBasis:\n    return VectorInBasis(self.basis, np.zeros(self.num_dims))\n\n  @classmethod\n  def from_names(cls, names: Sequence[Name]) -> \"VectorSpaceWithBasis\":\n    \"\"\"Creates a VectorSpace from a list of names for its basis directions.\"\"\"\n    return cls([BasisDirection(n) for n in names])\n\n  @classmethod\n  def from_values(\n      cls,\n      name: Name,\n      values: Iterable[Value],\n  ) -> \"VectorSpaceWithBasis\":\n    \"\"\"Creates a VectorSpace from a list of values for its basis directions.\"\"\"\n    return cls([BasisDirection(name, v) for v in values])\n\n\ndef direct_sum(*vs: VectorSpaceWithBasis) -> VectorSpaceWithBasis:\n  \"\"\"Create a direct sum of the vector spaces.\n\n  Assumes the basis elements of all input vector spaces are\n  orthogonal to each other. Maintains the order of the bases.\n\n  Args:\n    *vs: the vector spaces to sum.\n\n  Returns:\n    the combined vector space.\n\n  Raises:\n    Value error in case of overlapping bases.\n  \"\"\"\n  # Take the union of all the bases:\n  total_basis = sum([v.basis for v in vs], [])\n\n  if len(total_basis) != len(set(total_basis)):\n    raise ValueError(\"Overlapping bases!\")\n\n  return VectorSpaceWithBasis(total_basis)\n\n\ndef join_vector_spaces(*vs: VectorSpaceWithBasis) -> VectorSpaceWithBasis:\n  \"\"\"Joins a set of vector spaces allowing them to overlap.\n\n  Assumes the basis elements of all input vector spaces are\n  orthogonal to each other. Does not maintain the order of the bases but\n  sorts them.\n\n  Args:\n    *vs: the vector spaces to sum.\n\n  Returns:\n    the combined vector space.\n  \"\"\"\n  # Take the union of all the bases:"
  },
  {
    "id": "176",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Pieces for making transformers.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Iterable, List, Optional, Sequence, Union\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import vectorspace_fns\n\nproject = vectorspace_fns.project\n\n\ndef _np_softmax(x, axis=-1):\n  x_max = np.max(x, axis=axis, keepdims=True)\n  return np.exp(x - x_max) / np.sum(np.exp(x - x_max), axis=axis, keepdims=True)\n\n\ndef _np_relu(x):\n  return np.where(x > 0, x, 0)\n\n\ndef relu(x: bases.VectorInBasis) -> bases.VectorInBasis:\n  return bases.VectorInBasis(x.basis_directions, _np_relu(x.magnitudes))\n\n\nclass Block(abc.ABC):\n  \"\"\"Transformer block, acting on a sequence of vector space elements.\n\n  Attributes:\n    residual_space: Vector space that contains all subspaces the Block interacts\n      with. This can be either the full residual space of a model or a subspace.\n  \"\"\"\n  residual_space: bases.VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Applies self to an input.\"\"\"\n\n\n@dataclasses.dataclass\nclass AttentionHead(Block):\n  \"\"\"A transformer attention head.\"\"\"\n  w_qk: vectorspace_fns.ScalarBilinear\n  w_ov: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n  causal: bool = False\n\n  def __post_init__(self):\n    \"\"\"Infer residual stream and typecheck subspaces.\"\"\""
  },
  {
    "id": "177",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Pieces for making transformers.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Iterable, List, Optional, Sequence, Union\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import vectorspace_fns\n\nproject = vectorspace_fns.project\n\n\ndef _np_softmax(x, axis=-1):\n  x_max = np.max(x, axis=axis, keepdims=True)\n  return np.exp(x - x_max) / np.sum(np.exp(x - x_max), axis=axis, keepdims=True)\n\n\ndef _np_relu(x):\n  return np.where(x > 0, x, 0)\n\n\ndef relu(x: bases.VectorInBasis) -> bases.VectorInBasis:\n  return bases.VectorInBasis(x.basis_directions, _np_relu(x.magnitudes))\n\n\nclass Block(abc.ABC):\n  \"\"\"Transformer block, acting on a sequence of vector space elements.\n\n  Attributes:\n    residual_space: Vector space that contains all subspaces the Block interacts\n      with. This can be either the full residual space of a model or a subspace.\n  \"\"\"\n  residual_space: bases.VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Applies self to an input.\"\"\"\n\n\n@dataclasses.dataclass\nclass AttentionHead(Block):\n  \"\"\"A transformer attention head.\"\"\"\n  w_qk: vectorspace_fns.ScalarBilinear\n  w_ov: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n  causal: bool = False\n\n  def __post_init__(self):\n    \"\"\"Infer residual stream and typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.w_qk.left_space,\n                                                     self.w_qk.right_space,\n                                                     self.w_ov.input_space,\n                                                     self.w_ov.output_space)\n\n    assert self.w_qk.left_space.issubspace(self.residual_space)\n    assert self.w_qk.right_space.issubspace(self.residual_space)\n    assert self.w_ov.input_space.issubspace(self.residual_space)\n    assert self.w_ov.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:"
  },
  {
    "id": "178",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Pieces for making transformers.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Iterable, List, Optional, Sequence, Union\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import vectorspace_fns\n\nproject = vectorspace_fns.project\n\n\ndef _np_softmax(x, axis=-1):\n  x_max = np.max(x, axis=axis, keepdims=True)\n  return np.exp(x - x_max) / np.sum(np.exp(x - x_max), axis=axis, keepdims=True)\n\n\ndef _np_relu(x):\n  return np.where(x > 0, x, 0)\n\n\ndef relu(x: bases.VectorInBasis) -> bases.VectorInBasis:\n  return bases.VectorInBasis(x.basis_directions, _np_relu(x.magnitudes))\n\n\nclass Block(abc.ABC):\n  \"\"\"Transformer block, acting on a sequence of vector space elements.\n\n  Attributes:\n    residual_space: Vector space that contains all subspaces the Block interacts\n      with. This can be either the full residual space of a model or a subspace.\n  \"\"\"\n  residual_space: bases.VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Applies self to an input.\"\"\"\n\n\n@dataclasses.dataclass\nclass AttentionHead(Block):\n  \"\"\"A transformer attention head.\"\"\"\n  w_qk: vectorspace_fns.ScalarBilinear\n  w_ov: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n  causal: bool = False\n\n  def __post_init__(self):\n    \"\"\"Infer residual stream and typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.w_qk.left_space,\n                                                     self.w_qk.right_space,\n                                                     self.w_ov.input_space,\n                                                     self.w_ov.output_space)\n\n    assert self.w_qk.left_space.issubspace(self.residual_space)\n    assert self.w_qk.right_space.issubspace(self.residual_space)\n    assert self.w_ov.input_space.issubspace(self.residual_space)\n    assert self.w_ov.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    assert x in self.residual_space\n    # seq_len x query_space\n    queries = x.project(self.w_qk.left_space)\n    # seq_len x key_space\n    keys = x.project(self.w_qk.right_space)\n\n    attn_matrix = queries.magnitudes @ self.w_qk.matrix @ keys.magnitudes.T\n\n    if self.causal:\n      # The 1 gives us the matrix above the diagonal.\n      mask = np.triu(np.full_like(attn_matrix, -np.inf), 1)\n      attn_matrix = attn_matrix + mask\n\n    attn_weights = _np_softmax(attn_matrix)  # seq_len_from, seq_len_to\n    values = self.w_ov_residual(x).magnitudes  # seq_len_to, d_model\n\n    magnitudes = attn_weights @ values  # seq_len_from, d_model\n    return bases.VectorInBasis(sorted(self.residual_space.basis), magnitudes)\n\n  def w_ov_residual(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Wov but acting on the residual space.\"\"\""
  },
  {
    "id": "179",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Pieces for making transformers.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Iterable, List, Optional, Sequence, Union\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import vectorspace_fns\n\nproject = vectorspace_fns.project\n\n\ndef _np_softmax(x, axis=-1):\n  x_max = np.max(x, axis=axis, keepdims=True)\n  return np.exp(x - x_max) / np.sum(np.exp(x - x_max), axis=axis, keepdims=True)\n\n\ndef _np_relu(x):\n  return np.where(x > 0, x, 0)\n\n\ndef relu(x: bases.VectorInBasis) -> bases.VectorInBasis:\n  return bases.VectorInBasis(x.basis_directions, _np_relu(x.magnitudes))\n\n\nclass Block(abc.ABC):\n  \"\"\"Transformer block, acting on a sequence of vector space elements.\n\n  Attributes:\n    residual_space: Vector space that contains all subspaces the Block interacts\n      with. This can be either the full residual space of a model or a subspace.\n  \"\"\"\n  residual_space: bases.VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Applies self to an input.\"\"\"\n\n\n@dataclasses.dataclass\nclass AttentionHead(Block):\n  \"\"\"A transformer attention head.\"\"\"\n  w_qk: vectorspace_fns.ScalarBilinear\n  w_ov: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n  causal: bool = False\n\n  def __post_init__(self):\n    \"\"\"Infer residual stream and typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.w_qk.left_space,\n                                                     self.w_qk.right_space,\n                                                     self.w_ov.input_space,\n                                                     self.w_ov.output_space)\n\n    assert self.w_qk.left_space.issubspace(self.residual_space)\n    assert self.w_qk.right_space.issubspace(self.residual_space)\n    assert self.w_ov.input_space.issubspace(self.residual_space)\n    assert self.w_ov.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    assert x in self.residual_space\n    # seq_len x query_space\n    queries = x.project(self.w_qk.left_space)\n    # seq_len x key_space\n    keys = x.project(self.w_qk.right_space)\n\n    attn_matrix = queries.magnitudes @ self.w_qk.matrix @ keys.magnitudes.T\n\n    if self.causal:\n      # The 1 gives us the matrix above the diagonal.\n      mask = np.triu(np.full_like(attn_matrix, -np.inf), 1)\n      attn_matrix = attn_matrix + mask\n\n    attn_weights = _np_softmax(attn_matrix)  # seq_len_from, seq_len_to\n    values = self.w_ov_residual(x).magnitudes  # seq_len_to, d_model\n\n    magnitudes = attn_weights @ values  # seq_len_from, d_model\n    return bases.VectorInBasis(sorted(self.residual_space.basis), magnitudes)\n\n  def w_ov_residual(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Wov but acting on the residual space.\"\"\"\n    x = project(self.residual_space, self.w_ov.input_space)(x)\n    out = self.w_ov(x)\n    return project(self.w_ov.output_space, self.residual_space)(out)\n\n  @property\n  def num_heads(self) -> int:\n    return 1\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return MultiAttentionHead([self])\n\n\n@dataclasses.dataclass\nclass MultiAttentionHead(Block):\n  \"\"\"Applies attention heads in parallel.\"\"\"\n  sub_blocks: List[Union[AttentionHead, \"MultiAttentionHead\"]]\n\n  def __post_init__(self):"
  },
  {
    "id": "180",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Pieces for making transformers.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Iterable, List, Optional, Sequence, Union\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import vectorspace_fns\n\nproject = vectorspace_fns.project\n\n\ndef _np_softmax(x, axis=-1):\n  x_max = np.max(x, axis=axis, keepdims=True)\n  return np.exp(x - x_max) / np.sum(np.exp(x - x_max), axis=axis, keepdims=True)\n\n\ndef _np_relu(x):\n  return np.where(x > 0, x, 0)\n\n\ndef relu(x: bases.VectorInBasis) -> bases.VectorInBasis:\n  return bases.VectorInBasis(x.basis_directions, _np_relu(x.magnitudes))\n\n\nclass Block(abc.ABC):\n  \"\"\"Transformer block, acting on a sequence of vector space elements.\n\n  Attributes:\n    residual_space: Vector space that contains all subspaces the Block interacts\n      with. This can be either the full residual space of a model or a subspace.\n  \"\"\"\n  residual_space: bases.VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Applies self to an input.\"\"\"\n\n\n@dataclasses.dataclass\nclass AttentionHead(Block):\n  \"\"\"A transformer attention head.\"\"\"\n  w_qk: vectorspace_fns.ScalarBilinear\n  w_ov: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n  causal: bool = False\n\n  def __post_init__(self):\n    \"\"\"Infer residual stream and typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.w_qk.left_space,\n                                                     self.w_qk.right_space,\n                                                     self.w_ov.input_space,\n                                                     self.w_ov.output_space)\n\n    assert self.w_qk.left_space.issubspace(self.residual_space)\n    assert self.w_qk.right_space.issubspace(self.residual_space)\n    assert self.w_ov.input_space.issubspace(self.residual_space)\n    assert self.w_ov.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    assert x in self.residual_space\n    # seq_len x query_space\n    queries = x.project(self.w_qk.left_space)\n    # seq_len x key_space\n    keys = x.project(self.w_qk.right_space)\n\n    attn_matrix = queries.magnitudes @ self.w_qk.matrix @ keys.magnitudes.T\n\n    if self.causal:\n      # The 1 gives us the matrix above the diagonal.\n      mask = np.triu(np.full_like(attn_matrix, -np.inf), 1)\n      attn_matrix = attn_matrix + mask\n\n    attn_weights = _np_softmax(attn_matrix)  # seq_len_from, seq_len_to\n    values = self.w_ov_residual(x).magnitudes  # seq_len_to, d_model\n\n    magnitudes = attn_weights @ values  # seq_len_from, d_model\n    return bases.VectorInBasis(sorted(self.residual_space.basis), magnitudes)\n\n  def w_ov_residual(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Wov but acting on the residual space.\"\"\"\n    x = project(self.residual_space, self.w_ov.input_space)(x)\n    out = self.w_ov(x)\n    return project(self.w_ov.output_space, self.residual_space)(out)\n\n  @property\n  def num_heads(self) -> int:\n    return 1\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return MultiAttentionHead([self])\n\n\n@dataclasses.dataclass\nclass MultiAttentionHead(Block):\n  \"\"\"Applies attention heads in parallel.\"\"\"\n  sub_blocks: List[Union[AttentionHead, \"MultiAttentionHead\"]]\n\n  def __post_init__(self):\n    spaces = [block.residual_space for block in self.sub_blocks]\n    self.residual_space, *others = spaces\n    assert all(s == self.residual_space for s in others)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    # each element is seq_len x embedding\n    outs = [block.apply(x) for block in self.sub_blocks]\n    return bases.VectorInBasis.sum(outs)  # seq_len x embedding\n\n  @property\n  def num_heads(self) -> int:\n    return sum(sub_block.num_heads for sub_block in self.sub_blocks)\n\n  def heads(self) -> Iterable[AttentionHead]:"
  },
  {
    "id": "181",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Pieces for making transformers.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Iterable, List, Optional, Sequence, Union\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import vectorspace_fns\n\nproject = vectorspace_fns.project\n\n\ndef _np_softmax(x, axis=-1):\n  x_max = np.max(x, axis=axis, keepdims=True)\n  return np.exp(x - x_max) / np.sum(np.exp(x - x_max), axis=axis, keepdims=True)\n\n\ndef _np_relu(x):\n  return np.where(x > 0, x, 0)\n\n\ndef relu(x: bases.VectorInBasis) -> bases.VectorInBasis:\n  return bases.VectorInBasis(x.basis_directions, _np_relu(x.magnitudes))\n\n\nclass Block(abc.ABC):\n  \"\"\"Transformer block, acting on a sequence of vector space elements.\n\n  Attributes:\n    residual_space: Vector space that contains all subspaces the Block interacts\n      with. This can be either the full residual space of a model or a subspace.\n  \"\"\"\n  residual_space: bases.VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Applies self to an input.\"\"\"\n\n\n@dataclasses.dataclass\nclass AttentionHead(Block):\n  \"\"\"A transformer attention head.\"\"\"\n  w_qk: vectorspace_fns.ScalarBilinear\n  w_ov: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n  causal: bool = False\n\n  def __post_init__(self):\n    \"\"\"Infer residual stream and typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.w_qk.left_space,\n                                                     self.w_qk.right_space,\n                                                     self.w_ov.input_space,\n                                                     self.w_ov.output_space)\n\n    assert self.w_qk.left_space.issubspace(self.residual_space)\n    assert self.w_qk.right_space.issubspace(self.residual_space)\n    assert self.w_ov.input_space.issubspace(self.residual_space)\n    assert self.w_ov.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    assert x in self.residual_space\n    # seq_len x query_space\n    queries = x.project(self.w_qk.left_space)\n    # seq_len x key_space\n    keys = x.project(self.w_qk.right_space)\n\n    attn_matrix = queries.magnitudes @ self.w_qk.matrix @ keys.magnitudes.T\n\n    if self.causal:\n      # The 1 gives us the matrix above the diagonal.\n      mask = np.triu(np.full_like(attn_matrix, -np.inf), 1)\n      attn_matrix = attn_matrix + mask\n\n    attn_weights = _np_softmax(attn_matrix)  # seq_len_from, seq_len_to\n    values = self.w_ov_residual(x).magnitudes  # seq_len_to, d_model\n\n    magnitudes = attn_weights @ values  # seq_len_from, d_model\n    return bases.VectorInBasis(sorted(self.residual_space.basis), magnitudes)\n\n  def w_ov_residual(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Wov but acting on the residual space.\"\"\"\n    x = project(self.residual_space, self.w_ov.input_space)(x)\n    out = self.w_ov(x)\n    return project(self.w_ov.output_space, self.residual_space)(out)\n\n  @property\n  def num_heads(self) -> int:\n    return 1\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return MultiAttentionHead([self])\n\n\n@dataclasses.dataclass\nclass MultiAttentionHead(Block):\n  \"\"\"Applies attention heads in parallel.\"\"\"\n  sub_blocks: List[Union[AttentionHead, \"MultiAttentionHead\"]]\n\n  def __post_init__(self):\n    spaces = [block.residual_space for block in self.sub_blocks]\n    self.residual_space, *others = spaces\n    assert all(s == self.residual_space for s in others)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    # each element is seq_len x embedding\n    outs = [block.apply(x) for block in self.sub_blocks]\n    return bases.VectorInBasis.sum(outs)  # seq_len x embedding\n\n  @property\n  def num_heads(self) -> int:\n    return sum(sub_block.num_heads for sub_block in self.sub_blocks)\n\n  def heads(self) -> Iterable[AttentionHead]:\n    for sub_block in self.sub_blocks:\n      if isinstance(sub_block, AttentionHead):\n        yield sub_block\n      elif isinstance(sub_block, MultiAttentionHead):\n        yield from sub_block.heads()\n      else:\n        raise NotImplementedError()\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return self\n\n\n@dataclasses.dataclass\nclass MLP(Block):\n  \"\"\"A transformer MLP block.\"\"\"\n  fst: vectorspace_fns.Linear\n  snd: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n\n  def __post_init__(self):\n    \"\"\"Typecheck subspaces.\"\"\""
  },
  {
    "id": "182",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Pieces for making transformers.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Iterable, List, Optional, Sequence, Union\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import vectorspace_fns\n\nproject = vectorspace_fns.project\n\n\ndef _np_softmax(x, axis=-1):\n  x_max = np.max(x, axis=axis, keepdims=True)\n  return np.exp(x - x_max) / np.sum(np.exp(x - x_max), axis=axis, keepdims=True)\n\n\ndef _np_relu(x):\n  return np.where(x > 0, x, 0)\n\n\ndef relu(x: bases.VectorInBasis) -> bases.VectorInBasis:\n  return bases.VectorInBasis(x.basis_directions, _np_relu(x.magnitudes))\n\n\nclass Block(abc.ABC):\n  \"\"\"Transformer block, acting on a sequence of vector space elements.\n\n  Attributes:\n    residual_space: Vector space that contains all subspaces the Block interacts\n      with. This can be either the full residual space of a model or a subspace.\n  \"\"\"\n  residual_space: bases.VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Applies self to an input.\"\"\"\n\n\n@dataclasses.dataclass\nclass AttentionHead(Block):\n  \"\"\"A transformer attention head.\"\"\"\n  w_qk: vectorspace_fns.ScalarBilinear\n  w_ov: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n  causal: bool = False\n\n  def __post_init__(self):\n    \"\"\"Infer residual stream and typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.w_qk.left_space,\n                                                     self.w_qk.right_space,\n                                                     self.w_ov.input_space,\n                                                     self.w_ov.output_space)\n\n    assert self.w_qk.left_space.issubspace(self.residual_space)\n    assert self.w_qk.right_space.issubspace(self.residual_space)\n    assert self.w_ov.input_space.issubspace(self.residual_space)\n    assert self.w_ov.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    assert x in self.residual_space\n    # seq_len x query_space\n    queries = x.project(self.w_qk.left_space)\n    # seq_len x key_space\n    keys = x.project(self.w_qk.right_space)\n\n    attn_matrix = queries.magnitudes @ self.w_qk.matrix @ keys.magnitudes.T\n\n    if self.causal:\n      # The 1 gives us the matrix above the diagonal.\n      mask = np.triu(np.full_like(attn_matrix, -np.inf), 1)\n      attn_matrix = attn_matrix + mask\n\n    attn_weights = _np_softmax(attn_matrix)  # seq_len_from, seq_len_to\n    values = self.w_ov_residual(x).magnitudes  # seq_len_to, d_model\n\n    magnitudes = attn_weights @ values  # seq_len_from, d_model\n    return bases.VectorInBasis(sorted(self.residual_space.basis), magnitudes)\n\n  def w_ov_residual(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Wov but acting on the residual space.\"\"\"\n    x = project(self.residual_space, self.w_ov.input_space)(x)\n    out = self.w_ov(x)\n    return project(self.w_ov.output_space, self.residual_space)(out)\n\n  @property\n  def num_heads(self) -> int:\n    return 1\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return MultiAttentionHead([self])\n\n\n@dataclasses.dataclass\nclass MultiAttentionHead(Block):\n  \"\"\"Applies attention heads in parallel.\"\"\"\n  sub_blocks: List[Union[AttentionHead, \"MultiAttentionHead\"]]\n\n  def __post_init__(self):\n    spaces = [block.residual_space for block in self.sub_blocks]\n    self.residual_space, *others = spaces\n    assert all(s == self.residual_space for s in others)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    # each element is seq_len x embedding\n    outs = [block.apply(x) for block in self.sub_blocks]\n    return bases.VectorInBasis.sum(outs)  # seq_len x embedding\n\n  @property\n  def num_heads(self) -> int:\n    return sum(sub_block.num_heads for sub_block in self.sub_blocks)\n\n  def heads(self) -> Iterable[AttentionHead]:\n    for sub_block in self.sub_blocks:\n      if isinstance(sub_block, AttentionHead):\n        yield sub_block\n      elif isinstance(sub_block, MultiAttentionHead):\n        yield from sub_block.heads()\n      else:\n        raise NotImplementedError()\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return self\n\n\n@dataclasses.dataclass\nclass MLP(Block):\n  \"\"\"A transformer MLP block.\"\"\"\n  fst: vectorspace_fns.Linear\n  snd: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n\n  def __post_init__(self):\n    \"\"\"Typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.fst.input_space,\n                                                     self.snd.output_space)\n\n    assert self.fst.output_space == self.snd.input_space\n    assert self.fst.input_space.issubspace(self.residual_space)\n    assert self.snd.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:"
  },
  {
    "id": "183",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Pieces for making transformers.\"\"\"\n\nimport abc\nimport dataclasses\nfrom typing import Iterable, List, Optional, Sequence, Union\n\nimport numpy as np\n\nfrom tracr.craft import bases\nfrom tracr.craft import vectorspace_fns\n\nproject = vectorspace_fns.project\n\n\ndef _np_softmax(x, axis=-1):\n  x_max = np.max(x, axis=axis, keepdims=True)\n  return np.exp(x - x_max) / np.sum(np.exp(x - x_max), axis=axis, keepdims=True)\n\n\ndef _np_relu(x):\n  return np.where(x > 0, x, 0)\n\n\ndef relu(x: bases.VectorInBasis) -> bases.VectorInBasis:\n  return bases.VectorInBasis(x.basis_directions, _np_relu(x.magnitudes))\n\n\nclass Block(abc.ABC):\n  \"\"\"Transformer block, acting on a sequence of vector space elements.\n\n  Attributes:\n    residual_space: Vector space that contains all subspaces the Block interacts\n      with. This can be either the full residual space of a model or a subspace.\n  \"\"\"\n  residual_space: bases.VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Applies self to an input.\"\"\"\n\n\n@dataclasses.dataclass\nclass AttentionHead(Block):\n  \"\"\"A transformer attention head.\"\"\"\n  w_qk: vectorspace_fns.ScalarBilinear\n  w_ov: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n  causal: bool = False\n\n  def __post_init__(self):\n    \"\"\"Infer residual stream and typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.w_qk.left_space,\n                                                     self.w_qk.right_space,\n                                                     self.w_ov.input_space,\n                                                     self.w_ov.output_space)\n\n    assert self.w_qk.left_space.issubspace(self.residual_space)\n    assert self.w_qk.right_space.issubspace(self.residual_space)\n    assert self.w_ov.input_space.issubspace(self.residual_space)\n    assert self.w_ov.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    assert x in self.residual_space\n    # seq_len x query_space\n    queries = x.project(self.w_qk.left_space)\n    # seq_len x key_space\n    keys = x.project(self.w_qk.right_space)\n\n    attn_matrix = queries.magnitudes @ self.w_qk.matrix @ keys.magnitudes.T\n\n    if self.causal:\n      # The 1 gives us the matrix above the diagonal.\n      mask = np.triu(np.full_like(attn_matrix, -np.inf), 1)\n      attn_matrix = attn_matrix + mask\n\n    attn_weights = _np_softmax(attn_matrix)  # seq_len_from, seq_len_to\n    values = self.w_ov_residual(x).magnitudes  # seq_len_to, d_model\n\n    magnitudes = attn_weights @ values  # seq_len_from, d_model\n    return bases.VectorInBasis(sorted(self.residual_space.basis), magnitudes)\n\n  def w_ov_residual(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Wov but acting on the residual space.\"\"\"\n    x = project(self.residual_space, self.w_ov.input_space)(x)\n    out = self.w_ov(x)\n    return project(self.w_ov.output_space, self.residual_space)(out)\n\n  @property\n  def num_heads(self) -> int:\n    return 1\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return MultiAttentionHead([self])\n\n\n@dataclasses.dataclass\nclass MultiAttentionHead(Block):\n  \"\"\"Applies attention heads in parallel.\"\"\"\n  sub_blocks: List[Union[AttentionHead, \"MultiAttentionHead\"]]\n\n  def __post_init__(self):\n    spaces = [block.residual_space for block in self.sub_blocks]\n    self.residual_space, *others = spaces\n    assert all(s == self.residual_space for s in others)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    # each element is seq_len x embedding\n    outs = [block.apply(x) for block in self.sub_blocks]\n    return bases.VectorInBasis.sum(outs)  # seq_len x embedding\n\n  @property\n  def num_heads(self) -> int:\n    return sum(sub_block.num_heads for sub_block in self.sub_blocks)\n\n  def heads(self) -> Iterable[AttentionHead]:\n    for sub_block in self.sub_blocks:\n      if isinstance(sub_block, AttentionHead):\n        yield sub_block\n      elif isinstance(sub_block, MultiAttentionHead):\n        yield from sub_block.heads()\n      else:\n        raise NotImplementedError()\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return self\n\n\n@dataclasses.dataclass\nclass MLP(Block):\n  \"\"\"A transformer MLP block.\"\"\"\n  fst: vectorspace_fns.Linear\n  snd: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n\n  def __post_init__(self):\n    \"\"\"Typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.fst.input_space,\n                                                     self.snd.output_space)\n\n    assert self.fst.output_space == self.snd.input_space\n    assert self.fst.input_space.issubspace(self.residual_space)\n    assert self.snd.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    assert x in self.residual_space\n\n    x = project(self.residual_space, self.fst.input_space)(x)\n    hidden = self.fst(x)\n    hidden = relu(hidden)\n    out = self.snd(hidden)\n    return project(self.snd.output_space, self.residual_space)(out)\n\n  @classmethod\n  def combine_in_parallel(cls, mlps: Sequence[\"MLP\"]) -> \"MLP\":"
  },
  {
    "id": "184",
    "text": ".craft import vectorspace_fns\n\nproject = vectorspace_fns.project\n\n\ndef _np_softmax(x, axis=-1):\n  x_max = np.max(x, axis=axis, keepdims=True)\n  return np.exp(x - x_max) / np.sum(np.exp(x - x_max), axis=axis, keepdims=True)\n\n\ndef _np_relu(x):\n  return np.where(x > 0, x, 0)\n\n\ndef relu(x: bases.VectorInBasis) -> bases.VectorInBasis:\n  return bases.VectorInBasis(x.basis_directions, _np_relu(x.magnitudes))\n\n\nclass Block(abc.ABC):\n  \"\"\"Transformer block, acting on a sequence of vector space elements.\n\n  Attributes:\n    residual_space: Vector space that contains all subspaces the Block interacts\n      with. This can be either the full residual space of a model or a subspace.\n  \"\"\"\n  residual_space: bases.VectorSpaceWithBasis\n\n  @abc.abstractmethod\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Applies self to an input.\"\"\"\n\n\n@dataclasses.dataclass\nclass AttentionHead(Block):\n  \"\"\"A transformer attention head.\"\"\"\n  w_qk: vectorspace_fns.ScalarBilinear\n  w_ov: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n  causal: bool = False\n\n  def __post_init__(self):\n    \"\"\"Infer residual stream and typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.w_qk.left_space,\n                                                     self.w_qk.right_space,\n                                                     self.w_ov.input_space,\n                                                     self.w_ov.output_space)\n\n    assert self.w_qk.left_space.issubspace(self.residual_space)\n    assert self.w_qk.right_space.issubspace(self.residual_space)\n    assert self.w_ov.input_space.issubspace(self.residual_space)\n    assert self.w_ov.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    assert x in self.residual_space\n    # seq_len x query_space\n    queries = x.project(self.w_qk.left_space)\n    # seq_len x key_space\n    keys = x.project(self.w_qk.right_space)\n\n    attn_matrix = queries.magnitudes @ self.w_qk.matrix @ keys.magnitudes.T\n\n    if self.causal:\n      # The 1 gives us the matrix above the diagonal.\n      mask = np.triu(np.full_like(attn_matrix, -np.inf), 1)\n      attn_matrix = attn_matrix + mask\n\n    attn_weights = _np_softmax(attn_matrix)  # seq_len_from, seq_len_to\n    values = self.w_ov_residual(x).magnitudes  # seq_len_to, d_model\n\n    magnitudes = attn_weights @ values  # seq_len_from, d_model\n    return bases.VectorInBasis(sorted(self.residual_space.basis), magnitudes)\n\n  def w_ov_residual(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    \"\"\"Wov but acting on the residual space.\"\"\"\n    x = project(self.residual_space, self.w_ov.input_space)(x)\n    out = self.w_ov(x)\n    return project(self.w_ov.output_space, self.residual_space)(out)\n\n  @property\n  def num_heads(self) -> int:\n    return 1\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return MultiAttentionHead([self])\n\n\n@dataclasses.dataclass\nclass MultiAttentionHead(Block):\n  \"\"\"Applies attention heads in parallel.\"\"\"\n  sub_blocks: List[Union[AttentionHead, \"MultiAttentionHead\"]]\n\n  def __post_init__(self):\n    spaces = [block.residual_space for block in self.sub_blocks]\n    self.residual_space, *others = spaces\n    assert all(s == self.residual_space for s in others)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    # each element is seq_len x embedding\n    outs = [block.apply(x) for block in self.sub_blocks]\n    return bases.VectorInBasis.sum(outs)  # seq_len x embedding\n\n  @property\n  def num_heads(self) -> int:\n    return sum(sub_block.num_heads for sub_block in self.sub_blocks)\n\n  def heads(self) -> Iterable[AttentionHead]:\n    for sub_block in self.sub_blocks:\n      if isinstance(sub_block, AttentionHead):\n        yield sub_block\n      elif isinstance(sub_block, MultiAttentionHead):\n        yield from sub_block.heads()\n      else:\n        raise NotImplementedError()\n\n  def as_multi(self) -> \"MultiAttentionHead\":\n    return self\n\n\n@dataclasses.dataclass\nclass MLP(Block):\n  \"\"\"A transformer MLP block.\"\"\"\n  fst: vectorspace_fns.Linear\n  snd: vectorspace_fns.Linear\n  residual_space: Optional[bases.VectorSpaceWithBasis] = None\n\n  def __post_init__(self):\n    \"\"\"Typecheck subspaces.\"\"\"\n    if self.residual_space is None:\n      self.residual_space = bases.join_vector_spaces(self.fst.input_space,\n                                                     self.snd.output_space)\n\n    assert self.fst.output_space == self.snd.input_space\n    assert self.fst.input_space.issubspace(self.residual_space)\n    assert self.snd.output_space.issubspace(self.residual_space)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:\n    assert x in self.residual_space\n\n    x = project(self.residual_space, self.fst.input_space)(x)\n    hidden = self.fst(x)\n    hidden = relu(hidden)\n    out = self.snd(hidden)\n    return project(self.snd.output_space, self.residual_space)(out)\n\n  @classmethod\n  def combine_in_parallel(cls, mlps: Sequence[\"MLP\"]) -> \"MLP\":\n    fst = vectorspace_fns.Linear.combine_in_parallel(\n        [block.fst for block in mlps])\n    snd = vectorspace_fns.Linear.combine_in_parallel(\n        [block.snd for block in mlps])\n    return cls(fst=fst, snd=snd, residual_space=None)\n\n\n# Block that fits into a half-layer, without residual connections.\nHalfLayerBlock = Union[MLP, AttentionHead, MultiAttentionHead]\n\n\n@dataclasses.dataclass\nclass SeriesWithResiduals(Block):\n  \"\"\"A series of blocks with residual connections.\"\"\"\n  blocks: List[HalfLayerBlock]\n\n  def __post_init__(self):\n    spaces = [block.residual_space for block in self.blocks]\n    self.residual_space = bases.join_vector_spaces(*spaces)\n\n  def apply(self, x: bases.VectorInBasis) -> bases.VectorInBasis:"
  },
  {
    "id": "185",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Helpers for handling errors in user-provided functions.\"\"\"\n\nimport functools\nimport logging\nfrom typing import Any, Callable\n\n\ndef ignoring_arithmetic_errors(fun: Callable[..., Any]) -> Callable[..., Any]:\n  \"\"\"Makes fun return None instead of raising ArithmeticError.\"\"\"\n\n  @functools.wraps(fun)"
  },
  {
    "id": "186",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Helpers for handling errors in user-provided functions.\"\"\"\n\nimport functools\nimport logging\nfrom typing import Any, Callable\n\n\ndef ignoring_arithmetic_errors(fun: Callable[..., Any]) -> Callable[..., Any]:\n  \"\"\"Makes fun return None instead of raising ArithmeticError.\"\"\"\n\n  @functools.wraps(fun)\n  def fun_wrapped(*args):"
  },
  {
    "id": "187",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import compressed_model\nfrom tracr.transformer import model\n\n\nclass CompressedTransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"compressed_transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"compressed_transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"compressed_transformer/layer_{i}/layer_norm\""
  },
  {
    "id": "188",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import compressed_model\nfrom tracr.transformer import model\n\n\nclass CompressedTransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"compressed_transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"compressed_transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"compressed_transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"compressed_transformer\")\n      if len(levels) == 1:\n        self.assertEqual(list(params[key].keys()), [\"w_emb\"])\n        continue\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):"
  },
  {
    "id": "189",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import compressed_model\nfrom tracr.transformer import model\n\n\nclass CompressedTransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"compressed_transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"compressed_transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"compressed_transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"compressed_transformer\")\n      if len(levels) == 1:\n        self.assertEqual(list(params[key].keys()), [\"w_emb\"])\n        continue\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):"
  },
  {
    "id": "190",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import compressed_model\nfrom tracr.transformer import model\n\n\nclass CompressedTransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"compressed_transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"compressed_transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"compressed_transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"compressed_transformer\")\n      if len(levels) == 1:\n        self.assertEqual(list(params[key].keys()), [\"w_emb\"])\n        continue\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):"
  },
  {
    "id": "191",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import compressed_model\nfrom tracr.transformer import model\n\n\nclass CompressedTransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"compressed_transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"compressed_transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"compressed_transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"compressed_transformer\")\n      if len(levels) == 1:\n        self.assertEqual(list(params[key].keys()), [\"w_emb\"])\n        continue\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=False,\n              causal=causal))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    emb[:, 0, :] = 0\n    mask = np.array([[1, 0, 1, 1]])\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params = self._zero_mlps(params)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if causal:\n      self.assertEqual(0, out[0, 0, 0])\n      self.assertEqual(emb[0, 1, 0], out[0, 1, 0])\n    else:\n      self.assertNotEqual(0, out[0, 0, 0])\n      self.assertNotEqual(emb[0, 1, 0], out[0, 1, 0])\n    self.assertNotEqual(emb[0, 2, 0], out[0, 2, 0])\n    self.assertNotEqual(emb[0, 3, 0], out[0, 3, 0])\n\n  def test_setting_activation_function_to_zero(self):\n    # An activation function that always returns zeros should result in the\n    # same model output as setting all MLP weights to zero.\n\n    @hk.transform\n    def forward_zero(emb, mask):"
  },
  {
    "id": "192",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import compressed_model\nfrom tracr.transformer import model\n\n\nclass CompressedTransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"compressed_transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"compressed_transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"compressed_transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"compressed_transformer\")\n      if len(levels) == 1:\n        self.assertEqual(list(params[key].keys()), [\"w_emb\"])\n        continue\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=False,\n              causal=causal))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    emb[:, 0, :] = 0\n    mask = np.array([[1, 0, 1, 1]])\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params = self._zero_mlps(params)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if causal:\n      self.assertEqual(0, out[0, 0, 0])\n      self.assertEqual(emb[0, 1, 0], out[0, 1, 0])\n    else:\n      self.assertNotEqual(0, out[0, 0, 0])\n      self.assertNotEqual(emb[0, 1, 0], out[0, 1, 0])\n    self.assertNotEqual(emb[0, 2, 0], out[0, 2, 0])\n    self.assertNotEqual(emb[0, 3, 0], out[0, 3, 0])\n\n  def test_setting_activation_function_to_zero(self):\n    # An activation function that always returns zeros should result in the\n    # same model output as setting all MLP weights to zero.\n\n    @hk.transform\n    def forward_zero(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jnp.zeros_like))\n      return transformer(emb, mask).output\n\n    @hk.transform\n    def forward(emb, mask):"
  },
  {
    "id": "193",
    "text": "zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=False,\n              causal=causal))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    emb[:, 0, :] = 0\n    mask = np.array([[1, 0, 1, 1]])\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params = self._zero_mlps(params)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if causal:\n      self.assertEqual(0, out[0, 0, 0])\n      self.assertEqual(emb[0, 1, 0], out[0, 1, 0])\n    else:\n      self.assertNotEqual(0, out[0, 0, 0])\n      self.assertNotEqual(emb[0, 1, 0], out[0, 1, 0])\n    self.assertNotEqual(emb[0, 2, 0], out[0, 2, 0])\n    self.assertNotEqual(emb[0, 3, 0], out[0, 3, 0])\n\n  def test_setting_activation_function_to_zero(self):\n    # An activation function that always returns zeros should result in the\n    # same model output as setting all MLP weights to zero.\n\n    @hk.transform\n    def forward_zero(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jnp.zeros_like))\n      return transformer(emb, mask).output\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jax.nn.gelu))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    mask = np.ones((1, seq_len))\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params_no_mlps = self._zero_mlps(params)\n\n    out_zero_activation = forward_zero.apply(params, next(rng), emb, mask)\n    out_no_mlps = forward.apply(params_no_mlps, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    np.testing.assert_allclose(out_zero_activation, out_no_mlps)\n    self.assertFalse(np.allclose(out_zero_activation, 0))\n\n  def test_not_setting_embedding_size_produces_same_output_as_default_model(\n      self):\n    config = model.TransformerConfig(\n        num_heads=2,\n        num_layers=2,\n        key_size=5,\n        mlp_hidden_size=64,\n        dropout_rate=0.,\n        causal=False,\n        layer_norm=False)\n\n    @hk.without_apply_rng\n    @hk.transform\n    def forward_model(emb, mask):\n      return model.Transformer(config)(emb, mask).output\n\n    @hk.without_apply_rng\n    @hk.transform\n    def forward_superposition(emb, mask):\n      return compressed_model.CompressedTransformer(config)(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    mask = np.ones((1, seq_len))\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward_model.init(next(rng), emb, mask)\n    params_superposition = {\n        k.replace(\"transformer\", \"compressed_transformer\"): v\n        for k, v in params.items()\n    }\n\n    out_model = forward_model.apply(params, emb, mask)\n    out_superposition = forward_superposition.apply(params_superposition, emb,\n                                                    mask)\n\n    self._check_layer_naming(params_superposition)\n    np.testing.assert_allclose(out_model, out_superposition)\n\n  @parameterized.parameters(\n      dict(embedding_size=2, unembed_at_every_layer=True),\n      dict(embedding_size=2, unembed_at_every_layer=False),\n      dict(embedding_size=6, unembed_at_every_layer=True),\n      dict(embedding_size=6, unembed_at_every_layer=False))\n  def test_embbeding_size_produces_correct_shape_of_residuals_and_layer_outputs(\n      self, embedding_size, unembed_at_every_layer):\n\n    @hk.transform\n    def forward(emb, mask):"
  },
  {
    "id": "194",
    "text": ").output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    emb[:, 0, :] = 0\n    mask = np.array([[1, 0, 1, 1]])\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params = self._zero_mlps(params)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if causal:\n      self.assertEqual(0, out[0, 0, 0])\n      self.assertEqual(emb[0, 1, 0], out[0, 1, 0])\n    else:\n      self.assertNotEqual(0, out[0, 0, 0])\n      self.assertNotEqual(emb[0, 1, 0], out[0, 1, 0])\n    self.assertNotEqual(emb[0, 2, 0], out[0, 2, 0])\n    self.assertNotEqual(emb[0, 3, 0], out[0, 3, 0])\n\n  def test_setting_activation_function_to_zero(self):\n    # An activation function that always returns zeros should result in the\n    # same model output as setting all MLP weights to zero.\n\n    @hk.transform\n    def forward_zero(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jnp.zeros_like))\n      return transformer(emb, mask).output\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jax.nn.gelu))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    mask = np.ones((1, seq_len))\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params_no_mlps = self._zero_mlps(params)\n\n    out_zero_activation = forward_zero.apply(params, next(rng), emb, mask)\n    out_no_mlps = forward.apply(params_no_mlps, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    np.testing.assert_allclose(out_zero_activation, out_no_mlps)\n    self.assertFalse(np.allclose(out_zero_activation, 0))\n\n  def test_not_setting_embedding_size_produces_same_output_as_default_model(\n      self):\n    config = model.TransformerConfig(\n        num_heads=2,\n        num_layers=2,\n        key_size=5,\n        mlp_hidden_size=64,\n        dropout_rate=0.,\n        causal=False,\n        layer_norm=False)\n\n    @hk.without_apply_rng\n    @hk.transform\n    def forward_model(emb, mask):\n      return model.Transformer(config)(emb, mask).output\n\n    @hk.without_apply_rng\n    @hk.transform\n    def forward_superposition(emb, mask):\n      return compressed_model.CompressedTransformer(config)(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    mask = np.ones((1, seq_len))\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward_model.init(next(rng), emb, mask)\n    params_superposition = {\n        k.replace(\"transformer\", \"compressed_transformer\"): v\n        for k, v in params.items()\n    }\n\n    out_model = forward_model.apply(params, emb, mask)\n    out_superposition = forward_superposition.apply(params_superposition, emb,\n                                                    mask)\n\n    self._check_layer_naming(params_superposition)\n    np.testing.assert_allclose(out_model, out_superposition)\n\n  @parameterized.parameters(\n      dict(embedding_size=2, unembed_at_every_layer=True),\n      dict(embedding_size=2, unembed_at_every_layer=False),\n      dict(embedding_size=6, unembed_at_every_layer=True),\n      dict(embedding_size=6, unembed_at_every_layer=False))\n  def test_embbeding_size_produces_correct_shape_of_residuals_and_layer_outputs(\n      self, embedding_size, unembed_at_every_layer):\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = compressed_model.CompressedTransformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False))\n      return transformer(\n          emb,\n          mask,\n          embedding_size=embedding_size,\n          unembed_at_every_layer=unembed_at_every_layer,\n      )\n\n    seq_len = 4\n    model_size = 16\n\n    emb = np.random.random((1, seq_len, model_size))\n    mask = np.ones((1, seq_len))\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    activations = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n\n    for residual in activations.residuals:\n      self.assertEqual(residual.shape, (1, seq_len, embedding_size))\n\n    for layer_output in activations.layer_outputs:\n      self.assertEqual(layer_output.shape, (1, seq_len, model_size))\n\n  @parameterized.parameters(\n      dict(model_size=2, unembed_at_every_layer=True),\n      dict(model_size=2, unembed_at_every_layer=False),\n      dict(model_size=6, unembed_at_every_layer=True),\n      dict(model_size=6, unembed_at_every_layer=False))\n  def test_identity_embedding_produces_same_output_as_standard_model(\n      self, model_size, unembed_at_every_layer):\n\n    config = model.TransformerConfig(\n        num_heads=2,\n        num_layers=2,\n        key_size=5,\n        mlp_hidden_size=64,\n        dropout_rate=0.,\n        causal=False,\n        layer_norm=False)\n\n    @hk.without_apply_rng\n    @hk.transform\n    def forward_model(emb, mask):\n      return model.Transformer(config)(emb, mask).output\n\n    @hk.without_apply_rng\n    @hk.transform\n    def forward_superposition(emb, mask):"
  },
  {
    "id": "195",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Didactic example of an autoregressive Transformer-based language model.\n\nGlossary of shapes:\n- B: Batch size.\n- T: Sequence length.\n- D: Model embedding size.\n- H: Number of attention heads.\n- V: Vocabulary size.\n\nForked from: haiku.examples.transformer.model\n\"\"\"\n\nimport collections\nimport dataclasses\nfrom typing import Callable, List, Optional\n\nimport chex\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import attention\n\n# hk.Modules are not always callable: github.com/deepmind/dm-haiku/issues/52\n# Ideally, we'd want a type:\n# CallableHaikuModule = Intersection[Callable[..., jax.Array], hk.Module]\n# But Intersection does not exist (yet): github.com/python/typing/issues/213\nCallableHaikuModule = Callable[..., jax.Array]\n\n\n@chex.dataclass\nclass TransformerOutput:\n  layer_outputs: List[jax.Array]  # [B, T, D]\n  residuals: List[jax.Array]  # [B, T, D]\n  attn_logits: List[jax.Array]  # [B, H, T, T]\n  output: jax.Array  # [B, T, D]\n  input_embeddings: jax.Array  # [B, T, D]\n\n\n@dataclasses.dataclass\nclass TransformerConfig:\n  num_heads: int\n  num_layers: int\n  key_size: int\n  mlp_hidden_size: int\n  dropout_rate: float\n  activation_function: Callable[[jax.Array], jax.Array] = jax.nn.gelu\n  layer_norm: bool = True\n  causal: bool = False\n\n\n@dataclasses.dataclass\nclass Transformer(hk.Module):\n  \"\"\"A transformer stack.\"\"\"\n\n  config: TransformerConfig\n  name: Optional[str] = None\n\n  def __call__(\n      self,\n      embeddings: jax.Array,  # [B, T, D]\n      mask: jax.Array,  # [B, T]\n      *,\n      use_dropout: bool = True,\n  ) -> TransformerOutput:\n    \"\"\"Transforms input embedding sequences to output embedding sequences.\"\"\"\n\n    def layer_norm(x: jax.Array) -> jax.Array:\n      \"\"\"Applies a unique LayerNorm to x with default settings.\"\"\""
  },
  {
    "id": "196",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Didactic example of an autoregressive Transformer-based language model.\n\nGlossary of shapes:\n- B: Batch size.\n- T: Sequence length.\n- D: Model embedding size.\n- H: Number of attention heads.\n- V: Vocabulary size.\n\nForked from: haiku.examples.transformer.model\n\"\"\"\n\nimport collections\nimport dataclasses\nfrom typing import Callable, List, Optional\n\nimport chex\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import attention\n\n# hk.Modules are not always callable: github.com/deepmind/dm-haiku/issues/52\n# Ideally, we'd want a type:\n# CallableHaikuModule = Intersection[Callable[..., jax.Array], hk.Module]\n# But Intersection does not exist (yet): github.com/python/typing/issues/213\nCallableHaikuModule = Callable[..., jax.Array]\n\n\n@chex.dataclass\nclass TransformerOutput:\n  layer_outputs: List[jax.Array]  # [B, T, D]\n  residuals: List[jax.Array]  # [B, T, D]\n  attn_logits: List[jax.Array]  # [B, H, T, T]\n  output: jax.Array  # [B, T, D]\n  input_embeddings: jax.Array  # [B, T, D]\n\n\n@dataclasses.dataclass\nclass TransformerConfig:\n  num_heads: int\n  num_layers: int\n  key_size: int\n  mlp_hidden_size: int\n  dropout_rate: float\n  activation_function: Callable[[jax.Array], jax.Array] = jax.nn.gelu\n  layer_norm: bool = True\n  causal: bool = False\n\n\n@dataclasses.dataclass\nclass Transformer(hk.Module):\n  \"\"\"A transformer stack.\"\"\"\n\n  config: TransformerConfig\n  name: Optional[str] = None\n\n  def __call__(\n      self,\n      embeddings: jax.Array,  # [B, T, D]\n      mask: jax.Array,  # [B, T]\n      *,\n      use_dropout: bool = True,\n  ) -> TransformerOutput:\n    \"\"\"Transforms input embedding sequences to output embedding sequences.\"\"\"\n\n    def layer_norm(x: jax.Array) -> jax.Array:\n      \"\"\"Applies a unique LayerNorm to x with default settings.\"\"\"\n      if self.config.layer_norm:\n        return hk.LayerNorm(axis=-1, create_scale=True, create_offset=True)(x)\n      return x\n\n    initializer = hk.initializers.VarianceScaling(2 / self.config.num_layers)\n    dropout_rate = self.config.dropout_rate if use_dropout else 0.\n    _, seq_len, model_size = embeddings.shape\n\n    # Compute causal mask for autoregressive sequence modelling.\n    mask = mask[:, None, None, :]  # [B, H=1, T'=1, T]\n    mask = mask.repeat(seq_len, axis=2)  # [B, H=1, T, T]\n\n    if self.config.causal:\n      causal_mask = np.ones((1, 1, seq_len, seq_len))  # [B=1, H=1, T, T]\n      causal_mask = np.tril(causal_mask)\n      mask = mask * causal_mask  # [B, H=1, T, T]\n\n    # Set up activation collection.\n    collected = collections.defaultdict(list)\n\n    def collect(**kwargs):\n      for k, v in kwargs.items():\n        collected[k].append(v)\n\n    residual = embeddings\n    for layer in range(self.config.num_layers):\n      with hk.experimental.name_scope(f\"layer_{layer}\"):\n        # First the attention block.\n        attn_block = attention.MultiHeadAttention(\n            num_heads=self.config.num_heads,\n            key_size=self.config.key_size,\n            model_size=model_size,\n            w_init=initializer,\n            name=\"attn\")\n        attn_in = layer_norm(residual)\n        attn_out = attn_block(attn_in, attn_in, attn_in, mask=mask)\n        attn_out, attn_logits = attn_out.out, attn_out.logits\n        if dropout_rate > 0:\n          attn_out = hk.dropout(hk.next_rng_key(), dropout_rate, attn_out)\n        residual = residual + attn_out\n\n        collect(\n            residuals=residual, layer_outputs=attn_out, attn_logits=attn_logits)\n\n        # Then the dense block.\n        with hk.experimental.name_scope(\"mlp\"):\n          dense_block = hk.Sequential([\n              hk.Linear(\n                  self.config.mlp_hidden_size,\n                  w_init=initializer,\n                  name=\"linear_1\"),\n              self.config.activation_function,\n              hk.Linear(model_size, w_init=initializer, name=\"linear_2\"),\n          ])\n        dense_in = layer_norm(residual)\n        dense_out = dense_block(dense_in)\n        if dropout_rate > 0:\n          dense_out = hk.dropout(hk.next_rng_key(), dropout_rate, dense_out)\n        residual = residual + dense_out\n\n        collect(residuals=residual, layer_outputs=dense_out)\n\n    return TransformerOutput(\n        residuals=collected[\"residuals\"],\n        layer_outputs=collected[\"layer_outputs\"],\n        attn_logits=collected[\"attn_logits\"],\n        output=layer_norm(residual),\n        input_embeddings=embeddings,\n    )\n\n\n@chex.dataclass\nclass CompiledTransformerModelOutput:\n  transformer_output: TransformerOutput\n  unembedded_output: jax.Array  # [B, T]\n\n\n@dataclasses.dataclass\nclass CompiledTransformerModel(hk.Module):\n  \"\"\"A transformer model with one-hot embeddings.\"\"\"\n  transformer: Transformer\n  token_embed: CallableHaikuModule\n  position_embed: CallableHaikuModule\n  unembed: CallableHaikuModule\n  use_unembed_argmax: bool\n  pad_token: Optional[int] = None\n\n  def embed(self, tokens: jax.Array) -> jax.Array:"
  },
  {
    "id": "197",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Didactic example of an autoregressive Transformer-based language model.\n\nGlossary of shapes:\n- B: Batch size.\n- T: Sequence length.\n- D: Model embedding size.\n- H: Number of attention heads.\n- V: Vocabulary size.\n\nForked from: haiku.examples.transformer.model\n\"\"\"\n\nimport collections\nimport dataclasses\nfrom typing import Callable, List, Optional\n\nimport chex\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import attention\n\n# hk.Modules are not always callable: github.com/deepmind/dm-haiku/issues/52\n# Ideally, we'd want a type:\n# CallableHaikuModule = Intersection[Callable[..., jax.Array], hk.Module]\n# But Intersection does not exist (yet): github.com/python/typing/issues/213\nCallableHaikuModule = Callable[..., jax.Array]\n\n\n@chex.dataclass\nclass TransformerOutput:\n  layer_outputs: List[jax.Array]  # [B, T, D]\n  residuals: List[jax.Array]  # [B, T, D]\n  attn_logits: List[jax.Array]  # [B, H, T, T]\n  output: jax.Array  # [B, T, D]\n  input_embeddings: jax.Array  # [B, T, D]\n\n\n@dataclasses.dataclass\nclass TransformerConfig:\n  num_heads: int\n  num_layers: int\n  key_size: int\n  mlp_hidden_size: int\n  dropout_rate: float\n  activation_function: Callable[[jax.Array], jax.Array] = jax.nn.gelu\n  layer_norm: bool = True\n  causal: bool = False\n\n\n@dataclasses.dataclass\nclass Transformer(hk.Module):\n  \"\"\"A transformer stack.\"\"\"\n\n  config: TransformerConfig\n  name: Optional[str] = None\n\n  def __call__(\n      self,\n      embeddings: jax.Array,  # [B, T, D]\n      mask: jax.Array,  # [B, T]\n      *,\n      use_dropout: bool = True,\n  ) -> TransformerOutput:\n    \"\"\"Transforms input embedding sequences to output embedding sequences.\"\"\"\n\n    def layer_norm(x: jax.Array) -> jax.Array:\n      \"\"\"Applies a unique LayerNorm to x with default settings.\"\"\"\n      if self.config.layer_norm:\n        return hk.LayerNorm(axis=-1, create_scale=True, create_offset=True)(x)\n      return x\n\n    initializer = hk.initializers.VarianceScaling(2 / self.config.num_layers)\n    dropout_rate = self.config.dropout_rate if use_dropout else 0.\n    _, seq_len, model_size = embeddings.shape\n\n    # Compute causal mask for autoregressive sequence modelling.\n    mask = mask[:, None, None, :]  # [B, H=1, T'=1, T]\n    mask = mask.repeat(seq_len, axis=2)  # [B, H=1, T, T]\n\n    if self.config.causal:\n      causal_mask = np.ones((1, 1, seq_len, seq_len))  # [B=1, H=1, T, T]\n      causal_mask = np.tril(causal_mask)\n      mask = mask * causal_mask  # [B, H=1, T, T]\n\n    # Set up activation collection.\n    collected = collections.defaultdict(list)\n\n    def collect(**kwargs):\n      for k, v in kwargs.items():\n        collected[k].append(v)\n\n    residual = embeddings\n    for layer in range(self.config.num_layers):\n      with hk.experimental.name_scope(f\"layer_{layer}\"):\n        # First the attention block.\n        attn_block = attention.MultiHeadAttention(\n            num_heads=self.config.num_heads,\n            key_size=self.config.key_size,\n            model_size=model_size,\n            w_init=initializer,\n            name=\"attn\")\n        attn_in = layer_norm(residual)\n        attn_out = attn_block(attn_in, attn_in, attn_in, mask=mask)\n        attn_out, attn_logits = attn_out.out, attn_out.logits\n        if dropout_rate > 0:\n          attn_out = hk.dropout(hk.next_rng_key(), dropout_rate, attn_out)\n        residual = residual + attn_out\n\n        collect(\n            residuals=residual, layer_outputs=attn_out, attn_logits=attn_logits)\n\n        # Then the dense block.\n        with hk.experimental.name_scope(\"mlp\"):\n          dense_block = hk.Sequential([\n              hk.Linear(\n                  self.config.mlp_hidden_size,\n                  w_init=initializer,\n                  name=\"linear_1\"),\n              self.config.activation_function,\n              hk.Linear(model_size, w_init=initializer, name=\"linear_2\"),\n          ])\n        dense_in = layer_norm(residual)\n        dense_out = dense_block(dense_in)\n        if dropout_rate > 0:\n          dense_out = hk.dropout(hk.next_rng_key(), dropout_rate, dense_out)\n        residual = residual + dense_out\n\n        collect(residuals=residual, layer_outputs=dense_out)\n\n    return TransformerOutput(\n        residuals=collected[\"residuals\"],\n        layer_outputs=collected[\"layer_outputs\"],\n        attn_logits=collected[\"attn_logits\"],\n        output=layer_norm(residual),\n        input_embeddings=embeddings,\n    )\n\n\n@chex.dataclass\nclass CompiledTransformerModelOutput:\n  transformer_output: TransformerOutput\n  unembedded_output: jax.Array  # [B, T]\n\n\n@dataclasses.dataclass\nclass CompiledTransformerModel(hk.Module):\n  \"\"\"A transformer model with one-hot embeddings.\"\"\"\n  transformer: Transformer\n  token_embed: CallableHaikuModule\n  position_embed: CallableHaikuModule\n  unembed: CallableHaikuModule\n  use_unembed_argmax: bool\n  pad_token: Optional[int] = None\n\n  def embed(self, tokens: jax.Array) -> jax.Array:\n    token_embeddings = self.token_embed(tokens)\n    positional_embeddings = self.position_embed(jnp.indices(tokens.shape)[-1])\n    return token_embeddings + positional_embeddings  # [B, T, D]\n\n  def __call__(\n      self,\n      tokens: jax.Array,\n      use_dropout: bool = True,\n  ) -> CompiledTransformerModelOutput:\n    \"\"\"Embed tokens, pass through model, and unembed output.\"\"\""
  },
  {
    "id": "198",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Modified transformer to learn a linear compression of the residual stream.\n\nCompressedTransformer adds three arguments compared to Transformer:\n- embedding_size: the size of the compressed residual stream.\n- unembed_at_every_layer: whether to apply the unembedding before applying\n    attention and MLP layers\n- return_activations: whether to return all model activations rather than just\n    the outputs\n\"\"\"\n\nimport collections\nimport dataclasses\nfrom typing import Optional\n\nimport haiku as hk\nimport jax\nimport numpy as np\n\nfrom tracr.transformer import attention\nfrom tracr.transformer import model\n\n\n@dataclasses.dataclass\nclass CompressedTransformer(hk.Module):\n  \"\"\"A transformer stack with linearly compressed residual stream.\"\"\"\n\n  config: model.TransformerConfig\n  name: Optional[str] = None\n\n  def __call__(\n      self,\n      embeddings: jax.Array,  # [B, T, D]\n      mask: jax.Array,  # [B, T]\n      *,\n      use_dropout: bool = True,\n      embedding_size: Optional[int] = None,\n      unembed_at_every_layer: bool = False,\n  ) -> model.TransformerOutput:  # [B, T, D]\n    \"\"\"Transforms input embedding sequences to output embedding sequences.\n\n    Args:\n      embeddings: Input embeddings to pass through the model.\n      mask: Boolean mask to restrict the inputs the model uses.\n      use_dropout: Turns dropout on/off.\n      embedding_size: Dimension to compress the residual stream to.\n      unembed_at_every_layer: Whether to unembed the residual stream when\n        reading the input for every layer (keeping the layer input sizes) or to\n        only unembed before the model output (compressing the layer inputs).\n\n    Returns:\n      The outputs of the forward pass through the transformer.\n    \"\"\"\n\n    def layer_norm(x: jax.Array) -> jax.Array:\n      \"\"\"Applies a unique LayerNorm to x with default settings.\"\"\""
  },
  {
    "id": "199",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Basic encoder for inputs with a fixed vocabulary.\"\"\"\n\nimport abc\nfrom typing import Any, List, Optional, Sequence\n\nfrom tracr.craft import bases\n\n\nclass Encoder(abc.ABC):\n  \"\"\"Encodes a list of tokens into a list of inputs for a transformer model.\n\n  The abstract class does not make assumptions on the input and output types,\n  and we have different encoders for different input types.\n  \"\"\"\n\n  @abc.abstractmethod\n  def encode(self, inputs: List[Any]) -> List[Any]:\n    return list()\n\n  @abc.abstractmethod\n  def decode(self, encodings: List[Any]) -> List[Any]:\n    return list()\n\n  @property\n  def pad_token(self) -> Optional[str]:\n    return None\n\n  @property\n  def bos_token(self) -> Optional[str]:\n    return None\n\n  @property\n  def pad_encoding(self) -> Optional[int]:\n    return None\n\n  @property\n  def bos_encoding(self) -> Optional[int]:\n    return None\n\n\nclass NumericalEncoder(Encoder):\n  \"\"\"Encodes numerical variables (simply using the identity mapping).\"\"\"\n\n  def encode(self, inputs: List[float]) -> List[float]:\n    return inputs\n\n  def decode(self, encodings: List[float]) -> List[float]:\n    return encodings\n\n\nclass CategoricalEncoder(Encoder):\n  \"\"\"Encodes categorical variables with a fixed vocabulary.\"\"\"\n\n  def __init__(\n      self,\n      basis: Sequence[bases.BasisDirection],\n      enforce_bos: bool = False,\n      bos_token: Optional[str] = None,\n      pad_token: Optional[str] = None,\n      max_seq_len: Optional[int] = None,\n  ):\n    \"\"\"Initialises. If enforce_bos is set, ensures inputs start with it.\"\"\""
  },
  {
    "id": "200",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Basic encoder for inputs with a fixed vocabulary.\"\"\"\n\nimport abc\nfrom typing import Any, List, Optional, Sequence\n\nfrom tracr.craft import bases\n\n\nclass Encoder(abc.ABC):\n  \"\"\"Encodes a list of tokens into a list of inputs for a transformer model.\n\n  The abstract class does not make assumptions on the input and output types,\n  and we have different encoders for different input types.\n  \"\"\"\n\n  @abc.abstractmethod\n  def encode(self, inputs: List[Any]) -> List[Any]:\n    return list()\n\n  @abc.abstractmethod\n  def decode(self, encodings: List[Any]) -> List[Any]:\n    return list()\n\n  @property\n  def pad_token(self) -> Optional[str]:\n    return None\n\n  @property\n  def bos_token(self) -> Optional[str]:\n    return None\n\n  @property\n  def pad_encoding(self) -> Optional[int]:\n    return None\n\n  @property\n  def bos_encoding(self) -> Optional[int]:\n    return None\n\n\nclass NumericalEncoder(Encoder):\n  \"\"\"Encodes numerical variables (simply using the identity mapping).\"\"\"\n\n  def encode(self, inputs: List[float]) -> List[float]:\n    return inputs\n\n  def decode(self, encodings: List[float]) -> List[float]:\n    return encodings\n\n\nclass CategoricalEncoder(Encoder):\n  \"\"\"Encodes categorical variables with a fixed vocabulary.\"\"\"\n\n  def __init__(\n      self,\n      basis: Sequence[bases.BasisDirection],\n      enforce_bos: bool = False,\n      bos_token: Optional[str] = None,\n      pad_token: Optional[str] = None,\n      max_seq_len: Optional[int] = None,\n  ):\n    \"\"\"Initialises. If enforce_bos is set, ensures inputs start with it.\"\"\"\n    if enforce_bos and not bos_token:\n      raise ValueError(\"BOS token must be specified if enforcing BOS.\")\n\n    self.encoding_map = {}\n    for i, direction in enumerate(basis):\n      val = direction.value\n      self.encoding_map[val] = i\n\n    if bos_token and bos_token not in self.encoding_map:\n      raise ValueError(\"BOS token missing in encoding.\")\n\n    if pad_token and pad_token not in self.encoding_map:\n      raise ValueError(\"PAD token missing in encoding.\")\n\n    self.enforce_bos = enforce_bos\n    self._bos_token = bos_token\n    self._pad_token = pad_token\n    self._max_seq_len = max_seq_len\n\n  def encode(self, inputs: List[bases.Value]) -> List[int]:"
  },
  {
    "id": "201",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Basic encoder for inputs with a fixed vocabulary.\"\"\"\n\nimport abc\nfrom typing import Any, List, Optional, Sequence\n\nfrom tracr.craft import bases\n\n\nclass Encoder(abc.ABC):\n  \"\"\"Encodes a list of tokens into a list of inputs for a transformer model.\n\n  The abstract class does not make assumptions on the input and output types,\n  and we have different encoders for different input types.\n  \"\"\"\n\n  @abc.abstractmethod\n  def encode(self, inputs: List[Any]) -> List[Any]:\n    return list()\n\n  @abc.abstractmethod\n  def decode(self, encodings: List[Any]) -> List[Any]:\n    return list()\n\n  @property\n  def pad_token(self) -> Optional[str]:\n    return None\n\n  @property\n  def bos_token(self) -> Optional[str]:\n    return None\n\n  @property\n  def pad_encoding(self) -> Optional[int]:\n    return None\n\n  @property\n  def bos_encoding(self) -> Optional[int]:\n    return None\n\n\nclass NumericalEncoder(Encoder):\n  \"\"\"Encodes numerical variables (simply using the identity mapping).\"\"\"\n\n  def encode(self, inputs: List[float]) -> List[float]:\n    return inputs\n\n  def decode(self, encodings: List[float]) -> List[float]:\n    return encodings\n\n\nclass CategoricalEncoder(Encoder):\n  \"\"\"Encodes categorical variables with a fixed vocabulary.\"\"\"\n\n  def __init__(\n      self,\n      basis: Sequence[bases.BasisDirection],\n      enforce_bos: bool = False,\n      bos_token: Optional[str] = None,\n      pad_token: Optional[str] = None,\n      max_seq_len: Optional[int] = None,\n  ):\n    \"\"\"Initialises. If enforce_bos is set, ensures inputs start with it.\"\"\"\n    if enforce_bos and not bos_token:\n      raise ValueError(\"BOS token must be specified if enforcing BOS.\")\n\n    self.encoding_map = {}\n    for i, direction in enumerate(basis):\n      val = direction.value\n      self.encoding_map[val] = i\n\n    if bos_token and bos_token not in self.encoding_map:\n      raise ValueError(\"BOS token missing in encoding.\")\n\n    if pad_token and pad_token not in self.encoding_map:\n      raise ValueError(\"PAD token missing in encoding.\")\n\n    self.enforce_bos = enforce_bos\n    self._bos_token = bos_token\n    self._pad_token = pad_token\n    self._max_seq_len = max_seq_len\n\n  def encode(self, inputs: List[bases.Value]) -> List[int]:\n    if self.enforce_bos and inputs[0] != self.bos_token:\n      raise ValueError(\"First input token must be BOS token. \"\n                       f\"Should be '{self.bos_token}', but was '{inputs[0]}'.\")\n    if missing := set(inputs) - set(self.encoding_map.keys()):\n      raise ValueError(f\"Inputs {missing} not found in encoding \",\n                       self.encoding_map.keys())\n    if self._max_seq_len is not None and len(inputs) > self._max_seq_len:\n      raise ValueError(f\"inputs={inputs} are longer than the maximum \"\n                       f\"sequence length {self._max_seq_len}\")\n\n    return [self.encoding_map[x] for x in inputs]\n\n  def decode(self, encodings: List[int]) -> List[bases.Value]:\n    \"\"\"Recover the tokens that corresponds to `ids`. Inverse of __call__.\"\"\""
  },
  {
    "id": "202",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import model\n\n\nclass TransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"transformer/layer_{i}/layer_norm\""
  },
  {
    "id": "203",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import model\n\n\nclass TransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"transformer\")\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):"
  },
  {
    "id": "204",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import model\n\n\nclass TransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"transformer\")\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):"
  },
  {
    "id": "205",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import model\n\n\nclass TransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"transformer\")\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):"
  },
  {
    "id": "206",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import model\n\n\nclass TransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"transformer\")\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=False,\n              causal=causal))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    emb[:, 0, :] = 0\n    mask = np.array([[1, 0, 1, 1]])\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params = self._zero_mlps(params)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if causal:\n      self.assertEqual(0, out[0, 0, 0])\n      self.assertEqual(emb[0, 1, 0], out[0, 1, 0])\n    else:\n      self.assertNotEqual(0, out[0, 0, 0])\n      self.assertNotEqual(emb[0, 1, 0], out[0, 1, 0])\n    self.assertNotEqual(emb[0, 2, 0], out[0, 2, 0])\n    self.assertNotEqual(emb[0, 3, 0], out[0, 3, 0])\n\n  def test_setting_activation_function_to_zero(self):\n    # An activation function that always returns zeros should result in the\n    # same model output as setting all MLP weights to zero.\n\n    @hk.transform\n    def forward_zero(emb, mask):"
  },
  {
    "id": "207",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import model\n\n\nclass TransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"transformer\")\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=False,\n              causal=causal))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    emb[:, 0, :] = 0\n    mask = np.array([[1, 0, 1, 1]])\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params = self._zero_mlps(params)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if causal:\n      self.assertEqual(0, out[0, 0, 0])\n      self.assertEqual(emb[0, 1, 0], out[0, 1, 0])\n    else:\n      self.assertNotEqual(0, out[0, 0, 0])\n      self.assertNotEqual(emb[0, 1, 0], out[0, 1, 0])\n    self.assertNotEqual(emb[0, 2, 0], out[0, 2, 0])\n    self.assertNotEqual(emb[0, 3, 0], out[0, 3, 0])\n\n  def test_setting_activation_function_to_zero(self):\n    # An activation function that always returns zeros should result in the\n    # same model output as setting all MLP weights to zero.\n\n    @hk.transform\n    def forward_zero(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jnp.zeros_like))\n      return transformer(emb, mask).output\n\n    @hk.transform\n    def forward(emb, mask):"
  },
  {
    "id": "208",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for transformer.model.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom tracr.transformer import model\n\n\nclass TransformerTest(parameterized.TestCase):\n\n  def _check_layer_naming(self, params):\n    # Modules should be named for example\n    # For MLPs: \"transformer/layer_{i}/mlp/linear_1\"\n    # For Attention: \"transformer/layer_{i}/attn/key\"\n    # For Layer Norm: \"transformer/layer_{i}/layer_norm\"\n    for key in params.keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"transformer\")\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=False,\n              causal=causal))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    emb[:, 0, :] = 0\n    mask = np.array([[1, 0, 1, 1]])\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params = self._zero_mlps(params)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if causal:\n      self.assertEqual(0, out[0, 0, 0])\n      self.assertEqual(emb[0, 1, 0], out[0, 1, 0])\n    else:\n      self.assertNotEqual(0, out[0, 0, 0])\n      self.assertNotEqual(emb[0, 1, 0], out[0, 1, 0])\n    self.assertNotEqual(emb[0, 2, 0], out[0, 2, 0])\n    self.assertNotEqual(emb[0, 3, 0], out[0, 3, 0])\n\n  def test_setting_activation_function_to_zero(self):\n    # An activation function that always returns zeros should result in the\n    # same model output as setting all MLP weights to zero.\n\n    @hk.transform\n    def forward_zero(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jnp.zeros_like))\n      return transformer(emb, mask).output\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jax.nn.gelu))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    mask = np.ones((1, seq_len))\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params_no_mlps = self._zero_mlps(params)\n\n    out_zero_activation = forward_zero.apply(params, next(rng), emb, mask)\n    out_no_mlps = forward.apply(params_no_mlps, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    np.testing.assert_allclose(out_zero_activation, out_no_mlps)\n    self.assertFalse(np.allclose(out_zero_activation, 0))\n\n\nclass CompiledTransformerModelTest(parameterized.TestCase):\n\n  def _get_one_hot_embed_unembed(self, vocab_size, max_seq_len):\n    # Embeds tokens as one-hot into the first `vocab_size` dimensions"
  },
  {
    "id": "209",
    "text": "keys():\n      levels = key.split(\"/\")\n      self.assertEqual(levels[0], \"transformer\")\n      if levels[1].startswith(\"layer_norm\"):\n        continue  # output layer norm\n      self.assertStartsWith(levels[1], \"layer\")\n      if levels[2] == \"mlp\":\n        self.assertIn(levels[3], {\"linear_1\", \"linear_2\"})\n      elif levels[2] == \"attn\":\n        self.assertIn(levels[3], {\"key\", \"query\", \"value\", \"linear\"})\n      else:\n        self.assertStartsWith(levels[2], \"layer_norm\")\n\n  def _zero_mlps(self, params):\n    for module in params:\n      if \"mlp\" in module:\n        for param in params[module]:\n          params[module][param] = jnp.zeros_like(params[module][param])\n    return params\n\n  @parameterized.parameters(dict(layer_norm=True), dict(layer_norm=False))\n  def test_layer_norm(self, layer_norm):\n    # input = [1, 1, 1, 1]\n    # If layer norm is used, this should give all-0 output for a freshly\n    # initialized model because LN will subtract the mean after each layer.\n    # Else we expect non-zero outputs.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=False,\n              causal=causal))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    emb[:, 0, :] = 0\n    mask = np.array([[1, 0, 1, 1]])\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params = self._zero_mlps(params)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if causal:\n      self.assertEqual(0, out[0, 0, 0])\n      self.assertEqual(emb[0, 1, 0], out[0, 1, 0])\n    else:\n      self.assertNotEqual(0, out[0, 0, 0])\n      self.assertNotEqual(emb[0, 1, 0], out[0, 1, 0])\n    self.assertNotEqual(emb[0, 2, 0], out[0, 2, 0])\n    self.assertNotEqual(emb[0, 3, 0], out[0, 3, 0])\n\n  def test_setting_activation_function_to_zero(self):\n    # An activation function that always returns zeros should result in the\n    # same model output as setting all MLP weights to zero.\n\n    @hk.transform\n    def forward_zero(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jnp.zeros_like))\n      return transformer(emb, mask).output\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jax.nn.gelu))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    mask = np.ones((1, seq_len))\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params_no_mlps = self._zero_mlps(params)\n\n    out_zero_activation = forward_zero.apply(params, next(rng), emb, mask)\n    out_no_mlps = forward.apply(params_no_mlps, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    np.testing.assert_allclose(out_zero_activation, out_no_mlps)\n    self.assertFalse(np.allclose(out_zero_activation, 0))\n\n\nclass CompiledTransformerModelTest(parameterized.TestCase):\n\n  def _get_one_hot_embed_unembed(self, vocab_size, max_seq_len):\n    # Embeds tokens as one-hot into the first `vocab_size` dimensions\n    token_embed = hk.Embed(\n        embedding_matrix=jnp.block(\n            [jnp.eye(vocab_size),\n             jnp.zeros((vocab_size, max_seq_len))]))\n\n    # Embeds positions as one-hot into the last `max_seq_len` dimensions\n    position_embed = hk.Embed(\n        embedding_matrix=jnp.block(\n            [jnp.zeros((max_seq_len, vocab_size)),\n             jnp.eye(max_seq_len)]))\n\n    class Unembed(hk.Module):\n\n      def __call__(self, embeddings):\n        return jnp.argmax(embeddings[:, :, :vocab_size], axis=-1)\n\n    return token_embed, position_embed, Unembed()\n\n  def test_embedding_gives_desired_result(self):\n    tokens = jnp.array([[1, 2, 3]])\n    vocab_size, max_seq_len, pad_token = 5, 5, 0\n\n    expected_embeddings = jnp.array([[[0, 1, 0, 0, 0, 1, 0, 0, 0, 0],\n                                      [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                                      [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]]])\n\n    @hk.transform\n    def embed(tokens):"
  },
  {
    "id": "210",
    "text": " key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=layer_norm))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = jnp.ones((1, seq_len, 1))\n    mask = jnp.ones((1, seq_len))\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if layer_norm:\n      np.testing.assert_allclose(out, 0)\n    else:\n      self.assertFalse(np.allclose(out, 0))\n\n  @parameterized.parameters(dict(causal=True), dict(causal=False))\n  def test_causal_attention(self, causal):\n    # input = [0, random, random, random]\n    # mask = [1, 0, 1, 1]\n    # For causal attention the second token can only attend to the first one, so\n    # it should be the same. For non-causal attention all tokens should change.\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              layer_norm=False,\n              causal=causal))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    emb[:, 0, :] = 0\n    mask = np.array([[1, 0, 1, 1]])\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params = self._zero_mlps(params)\n    out = forward.apply(params, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    if causal:\n      self.assertEqual(0, out[0, 0, 0])\n      self.assertEqual(emb[0, 1, 0], out[0, 1, 0])\n    else:\n      self.assertNotEqual(0, out[0, 0, 0])\n      self.assertNotEqual(emb[0, 1, 0], out[0, 1, 0])\n    self.assertNotEqual(emb[0, 2, 0], out[0, 2, 0])\n    self.assertNotEqual(emb[0, 3, 0], out[0, 3, 0])\n\n  def test_setting_activation_function_to_zero(self):\n    # An activation function that always returns zeros should result in the\n    # same model output as setting all MLP weights to zero.\n\n    @hk.transform\n    def forward_zero(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jnp.zeros_like))\n      return transformer(emb, mask).output\n\n    @hk.transform\n    def forward(emb, mask):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jax.nn.gelu))\n      return transformer(emb, mask).output\n\n    seq_len = 4\n    emb = np.random.random((1, seq_len, 1))\n    mask = np.ones((1, seq_len))\n    emb, mask = jnp.array(emb), jnp.array(mask)\n\n    rng = hk.PRNGSequence(1)\n    params = forward.init(next(rng), emb, mask)\n    params_no_mlps = self._zero_mlps(params)\n\n    out_zero_activation = forward_zero.apply(params, next(rng), emb, mask)\n    out_no_mlps = forward.apply(params_no_mlps, next(rng), emb, mask)\n\n    self._check_layer_naming(params)\n    np.testing.assert_allclose(out_zero_activation, out_no_mlps)\n    self.assertFalse(np.allclose(out_zero_activation, 0))\n\n\nclass CompiledTransformerModelTest(parameterized.TestCase):\n\n  def _get_one_hot_embed_unembed(self, vocab_size, max_seq_len):\n    # Embeds tokens as one-hot into the first `vocab_size` dimensions\n    token_embed = hk.Embed(\n        embedding_matrix=jnp.block(\n            [jnp.eye(vocab_size),\n             jnp.zeros((vocab_size, max_seq_len))]))\n\n    # Embeds positions as one-hot into the last `max_seq_len` dimensions\n    position_embed = hk.Embed(\n        embedding_matrix=jnp.block(\n            [jnp.zeros((max_seq_len, vocab_size)),\n             jnp.eye(max_seq_len)]))\n\n    class Unembed(hk.Module):\n\n      def __call__(self, embeddings):\n        return jnp.argmax(embeddings[:, :, :vocab_size], axis=-1)\n\n    return token_embed, position_embed, Unembed()\n\n  def test_embedding_gives_desired_result(self):\n    tokens = jnp.array([[1, 2, 3]])\n    vocab_size, max_seq_len, pad_token = 5, 5, 0\n\n    expected_embeddings = jnp.array([[[0, 1, 0, 0, 0, 1, 0, 0, 0, 0],\n                                      [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                                      [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]]])\n\n    @hk.transform\n    def embed(tokens):\n      transformer = model.Transformer(\n          model.TransformerConfig(\n              num_heads=2,\n              num_layers=2,\n              key_size=5,\n              mlp_hidden_size=64,\n              dropout_rate=0.,\n              causal=False,\n              layer_norm=False,\n              activation_function=jax.nn.gelu))\n      token_embed, position_embed, unembed = self._get_one_hot_embed_unembed(\n          vocab_size, max_seq_len)\n      compiled_model = model.CompiledTransformerModel(\n          transformer=transformer,\n          token_embed=token_embed,\n          position_embed=position_embed,\n          unembed=unembed,\n          use_unembed_argmax=True,\n          pad_token=pad_token)\n      return compiled_model.embed(tokens)\n\n    rng = hk.PRNGSequence(1)\n    params = embed.init(next(rng), tokens)\n    embeddings = embed.apply(params, next(rng), tokens)\n\n    np.testing.assert_allclose(embeddings, expected_embeddings)\n\n  def test_embedding_then_unembedding_gives_same_tokens(self):\n    tokens = jnp.array([[1, 2, 3], [4, 5, 6], [3, 2, 4]])\n    vocab_size, max_seq_len, pad_token = 10, 5, 0\n\n    @hk.transform\n    def embed_unembed(tokens):"
  },
  {
    "id": "211",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Instrumented attention layer (forked from the Haiku library implementation).\n\"\"\"\n\nfrom typing import Optional\nimport warnings\n\nimport chex\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\n\n\n@chex.dataclass\nclass AttentionOutput:\n  out: jax.Array  # [..., T', D']\n  logits: jax.Array  # [..., H, T', T]\n\n\nclass MultiHeadAttention(hk.Module):\n  \"\"\"Multi-headed attention (MHA) module.\n\n  This module is intended for attending over sequences of vectors.\n\n  Rough sketch:\n  - Compute keys (K), queries (Q), and values (V) as projections of inputs.\n  - Attention weights are computed as W = softmax(QK^T / sqrt(key_size)).\n  - Output is another projection of WV^T.\n\n  For more detail, see the original Transformer paper:\n    \"Attention is all you need\" https://arxiv.org/abs/1706.03762.\n\n  Glossary of shapes:\n  - T: Sequence length.\n  - D: Vector (embedding) size.\n  - H: Number of attention heads.\n  \"\"\"\n\n  def __init__(\n      self,\n      num_heads: int,\n      key_size: int,\n      # TODO(b/240019186): Remove `w_init_scale`.\n      w_init_scale: Optional[float] = None,\n      *,\n      w_init: Optional[hk.initializers.Initializer] = None,\n      value_size: Optional[int] = None,\n      model_size: Optional[int] = None,\n      name: Optional[str] = None,\n  ):\n    \"\"\"Initialises the module.\n\n    Args:\n      num_heads: Number of independent attention heads (H).\n      key_size: The size of keys (K) and queries used for attention.\n      w_init_scale: DEPRECATED. Please use w_init instead.\n      w_init: Initialiser for weights in the linear map.\n      value_size: Optional size of the value projection (V). If None, defaults\n        to the key size (K).\n      model_size: Optional size of the output embedding (D'). If None, defaults\n        to the key size multiplied by the number of heads (K * H).\n      name: Optional name for this module.\n    \"\"\""
  },
  {
    "id": "212",
    "text": "# Copyright 2022 DeepMind Technologies Limited. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Instrumented attention layer (forked from the Haiku library implementation).\n\"\"\"\n\nfrom typing import Optional\nimport warnings\n\nimport chex\nimport haiku as hk\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\n\n\n@chex.dataclass\nclass AttentionOutput:\n  out: jax.Array  # [..., T', D']\n  logits: jax.Array  # [..., H, T', T]\n\n\nclass MultiHeadAttention(hk.Module):\n  \"\"\"Multi-headed attention (MHA) module.\n\n  This module is intended for attending over sequences of vectors.\n\n  Rough sketch:\n  - Compute keys (K), queries (Q), and values (V) as projections of inputs.\n  - Attention weights are computed as W = softmax(QK^T / sqrt(key_size)).\n  - Output is another projection of WV^T.\n\n  For more detail, see the original Transformer paper:\n    \"Attention is all you need\" https://arxiv.org/abs/1706.03762.\n\n  Glossary of shapes:\n  - T: Sequence length.\n  - D: Vector (embedding) size.\n  - H: Number of attention heads.\n  \"\"\"\n\n  def __init__(\n      self,\n      num_heads: int,\n      key_size: int,\n      # TODO(b/240019186): Remove `w_init_scale`.\n      w_init_scale: Optional[float] = None,\n      *,\n      w_init: Optional[hk.initializers.Initializer] = None,\n      value_size: Optional[int] = None,\n      model_size: Optional[int] = None,\n      name: Optional[str] = None,\n  ):\n    \"\"\"Initialises the module.\n\n    Args:\n      num_heads: Number of independent attention heads (H).\n      key_size: The size of keys (K) and queries used for attention.\n      w_init_scale: DEPRECATED. Please use w_init instead.\n      w_init: Initialiser for weights in the linear map.\n      value_size: Optional size of the value projection (V). If None, defaults\n        to the key size (K).\n      model_size: Optional size of the output embedding (D'). If None, defaults\n        to the key size multiplied by the number of heads (K * H).\n      name: Optional name for this module.\n    \"\"\"\n    super().__init__(name=name)\n    self.num_heads = num_heads\n    self.key_size = key_size\n    self.value_size = value_size or key_size\n    self.model_size = model_size or key_size * num_heads\n\n    # Backwards-compatibility for w_init_scale.\n    if w_init_scale is not None:\n      warnings.warn(\n          \"w_init_scale is deprecated; please pass an explicit weight \"\n          \"initialiser instead.\", DeprecationWarning)\n    if w_init and w_init_scale:\n      raise ValueError(\"Please provide only `w_init`, not `w_init_scale`.\")\n    if w_init is None and w_init_scale is None:\n      raise ValueError(\"Please provide a weight initializer: `w_init`.\")\n    if w_init is None:\n      w_init = hk.initializers.VarianceScaling(w_init_scale)\n    self.w_init = w_init\n\n  def __call__(\n      self,\n      query: jnp.ndarray,\n      key: jnp.ndarray,\n      value: jnp.ndarray,\n      mask: Optional[jnp.ndarray] = None,\n  ) -> AttentionOutput:\n    \"\"\"Computes (optionally masked) MHA with queries, keys & values.\n\n    This module broadcasts over zero or more 'batch-like' leading dimensions.\n\n    Args:\n      query: Embeddings sequence used to compute queries; shape [..., T', D_q].\n      key: Embeddings sequence used to compute keys; shape [..., T, D_k].\n      value: Embeddings sequence used to compute values; shape [..., T, D_v].\n      mask: Optional mask applied to attention weights; shape [..., H=1, T', T].\n\n    Returns:\n      A new sequence of embeddings, consisting of a projection of the\n        attention-weighted value projections; shape [..., T', D'].\n    \"\"\"\n\n    # In shape hints below, we suppress the leading dims [...] for brevity.\n    # Hence e.g. [A, B] should be read in every case as [..., A, B].\n    *leading_dims, sequence_length, _ = query.shape\n    projection = self._linear_projection\n\n    # Compute key/query/values (overload K/Q/V to denote the respective sizes).\n    query_heads = projection(query, self.key_size, \"query\")  # [T', H, Q=K]\n    key_heads = projection(key, self.key_size, \"key\")  # [T, H, K]\n    value_heads = projection(value, self.value_size, \"value\")  # [T, H, V]\n\n    # Compute attention weights.\n    attn_logits = jnp.einsum(\"...thd,...Thd->...htT\", query_heads, key_heads)\n    attn_logits = attn_logits / np.sqrt(self.key_size).astype(key.dtype)\n    if mask is not None:\n      if mask.ndim != attn_logits.ndim:\n        raise ValueError(\n            f\"Mask dimensionality {mask.ndim} must match logits dimensionality \"\n            f\"{attn_logits.ndim}.\")\n      attn_logits = jnp.where(mask, attn_logits, -1e30)\n    attn_weights = jax.nn.softmax(attn_logits)  # [H, T', T]\n\n    # Weight the values by the attention and flatten the head vectors.\n    attn = jnp.einsum(\"...htT,...Thd->...thd\", attn_weights, value_heads)\n    attn = jnp.reshape(attn, (*leading_dims, sequence_length, -1))  # [T', H*V]\n\n    # Apply another projection to get the final embeddings.\n    final_projection = hk.Linear(self.model_size, w_init=self.w_init)\n    return AttentionOutput(\n        out=final_projection(attn),\n        logits=attn_logits,\n    )\n\n  @hk.transparent\n  def _linear_projection(\n      self,\n      x: jnp.ndarray,\n      head_size: int,\n      name: Optional[str] = None,\n  ) -> jnp.ndarray:"
  },
  {
    "id": "213",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Plotting functions pre and post model fitting.\"\"\"\n\nimport functools\nimport logging\n\n# Using these types from typing instead of their generic types in the type hints\n# in order to be compatible with Python 3.7 and 3.8.\nfrom typing import Any, List, Optional, Sequence, Tuple\n\nimport arviz\nimport jax\nimport jax.numpy as jnp\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport numpyro\nimport pandas as pd\nimport seaborn as sns\nfrom sklearn import metrics\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import models\nfrom lightweight_mmm import preprocessing\nfrom lightweight_mmm import utils\n\nplt.style.use(\"default\")\n\n_PALETTE = sns.color_palette(n_colors=100)\n\n\n@functools.partial(jax.jit, static_argnames=(\"media_mix_model\"))\ndef _make_single_prediction(media_mix_model: lightweight_mmm.LightweightMMM,\n                            mock_media: jnp.ndarray,\n                            extra_features: Optional[jnp.ndarray],\n                            seed: Optional[int]\n                            ) -> jnp.ndarray:\n  \"\"\"Makes a prediction of a single row.\n\n  Serves as a helper function for making predictions individually for each media\n  channel and one row at a time. It is meant to be used vmaped otherwise it can\n  be slow as it's meant to be used for plotting curve responses only. Use\n  lightweight_mmm.LightweightMMM for regular predict functionality.\n\n  Args:\n    media_mix_model: Media mix model to use for getting the predictions.\n    mock_media: Mock media for this iteration of predictions.\n    extra_features: Extra features to use for predictions.\n    seed: Seed to use for PRNGKey during sampling. For replicability run\n      this function and any other function that gets predictions with the same\n      seed.\n\n  Returns:\n    A point estimate for the given data.\n  \"\"\""
  },
  {
    "id": "214",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Plotting functions pre and post model fitting.\"\"\"\n\nimport functools\nimport logging\n\n# Using these types from typing instead of their generic types in the type hints\n# in order to be compatible with Python 3.7 and 3.8.\nfrom typing import Any, List, Optional, Sequence, Tuple\n\nimport arviz\nimport jax\nimport jax.numpy as jnp\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport numpyro\nimport pandas as pd\nimport seaborn as sns\nfrom sklearn import metrics\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import models\nfrom lightweight_mmm import preprocessing\nfrom lightweight_mmm import utils\n\nplt.style.use(\"default\")\n\n_PALETTE = sns.color_palette(n_colors=100)\n\n\n@functools.partial(jax.jit, static_argnames=(\"media_mix_model\"))\ndef _make_single_prediction(media_mix_model: lightweight_mmm.LightweightMMM,\n                            mock_media: jnp.ndarray,\n                            extra_features: Optional[jnp.ndarray],\n                            seed: Optional[int]\n                            ) -> jnp.ndarray:\n  \"\"\"Makes a prediction of a single row.\n\n  Serves as a helper function for making predictions individually for each media\n  channel and one row at a time. It is meant to be used vmaped otherwise it can\n  be slow as it's meant to be used for plotting curve responses only. Use\n  lightweight_mmm.LightweightMMM for regular predict functionality.\n\n  Args:\n    media_mix_model: Media mix model to use for getting the predictions.\n    mock_media: Mock media for this iteration of predictions.\n    extra_features: Extra features to use for predictions.\n    seed: Seed to use for PRNGKey during sampling. For replicability run\n      this function and any other function that gets predictions with the same\n      seed.\n\n  Returns:\n    A point estimate for the given data.\n  \"\"\"\n  return media_mix_model.predict(\n      media=jnp.expand_dims(mock_media, axis=0),\n      extra_features=extra_features,\n      seed=seed).mean(axis=0)\n\n\n@functools.partial(\n    jax.jit,\n    static_argnames=(\"media_mix_model\", \"target_scaler\"))\ndef _generate_diagonal_predictions(\n    media_mix_model: lightweight_mmm.LightweightMMM,\n    media_values: jnp.ndarray,\n    extra_features: Optional[jnp.ndarray],\n    target_scaler: Optional[preprocessing.CustomScaler],\n    prediction_offset: jnp.ndarray,\n    seed: Optional[int]):\n  \"\"\"Generates predictions for one value per channel leaving the rest to zero.\n\n  This function does the following steps:\n    - Vmaps the single prediction function on axis=0 of the media arg.\n    - Diagonalizes the media input values so that each value is represented\n      along side zeros on for the rest of the channels.\n    - Generate predictions.\n    - Unscale prediction if target_scaler is given.\n\n  Args:\n    media_mix_model: Media mix model to use for plotting the response curves.\n    media_values: Media values.\n    extra_features: Extra features values.\n    target_scaler: Scaler used for scaling the target, to unscaled values and\n      plot in the original scale.\n    prediction_offset: The value of a prediction of an all zero media input.\n    seed: Seed to use for PRNGKey during sampling. For replicability run\n      this function and any other function that gets predictions with the same\n      seed.\n\n  Returns:\n    The predictions for the given data.\n  \"\"\"\n  make_predictions = jax.vmap(fun=_make_single_prediction,\n                              in_axes=(None, 0, None, None))\n  diagonal = jnp.eye(media_values.shape[0])\n  if media_values.ndim == 2:  # Only two since we only provide one row\n    diagonal = jnp.expand_dims(diagonal, axis=-1)\n    media_values = jnp.expand_dims(media_values, axis=0)\n  diag_media_values = diagonal * media_values\n  predictions = make_predictions(\n      media_mix_model,\n      diag_media_values,\n      extra_features,\n      seed) - prediction_offset\n  predictions = jnp.squeeze(predictions)\n  if target_scaler:\n    predictions = target_scaler.inverse_transform(predictions)\n  if predictions.ndim == 2:\n    predictions = jnp.sum(predictions, axis=-1)\n  return predictions\n\n\ndef _calculate_number_rows_plot(n_media_channels: int, n_columns: int):\n  \"\"\"Calculates the number of rows of plots needed to fit n + 1 plots in n_cols.\n\n  Args:\n    n_media_channels: Number of media channels. The total of plots needed is\n      n_media_channels + 1.\n    n_columns: Number of columns in the plot grid.\n\n  Returns:\n    The number of rows of plots needed to fit n + 1 plots in n cols\n  \"\"\""
  },
  {
    "id": "215",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Plotting functions pre and post model fitting.\"\"\"\n\nimport functools\nimport logging\n\n# Using these types from typing instead of their generic types in the type hints\n# in order to be compatible with Python 3.7 and 3.8.\nfrom typing import Any, List, Optional, Sequence, Tuple\n\nimport arviz\nimport jax\nimport jax.numpy as jnp\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport numpyro\nimport pandas as pd\nimport seaborn as sns\nfrom sklearn import metrics\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import models\nfrom lightweight_mmm import preprocessing\nfrom lightweight_mmm import utils\n\nplt.style.use(\"default\")\n\n_PALETTE = sns.color_palette(n_colors=100)\n\n\n@functools.partial(jax.jit, static_argnames=(\"media_mix_model\"))\ndef _make_single_prediction(media_mix_model: lightweight_mmm.LightweightMMM,\n                            mock_media: jnp.ndarray,\n                            extra_features: Optional[jnp.ndarray],\n                            seed: Optional[int]\n                            ) -> jnp.ndarray:\n  \"\"\"Makes a prediction of a single row.\n\n  Serves as a helper function for making predictions individually for each media\n  channel and one row at a time. It is meant to be used vmaped otherwise it can\n  be slow as it's meant to be used for plotting curve responses only. Use\n  lightweight_mmm.LightweightMMM for regular predict functionality.\n\n  Args:\n    media_mix_model: Media mix model to use for getting the predictions.\n    mock_media: Mock media for this iteration of predictions.\n    extra_features: Extra features to use for predictions.\n    seed: Seed to use for PRNGKey during sampling. For replicability run\n      this function and any other function that gets predictions with the same\n      seed.\n\n  Returns:\n    A point estimate for the given data.\n  \"\"\"\n  return media_mix_model.predict(\n      media=jnp.expand_dims(mock_media, axis=0),\n      extra_features=extra_features,\n      seed=seed).mean(axis=0)\n\n\n@functools.partial(\n    jax.jit,\n    static_argnames=(\"media_mix_model\", \"target_scaler\"))\ndef _generate_diagonal_predictions(\n    media_mix_model: lightweight_mmm.LightweightMMM,\n    media_values: jnp.ndarray,\n    extra_features: Optional[jnp.ndarray],\n    target_scaler: Optional[preprocessing.CustomScaler],\n    prediction_offset: jnp.ndarray,\n    seed: Optional[int]):\n  \"\"\"Generates predictions for one value per channel leaving the rest to zero.\n\n  This function does the following steps:\n    - Vmaps the single prediction function on axis=0 of the media arg.\n    - Diagonalizes the media input values so that each value is represented\n      along side zeros on for the rest of the channels.\n    - Generate predictions.\n    - Unscale prediction if target_scaler is given.\n\n  Args:\n    media_mix_model: Media mix model to use for plotting the response curves.\n    media_values: Media values.\n    extra_features: Extra features values.\n    target_scaler: Scaler used for scaling the target, to unscaled values and\n      plot in the original scale.\n    prediction_offset: The value of a prediction of an all zero media input.\n    seed: Seed to use for PRNGKey during sampling. For replicability run\n      this function and any other function that gets predictions with the same\n      seed.\n\n  Returns:\n    The predictions for the given data.\n  \"\"\"\n  make_predictions = jax.vmap(fun=_make_single_prediction,\n                              in_axes=(None, 0, None, None))\n  diagonal = jnp.eye(media_values.shape[0])\n  if media_values.ndim == 2:  # Only two since we only provide one row\n    diagonal = jnp.expand_dims(diagonal, axis=-1)\n    media_values = jnp.expand_dims(media_values, axis=0)\n  diag_media_values = diagonal * media_values\n  predictions = make_predictions(\n      media_mix_model,\n      diag_media_values,\n      extra_features,\n      seed) - prediction_offset\n  predictions = jnp.squeeze(predictions)\n  if target_scaler:\n    predictions = target_scaler.inverse_transform(predictions)\n  if predictions.ndim == 2:\n    predictions = jnp.sum(predictions, axis=-1)\n  return predictions\n\n\ndef _calculate_number_rows_plot(n_media_channels: int, n_columns: int):\n  \"\"\"Calculates the number of rows of plots needed to fit n + 1 plots in n_cols.\n\n  Args:\n    n_media_channels: Number of media channels. The total of plots needed is\n      n_media_channels + 1.\n    n_columns: Number of columns in the plot grid.\n\n  Returns:\n    The number of rows of plots needed to fit n + 1 plots in n cols\n  \"\"\"\n  if n_media_channels % n_columns == 0:\n    return n_media_channels // n_columns + 1\n  return n_media_channels // n_columns + 2\n\n\ndef _calculate_media_contribution(\n    media_mix_model: lightweight_mmm.LightweightMMM) -> jnp.ndarray:\n  \"\"\"Computes contribution for each sample, time, channel.\n\n  Serves as a helper function for making predictions for each channel, time\n  and estimate sample. It is meant to be used in creating media baseline\n  contribution dataframe and visualize media attribution over spend proportion\n  plot.\n\n  Args:\n    media_mix_model: Media mix model.\n\n  Returns:\n    Estimation of contribution for each sample, time, channel.\n\n  Raises:\n    NotFittedModelError: if the model is not fitted before computation\n  \"\"\""
  },
  {
    "id": "216",
    "text": " False.\n    figure_size: Size of the plot figure.\n    n_columns: Number of columns to display in the subplots grid. Modifying this\n      parameter might require to adjust figure_size accordingly for the plot\n      to still have reasonable structure.\n    marker_size: Size of the marker for the optimization annotations. Only\n      useful if optimal_allocation_per_timeunit is not None. Default is 8.\n    legend_fontsize: Legend font size for individual subplots.\n    seed: Seed to use for PRNGKey during sampling. For replicability run\n      this function and any other function that gets predictions with the same\n      seed.\n\n  Returns:\n    Plots of response curves.\n  \"\"\"\n  if not hasattr(media_mix_model, \"trace\"):\n    raise lightweight_mmm.NotFittedModelError(\n        \"Model needs to be fit first before attempting to plot its response \"\n        \"curves.\")\n  media = media_mix_model.media\n  media_maxes = media.max(axis=0) * (1 + percentage_add)\n  if media_mix_model._extra_features is not None:\n    extra_features = jnp.expand_dims(\n        media_mix_model._extra_features.mean(axis=0), axis=0)\n  else:\n    extra_features = None\n  media_ranges = jnp.expand_dims(\n      jnp.linspace(start=0, stop=media_maxes, num=steps), axis=0)\n\n  make_predictions = jax.vmap(\n      jax.vmap(_make_single_prediction,\n               in_axes=(None, 0, None, None),\n               out_axes=0),\n      in_axes=(None, 0, None, None), out_axes=1)\n  diagonal = jnp.repeat(\n      jnp.eye(media_mix_model.n_media_channels), steps,\n      axis=0).reshape(media_mix_model.n_media_channels, steps,\n                      media_mix_model.n_media_channels)\n\n  prediction_offset = media_mix_model.predict(\n      media=jnp.zeros((1, *media.shape[1:])),\n      extra_features=extra_features).mean(axis=0)\n\n  if media.ndim == 3:\n    diagonal = jnp.expand_dims(diagonal, axis=-1)\n    prediction_offset = jnp.expand_dims(prediction_offset, axis=0)\n  mock_media = media_ranges * diagonal\n  predictions = jnp.squeeze(a=make_predictions(media_mix_model,\n                                               mock_media,\n                                               extra_features,\n                                               seed))\n  predictions = predictions - prediction_offset\n  media_ranges = jnp.squeeze(media_ranges)\n  if target_scaler:\n    predictions = target_scaler.inverse_transform(predictions)\n\n  if media_scaler:\n    media_ranges = media_scaler.inverse_transform(media_ranges)\n\n  if prices is not None:\n    if media.ndim == 3:\n      prices = jnp.expand_dims(prices, axis=-1)\n    media_ranges *= prices\n\n  if predictions.ndim == 3:\n    media_ranges = jnp.sum(media_ranges, axis=-1)\n    predictions = jnp.sum(predictions, axis=-1)\n\n  if optimal_allocation_per_timeunit is not None:\n    average_allocation = media_mix_model.media.mean(axis=0)\n    average_allocation_predictions = _generate_diagonal_predictions(\n        media_mix_model=media_mix_model,\n        media_values=average_allocation,\n        extra_features=extra_features,\n        target_scaler=target_scaler,\n        prediction_offset=prediction_offset,\n        seed=seed)\n    optimal_allocation_predictions = _generate_diagonal_predictions(\n        media_mix_model=media_mix_model,\n        media_values=optimal_allocation_per_timeunit,\n        extra_features=extra_features,\n        target_scaler=target_scaler,\n        prediction_offset=prediction_offset,\n        seed=seed)\n    if media_scaler:\n      average_allocation = media_scaler.inverse_transform(average_allocation)\n      optimal_allocation_per_timeunit = media_scaler.inverse_transform(\n          optimal_allocation_per_timeunit)\n    if prices is not None:\n      optimal_allocation_per_timeunit *= prices\n      average_allocation *= prices\n    if media.ndim == 3:\n      average_allocation = jnp.sum(average_allocation, axis=-1)\n      optimal_allocation_per_timeunit = jnp.sum(\n          optimal_allocation_per_timeunit, axis=-1)\n\n  kpi_label = \"KPI\" if target_scaler else \"Normalized KPI\"\n  fig = plt.figure(media_mix_model.n_media_channels + 1,\n                   figsize=figure_size,\n                   tight_layout=True)\n  n_rows = _calculate_number_rows_plot(\n      n_media_channels=media_mix_model.n_media_channels, n_columns=n_columns)\n  last_ax = fig.add_subplot(n_rows, 1, n_rows)\n  for i in range(media_mix_model.n_media_channels):\n    ax = fig.add_subplot(n_rows, n_columns, i + 1)\n    sns.lineplot(\n        x=media_ranges[:, i],\n        y=predictions[:, i],\n        label=media_mix_model.media_names[i],\n        color=_PALETTE[i],\n        ax=ax)\n    sns.lineplot(\n        x=media_ranges[:, i],\n        y=jnp.log(predictions[:, i]) if apply_log_scale else predictions[:, i],\n        label=media_mix_model.media_names[i],\n        color=_PALETTE[i],\n        ax=last_ax)\n    if optimal_allocation_per_timeunit is not None:\n      ax.plot(\n          average_allocation[i],\n          average_allocation_predictions[i],\n          marker=\"o\",\n          markersize=marker_size,\n          label=\"avg_spend\",\n          color=_PALETTE[i])\n      ax.plot(\n          optimal_allocation_per_timeunit[i],\n          optimal_allocation_predictions[i],\n          marker=\"x\",\n          markersize=marker_size + 2,\n          label=\"optimal_spend\",\n          color=_PALETTE[i])\n    ax.set_ylabel(kpi_label)\n    ax.set_xlabel(\"Normalized Spend\" if not media_scaler else \"Spend\")\n    ax.legend(fontsize=legend_fontsize)\n\n  fig.suptitle(\"Response curves\", fontsize=20)\n  last_ax.set_ylabel(kpi_label if not apply_log_scale else f\"log({kpi_label})\")\n  last_ax.set_xlabel(\"Normalized spend per channel\"\n                     if not media_scaler else \"Spend per channel\")\n  plt.close()\n  return fig\n\n\ndef plot_cross_correlate(feature: jnp.ndarray,\n                         target: jnp.ndarray,\n                         maxlags: int = 10) -> Tuple[int, float]:\n  \"\"\"Plots the cross correlation coefficients between 2 vectors.\n\n  In the chart look for positive peaks, this shows how the lags of the feature\n  lead the target.\n\n  Args:\n    feature: Vector, the lags of which predict target.\n    target: Vector, what is predicted.\n    maxlags: Maximum number of lags.\n\n  Returns:\n    Lag index and corresponding correlation of the peak correlation.\n\n  Raises:\n    ValueError: If inputs don't have same length.\n  \"\"\""
  },
  {
    "id": "217",
    "text": "np.expand_dims(\n        media_mix_model._extra_features.mean(axis=0), axis=0)\n  else:\n    extra_features = None\n  media_ranges = jnp.expand_dims(\n      jnp.linspace(start=0, stop=media_maxes, num=steps), axis=0)\n\n  make_predictions = jax.vmap(\n      jax.vmap(_make_single_prediction,\n               in_axes=(None, 0, None, None),\n               out_axes=0),\n      in_axes=(None, 0, None, None), out_axes=1)\n  diagonal = jnp.repeat(\n      jnp.eye(media_mix_model.n_media_channels), steps,\n      axis=0).reshape(media_mix_model.n_media_channels, steps,\n                      media_mix_model.n_media_channels)\n\n  prediction_offset = media_mix_model.predict(\n      media=jnp.zeros((1, *media.shape[1:])),\n      extra_features=extra_features).mean(axis=0)\n\n  if media.ndim == 3:\n    diagonal = jnp.expand_dims(diagonal, axis=-1)\n    prediction_offset = jnp.expand_dims(prediction_offset, axis=0)\n  mock_media = media_ranges * diagonal\n  predictions = jnp.squeeze(a=make_predictions(media_mix_model,\n                                               mock_media,\n                                               extra_features,\n                                               seed))\n  predictions = predictions - prediction_offset\n  media_ranges = jnp.squeeze(media_ranges)\n  if target_scaler:\n    predictions = target_scaler.inverse_transform(predictions)\n\n  if media_scaler:\n    media_ranges = media_scaler.inverse_transform(media_ranges)\n\n  if prices is not None:\n    if media.ndim == 3:\n      prices = jnp.expand_dims(prices, axis=-1)\n    media_ranges *= prices\n\n  if predictions.ndim == 3:\n    media_ranges = jnp.sum(media_ranges, axis=-1)\n    predictions = jnp.sum(predictions, axis=-1)\n\n  if optimal_allocation_per_timeunit is not None:\n    average_allocation = media_mix_model.media.mean(axis=0)\n    average_allocation_predictions = _generate_diagonal_predictions(\n        media_mix_model=media_mix_model,\n        media_values=average_allocation,\n        extra_features=extra_features,\n        target_scaler=target_scaler,\n        prediction_offset=prediction_offset,\n        seed=seed)\n    optimal_allocation_predictions = _generate_diagonal_predictions(\n        media_mix_model=media_mix_model,\n        media_values=optimal_allocation_per_timeunit,\n        extra_features=extra_features,\n        target_scaler=target_scaler,\n        prediction_offset=prediction_offset,\n        seed=seed)\n    if media_scaler:\n      average_allocation = media_scaler.inverse_transform(average_allocation)\n      optimal_allocation_per_timeunit = media_scaler.inverse_transform(\n          optimal_allocation_per_timeunit)\n    if prices is not None:\n      optimal_allocation_per_timeunit *= prices\n      average_allocation *= prices\n    if media.ndim == 3:\n      average_allocation = jnp.sum(average_allocation, axis=-1)\n      optimal_allocation_per_timeunit = jnp.sum(\n          optimal_allocation_per_timeunit, axis=-1)\n\n  kpi_label = \"KPI\" if target_scaler else \"Normalized KPI\"\n  fig = plt.figure(media_mix_model.n_media_channels + 1,\n                   figsize=figure_size,\n                   tight_layout=True)\n  n_rows = _calculate_number_rows_plot(\n      n_media_channels=media_mix_model.n_media_channels, n_columns=n_columns)\n  last_ax = fig.add_subplot(n_rows, 1, n_rows)\n  for i in range(media_mix_model.n_media_channels):\n    ax = fig.add_subplot(n_rows, n_columns, i + 1)\n    sns.lineplot(\n        x=media_ranges[:, i],\n        y=predictions[:, i],\n        label=media_mix_model.media_names[i],\n        color=_PALETTE[i],\n        ax=ax)\n    sns.lineplot(\n        x=media_ranges[:, i],\n        y=jnp.log(predictions[:, i]) if apply_log_scale else predictions[:, i],\n        label=media_mix_model.media_names[i],\n        color=_PALETTE[i],\n        ax=last_ax)\n    if optimal_allocation_per_timeunit is not None:\n      ax.plot(\n          average_allocation[i],\n          average_allocation_predictions[i],\n          marker=\"o\",\n          markersize=marker_size,\n          label=\"avg_spend\",\n          color=_PALETTE[i])\n      ax.plot(\n          optimal_allocation_per_timeunit[i],\n          optimal_allocation_predictions[i],\n          marker=\"x\",\n          markersize=marker_size + 2,\n          label=\"optimal_spend\",\n          color=_PALETTE[i])\n    ax.set_ylabel(kpi_label)\n    ax.set_xlabel(\"Normalized Spend\" if not media_scaler else \"Spend\")\n    ax.legend(fontsize=legend_fontsize)\n\n  fig.suptitle(\"Response curves\", fontsize=20)\n  last_ax.set_ylabel(kpi_label if not apply_log_scale else f\"log({kpi_label})\")\n  last_ax.set_xlabel(\"Normalized spend per channel\"\n                     if not media_scaler else \"Spend per channel\")\n  plt.close()\n  return fig\n\n\ndef plot_cross_correlate(feature: jnp.ndarray,\n                         target: jnp.ndarray,\n                         maxlags: int = 10) -> Tuple[int, float]:\n  \"\"\"Plots the cross correlation coefficients between 2 vectors.\n\n  In the chart look for positive peaks, this shows how the lags of the feature\n  lead the target.\n\n  Args:\n    feature: Vector, the lags of which predict target.\n    target: Vector, what is predicted.\n    maxlags: Maximum number of lags.\n\n  Returns:\n    Lag index and corresponding correlation of the peak correlation.\n\n  Raises:\n    ValueError: If inputs don't have same length.\n  \"\"\"\n  if len(feature) != len(target):\n    raise ValueError(\"feature and target need to have the same length.\")\n  maxlags = jnp.minimum(len(feature) - 1, maxlags)\n  mean_feature, mean_target = feature.mean(), target.mean()\n  plot = plt.xcorr(\n      x=feature - mean_feature, y=target - mean_target, maxlags=maxlags)\n  plt.show()\n  maxidx = plot[1][plot[0] <= 0].argmax()\n  return plot[0][maxidx], plot[1][maxidx]\n\n\ndef plot_var_cost(media: jnp.ndarray, costs: jnp.ndarray,\n                  names: List[str]) -> matplotlib.figure.Figure:\n  \"\"\"Plots a a chart between the coefficient of variation and cost.\n\n  Args:\n    media: Media matrix.\n    costs: Cost vector.\n    names: List of variable names.\n\n  Returns:\n    Plot of coefficient of variation and cost.\n\n  Raises:\n    ValueError if inputs don't conform to same length.\n  \"\"\""
  },
  {
    "id": "218",
    "text": "ranges[:, i],\n        y=jnp.log(predictions[:, i]) if apply_log_scale else predictions[:, i],\n        label=media_mix_model.media_names[i],\n        color=_PALETTE[i],\n        ax=last_ax)\n    if optimal_allocation_per_timeunit is not None:\n      ax.plot(\n          average_allocation[i],\n          average_allocation_predictions[i],\n          marker=\"o\",\n          markersize=marker_size,\n          label=\"avg_spend\",\n          color=_PALETTE[i])\n      ax.plot(\n          optimal_allocation_per_timeunit[i],\n          optimal_allocation_predictions[i],\n          marker=\"x\",\n          markersize=marker_size + 2,\n          label=\"optimal_spend\",\n          color=_PALETTE[i])\n    ax.set_ylabel(kpi_label)\n    ax.set_xlabel(\"Normalized Spend\" if not media_scaler else \"Spend\")\n    ax.legend(fontsize=legend_fontsize)\n\n  fig.suptitle(\"Response curves\", fontsize=20)\n  last_ax.set_ylabel(kpi_label if not apply_log_scale else f\"log({kpi_label})\")\n  last_ax.set_xlabel(\"Normalized spend per channel\"\n                     if not media_scaler else \"Spend per channel\")\n  plt.close()\n  return fig\n\n\ndef plot_cross_correlate(feature: jnp.ndarray,\n                         target: jnp.ndarray,\n                         maxlags: int = 10) -> Tuple[int, float]:\n  \"\"\"Plots the cross correlation coefficients between 2 vectors.\n\n  In the chart look for positive peaks, this shows how the lags of the feature\n  lead the target.\n\n  Args:\n    feature: Vector, the lags of which predict target.\n    target: Vector, what is predicted.\n    maxlags: Maximum number of lags.\n\n  Returns:\n    Lag index and corresponding correlation of the peak correlation.\n\n  Raises:\n    ValueError: If inputs don't have same length.\n  \"\"\"\n  if len(feature) != len(target):\n    raise ValueError(\"feature and target need to have the same length.\")\n  maxlags = jnp.minimum(len(feature) - 1, maxlags)\n  mean_feature, mean_target = feature.mean(), target.mean()\n  plot = plt.xcorr(\n      x=feature - mean_feature, y=target - mean_target, maxlags=maxlags)\n  plt.show()\n  maxidx = plot[1][plot[0] <= 0].argmax()\n  return plot[0][maxidx], plot[1][maxidx]\n\n\ndef plot_var_cost(media: jnp.ndarray, costs: jnp.ndarray,\n                  names: List[str]) -> matplotlib.figure.Figure:\n  \"\"\"Plots a a chart between the coefficient of variation and cost.\n\n  Args:\n    media: Media matrix.\n    costs: Cost vector.\n    names: List of variable names.\n\n  Returns:\n    Plot of coefficient of variation and cost.\n\n  Raises:\n    ValueError if inputs don't conform to same length.\n  \"\"\"\n  if media.shape[1] != len(costs):\n    raise ValueError(\"media columns and costs needs to have same length.\")\n  if media.shape[1] != len(names):\n    raise ValueError(\"media columns and names needs to have same length.\")\n  coef_of_variation = media.std(axis=0) / media.mean(axis=0)\n\n  fig, ax = plt.subplots(1, 1)\n  ax.scatter(x=costs, y=coef_of_variation)\n  # https://queirozf.com/entries/add-labels-and-text-to-matplotlib-plots-annotation-examples.\n  for i in range(len(costs)):\n    x, y, label = costs[i], coef_of_variation[i], names[i]\n    ax.annotate(text=label, xy=(x, y))\n  ax.set_xlabel(\"Cost\")\n  ax.set_ylabel(\"Coef of Variation\")\n  plt.close()\n  return fig\n\n\ndef _create_shaded_line_plot(predictions: jnp.ndarray,\n                             target: jnp.ndarray,\n                             axis: matplotlib.axes.Axes,\n                             title_prefix: str = \"\",\n                             interval_mid_range: float = .9,\n                             digits: int = 3) -> None:\n  \"\"\"Creates a plot of ground truth, predicted value and credibility interval.\n\n  Args:\n    predictions: 2d array of predicted values.\n    target: Array of true values. Must be same length as predictions.\n    axis: Matplotlib axis in which to plot the data.\n    title_prefix: Prefix to add as the label of the plot.\n    interval_mid_range: Mid range interval to take for plotting. Eg. .9 will use\n      .05 and .95 as the lower and upper quantiles. Must be a float number\n      between 0 and 1.\n    digits: Number of decimals to display on metrics in the plot.\n  \"\"\"\n  if predictions.shape[1] != len(target):\n    raise ValueError(\n        \"Predicted data and ground-truth data must have same length.\")\n  upper_quantile = 1 - (1 - interval_mid_range) / 2\n  lower_quantile = (1 - interval_mid_range) / 2\n  upper_bound = jnp.quantile(a=predictions, q=upper_quantile, axis=0)\n  lower_bound = jnp.quantile(a=predictions, q=lower_quantile, axis=0)\n\n  r2, _ = arviz.r2_score(y_true=target, y_pred=predictions)\n  mape = 100 * metrics.mean_absolute_percentage_error(\n      y_true=target, y_pred=predictions.mean(axis=0))\n  axis.plot(jnp.arange(target.shape[0]), target, c=\"grey\", alpha=.9)\n  axis.plot(\n      jnp.arange(target.shape[0]),\n      predictions.mean(axis=0),\n      c=\"green\",\n      alpha=.9)\n  axis.fill_between(\n      x=jnp.arange(target.shape[0]),\n      y1=lower_bound,\n      y2=upper_bound,\n      alpha=.35,\n      color=\"green\")\n  axis.legend([\"True KPI\", \"Predicted KPI\"])\n  axis.yaxis.grid(color=\"gray\", linestyle=\"dashed\", alpha=0.3)\n  axis.xaxis.grid(color=\"gray\", linestyle=\"dashed\", alpha=0.3)\n  title = \" \".join([\n      title_prefix,\n      \"True and predicted KPI.\",\n      \"R2 = {r2:.{digits}f}\".format(r2=r2, digits=digits),\n      \"MAPE = {mape:.{digits}f}%\".format(mape=mape, digits=digits)\n  ])\n  axis.title.set_text(title)\n  plt.close()\n\n\ndef _call_fit_plotter(\n    predictions: jnp.array,\n    target: jnp.array,\n    interval_mid_range: float,\n    digits: int) -> matplotlib.figure.Figure:\n  \"\"\"Calls the shaded line plot once for national and N times for geo models.\n\n  Args:\n    predictions: 2d array of predicted values.\n    target: Array of true values. Must be same length as prediction.\n    interval_mid_range: Mid range interval to take for plotting. Eg. .9 will use\n      .05 and .95 as the lower and upper quantiles. Must be a float number\n      between 0 and 1.\n    digits: Number of decimals to display on metrics in the plot.\n\n  Returns:\n    Figure of the plot.\n  \"\"\"\n  # TODO(): Allow to pass geo names for fit plots"
  },
  {
    "id": "219",
    "text": " of which predict target.\n    target: Vector, what is predicted.\n    maxlags: Maximum number of lags.\n\n  Returns:\n    Lag index and corresponding correlation of the peak correlation.\n\n  Raises:\n    ValueError: If inputs don't have same length.\n  \"\"\"\n  if len(feature) != len(target):\n    raise ValueError(\"feature and target need to have the same length.\")\n  maxlags = jnp.minimum(len(feature) - 1, maxlags)\n  mean_feature, mean_target = feature.mean(), target.mean()\n  plot = plt.xcorr(\n      x=feature - mean_feature, y=target - mean_target, maxlags=maxlags)\n  plt.show()\n  maxidx = plot[1][plot[0] <= 0].argmax()\n  return plot[0][maxidx], plot[1][maxidx]\n\n\ndef plot_var_cost(media: jnp.ndarray, costs: jnp.ndarray,\n                  names: List[str]) -> matplotlib.figure.Figure:\n  \"\"\"Plots a a chart between the coefficient of variation and cost.\n\n  Args:\n    media: Media matrix.\n    costs: Cost vector.\n    names: List of variable names.\n\n  Returns:\n    Plot of coefficient of variation and cost.\n\n  Raises:\n    ValueError if inputs don't conform to same length.\n  \"\"\"\n  if media.shape[1] != len(costs):\n    raise ValueError(\"media columns and costs needs to have same length.\")\n  if media.shape[1] != len(names):\n    raise ValueError(\"media columns and names needs to have same length.\")\n  coef_of_variation = media.std(axis=0) / media.mean(axis=0)\n\n  fig, ax = plt.subplots(1, 1)\n  ax.scatter(x=costs, y=coef_of_variation)\n  # https://queirozf.com/entries/add-labels-and-text-to-matplotlib-plots-annotation-examples.\n  for i in range(len(costs)):\n    x, y, label = costs[i], coef_of_variation[i], names[i]\n    ax.annotate(text=label, xy=(x, y))\n  ax.set_xlabel(\"Cost\")\n  ax.set_ylabel(\"Coef of Variation\")\n  plt.close()\n  return fig\n\n\ndef _create_shaded_line_plot(predictions: jnp.ndarray,\n                             target: jnp.ndarray,\n                             axis: matplotlib.axes.Axes,\n                             title_prefix: str = \"\",\n                             interval_mid_range: float = .9,\n                             digits: int = 3) -> None:\n  \"\"\"Creates a plot of ground truth, predicted value and credibility interval.\n\n  Args:\n    predictions: 2d array of predicted values.\n    target: Array of true values. Must be same length as predictions.\n    axis: Matplotlib axis in which to plot the data.\n    title_prefix: Prefix to add as the label of the plot.\n    interval_mid_range: Mid range interval to take for plotting. Eg. .9 will use\n      .05 and .95 as the lower and upper quantiles. Must be a float number\n      between 0 and 1.\n    digits: Number of decimals to display on metrics in the plot.\n  \"\"\"\n  if predictions.shape[1] != len(target):\n    raise ValueError(\n        \"Predicted data and ground-truth data must have same length.\")\n  upper_quantile = 1 - (1 - interval_mid_range) / 2\n  lower_quantile = (1 - interval_mid_range) / 2\n  upper_bound = jnp.quantile(a=predictions, q=upper_quantile, axis=0)\n  lower_bound = jnp.quantile(a=predictions, q=lower_quantile, axis=0)\n\n  r2, _ = arviz.r2_score(y_true=target, y_pred=predictions)\n  mape = 100 * metrics.mean_absolute_percentage_error(\n      y_true=target, y_pred=predictions.mean(axis=0))\n  axis.plot(jnp.arange(target.shape[0]), target, c=\"grey\", alpha=.9)\n  axis.plot(\n      jnp.arange(target.shape[0]),\n      predictions.mean(axis=0),\n      c=\"green\",\n      alpha=.9)\n  axis.fill_between(\n      x=jnp.arange(target.shape[0]),\n      y1=lower_bound,\n      y2=upper_bound,\n      alpha=.35,\n      color=\"green\")\n  axis.legend([\"True KPI\", \"Predicted KPI\"])\n  axis.yaxis.grid(color=\"gray\", linestyle=\"dashed\", alpha=0.3)\n  axis.xaxis.grid(color=\"gray\", linestyle=\"dashed\", alpha=0.3)\n  title = \" \".join([\n      title_prefix,\n      \"True and predicted KPI.\",\n      \"R2 = {r2:.{digits}f}\".format(r2=r2, digits=digits),\n      \"MAPE = {mape:.{digits}f}%\".format(mape=mape, digits=digits)\n  ])\n  axis.title.set_text(title)\n  plt.close()\n\n\ndef _call_fit_plotter(\n    predictions: jnp.array,\n    target: jnp.array,\n    interval_mid_range: float,\n    digits: int) -> matplotlib.figure.Figure:\n  \"\"\"Calls the shaded line plot once for national and N times for geo models.\n\n  Args:\n    predictions: 2d array of predicted values.\n    target: Array of true values. Must be same length as prediction.\n    interval_mid_range: Mid range interval to take for plotting. Eg. .9 will use\n      .05 and .95 as the lower and upper quantiles. Must be a float number\n      between 0 and 1.\n    digits: Number of decimals to display on metrics in the plot.\n\n  Returns:\n    Figure of the plot.\n  \"\"\"\n  # TODO(): Allow to pass geo names for fit plots\n  if predictions.ndim == 3:  # Multiple plots for geo model\n    figure, axes = plt.subplots(predictions.shape[-1],\n                                figsize=(10, 5 * predictions.shape[-1]))\n    for i, ax in enumerate(axes):\n      _create_shaded_line_plot(predictions=predictions[..., i],\n                               target=target[..., i],\n                               axis=ax,\n                               title_prefix=f\"Geo {i}:\",\n                               interval_mid_range=interval_mid_range,\n                               digits=digits)\n  else:  # Single plot for national model\n    figure, ax = plt.subplots(1, 1)\n    _create_shaded_line_plot(predictions=predictions,\n                             target=target,\n                             axis=ax,\n                             interval_mid_range=interval_mid_range,\n                             digits=digits)\n  return figure\n\n\ndef plot_model_fit(media_mix_model: lightweight_mmm.LightweightMMM,\n                   target_scaler: Optional[preprocessing.CustomScaler] = None,\n                   interval_mid_range: float = .9,\n                   digits: int = 3) -> matplotlib.figure.Figure:\n  \"\"\"Plots the ground truth, predicted value and interval for the training data.\n\n  Model needs to be fit before calling this function to plot.\n\n  Args:\n    media_mix_model: Media mix model.\n    target_scaler: Scaler used for scaling the target, to unscaled values and\n      plot in the original scale.\n    interval_mid_range: Mid range interval to take for plotting. Eg. .9 will use\n      .05 and .95 as the lower and upper quantiles. Must be a float number.\n      between 0 and 1.\n    digits: Number of decimals to display on metrics in the plot.\n\n  Returns:\n    Plot of model fit.\n  \"\"\""
  },
  {
    "id": "220",
    "text": "t.subplots(1, 1)\n  ax.scatter(x=costs, y=coef_of_variation)\n  # https://queirozf.com/entries/add-labels-and-text-to-matplotlib-plots-annotation-examples.\n  for i in range(len(costs)):\n    x, y, label = costs[i], coef_of_variation[i], names[i]\n    ax.annotate(text=label, xy=(x, y))\n  ax.set_xlabel(\"Cost\")\n  ax.set_ylabel(\"Coef of Variation\")\n  plt.close()\n  return fig\n\n\ndef _create_shaded_line_plot(predictions: jnp.ndarray,\n                             target: jnp.ndarray,\n                             axis: matplotlib.axes.Axes,\n                             title_prefix: str = \"\",\n                             interval_mid_range: float = .9,\n                             digits: int = 3) -> None:\n  \"\"\"Creates a plot of ground truth, predicted value and credibility interval.\n\n  Args:\n    predictions: 2d array of predicted values.\n    target: Array of true values. Must be same length as predictions.\n    axis: Matplotlib axis in which to plot the data.\n    title_prefix: Prefix to add as the label of the plot.\n    interval_mid_range: Mid range interval to take for plotting. Eg. .9 will use\n      .05 and .95 as the lower and upper quantiles. Must be a float number\n      between 0 and 1.\n    digits: Number of decimals to display on metrics in the plot.\n  \"\"\"\n  if predictions.shape[1] != len(target):\n    raise ValueError(\n        \"Predicted data and ground-truth data must have same length.\")\n  upper_quantile = 1 - (1 - interval_mid_range) / 2\n  lower_quantile = (1 - interval_mid_range) / 2\n  upper_bound = jnp.quantile(a=predictions, q=upper_quantile, axis=0)\n  lower_bound = jnp.quantile(a=predictions, q=lower_quantile, axis=0)\n\n  r2, _ = arviz.r2_score(y_true=target, y_pred=predictions)\n  mape = 100 * metrics.mean_absolute_percentage_error(\n      y_true=target, y_pred=predictions.mean(axis=0))\n  axis.plot(jnp.arange(target.shape[0]), target, c=\"grey\", alpha=.9)\n  axis.plot(\n      jnp.arange(target.shape[0]),\n      predictions.mean(axis=0),\n      c=\"green\",\n      alpha=.9)\n  axis.fill_between(\n      x=jnp.arange(target.shape[0]),\n      y1=lower_bound,\n      y2=upper_bound,\n      alpha=.35,\n      color=\"green\")\n  axis.legend([\"True KPI\", \"Predicted KPI\"])\n  axis.yaxis.grid(color=\"gray\", linestyle=\"dashed\", alpha=0.3)\n  axis.xaxis.grid(color=\"gray\", linestyle=\"dashed\", alpha=0.3)\n  title = \" \".join([\n      title_prefix,\n      \"True and predicted KPI.\",\n      \"R2 = {r2:.{digits}f}\".format(r2=r2, digits=digits),\n      \"MAPE = {mape:.{digits}f}%\".format(mape=mape, digits=digits)\n  ])\n  axis.title.set_text(title)\n  plt.close()\n\n\ndef _call_fit_plotter(\n    predictions: jnp.array,\n    target: jnp.array,\n    interval_mid_range: float,\n    digits: int) -> matplotlib.figure.Figure:\n  \"\"\"Calls the shaded line plot once for national and N times for geo models.\n\n  Args:\n    predictions: 2d array of predicted values.\n    target: Array of true values. Must be same length as prediction.\n    interval_mid_range: Mid range interval to take for plotting. Eg. .9 will use\n      .05 and .95 as the lower and upper quantiles. Must be a float number\n      between 0 and 1.\n    digits: Number of decimals to display on metrics in the plot.\n\n  Returns:\n    Figure of the plot.\n  \"\"\"\n  # TODO(): Allow to pass geo names for fit plots\n  if predictions.ndim == 3:  # Multiple plots for geo model\n    figure, axes = plt.subplots(predictions.shape[-1],\n                                figsize=(10, 5 * predictions.shape[-1]))\n    for i, ax in enumerate(axes):\n      _create_shaded_line_plot(predictions=predictions[..., i],\n                               target=target[..., i],\n                               axis=ax,\n                               title_prefix=f\"Geo {i}:\",\n                               interval_mid_range=interval_mid_range,\n                               digits=digits)\n  else:  # Single plot for national model\n    figure, ax = plt.subplots(1, 1)\n    _create_shaded_line_plot(predictions=predictions,\n                             target=target,\n                             axis=ax,\n                             interval_mid_range=interval_mid_range,\n                             digits=digits)\n  return figure\n\n\ndef plot_model_fit(media_mix_model: lightweight_mmm.LightweightMMM,\n                   target_scaler: Optional[preprocessing.CustomScaler] = None,\n                   interval_mid_range: float = .9,\n                   digits: int = 3) -> matplotlib.figure.Figure:\n  \"\"\"Plots the ground truth, predicted value and interval for the training data.\n\n  Model needs to be fit before calling this function to plot.\n\n  Args:\n    media_mix_model: Media mix model.\n    target_scaler: Scaler used for scaling the target, to unscaled values and\n      plot in the original scale.\n    interval_mid_range: Mid range interval to take for plotting. Eg. .9 will use\n      .05 and .95 as the lower and upper quantiles. Must be a float number.\n      between 0 and 1.\n    digits: Number of decimals to display on metrics in the plot.\n\n  Returns:\n    Plot of model fit.\n  \"\"\"\n  if not hasattr(media_mix_model, \"trace\"):\n    raise lightweight_mmm.NotFittedModelError(\n        \"Model needs to be fit first before attempting to plot its fit.\")\n  target_train = media_mix_model._target\n  posterior_pred = media_mix_model.trace[\"mu\"]\n  if target_scaler:\n    posterior_pred = target_scaler.inverse_transform(posterior_pred)\n    target_train = target_scaler.inverse_transform(target_train)\n\n  return _call_fit_plotter(\n      predictions=posterior_pred,\n      target=target_train,\n      interval_mid_range=interval_mid_range,\n      digits=digits)\n\n\ndef plot_out_of_sample_model_fit(out_of_sample_predictions: jnp.ndarray,\n                                 out_of_sample_target: jnp.ndarray,\n                                 interval_mid_range: float = .9,\n                                 digits: int = 3) -> matplotlib.figure.Figure:\n  \"\"\"Plots the ground truth, predicted value and interval for the test data.\n\n  Args:\n    out_of_sample_predictions: Predictions for the out-of-sample period, as\n      derived from mmm.predict.\n    out_of_sample_target: Target for the out-of-sample period. Needs to be on\n      the same scale as out_of_sample_predictions.\n    interval_mid_range: Mid range interval to take for plotting. Eg. .9 will use\n      .05 and .95 as the lower and upper quantiles. Must be a float number.\n      between 0 and 1.\n    digits: Number of decimals to display on metrics in the plot.\n\n  Returns:\n    Plot of model fit.\n  \"\"\""
  },
  {
    "id": "221",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for seasonality.\"\"\"\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import handlers\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nfrom lightweight_mmm.core import priors\nfrom lightweight_mmm.core.time import seasonality\n\n\nclass SeasonalityTest(parameterized.TestCase):\n\n  @parameterized.named_parameters([\n      dict(\n          testcase_name=\"2_degrees\",\n          seasonality_arange_value=150,\n          degrees_arange_shape=5,\n          gamma_seasonality_shape=(5, 2),\n      ),\n      dict(\n          testcase_name=\"10_degree\",\n          seasonality_arange_value=150,\n          degrees_arange_shape=10,\n          gamma_seasonality_shape=(10, 2),\n      ),\n      dict(\n          testcase_name=\"1_degree\",\n          seasonality_arange_value=200,\n          degrees_arange_shape=1,\n          gamma_seasonality_shape=(1, 2),\n      ),\n  ])\n  def test_core_sinusoidal_seasonality_produces_correct_shape(\n      self, seasonality_arange_value, degrees_arange_shape,\n      gamma_seasonality_shape):\n    seasonality_arange = jnp.expand_dims(\n        jnp.arange(seasonality_arange_value), axis=-1)\n    degrees_arange = jnp.arange(degrees_arange_shape)\n    gamma_seasonality = jnp.ones(gamma_seasonality_shape)\n\n    seasonality_values = seasonality._sinusoidal_seasonality(\n        seasonality_arange=seasonality_arange,\n        degrees_arange=degrees_arange,\n        gamma_seasonality=gamma_seasonality,\n        frequency=52,\n    )\n    self.assertEqual(seasonality_values.shape, (seasonality_arange_value,))\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"ten_degrees_national\",\n          data_shape=(500, 5),\n          degrees_seasonality=10,\n          expected_shape=(10, 500),\n      ),\n      dict(\n          testcase_name=\"ten_degrees_geo\",\n          data_shape=(500, 5, 5),\n          degrees_seasonality=10,\n          expected_shape=(10, 500, 1),\n      ),\n      dict(\n          testcase_name=\"one_degrees_national\",\n          data_shape=(500, 5),\n          degrees_seasonality=1,\n          expected_shape=(10, 500),\n      ),\n      dict(\n          testcase_name=\"one_degrees_geo\",\n          data_shape=(500, 5, 5),\n          degrees_seasonality=1,\n          expected_shape=(10, 500, 1),\n      ),\n  )\n  def test_model_sinusoidal_seasonality_produces_correct_shape(\n      self, data_shape, degrees_seasonality, expected_shape):\n\n    def mock_model_function(data, degrees_seasonality, frequency):"
  },
  {
    "id": "222",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for seasonality.\"\"\"\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import handlers\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nfrom lightweight_mmm.core import priors\nfrom lightweight_mmm.core.time import seasonality\n\n\nclass SeasonalityTest(parameterized.TestCase):\n\n  @parameterized.named_parameters([\n      dict(\n          testcase_name=\"2_degrees\",\n          seasonality_arange_value=150,\n          degrees_arange_shape=5,\n          gamma_seasonality_shape=(5, 2),\n      ),\n      dict(\n          testcase_name=\"10_degree\",\n          seasonality_arange_value=150,\n          degrees_arange_shape=10,\n          gamma_seasonality_shape=(10, 2),\n      ),\n      dict(\n          testcase_name=\"1_degree\",\n          seasonality_arange_value=200,\n          degrees_arange_shape=1,\n          gamma_seasonality_shape=(1, 2),\n      ),\n  ])\n  def test_core_sinusoidal_seasonality_produces_correct_shape(\n      self, seasonality_arange_value, degrees_arange_shape,\n      gamma_seasonality_shape):\n    seasonality_arange = jnp.expand_dims(\n        jnp.arange(seasonality_arange_value), axis=-1)\n    degrees_arange = jnp.arange(degrees_arange_shape)\n    gamma_seasonality = jnp.ones(gamma_seasonality_shape)\n\n    seasonality_values = seasonality._sinusoidal_seasonality(\n        seasonality_arange=seasonality_arange,\n        degrees_arange=degrees_arange,\n        gamma_seasonality=gamma_seasonality,\n        frequency=52,\n    )\n    self.assertEqual(seasonality_values.shape, (seasonality_arange_value,))\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"ten_degrees_national\",\n          data_shape=(500, 5),\n          degrees_seasonality=10,\n          expected_shape=(10, 500),\n      ),\n      dict(\n          testcase_name=\"ten_degrees_geo\",\n          data_shape=(500, 5, 5),\n          degrees_seasonality=10,\n          expected_shape=(10, 500, 1),\n      ),\n      dict(\n          testcase_name=\"one_degrees_national\",\n          data_shape=(500, 5),\n          degrees_seasonality=1,\n          expected_shape=(10, 500),\n      ),\n      dict(\n          testcase_name=\"one_degrees_geo\",\n          data_shape=(500, 5, 5),\n          degrees_seasonality=1,\n          expected_shape=(10, 500, 1),\n      ),\n  )\n  def test_model_sinusoidal_seasonality_produces_correct_shape(\n      self, data_shape, degrees_seasonality, expected_shape):\n\n    def mock_model_function(data, degrees_seasonality, frequency):\n      numpyro.deterministic(\n          \"seasonality\",\n          seasonality.sinusoidal_seasonality(\n              data=data,\n              degrees_seasonality=degrees_seasonality,\n              custom_priors={},\n              frequency=frequency))\n\n    num_samples = 10\n    data = jnp.ones(data_shape)\n    kernel = numpyro.infer.NUTS(model=mock_model_function)\n    mcmc = numpyro.infer.MCMC(\n        sampler=kernel, num_warmup=10, num_samples=num_samples, num_chains=1)\n    rng_key = jax.random.PRNGKey(0)\n\n    mcmc.run(\n        rng_key,\n        data=data,\n        degrees_seasonality=degrees_seasonality,\n        frequency=52,\n    )\n    seasonality_values = mcmc.get_samples()[\"seasonality\"]\n\n    self.assertEqual(seasonality_values.shape, expected_shape)\n\n  def test_sinusoidal_seasonality_custom_priors_are_taken_correctly(self):\n    prior_name = priors.GAMMA_SEASONALITY\n    expected_value1, expected_value2 = 5.2, 7.56\n    custom_priors = {\n        prior_name:\n            dist.Kumaraswamy(\n                concentration1=expected_value1, concentration0=expected_value2)\n    }\n    media = jnp.ones((10, 5, 5))\n    degrees_seasonality = 3\n    frequency = 365\n\n    trace_handler = handlers.trace(\n        handlers.seed(seasonality.sinusoidal_seasonality, rng_seed=0))\n    trace = trace_handler.get_trace(\n        data=media,\n        custom_priors=custom_priors,\n        degrees_seasonality=degrees_seasonality,\n        frequency=frequency,\n    )\n    values_and_dists = {\n        name: site[\"fn\"] for name, site in trace.items() if \"fn\" in site\n    }\n\n    used_distribution = values_and_dists[prior_name]\n    if isinstance(used_distribution, dist.ExpandedDistribution):\n      used_distribution = used_distribution.base_dist\n    self.assertIsInstance(used_distribution, dist.Kumaraswamy)\n    self.assertEqual(used_distribution.concentration0, expected_value2)\n    self.assertEqual(used_distribution.concentration1, expected_value1)\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"ten_degrees\",\n          data_shape=(500, 3),\n          expected_shape=(10, 500),\n      ),\n      dict(\n          testcase_name=\"five_degrees\",\n          data_shape=(500, 3, 5),\n          expected_shape=(10, 500, 1),\n      ),\n  )\n  def test_intra_week_seasonality_produces_correct_shape(\n      self, data_shape, expected_shape):\n\n    def mock_model_function(data):"
  },
  {
    "id": "223",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for trend.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import handlers\n\nfrom lightweight_mmm.core import core_utils\nfrom lightweight_mmm.core import priors\nfrom lightweight_mmm.core.time import trend\n\n\nclass TrendTest(parameterized.TestCase):\n\n  @parameterized.named_parameters([\n      dict(\n          testcase_name=\"national\",\n          coef_trend_shape=(),\n          trend_length=150,\n          expo_trend_shape=(),\n      ),\n      dict(\n          testcase_name=\"geo\",\n          coef_trend_shape=(5,),\n          trend_length=150,\n          expo_trend_shape=(),\n      ),\n  ])\n  def test_core_trend_with_exponent_produces_correct_shape(\n      self, coef_trend_shape, trend_length, expo_trend_shape):\n    coef_trend = jnp.ones(coef_trend_shape)\n    linear_trend = jnp.arange(trend_length)\n    if coef_trend.ndim == 1:  # For geo model's case\n      linear_trend = jnp.expand_dims(linear_trend, axis=-1)\n    expo_trend = jnp.ones(expo_trend_shape)\n\n    trend_values = trend._trend_with_exponent(\n        coef_trend=coef_trend, trend=linear_trend, expo_trend=expo_trend)\n\n    self.assertEqual(trend_values.shape,\n                     (linear_trend.shape[0], *coef_trend_shape))\n\n  @parameterized.named_parameters([\n      dict(testcase_name=\"national\", data_shape=(150, 3)),\n      dict(testcase_name=\"geo\", data_shape=(150, 3, 5)),\n  ])\n  def test_trend_with_exponent_produces_correct_shape(self, data_shape):\n\n    def mock_model_function(data):"
  },
  {
    "id": "224",
    "text": " linear_trend = jnp.expand_dims(linear_trend, axis=-1)\n    expo_trend = jnp.ones(expo_trend_shape)\n\n    trend_values = trend._trend_with_exponent(\n        coef_trend=coef_trend, trend=linear_trend, expo_trend=expo_trend)\n\n    self.assertEqual(trend_values.shape,\n                     (linear_trend.shape[0], *coef_trend_shape))\n\n  @parameterized.named_parameters([\n      dict(testcase_name=\"national\", data_shape=(150, 3)),\n      dict(testcase_name=\"geo\", data_shape=(150, 3, 5)),\n  ])\n  def test_trend_with_exponent_produces_correct_shape(self, data_shape):\n\n    def mock_model_function(data):\n      numpyro.deterministic(\n          \"trend\", trend.trend_with_exponent(\n              data=data,\n              custom_priors={},\n          ))\n\n    num_samples = 10\n    data = jnp.ones(data_shape)\n    kernel = numpyro.infer.NUTS(model=mock_model_function)\n    mcmc = numpyro.infer.MCMC(\n        sampler=kernel, num_warmup=10, num_samples=num_samples, num_chains=1)\n    rng_key = jax.random.PRNGKey(0)\n    coef_expected_shape = () if data.ndim == 2 else (data.shape[2],)\n\n    mcmc.run(rng_key, data=data)\n    trend_values = mcmc.get_samples()[\"trend\"]\n\n    self.assertEqual(trend_values.shape,\n                     (num_samples, data.shape[0], *coef_expected_shape))\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=f\"model_{priors.COEF_TREND}\",\n          prior_name=priors.COEF_TREND,\n      ),\n      dict(\n          testcase_name=f\"model_{priors.EXPO_TREND}\",\n          prior_name=priors.EXPO_TREND,\n      ),\n  )\n  def test_trend_with_exponent_custom_priors_are_taken_correctly(\n      self, prior_name):\n    expected_value1, expected_value2 = 5.2, 7.56\n    custom_priors = {\n        prior_name:\n            dist.Kumaraswamy(\n                concentration1=expected_value1, concentration0=expected_value2)\n    }\n    media = jnp.ones((10, 5, 5))\n\n    trace_handler = handlers.trace(\n        handlers.seed(trend.trend_with_exponent, rng_seed=0))\n    trace = trace_handler.get_trace(\n        data=media,\n        custom_priors=custom_priors,\n    )\n    values_and_dists = {\n        name: site[\"fn\"] for name, site in trace.items() if \"fn\" in site\n    }\n\n    used_distribution = values_and_dists[prior_name]\n    if isinstance(used_distribution, dist.ExpandedDistribution):\n      used_distribution = used_distribution.base_dist\n    self.assertIsInstance(used_distribution, dist.Kumaraswamy)\n    self.assertEqual(used_distribution.concentration0, expected_value2)\n    self.assertEqual(used_distribution.concentration1, expected_value1)\n\n  @parameterized.named_parameters([\n      dict(\n          testcase_name=\"dynamic_trend_national_shape\",\n          number_periods=100,\n          initial_level_shape=(),\n          initial_slope_shape=(),\n          variance_level_shape=(),\n          variance_slope_shape=(),\n      ),\n      dict(\n          testcase_name=\"dynamic_trend_geo_shape\",\n          number_periods=100,\n          initial_level_shape=(2,),\n          initial_slope_shape=(2,),\n          variance_level_shape=(2,),\n          variance_slope_shape=(2,),\n      ),\n  ])\n  def test_core_dynamic_trend_produces_correct_shape(\n      self, number_periods, initial_level_shape, initial_slope_shape,\n      variance_level_shape, variance_slope_shape):\n    initial_level = jnp.ones(initial_level_shape)\n    initial_slope = jnp.ones(initial_slope_shape)\n    variance_level = jnp.ones(variance_level_shape)\n    variance_slope = jnp.ones(variance_slope_shape)\n    random_walk_level = jnp.arange(number_periods)\n    random_walk_slope = jnp.arange(number_periods)\n    if initial_level.ndim == 1:  # For geo model's case\n      random_walk_level = jnp.expand_dims(random_walk_level, axis=-1)\n      random_walk_slope = jnp.expand_dims(random_walk_slope, axis=-1)\n\n    dynamic_trend_values = trend._dynamic_trend(\n        number_periods=number_periods,\n        random_walk_level=random_walk_level,\n        random_walk_slope=random_walk_slope,\n        initial_level=initial_level,\n        initial_slope=initial_slope,\n        variance_level=variance_level,\n        variance_slope=variance_slope,\n    )\n\n    self.assertEqual(dynamic_trend_values.shape,\n                     (number_periods, *initial_level_shape))\n\n  def test_core_dynamic_trend_produces_correct_value(self):\n    number_periods = 5\n    initial_level = jnp.ones(())\n    initial_slope = jnp.ones(())\n    variance_level = jnp.ones(())\n    variance_slope = jnp.ones(())\n    random_walk_level = jnp.arange(number_periods)\n    random_walk_slope = jnp.arange(number_periods)\n    dynamic_trend_expected_value = jnp.array([1, 3, 7, 14, 25])\n\n    dynamic_trend_values = trend._dynamic_trend(\n        number_periods=number_periods,\n        random_walk_level=random_walk_level,\n        random_walk_slope=random_walk_slope,\n        initial_level=initial_level,\n        initial_slope=initial_slope,\n        variance_level=variance_level,\n        variance_slope=variance_slope,\n    )\n\n    np.testing.assert_array_equal(x=dynamic_trend_values,\n                                  y=dynamic_trend_expected_value)\n\n  @parameterized.named_parameters([\n      dict(\n          testcase_name=\"national_with_prediction_is_true\",\n          data_shape=(100, 3),\n          is_trend_prediction=True),\n      dict(\n          testcase_name=\"geo_with_prediction_is_true\",\n          data_shape=(150, 3, 5),\n          is_trend_prediction=True),\n      dict(\n          testcase_name=\"national_with_prediction_is_false\",\n          data_shape=(100, 3),\n          is_trend_prediction=False),\n      dict(\n          testcase_name=\"geo_with_prediction_is_false\",\n          data_shape=(150, 3, 5),\n          is_trend_prediction=False),\n  ])\n  def test_dynamic_trend_produces_correct_shape(\n      self, data_shape, is_trend_prediction):\n\n    def mock_model_function(geo_size, data_size):"
  },
  {
    "id": "225",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Core and modelling functions for seasonality.\"\"\"\n\nfrom typing import Mapping\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm.core import priors\nfrom lightweight_mmm.core import core_utils\n\n\n@jax.jit\ndef _sinusoidal_seasonality(\n    seasonality_arange: jnp.ndarray,\n    degrees_arange: jnp.ndarray,\n    gamma_seasonality: jnp.ndarray,\n    frequency: int,\n) -> jnp.ndarray:\n  \"\"\"Core calculation of cyclic variation seasonality.\n\n  Args:\n    seasonality_arange: Array with range [0, N - 1] where N is the size of the\n      data for which the seasonality is modelled.\n    degrees_arange: Array with range [0, D - 1] where D is the number of degrees\n      to use. Must be greater or equal than 1.\n    gamma_seasonality: Factor to multiply to each degree calculation. Shape must\n      be aligned with the number of degrees.\n    frequency: Frecuency of the seasonality be in computed.\n\n  Returns:\n    An array with the seasonality values.\n  \"\"\""
  },
  {
    "id": "226",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Core and modelling functions for seasonality.\"\"\"\n\nfrom typing import Mapping\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm.core import priors\nfrom lightweight_mmm.core import core_utils\n\n\n@jax.jit\ndef _sinusoidal_seasonality(\n    seasonality_arange: jnp.ndarray,\n    degrees_arange: jnp.ndarray,\n    gamma_seasonality: jnp.ndarray,\n    frequency: int,\n) -> jnp.ndarray:\n  \"\"\"Core calculation of cyclic variation seasonality.\n\n  Args:\n    seasonality_arange: Array with range [0, N - 1] where N is the size of the\n      data for which the seasonality is modelled.\n    degrees_arange: Array with range [0, D - 1] where D is the number of degrees\n      to use. Must be greater or equal than 1.\n    gamma_seasonality: Factor to multiply to each degree calculation. Shape must\n      be aligned with the number of degrees.\n    frequency: Frecuency of the seasonality be in computed.\n\n  Returns:\n    An array with the seasonality values.\n  \"\"\"\n  inner_value = seasonality_arange * 2 * jnp.pi * degrees_arange / frequency\n  season_matrix_sin = jnp.sin(inner_value)\n  season_matrix_cos = jnp.cos(inner_value)\n  season_matrix = jnp.concatenate([\n      jnp.expand_dims(a=season_matrix_sin, axis=-1),\n      jnp.expand_dims(a=season_matrix_cos, axis=-1)\n  ],\n                                  axis=-1)\n  return jnp.einsum(\"tds, ds -> t\", season_matrix, gamma_seasonality)\n\n\ndef sinusoidal_seasonality(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n    *,\n    degrees_seasonality: int = 2,\n    frequency: int = 52,\n) -> jnp.ndarray:\n  \"\"\"Calculates cyclic variation seasonality.\n\n  For detailed info check:\n    https://en.wikipedia.org/wiki/Seasonality#Modeling\n\n  Args:\n    data: Data for which the seasonality will be modelled for. It is used to\n      obtain the length of the time dimension, axis 0.\n    custom_priors: The custom priors we want the model to take instead of\n      default ones.\n    degrees_seasonality: Number of degrees to use. Must be greater or equal than\n      1.\n    frequency: Frecuency of the seasonality be in computed. By default is 52 for\n      weekly data (52 weeks in a year).\n\n  Returns:\n    An array with the seasonality values.\n  \"\"\""
  },
  {
    "id": "227",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Core and modelling functions for seasonality.\"\"\"\n\nfrom typing import Mapping\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm.core import priors\nfrom lightweight_mmm.core import core_utils\n\n\n@jax.jit\ndef _sinusoidal_seasonality(\n    seasonality_arange: jnp.ndarray,\n    degrees_arange: jnp.ndarray,\n    gamma_seasonality: jnp.ndarray,\n    frequency: int,\n) -> jnp.ndarray:\n  \"\"\"Core calculation of cyclic variation seasonality.\n\n  Args:\n    seasonality_arange: Array with range [0, N - 1] where N is the size of the\n      data for which the seasonality is modelled.\n    degrees_arange: Array with range [0, D - 1] where D is the number of degrees\n      to use. Must be greater or equal than 1.\n    gamma_seasonality: Factor to multiply to each degree calculation. Shape must\n      be aligned with the number of degrees.\n    frequency: Frecuency of the seasonality be in computed.\n\n  Returns:\n    An array with the seasonality values.\n  \"\"\"\n  inner_value = seasonality_arange * 2 * jnp.pi * degrees_arange / frequency\n  season_matrix_sin = jnp.sin(inner_value)\n  season_matrix_cos = jnp.cos(inner_value)\n  season_matrix = jnp.concatenate([\n      jnp.expand_dims(a=season_matrix_sin, axis=-1),\n      jnp.expand_dims(a=season_matrix_cos, axis=-1)\n  ],\n                                  axis=-1)\n  return jnp.einsum(\"tds, ds -> t\", season_matrix, gamma_seasonality)\n\n\ndef sinusoidal_seasonality(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n    *,\n    degrees_seasonality: int = 2,\n    frequency: int = 52,\n) -> jnp.ndarray:\n  \"\"\"Calculates cyclic variation seasonality.\n\n  For detailed info check:\n    https://en.wikipedia.org/wiki/Seasonality#Modeling\n\n  Args:\n    data: Data for which the seasonality will be modelled for. It is used to\n      obtain the length of the time dimension, axis 0.\n    custom_priors: The custom priors we want the model to take instead of\n      default ones.\n    degrees_seasonality: Number of degrees to use. Must be greater or equal than\n      1.\n    frequency: Frecuency of the seasonality be in computed. By default is 52 for\n      weekly data (52 weeks in a year).\n\n  Returns:\n    An array with the seasonality values.\n  \"\"\"\n  number_periods = data.shape[0]\n  default_priors = priors.get_default_priors()\n  n_geos = core_utils.get_number_geos(data=data)\n  with numpyro.plate(name=f\"{priors.GAMMA_SEASONALITY}_sin_cos_plate\", size=2):\n    with numpyro.plate(\n        name=f\"{priors.GAMMA_SEASONALITY}_plate\", size=degrees_seasonality):\n      gamma_seasonality = numpyro.sample(\n          name=priors.GAMMA_SEASONALITY,\n          fn=custom_priors.get(priors.GAMMA_SEASONALITY,\n                               default_priors[priors.GAMMA_SEASONALITY]))\n  seasonality_arange = jnp.expand_dims(a=jnp.arange(number_periods), axis=-1)\n  degrees_arange = jnp.arange(degrees_seasonality)\n  seasonality_values = _sinusoidal_seasonality(\n      seasonality_arange=seasonality_arange,\n      degrees_arange=degrees_arange,\n      frequency=frequency,\n      gamma_seasonality=gamma_seasonality,\n  )\n  if n_geos > 1:\n    seasonality_values = jnp.expand_dims(seasonality_values, axis=-1)\n  return seasonality_values\n\n\ndef _intra_week_seasonality(\n    data: jnp.ndarray,\n    weekday: jnp.ndarray,\n) -> jnp.ndarray:\n  data_size = data.shape[0]\n  return weekday[jnp.arange(data_size) % 7]\n\n\ndef intra_week_seasonality(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n) -> jnp.ndarray:\n  \"\"\"Models intra week seasonality.\n\n  Args:\n    data: Data for which the seasonality will be modelled for. It is used to\n      obtain the length of the time dimension, axis 0.\n    custom_priors: The custom priors we want the model to take instead of\n      default ones.\n\n  Returns:\n    The contribution of the weekday seasonality.\n  \"\"\""
  },
  {
    "id": "228",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Core and modelling functions for trend.\"\"\"\n\nimport functools\nfrom typing import Mapping\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm.core import core_utils\nfrom lightweight_mmm.core import priors\n\n\n@jax.jit\ndef _trend_with_exponent(coef_trend: jnp.ndarray, trend: jnp.ndarray,\n                         expo_trend: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Applies the coefficient and exponent to the trend to obtain trend values.\n\n  Args:\n    coef_trend: Coefficient to be multiplied by the trend.\n    trend: Initial trend values.\n    expo_trend: Exponent to be applied to the trend.\n\n  Returns:\n    The trend values generated.\n  \"\"\"\n  return coef_trend * trend**expo_trend\n\n\ndef trend_with_exponent(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n) -> jnp.ndarray:\n  \"\"\"Trend with exponent for curvature.\n\n  Args:\n    data: Data for which trend will be created.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones. See our custom_priors documentation for details about the\n      API and possible options.\n\n  Returns:\n    The values of the trend.\n  \"\"\""
  },
  {
    "id": "229",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Core and modelling functions for trend.\"\"\"\n\nimport functools\nfrom typing import Mapping\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm.core import core_utils\nfrom lightweight_mmm.core import priors\n\n\n@jax.jit\ndef _trend_with_exponent(coef_trend: jnp.ndarray, trend: jnp.ndarray,\n                         expo_trend: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Applies the coefficient and exponent to the trend to obtain trend values.\n\n  Args:\n    coef_trend: Coefficient to be multiplied by the trend.\n    trend: Initial trend values.\n    expo_trend: Exponent to be applied to the trend.\n\n  Returns:\n    The trend values generated.\n  \"\"\"\n  return coef_trend * trend**expo_trend\n\n\ndef trend_with_exponent(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n) -> jnp.ndarray:\n  \"\"\"Trend with exponent for curvature.\n\n  Args:\n    data: Data for which trend will be created.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones. See our custom_priors documentation for details about the\n      API and possible options.\n\n  Returns:\n    The values of the trend.\n  \"\"\"\n  default_priors = priors.get_default_priors()\n  n_geos = core_utils.get_number_geos(data=data)\n  # TODO(): Force all geos to have the same trend sign.\n  with numpyro.plate(name=f\"{priors.COEF_TREND}_plate\", size=n_geos):\n    coef_trend = numpyro.sample(\n        name=priors.COEF_TREND,\n        fn=custom_priors.get(priors.COEF_TREND,\n                             default_priors[priors.COEF_TREND]))\n\n  expo_trend = numpyro.sample(\n      name=priors.EXPO_TREND,\n      fn=custom_priors.get(priors.EXPO_TREND,\n                           default_priors[priors.EXPO_TREND]))\n  linear_trend = jnp.arange(data.shape[0])\n  if n_geos > 1:  # For geo model's case\n    linear_trend = jnp.expand_dims(linear_trend, axis=-1)\n  return _trend_with_exponent(\n      coef_trend=coef_trend, trend=linear_trend, expo_trend=expo_trend)\n\n\n@functools.partial(jax.jit, static_argnames=(\"number_periods\",))\ndef _dynamic_trend(\n    number_periods: int,\n    random_walk_level: jnp.ndarray,\n    random_walk_slope: jnp.ndarray,\n    initial_level: jnp.ndarray,\n    initial_slope: jnp.ndarray,\n    variance_level: jnp.ndarray,\n    variance_slope: jnp.ndarray,\n) -> jnp.ndarray:\n  \"\"\"Calculates dynamic trend using local linear trend method.\n\n  More details about this function can be found in:\n  https://storage.googleapis.com/pub-tools-public-publication-data/pdf/41854.pdf\n\n  Args:\n    number_periods: Number of time periods in the data.\n    random_walk_level: Random walk of level from sample.\n    random_walk_slope: Random walk of slope from sample.\n    initial_level: The initial value for level in local linear trend model.\n    initial_slope: The initial value for slope in local linear trend model.\n    variance_level: The variance of the expected increase in level between time.\n    variance_slope: The variance of the expected increase in slope between time.\n\n  Returns:\n    The dynamic trend values for the given data with the given parameters.\n  \"\"\"\n  # Simulate gaussian random walk of level with initial level."
  },
  {
    "id": "230",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Module for modeling the intercept.\"\"\"\n\nfrom typing import Mapping\n\nimport immutabledict\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm.core import core_utils\nfrom lightweight_mmm.core import priors\n\n\ndef simple_intercept(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str,\n                           dist.Distribution] = immutabledict.immutabledict(),\n) -> jnp.ndarray:\n  \"\"\"Calculates a national or geo incercept.\n  Note that this intercept is constant over time.\n\n  Args:\n    data: Media input data. Media data must have either 2 dims for national\n      model or 3 for geo models.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones. Refer to the full documentation on custom priors for\n      details.\n\n  Returns:\n    The values of the intercept.\n  \"\"\""
  },
  {
    "id": "231",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for intercept.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import handlers\nimport numpyro.distributions as dist\n\nfrom lightweight_mmm.core import core_utils\nfrom lightweight_mmm.core import priors\nfrom lightweight_mmm.core.baseline import intercept\n\n\nclass InterceptTest(parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"national\",\n          data_shape=(150, 3),\n      ),\n      dict(\n          testcase_name=\"geo\",\n          data_shape=(150, 3, 5),\n      ),\n  )\n  def test_simple_intercept_produces_output_correct_shape(self, data_shape):\n\n    def mock_model_function(data):"
  },
  {
    "id": "232",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set of core and modelling saturation functions.\"\"\"\n\nfrom typing import Mapping\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm.core import core_utils\nfrom lightweight_mmm.core import priors\n\n\n@jax.jit\ndef _hill(\n    data: jnp.ndarray,\n    half_max_effective_concentration: jnp.ndarray,\n    slope: jnp.ndarray,\n) -> jnp.ndarray:\n  \"\"\"Calculates the hill function for a given array of values.\n\n  Refer to the following link for detailed information on this equation:\n    https://en.wikipedia.org/wiki/Hill_equation_(biochemistry)\n\n  Args:\n    data: Input data.\n    half_max_effective_concentration: ec50 value for the hill function.\n    slope: Slope of the hill function.\n\n  Returns:\n    The hill values for the respective input data.\n  \"\"\""
  },
  {
    "id": "233",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set of core and modelling saturation functions.\"\"\"\n\nfrom typing import Mapping\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm.core import core_utils\nfrom lightweight_mmm.core import priors\n\n\n@jax.jit\ndef _hill(\n    data: jnp.ndarray,\n    half_max_effective_concentration: jnp.ndarray,\n    slope: jnp.ndarray,\n) -> jnp.ndarray:\n  \"\"\"Calculates the hill function for a given array of values.\n\n  Refer to the following link for detailed information on this equation:\n    https://en.wikipedia.org/wiki/Hill_equation_(biochemistry)\n\n  Args:\n    data: Input data.\n    half_max_effective_concentration: ec50 value for the hill function.\n    slope: Slope of the hill function.\n\n  Returns:\n    The hill values for the respective input data.\n  \"\"\"\n  save_transform = core_utils.apply_exponent_safe(\n      data=data / half_max_effective_concentration, exponent=-slope)\n  return jnp.where(save_transform == 0, x=0, y=1. / (1 + save_transform))\n\n\ndef hill(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n    *,\n    prefix: str = \"\",\n) -> jnp.ndarray:\n  \"\"\"Transforms the input data with the adstock and hill functions.\n\n  Args:\n    data: Media data to be transformed. It is expected to have 2 dims for\n      national models and 3 for geo models.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones. The possible names of parameters for hill_adstock and\n      exponent are \"lag_weight\", \"half_max_effective_concentration\" and \"slope\".\n    prefix: Prefix to use in the variable name for Numpyro.\n\n  Returns:\n    The transformed media data.\n  \"\"\""
  },
  {
    "id": "234",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set of core and modelling saturation functions.\"\"\"\n\nfrom typing import Mapping\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm.core import core_utils\nfrom lightweight_mmm.core import priors\n\n\n@jax.jit\ndef _hill(\n    data: jnp.ndarray,\n    half_max_effective_concentration: jnp.ndarray,\n    slope: jnp.ndarray,\n) -> jnp.ndarray:\n  \"\"\"Calculates the hill function for a given array of values.\n\n  Refer to the following link for detailed information on this equation:\n    https://en.wikipedia.org/wiki/Hill_equation_(biochemistry)\n\n  Args:\n    data: Input data.\n    half_max_effective_concentration: ec50 value for the hill function.\n    slope: Slope of the hill function.\n\n  Returns:\n    The hill values for the respective input data.\n  \"\"\"\n  save_transform = core_utils.apply_exponent_safe(\n      data=data / half_max_effective_concentration, exponent=-slope)\n  return jnp.where(save_transform == 0, x=0, y=1. / (1 + save_transform))\n\n\ndef hill(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n    *,\n    prefix: str = \"\",\n) -> jnp.ndarray:\n  \"\"\"Transforms the input data with the adstock and hill functions.\n\n  Args:\n    data: Media data to be transformed. It is expected to have 2 dims for\n      national models and 3 for geo models.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones. The possible names of parameters for hill_adstock and\n      exponent are \"lag_weight\", \"half_max_effective_concentration\" and \"slope\".\n    prefix: Prefix to use in the variable name for Numpyro.\n\n  Returns:\n    The transformed media data.\n  \"\"\"\n  default_priors = priors.get_default_priors()\n\n  with numpyro.plate(\n      name=f\"{prefix}{priors.HALF_MAX_EFFECTIVE_CONCENTRATION}_plate\",\n      size=data.shape[1]):\n    half_max_effective_concentration = numpyro.sample(\n        name=f\"{prefix}{priors.HALF_MAX_EFFECTIVE_CONCENTRATION}\",\n        fn=custom_priors.get(\n            priors.HALF_MAX_EFFECTIVE_CONCENTRATION,\n            default_priors[priors.HALF_MAX_EFFECTIVE_CONCENTRATION]))\n\n  with numpyro.plate(name=f\"{prefix}{priors.SLOPE}_plate\", size=data.shape[1]):\n    slope = numpyro.sample(\n        name=f\"{prefix}{priors.SLOPE}\",\n        fn=custom_priors.get(priors.SLOPE, default_priors[priors.SLOPE]))\n\n  if data.ndim == 3:\n    half_max_effective_concentration = jnp.expand_dims(\n        half_max_effective_concentration, axis=-1)\n    slope = jnp.expand_dims(slope, axis=-1)\n\n  return _hill(\n      data=data,\n      half_max_effective_concentration=half_max_effective_concentration,\n      slope=slope)\n\n\ndef _exponent(data: jnp.ndarray, exponent_values: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Applies exponent to the given data.\"\"\"\n  return core_utils.apply_exponent_safe(data=data, exponent=exponent_values)\n\n\ndef exponent(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n    *,\n    prefix: str = \"\",\n) -> jnp.ndarray:\n  \"\"\"Transforms the input data with the carryover function and exponent.\n\n  Args:\n    data: Media data to be transformed. It is expected to have 2 dims for\n      national models and 3 for geo models.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones.\n    prefix: Prefix to use in the variable name for Numpyro.\n\n  Returns:\n    The transformed media data.\n  \"\"\""
  },
  {
    "id": "235",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set of core and modelling lagging functions.\"\"\"\n\nimport functools\nfrom typing import Mapping, Union\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nimport numpyro.distributions as dist\nfrom lightweight_mmm.core import priors\n\n\n@functools.partial(jax.vmap, in_axes=(1, 1, None), out_axes=1)\ndef _carryover_convolve(data: jnp.ndarray, weights: jnp.ndarray,\n                        number_lags: int) -> jnp.ndarray:\n  \"\"\"Applies the convolution between the data and the weights for the carryover.\n\n  Args:\n    data: Input data.\n    weights: Window weights for the carryover.\n    number_lags: Number of lags the window has.\n\n  Returns:\n    The result values from convolving the data and the weights with padding.\n  \"\"\"\n  window = jnp.concatenate([jnp.zeros(number_lags - 1), weights])\n  return jax.scipy.signal.convolve(data, window, mode=\"same\") / weights.sum()\n\n\n@functools.partial(jax.jit, static_argnames=(\"number_lags\",))\ndef _carryover(\n    data: jnp.ndarray,\n    ad_effect_retention_rate: jnp.ndarray,\n    peak_effect_delay: jnp.ndarray,\n    number_lags: int,\n) -> jnp.ndarray:\n  \"\"\"Calculates media carryover.\n\n  More details about this function can be found in:\n  https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46001.pdf\n\n  Args:\n    data: Input data. It is expected that data has either 2 dimensions for\n      national models and 3 for geo models.\n    ad_effect_retention_rate: Retention rate of the advertisement effect.\n      Default is 0.5.\n    peak_effect_delay: Delay of the peak effect in the carryover function.\n      Default is 1.\n    number_lags: Number of lags to include in the carryover calculation. Default\n      is 13.\n\n  Returns:\n    The carryover values for the given data with the given parameters.\n  \"\"\""
  },
  {
    "id": "236",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set of core and modelling lagging functions.\"\"\"\n\nimport functools\nfrom typing import Mapping, Union\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nimport numpyro.distributions as dist\nfrom lightweight_mmm.core import priors\n\n\n@functools.partial(jax.vmap, in_axes=(1, 1, None), out_axes=1)\ndef _carryover_convolve(data: jnp.ndarray, weights: jnp.ndarray,\n                        number_lags: int) -> jnp.ndarray:\n  \"\"\"Applies the convolution between the data and the weights for the carryover.\n\n  Args:\n    data: Input data.\n    weights: Window weights for the carryover.\n    number_lags: Number of lags the window has.\n\n  Returns:\n    The result values from convolving the data and the weights with padding.\n  \"\"\"\n  window = jnp.concatenate([jnp.zeros(number_lags - 1), weights])\n  return jax.scipy.signal.convolve(data, window, mode=\"same\") / weights.sum()\n\n\n@functools.partial(jax.jit, static_argnames=(\"number_lags\",))\ndef _carryover(\n    data: jnp.ndarray,\n    ad_effect_retention_rate: jnp.ndarray,\n    peak_effect_delay: jnp.ndarray,\n    number_lags: int,\n) -> jnp.ndarray:\n  \"\"\"Calculates media carryover.\n\n  More details about this function can be found in:\n  https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46001.pdf\n\n  Args:\n    data: Input data. It is expected that data has either 2 dimensions for\n      national models and 3 for geo models.\n    ad_effect_retention_rate: Retention rate of the advertisement effect.\n      Default is 0.5.\n    peak_effect_delay: Delay of the peak effect in the carryover function.\n      Default is 1.\n    number_lags: Number of lags to include in the carryover calculation. Default\n      is 13.\n\n  Returns:\n    The carryover values for the given data with the given parameters.\n  \"\"\"\n  lags_arange = jnp.expand_dims(\n      jnp.arange(number_lags, dtype=jnp.float32), axis=-1)\n  convolve_func = _carryover_convolve\n  if data.ndim == 3:\n    # Since _carryover_convolve is already vmaped in the decorator we only need\n    # to vmap it once here to handle the geo level data. We keep the windows bi\n    # dimensional also for three dims data and vmap over only the extra data\n    # dimension.\n    convolve_func = jax.vmap(\n        fun=_carryover_convolve, in_axes=(2, None, None), out_axes=2)\n  weights = ad_effect_retention_rate**((lags_arange - peak_effect_delay)**2)\n  return convolve_func(data, weights, number_lags)\n\n\ndef carryover(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n    *,\n    number_lags: int = 13,\n    prefix: str = \"\",\n) -> jnp.ndarray:\n  \"\"\"Transforms the input data with the carryover function.\n\n  Args:\n    data: Media data to be transformed. It is expected to have 2 dims for\n      national models and 3 for geo models.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones.\n    number_lags: Number of lags for the carryover function.\n    prefix: Prefix to use in the variable name for Numpyro.\n\n  Returns:\n    The transformed media data.\n  \"\"\""
  },
  {
    "id": "237",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set of core and modelling lagging functions.\"\"\"\n\nimport functools\nfrom typing import Mapping, Union\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nimport numpyro.distributions as dist\nfrom lightweight_mmm.core import priors\n\n\n@functools.partial(jax.vmap, in_axes=(1, 1, None), out_axes=1)\ndef _carryover_convolve(data: jnp.ndarray, weights: jnp.ndarray,\n                        number_lags: int) -> jnp.ndarray:\n  \"\"\"Applies the convolution between the data and the weights for the carryover.\n\n  Args:\n    data: Input data.\n    weights: Window weights for the carryover.\n    number_lags: Number of lags the window has.\n\n  Returns:\n    The result values from convolving the data and the weights with padding.\n  \"\"\"\n  window = jnp.concatenate([jnp.zeros(number_lags - 1), weights])\n  return jax.scipy.signal.convolve(data, window, mode=\"same\") / weights.sum()\n\n\n@functools.partial(jax.jit, static_argnames=(\"number_lags\",))\ndef _carryover(\n    data: jnp.ndarray,\n    ad_effect_retention_rate: jnp.ndarray,\n    peak_effect_delay: jnp.ndarray,\n    number_lags: int,\n) -> jnp.ndarray:\n  \"\"\"Calculates media carryover.\n\n  More details about this function can be found in:\n  https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46001.pdf\n\n  Args:\n    data: Input data. It is expected that data has either 2 dimensions for\n      national models and 3 for geo models.\n    ad_effect_retention_rate: Retention rate of the advertisement effect.\n      Default is 0.5.\n    peak_effect_delay: Delay of the peak effect in the carryover function.\n      Default is 1.\n    number_lags: Number of lags to include in the carryover calculation. Default\n      is 13.\n\n  Returns:\n    The carryover values for the given data with the given parameters.\n  \"\"\"\n  lags_arange = jnp.expand_dims(\n      jnp.arange(number_lags, dtype=jnp.float32), axis=-1)\n  convolve_func = _carryover_convolve\n  if data.ndim == 3:\n    # Since _carryover_convolve is already vmaped in the decorator we only need\n    # to vmap it once here to handle the geo level data. We keep the windows bi\n    # dimensional also for three dims data and vmap over only the extra data\n    # dimension.\n    convolve_func = jax.vmap(\n        fun=_carryover_convolve, in_axes=(2, None, None), out_axes=2)\n  weights = ad_effect_retention_rate**((lags_arange - peak_effect_delay)**2)\n  return convolve_func(data, weights, number_lags)\n\n\ndef carryover(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n    *,\n    number_lags: int = 13,\n    prefix: str = \"\",\n) -> jnp.ndarray:\n  \"\"\"Transforms the input data with the carryover function.\n\n  Args:\n    data: Media data to be transformed. It is expected to have 2 dims for\n      national models and 3 for geo models.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones.\n    number_lags: Number of lags for the carryover function.\n    prefix: Prefix to use in the variable name for Numpyro.\n\n  Returns:\n    The transformed media data.\n  \"\"\"\n  default_priors = priors.get_default_priors()\n  with numpyro.plate(\n      name=f\"{prefix}{priors.AD_EFFECT_RETENTION_RATE}_plate\",\n      size=data.shape[1]):\n    ad_effect_retention_rate = numpyro.sample(\n        name=f\"{prefix}{priors.AD_EFFECT_RETENTION_RATE}\",\n        fn=custom_priors.get(priors.AD_EFFECT_RETENTION_RATE,\n                             default_priors[priors.AD_EFFECT_RETENTION_RATE]))\n\n  with numpyro.plate(\n      name=f\"{prefix}{priors.PEAK_EFFECT_DELAY}_plate\", size=data.shape[1]):\n    peak_effect_delay = numpyro.sample(\n        name=f\"{prefix}{priors.PEAK_EFFECT_DELAY}\",\n        fn=custom_priors.get(priors.PEAK_EFFECT_DELAY,\n                             default_priors[priors.PEAK_EFFECT_DELAY]))\n\n  return _carryover(\n      data=data,\n      ad_effect_retention_rate=ad_effect_retention_rate,\n      peak_effect_delay=peak_effect_delay,\n      number_lags=number_lags)\n\n\n@jax.jit\ndef _adstock(\n    data: jnp.ndarray,\n    lag_weight: Union[float, jnp.ndarray] = .9,\n    normalise: bool = True,\n) -> jnp.ndarray:\n  \"\"\"Calculates the adstock value of a given array.\n\n  To learn more about advertising lag:\n  https://en.wikipedia.org/wiki/Advertising_adstock\n\n  Args:\n    data: Input array.\n    lag_weight: lag_weight effect of the adstock function. Default is 0.9.\n    normalise: Whether to normalise the output value. This normalization will\n      divide the output values by (1 / (1 - lag_weight)).\n\n  Returns:\n    The adstock output of the input array.\n  \"\"\""
  },
  {
    "id": "238",
    "text": "LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set of core and modelling lagging functions.\"\"\"\n\nimport functools\nfrom typing import Mapping, Union\n\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nimport numpyro.distributions as dist\nfrom lightweight_mmm.core import priors\n\n\n@functools.partial(jax.vmap, in_axes=(1, 1, None), out_axes=1)\ndef _carryover_convolve(data: jnp.ndarray, weights: jnp.ndarray,\n                        number_lags: int) -> jnp.ndarray:\n  \"\"\"Applies the convolution between the data and the weights for the carryover.\n\n  Args:\n    data: Input data.\n    weights: Window weights for the carryover.\n    number_lags: Number of lags the window has.\n\n  Returns:\n    The result values from convolving the data and the weights with padding.\n  \"\"\"\n  window = jnp.concatenate([jnp.zeros(number_lags - 1), weights])\n  return jax.scipy.signal.convolve(data, window, mode=\"same\") / weights.sum()\n\n\n@functools.partial(jax.jit, static_argnames=(\"number_lags\",))\ndef _carryover(\n    data: jnp.ndarray,\n    ad_effect_retention_rate: jnp.ndarray,\n    peak_effect_delay: jnp.ndarray,\n    number_lags: int,\n) -> jnp.ndarray:\n  \"\"\"Calculates media carryover.\n\n  More details about this function can be found in:\n  https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46001.pdf\n\n  Args:\n    data: Input data. It is expected that data has either 2 dimensions for\n      national models and 3 for geo models.\n    ad_effect_retention_rate: Retention rate of the advertisement effect.\n      Default is 0.5.\n    peak_effect_delay: Delay of the peak effect in the carryover function.\n      Default is 1.\n    number_lags: Number of lags to include in the carryover calculation. Default\n      is 13.\n\n  Returns:\n    The carryover values for the given data with the given parameters.\n  \"\"\"\n  lags_arange = jnp.expand_dims(\n      jnp.arange(number_lags, dtype=jnp.float32), axis=-1)\n  convolve_func = _carryover_convolve\n  if data.ndim == 3:\n    # Since _carryover_convolve is already vmaped in the decorator we only need\n    # to vmap it once here to handle the geo level data. We keep the windows bi\n    # dimensional also for three dims data and vmap over only the extra data\n    # dimension.\n    convolve_func = jax.vmap(\n        fun=_carryover_convolve, in_axes=(2, None, None), out_axes=2)\n  weights = ad_effect_retention_rate**((lags_arange - peak_effect_delay)**2)\n  return convolve_func(data, weights, number_lags)\n\n\ndef carryover(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n    *,\n    number_lags: int = 13,\n    prefix: str = \"\",\n) -> jnp.ndarray:\n  \"\"\"Transforms the input data with the carryover function.\n\n  Args:\n    data: Media data to be transformed. It is expected to have 2 dims for\n      national models and 3 for geo models.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones.\n    number_lags: Number of lags for the carryover function.\n    prefix: Prefix to use in the variable name for Numpyro.\n\n  Returns:\n    The transformed media data.\n  \"\"\"\n  default_priors = priors.get_default_priors()\n  with numpyro.plate(\n      name=f\"{prefix}{priors.AD_EFFECT_RETENTION_RATE}_plate\",\n      size=data.shape[1]):\n    ad_effect_retention_rate = numpyro.sample(\n        name=f\"{prefix}{priors.AD_EFFECT_RETENTION_RATE}\",\n        fn=custom_priors.get(priors.AD_EFFECT_RETENTION_RATE,\n                             default_priors[priors.AD_EFFECT_RETENTION_RATE]))\n\n  with numpyro.plate(\n      name=f\"{prefix}{priors.PEAK_EFFECT_DELAY}_plate\", size=data.shape[1]):\n    peak_effect_delay = numpyro.sample(\n        name=f\"{prefix}{priors.PEAK_EFFECT_DELAY}\",\n        fn=custom_priors.get(priors.PEAK_EFFECT_DELAY,\n                             default_priors[priors.PEAK_EFFECT_DELAY]))\n\n  return _carryover(\n      data=data,\n      ad_effect_retention_rate=ad_effect_retention_rate,\n      peak_effect_delay=peak_effect_delay,\n      number_lags=number_lags)\n\n\n@jax.jit\ndef _adstock(\n    data: jnp.ndarray,\n    lag_weight: Union[float, jnp.ndarray] = .9,\n    normalise: bool = True,\n) -> jnp.ndarray:\n  \"\"\"Calculates the adstock value of a given array.\n\n  To learn more about advertising lag:\n  https://en.wikipedia.org/wiki/Advertising_adstock\n\n  Args:\n    data: Input array.\n    lag_weight: lag_weight effect of the adstock function. Default is 0.9.\n    normalise: Whether to normalise the output value. This normalization will\n      divide the output values by (1 / (1 - lag_weight)).\n\n  Returns:\n    The adstock output of the input array.\n  \"\"\"\n\n  def adstock_internal(\n      prev_adstock: jnp.ndarray,\n      data: jnp.ndarray,\n      lag_weight: Union[float, jnp.ndarray] = lag_weight,\n  ) -> jnp.ndarray:\n    adstock_value = prev_adstock * lag_weight + data\n    return adstock_value, adstock_value# jax-ndarray\n\n  _, adstock_values = jax.lax.scan(\n      f=adstock_internal, init=data[0, ...], xs=data[1:, ...])\n  adstock_values = jnp.concatenate([jnp.array([data[0, ...]]), adstock_values])\n  return jax.lax.cond(\n      normalise,\n      lambda adstock_values: adstock_values / (1. / (1 - lag_weight)),\n      lambda adstock_values: adstock_values,\n      operand=adstock_values)\n\n\ndef adstock(\n    data: jnp.ndarray,\n    custom_priors: Mapping[str, dist.Distribution],\n    *,\n    normalise: bool = True,\n    prefix: str = \"\",\n) -> jnp.ndarray:\n  \"\"\"Transforms the input data with the adstock function and exponent.\n\n  Args:\n    data: Media data to be transformed. It is expected to have 2 dims for\n      national models and 3 for geo models.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones. The possible names of parameters for adstock and exponent\n      are \"lag_weight\" and \"exponent\".\n    normalise: Whether to normalise the output values.\n    prefix: Prefix to use in the variable name for Numpyro.\n\n  Returns:\n    The transformed media data.\n  \"\"\""
  },
  {
    "id": "239",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for lagging.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro\nfrom numpyro import handlers\nimport numpyro.distributions as dist\n\nfrom lightweight_mmm.core import priors\nfrom lightweight_mmm.core.transformations import lagging\n\n\nclass LaggingTest(parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"national\",\n          data_shape=(150, 3),\n          ad_effect_retention_rate_shape=(3,),\n          peak_effect_delay_shape=(3,),\n          number_lags=13,\n      ),\n      dict(\n          testcase_name=\"geo\",\n          data_shape=(150, 3, 5),\n          ad_effect_retention_rate_shape=(3,),\n          peak_effect_delay_shape=(3,),\n          number_lags=13,\n      ),\n  )\n  def test_core_carryover_produces_correct_shape(\n      self,\n      data_shape,\n      ad_effect_retention_rate_shape,\n      peak_effect_delay_shape,\n      number_lags,\n  ):\n    data = jnp.ones(data_shape)\n    ad_effect_retention_rate = jnp.ones(ad_effect_retention_rate_shape)\n    peak_effect_delay = jnp.ones(peak_effect_delay_shape)\n\n    output = lagging._carryover(\n        data=data,\n        ad_effect_retention_rate=ad_effect_retention_rate,\n        peak_effect_delay=peak_effect_delay,\n        number_lags=number_lags,\n    )\n\n    self.assertEqual(output.shape, data_shape)\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"national\",\n          data_shape=(150, 3),\n      ),\n      dict(\n          testcase_name=\"geo\",\n          data_shape=(150, 3, 5),\n      ),\n  )\n  def test_carryover_produces_correct_shape(self, data_shape):\n\n    def mock_model_function(data, number_lags):"
  },
  {
    "id": "240",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for lagging.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro\nfrom numpyro import handlers\nimport numpyro.distributions as dist\n\nfrom lightweight_mmm.core import priors\nfrom lightweight_mmm.core.transformations import lagging\n\n\nclass LaggingTest(parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"national\",\n          data_shape=(150, 3),\n          ad_effect_retention_rate_shape=(3,),\n          peak_effect_delay_shape=(3,),\n          number_lags=13,\n      ),\n      dict(\n          testcase_name=\"geo\",\n          data_shape=(150, 3, 5),\n          ad_effect_retention_rate_shape=(3,),\n          peak_effect_delay_shape=(3,),\n          number_lags=13,\n      ),\n  )\n  def test_core_carryover_produces_correct_shape(\n      self,\n      data_shape,\n      ad_effect_retention_rate_shape,\n      peak_effect_delay_shape,\n      number_lags,\n  ):\n    data = jnp.ones(data_shape)\n    ad_effect_retention_rate = jnp.ones(ad_effect_retention_rate_shape)\n    peak_effect_delay = jnp.ones(peak_effect_delay_shape)\n\n    output = lagging._carryover(\n        data=data,\n        ad_effect_retention_rate=ad_effect_retention_rate,\n        peak_effect_delay=peak_effect_delay,\n        number_lags=number_lags,\n    )\n\n    self.assertEqual(output.shape, data_shape)\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"national\",\n          data_shape=(150, 3),\n      ),\n      dict(\n          testcase_name=\"geo\",\n          data_shape=(150, 3, 5),\n      ),\n  )\n  def test_carryover_produces_correct_shape(self, data_shape):\n\n    def mock_model_function(data, number_lags):\n      numpyro.deterministic(\n          \"carryover\",\n          lagging.carryover(\n              data=data, custom_priors={}, number_lags=number_lags))\n\n    num_samples = 10\n    data = jnp.ones(data_shape)\n    number_lags = 15\n    kernel = numpyro.infer.NUTS(model=mock_model_function)\n    mcmc = numpyro.infer.MCMC(\n        sampler=kernel, num_warmup=10, num_samples=num_samples, num_chains=1)\n    rng_key = jax.random.PRNGKey(0)\n\n    mcmc.run(rng_key, data=data, number_lags=number_lags)\n    carryover_values = mcmc.get_samples()[\"carryover\"]\n\n    self.assertEqual(carryover_values.shape, (num_samples, *data.shape))\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"ad_effect_retention_rate\",\n          prior_name=priors.AD_EFFECT_RETENTION_RATE,\n      ),\n      dict(\n          testcase_name=\"peak_effect_delay\",\n          prior_name=priors.PEAK_EFFECT_DELAY,\n      ),\n  )\n  def test_carryover_custom_priors_are_taken_correctly(self, prior_name):\n    expected_value1, expected_value2 = 5.2, 7.56\n    custom_priors = {\n        prior_name:\n            dist.Kumaraswamy(\n                concentration1=expected_value1, concentration0=expected_value2)\n    }\n    media = jnp.ones((10, 5, 5))\n    number_lags = 13\n\n    trace_handler = handlers.trace(handlers.seed(lagging.carryover, rng_seed=0))\n    trace = trace_handler.get_trace(\n        data=media,\n        custom_priors=custom_priors,\n        number_lags=number_lags,\n    )\n    values_and_dists = {\n        name: site[\"fn\"] for name, site in trace.items() if \"fn\" in site\n    }\n\n    used_distribution = values_and_dists[prior_name]\n    used_distribution = used_distribution.base_dist\n    self.assertIsInstance(used_distribution, dist.Kumaraswamy)\n    self.assertEqual(used_distribution.concentration0, expected_value2)\n    self.assertEqual(used_distribution.concentration1, expected_value1)\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"national\",\n          data_shape=(150, 3),\n          lag_weight_shape=(3,),\n      ),\n      dict(\n          testcase_name=\"geo\",\n          data_shape=(150, 3, 5),\n          lag_weight_shape=(3, 1),\n      ),\n  )\n  def test_core_adstock_produces_correct_shape(self, data_shape,\n                                               lag_weight_shape):\n    data = jnp.ones(data_shape)\n    lag_weight = jnp.ones(lag_weight_shape)\n\n    output = lagging._adstock(data=data, lag_weight=lag_weight)\n\n    self.assertEqual(output.shape, data_shape)\n\n  @parameterized.named_parameters(\n      dict(\n          testcase_name=\"national\",\n          data_shape=(150, 3),\n      ),\n      dict(\n          testcase_name=\"geo\",\n          data_shape=(150, 3, 5),\n      ),\n  )\n  def test_adstock_produces_correct_shape(self, data_shape):\n\n    def mock_model_function(data, normalise):"
  },
  {
    "id": "241",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Module containing the different models available in the lightweightMMM lib.\n\nCurrently this file contains a main model with three possible options for\nprocessing the media data. Which essentially grants the possibility of building\nthree different models.\n  - Adstock\n  - Hill-Adstock\n  - Carryover\n\"\"\"\nimport sys\n#  pylint: disable=g-import-not-at-top\nif sys.version_info >= (3, 8):\n  from typing import Protocol\nelse:\n  from typing_extensions import Protocol\n\nfrom typing import Any, Dict, Mapping, MutableMapping, Optional, Sequence, Union\n\nimport immutabledict\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm import media_transforms\n\nPrior = Union[\n    dist.Distribution,\n    Dict[str, float],\n    Sequence[float],\n    float\n]\n\n\nclass TransformFunction(Protocol):\n\n  def __call__(\n      self,\n      media_data: jnp.ndarray,\n      custom_priors: MutableMapping[str, Prior],\n      **kwargs: Any) -> jnp.ndarray:\n    ...\n\n\n_INTERCEPT = \"intercept\"\n_COEF_TREND = \"coef_trend\"\n_EXPO_TREND = \"expo_trend\"\n_SIGMA = \"sigma\"\n_GAMMA_SEASONALITY = \"gamma_seasonality\"\n_WEEKDAY = \"weekday\"\n_COEF_EXTRA_FEATURES = \"coef_extra_features\"\n_COEF_SEASONALITY = \"coef_seasonality\"\n\nMODEL_PRIORS_NAMES = frozenset((\n    _INTERCEPT,\n    _COEF_TREND,\n    _EXPO_TREND,\n    _SIGMA,\n    _GAMMA_SEASONALITY,\n    _WEEKDAY,\n    _COEF_EXTRA_FEATURES,\n    _COEF_SEASONALITY))\n\n_EXPONENT = \"exponent\"\n_LAG_WEIGHT = \"lag_weight\"\n_HALF_MAX_EFFECTIVE_CONCENTRATION = \"half_max_effective_concentration\"\n_SLOPE = \"slope\"\n_AD_EFFECT_RETENTION_RATE = \"ad_effect_retention_rate\"\n_PEAK_EFFECT_DELAY = \"peak_effect_delay\"\n\nTRANSFORM_PRIORS_NAMES = immutabledict.immutabledict({\n    \"carryover\":\n        frozenset((_AD_EFFECT_RETENTION_RATE, _PEAK_EFFECT_DELAY, _EXPONENT)),\n    \"adstock\":\n        frozenset((_EXPONENT, _LAG_WEIGHT)),\n    \"hill_adstock\":\n        frozenset((_LAG_WEIGHT, _HALF_MAX_EFFECTIVE_CONCENTRATION, _SLOPE))\n})\n\nGEO_ONLY_PRIORS = frozenset((_COEF_SEASONALITY,))\n\n\ndef _get_default_priors() -> Mapping[str, Prior]:\n  # Since JAX cannot be called before absl.app.run in tests we get default\n  # priors from a function."
  },
  {
    "id": "242",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Module containing the different models available in the lightweightMMM lib.\n\nCurrently this file contains a main model with three possible options for\nprocessing the media data. Which essentially grants the possibility of building\nthree different models.\n  - Adstock\n  - Hill-Adstock\n  - Carryover\n\"\"\"\nimport sys\n#  pylint: disable=g-import-not-at-top\nif sys.version_info >= (3, 8):\n  from typing import Protocol\nelse:\n  from typing_extensions import Protocol\n\nfrom typing import Any, Dict, Mapping, MutableMapping, Optional, Sequence, Union\n\nimport immutabledict\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm import media_transforms\n\nPrior = Union[\n    dist.Distribution,\n    Dict[str, float],\n    Sequence[float],\n    float\n]\n\n\nclass TransformFunction(Protocol):\n\n  def __call__(\n      self,\n      media_data: jnp.ndarray,\n      custom_priors: MutableMapping[str, Prior],\n      **kwargs: Any) -> jnp.ndarray:\n    ...\n\n\n_INTERCEPT = \"intercept\"\n_COEF_TREND = \"coef_trend\"\n_EXPO_TREND = \"expo_trend\"\n_SIGMA = \"sigma\"\n_GAMMA_SEASONALITY = \"gamma_seasonality\"\n_WEEKDAY = \"weekday\"\n_COEF_EXTRA_FEATURES = \"coef_extra_features\"\n_COEF_SEASONALITY = \"coef_seasonality\"\n\nMODEL_PRIORS_NAMES = frozenset((\n    _INTERCEPT,\n    _COEF_TREND,\n    _EXPO_TREND,\n    _SIGMA,\n    _GAMMA_SEASONALITY,\n    _WEEKDAY,\n    _COEF_EXTRA_FEATURES,\n    _COEF_SEASONALITY))\n\n_EXPONENT = \"exponent\"\n_LAG_WEIGHT = \"lag_weight\"\n_HALF_MAX_EFFECTIVE_CONCENTRATION = \"half_max_effective_concentration\"\n_SLOPE = \"slope\"\n_AD_EFFECT_RETENTION_RATE = \"ad_effect_retention_rate\"\n_PEAK_EFFECT_DELAY = \"peak_effect_delay\"\n\nTRANSFORM_PRIORS_NAMES = immutabledict.immutabledict({\n    \"carryover\":\n        frozenset((_AD_EFFECT_RETENTION_RATE, _PEAK_EFFECT_DELAY, _EXPONENT)),\n    \"adstock\":\n        frozenset((_EXPONENT, _LAG_WEIGHT)),\n    \"hill_adstock\":\n        frozenset((_LAG_WEIGHT, _HALF_MAX_EFFECTIVE_CONCENTRATION, _SLOPE))\n})\n\nGEO_ONLY_PRIORS = frozenset((_COEF_SEASONALITY,))\n\n\ndef _get_default_priors() -> Mapping[str, Prior]:\n  # Since JAX cannot be called before absl.app.run in tests we get default\n  # priors from a function.\n  return immutabledict.immutabledict({\n      _INTERCEPT: dist.HalfNormal(scale=2.),\n      _COEF_TREND: dist.Normal(loc=0., scale=1.),\n      _EXPO_TREND: dist.Uniform(low=0.5, high=1.5),\n      _SIGMA: dist.Gamma(concentration=1., rate=1.),\n      _GAMMA_SEASONALITY: dist.Normal(loc=0., scale=1.),\n      _WEEKDAY: dist.Normal(loc=0., scale=.5),\n      _COEF_EXTRA_FEATURES: dist.Normal(loc=0., scale=1.),\n      _COEF_SEASONALITY: dist.HalfNormal(scale=.5)\n  })\n\n\ndef _get_transform_default_priors() -> Mapping[str, Prior]:\n  # Since JAX cannot be called before absl.app.run in tests we get default\n  # priors from a function."
  },
  {
    "id": "243",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Module containing the different models available in the lightweightMMM lib.\n\nCurrently this file contains a main model with three possible options for\nprocessing the media data. Which essentially grants the possibility of building\nthree different models.\n  - Adstock\n  - Hill-Adstock\n  - Carryover\n\"\"\"\nimport sys\n#  pylint: disable=g-import-not-at-top\nif sys.version_info >= (3, 8):\n  from typing import Protocol\nelse:\n  from typing_extensions import Protocol\n\nfrom typing import Any, Dict, Mapping, MutableMapping, Optional, Sequence, Union\n\nimport immutabledict\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\n\nfrom lightweight_mmm import media_transforms\n\nPrior = Union[\n    dist.Distribution,\n    Dict[str, float],\n    Sequence[float],\n    float\n]\n\n\nclass TransformFunction(Protocol):\n\n  def __call__(\n      self,\n      media_data: jnp.ndarray,\n      custom_priors: MutableMapping[str, Prior],\n      **kwargs: Any) -> jnp.ndarray:\n    ...\n\n\n_INTERCEPT = \"intercept\"\n_COEF_TREND = \"coef_trend\"\n_EXPO_TREND = \"expo_trend\"\n_SIGMA = \"sigma\"\n_GAMMA_SEASONALITY = \"gamma_seasonality\"\n_WEEKDAY = \"weekday\"\n_COEF_EXTRA_FEATURES = \"coef_extra_features\"\n_COEF_SEASONALITY = \"coef_seasonality\"\n\nMODEL_PRIORS_NAMES = frozenset((\n    _INTERCEPT,\n    _COEF_TREND,\n    _EXPO_TREND,\n    _SIGMA,\n    _GAMMA_SEASONALITY,\n    _WEEKDAY,\n    _COEF_EXTRA_FEATURES,\n    _COEF_SEASONALITY))\n\n_EXPONENT = \"exponent\"\n_LAG_WEIGHT = \"lag_weight\"\n_HALF_MAX_EFFECTIVE_CONCENTRATION = \"half_max_effective_concentration\"\n_SLOPE = \"slope\"\n_AD_EFFECT_RETENTION_RATE = \"ad_effect_retention_rate\"\n_PEAK_EFFECT_DELAY = \"peak_effect_delay\"\n\nTRANSFORM_PRIORS_NAMES = immutabledict.immutabledict({\n    \"carryover\":\n        frozenset((_AD_EFFECT_RETENTION_RATE, _PEAK_EFFECT_DELAY, _EXPONENT)),\n    \"adstock\":\n        frozenset((_EXPONENT, _LAG_WEIGHT)),\n    \"hill_adstock\":\n        frozenset((_LAG_WEIGHT, _HALF_MAX_EFFECTIVE_CONCENTRATION, _SLOPE))\n})\n\nGEO_ONLY_PRIORS = frozenset((_COEF_SEASONALITY,))\n\n\ndef _get_default_priors() -> Mapping[str, Prior]:\n  # Since JAX cannot be called before absl.app.run in tests we get default\n  # priors from a function.\n  return immutabledict.immutabledict({\n      _INTERCEPT: dist.HalfNormal(scale=2.),\n      _COEF_TREND: dist.Normal(loc=0., scale=1.),\n      _EXPO_TREND: dist.Uniform(low=0.5, high=1.5),\n      _SIGMA: dist.Gamma(concentration=1., rate=1.),\n      _GAMMA_SEASONALITY: dist.Normal(loc=0., scale=1.),\n      _WEEKDAY: dist.Normal(loc=0., scale=.5),\n      _COEF_EXTRA_FEATURES: dist.Normal(loc=0., scale=1.),\n      _COEF_SEASONALITY: dist.HalfNormal(scale=.5)\n  })\n\n\ndef _get_transform_default_priors() -> Mapping[str, Prior]:\n  # Since JAX cannot be called before absl.app.run in tests we get default\n  # priors from a function.\n  return immutabledict.immutabledict({\n      \"carryover\":\n          immutabledict.immutabledict({\n              _AD_EFFECT_RETENTION_RATE:\n                  dist.Beta(concentration1=1., concentration0=1.),\n              _PEAK_EFFECT_DELAY:\n                  dist.HalfNormal(scale=2.),\n              _EXPONENT:\n                  dist.Beta(concentration1=9., concentration0=1.)\n          }),\n      \"adstock\":\n          immutabledict.immutabledict({\n              _EXPONENT: dist.Beta(concentration1=9., concentration0=1.),\n              _LAG_WEIGHT: dist.Beta(concentration1=2., concentration0=1.)\n          }),\n      \"hill_adstock\":\n          immutabledict.immutabledict({\n              _LAG_WEIGHT:\n                  dist.Beta(concentration1=2., concentration0=1.),\n              _HALF_MAX_EFFECTIVE_CONCENTRATION:\n                  dist.Gamma(concentration=1., rate=1.),\n              _SLOPE:\n                  dist.Gamma(concentration=1., rate=1.)\n          })\n  })\n\n\ndef transform_adstock(media_data: jnp.ndarray,\n                      custom_priors: MutableMapping[str, Prior],\n                      normalise: bool = True) -> jnp.ndarray:\n  \"\"\"Transforms the input data with the adstock function and exponent.\n\n  Args:\n    media_data: Media data to be transformed. It is expected to have 2 dims for\n      national models and 3 for geo models.\n    custom_priors: The custom priors we want the model to take instead of the\n      default ones. The possible names of parameters for adstock and exponent\n      are \"lag_weight\" and \"exponent\".\n    normalise: Whether to normalise the output values.\n\n  Returns:\n    The transformed media data.\n  \"\"\""
  },
  {
    "id": "244",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for plot.\"\"\"\n\nfrom unittest import mock\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax.numpy as jnp\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport numpyro.distributions as dist\nimport pandas as pd\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import models\nfrom lightweight_mmm import plot\nfrom lightweight_mmm import preprocessing\n\nMOCK_NATIONAL_TRACE = {\n    \"coef_extra_features\": np.ones([10, 2]),\n    \"coef_media\": np.ones([10, 5]),\n    \"coef_trend\": np.ones([10, 1]),\n    \"expo_trend\": np.ones([10, 1]),\n    \"gamma_seasonality\": np.ones([10, 3, 2]),\n    \"intercept\": np.ones([10, 1]),\n    \"media_transformed\": np.ones([10, 50, 5,]),\n    \"mu\": np.ones([10, 50]),\n    \"sigma\": np.ones([10, 1]),\n    \"ad_effect_retention_rate\": np.ones([10, 5]),\n    \"exponent\": np.ones([10, 5]),\n    \"half_max_effective_concentration\": np.ones([10, 5]),\n    \"lag_weight\": np.ones([10, 5]),\n    \"slope\": np.ones([10, 5]),\n    \"peak_effect_delay\": np.ones([10, 5]),\n    }\n\nMOCK_GEO_TRACE = {\n    \"channel_coef_media\": np.ones([10, 5, 1]),\n    \"coef_extra_features\": np.ones([10, 2, 3]),\n    \"coef_media\": np.ones([10, 5, 3]),\n    \"coef_seasonality\": np.ones([10, 3]),\n    \"coef_trend\": np.ones([10, 3]),\n    \"expo_trend\": np.ones([10, 1]),\n    \"gamma_seasonality\": np.ones([10, 3, 2]),\n    \"intercept\": np.ones([10, 3]),\n    \"media_transformed\": np.ones([10, 50, 5, 3]),\n    \"mu\": np.ones([10, 50, 3]),\n    \"sigma\": np.ones([10, 3]),\n    \"ad_effect_retention_rate\": np.ones([10, 5]),\n    \"exponent\": np.ones([10, 5]),\n    \"half_max_effective_concentration\": np.ones([10, 5]),\n    \"lag_weight\": np.ones([10, 5]),\n    \"peak_effect_delay\": np.ones([10, 5]),\n    \"slope\": np.ones([10, 5]),\n}\n\n\ndef _set_up_mock_mmm(model_name: str,\n                     is_geo_model: bool) -> lightweight_mmm.LightweightMMM:\n  \"\"\"Creates a mock LightweightMMM instance that acts like a fitted model.\n\n  These instances are used when we want to run tests on more diverse ranges of\n  models than the two standard national_mmm and geo_mmm defined below but don't\n  need the unit tests to spend time actually running the model fits.\n\n  Args:\n    model_name: One of [\"adstock\", \"carryover\", or \"hill_adstock\"], specifying\n      which model type should be used in the mock LightweightMMM.\n    is_geo_model: Whether to create a geo-level model (True) or a national-level\n      model (False).\n\n  Returns:\n    mmm: A LightweightMMM object that can be treated like a fitted model\n    for plotting-related unit tests.\n  \"\"\""
  },
  {
    "id": "245",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for plot.\"\"\"\n\nfrom unittest import mock\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax.numpy as jnp\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport numpyro.distributions as dist\nimport pandas as pd\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import models\nfrom lightweight_mmm import plot\nfrom lightweight_mmm import preprocessing\n\nMOCK_NATIONAL_TRACE = {\n    \"coef_extra_features\": np.ones([10, 2]),\n    \"coef_media\": np.ones([10, 5]),\n    \"coef_trend\": np.ones([10, 1]),\n    \"expo_trend\": np.ones([10, 1]),\n    \"gamma_seasonality\": np.ones([10, 3, 2]),\n    \"intercept\": np.ones([10, 1]),\n    \"media_transformed\": np.ones([10, 50, 5,]),\n    \"mu\": np.ones([10, 50]),\n    \"sigma\": np.ones([10, 1]),\n    \"ad_effect_retention_rate\": np.ones([10, 5]),\n    \"exponent\": np.ones([10, 5]),\n    \"half_max_effective_concentration\": np.ones([10, 5]),\n    \"lag_weight\": np.ones([10, 5]),\n    \"slope\": np.ones([10, 5]),\n    \"peak_effect_delay\": np.ones([10, 5]),\n    }\n\nMOCK_GEO_TRACE = {\n    \"channel_coef_media\": np.ones([10, 5, 1]),\n    \"coef_extra_features\": np.ones([10, 2, 3]),\n    \"coef_media\": np.ones([10, 5, 3]),\n    \"coef_seasonality\": np.ones([10, 3]),\n    \"coef_trend\": np.ones([10, 3]),\n    \"expo_trend\": np.ones([10, 1]),\n    \"gamma_seasonality\": np.ones([10, 3, 2]),\n    \"intercept\": np.ones([10, 3]),\n    \"media_transformed\": np.ones([10, 50, 5, 3]),\n    \"mu\": np.ones([10, 50, 3]),\n    \"sigma\": np.ones([10, 3]),\n    \"ad_effect_retention_rate\": np.ones([10, 5]),\n    \"exponent\": np.ones([10, 5]),\n    \"half_max_effective_concentration\": np.ones([10, 5]),\n    \"lag_weight\": np.ones([10, 5]),\n    \"peak_effect_delay\": np.ones([10, 5]),\n    \"slope\": np.ones([10, 5]),\n}\n\n\ndef _set_up_mock_mmm(model_name: str,\n                     is_geo_model: bool) -> lightweight_mmm.LightweightMMM:\n  \"\"\"Creates a mock LightweightMMM instance that acts like a fitted model.\n\n  These instances are used when we want to run tests on more diverse ranges of\n  models than the two standard national_mmm and geo_mmm defined below but don't\n  need the unit tests to spend time actually running the model fits.\n\n  Args:\n    model_name: One of [\"adstock\", \"carryover\", or \"hill_adstock\"], specifying\n      which model type should be used in the mock LightweightMMM.\n    is_geo_model: Whether to create a geo-level model (True) or a national-level\n      model (False).\n\n  Returns:\n    mmm: A LightweightMMM object that can be treated like a fitted model\n    for plotting-related unit tests.\n  \"\"\"\n  initial_mock_trace = MOCK_GEO_TRACE if is_geo_model else MOCK_NATIONAL_TRACE\n  all_model_names = {\"adstock\", \"carryover\", \"hill_adstock\"}\n  model_items_to_delete = frozenset.union(*[\n      models.TRANSFORM_PRIORS_NAMES[x]\n      for x in all_model_names - {model_name}\n  ]) - models.TRANSFORM_PRIORS_NAMES[model_name]\n  mock_trace = {\n      key: initial_mock_trace[key]\n      for key in initial_mock_trace\n      if key not in model_items_to_delete\n  }\n  mmm = lightweight_mmm.LightweightMMM(model_name=model_name)\n  mmm.n_media_channels = 5\n  mmm.n_geos = 3 if is_geo_model else 1\n  mmm._media_prior = jnp.ones(5)\n  mmm._weekday_seasonality = False\n  mmm._degrees_seasonality = 3\n  mmm.custom_priors = {}\n  mmm._extra_features = None\n  mmm.trace = mock_trace\n  mmm.media = jnp.ones_like(mock_trace[\"media_transformed\"][0])\n  mmm.media_names = [f\"channel_{i}\" for i in range(5)]\n  return mmm\n\n\nclass PlotTest(parameterized.TestCase):\n\n  @classmethod\n  def setUpClass(cls):"
  },
  {
    "id": "246",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for plot.\"\"\"\n\nfrom unittest import mock\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax.numpy as jnp\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport numpyro.distributions as dist\nimport pandas as pd\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import models\nfrom lightweight_mmm import plot\nfrom lightweight_mmm import preprocessing\n\nMOCK_NATIONAL_TRACE = {\n    \"coef_extra_features\": np.ones([10, 2]),\n    \"coef_media\": np.ones([10, 5]),\n    \"coef_trend\": np.ones([10, 1]),\n    \"expo_trend\": np.ones([10, 1]),\n    \"gamma_seasonality\": np.ones([10, 3, 2]),\n    \"intercept\": np.ones([10, 1]),\n    \"media_transformed\": np.ones([10, 50, 5,]),\n    \"mu\": np.ones([10, 50]),\n    \"sigma\": np.ones([10, 1]),\n    \"ad_effect_retention_rate\": np.ones([10, 5]),\n    \"exponent\": np.ones([10, 5]),\n    \"half_max_effective_concentration\": np.ones([10, 5]),\n    \"lag_weight\": np.ones([10, 5]),\n    \"slope\": np.ones([10, 5]),\n    \"peak_effect_delay\": np.ones([10, 5]),\n    }\n\nMOCK_GEO_TRACE = {\n    \"channel_coef_media\": np.ones([10, 5, 1]),\n    \"coef_extra_features\": np.ones([10, 2, 3]),\n    \"coef_media\": np.ones([10, 5, 3]),\n    \"coef_seasonality\": np.ones([10, 3]),\n    \"coef_trend\": np.ones([10, 3]),\n    \"expo_trend\": np.ones([10, 1]),\n    \"gamma_seasonality\": np.ones([10, 3, 2]),\n    \"intercept\": np.ones([10, 3]),\n    \"media_transformed\": np.ones([10, 50, 5, 3]),\n    \"mu\": np.ones([10, 50, 3]),\n    \"sigma\": np.ones([10, 3]),\n    \"ad_effect_retention_rate\": np.ones([10, 5]),\n    \"exponent\": np.ones([10, 5]),\n    \"half_max_effective_concentration\": np.ones([10, 5]),\n    \"lag_weight\": np.ones([10, 5]),\n    \"peak_effect_delay\": np.ones([10, 5]),\n    \"slope\": np.ones([10, 5]),\n}\n\n\ndef _set_up_mock_mmm(model_name: str,\n                     is_geo_model: bool) -> lightweight_mmm.LightweightMMM:\n  \"\"\"Creates a mock LightweightMMM instance that acts like a fitted model.\n\n  These instances are used when we want to run tests on more diverse ranges of\n  models than the two standard national_mmm and geo_mmm defined below but don't\n  need the unit tests to spend time actually running the model fits.\n\n  Args:\n    model_name: One of [\"adstock\", \"carryover\", or \"hill_adstock\"], specifying\n      which model type should be used in the mock LightweightMMM.\n    is_geo_model: Whether to create a geo-level model (True) or a national-level\n      model (False).\n\n  Returns:\n    mmm: A LightweightMMM object that can be treated like a fitted model\n    for plotting-related unit tests.\n  \"\"\"\n  initial_mock_trace = MOCK_GEO_TRACE if is_geo_model else MOCK_NATIONAL_TRACE\n  all_model_names = {\"adstock\", \"carryover\", \"hill_adstock\"}\n  model_items_to_delete = frozenset.union(*[\n      models.TRANSFORM_PRIORS_NAMES[x]\n      for x in all_model_names - {model_name}\n  ]) - models.TRANSFORM_PRIORS_NAMES[model_name]\n  mock_trace = {\n      key: initial_mock_trace[key]\n      for key in initial_mock_trace\n      if key not in model_items_to_delete\n  }\n  mmm = lightweight_mmm.LightweightMMM(model_name=model_name)\n  mmm.n_media_channels = 5\n  mmm.n_geos = 3 if is_geo_model else 1\n  mmm._media_prior = jnp.ones(5)\n  mmm._weekday_seasonality = False\n  mmm._degrees_seasonality = 3\n  mmm.custom_priors = {}\n  mmm._extra_features = None\n  mmm.trace = mock_trace\n  mmm.media = jnp.ones_like(mock_trace[\"media_transformed\"][0])\n  mmm.media_names = [f\"channel_{i}\" for i in range(5)]\n  return mmm\n\n\nclass PlotTest(parameterized.TestCase):\n\n  @classmethod\n  def setUpClass(cls):\n    super(PlotTest, cls).setUpClass()\n    cls.national_mmm = lightweight_mmm.LightweightMMM()\n    cls.national_mmm.fit(\n        media=jnp.ones((50, 5)),\n        target=jnp.ones(50),\n        media_prior=jnp.ones(5) * 50,\n        number_warmup=2,\n        number_samples=2,\n        number_chains=1)\n    cls.geo_mmm = lightweight_mmm.LightweightMMM()\n    cls.geo_mmm.fit(\n        media=jnp.ones((50, 5, 3)),\n        target=jnp.ones((50, 3)),\n        media_prior=jnp.ones(5) * 50,\n        number_warmup=2,\n        number_samples=2,\n        number_chains=1)\n    cls.not_fitted_mmm = lightweight_mmm.LightweightMMM()\n\n  def setUp(self):"
  },
  {
    "id": "247",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilities for optimizing your media based on media mix models.\"\"\"\nimport functools\nfrom typing import Optional, Tuple, Union\nfrom absl import logging\nimport jax\nimport jax.numpy as jnp\nfrom scipy import optimize\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import preprocessing\n\n\n@functools.partial(\n    jax.jit,\n    static_argnames=(\"media_mix_model\", \"media_input_shape\", \"target_scaler\",\n                     \"media_scaler\"))\ndef _objective_function(extra_features: jnp.ndarray,\n                        media_mix_model: lightweight_mmm.LightweightMMM,\n                        media_input_shape: Tuple[int,\n                                                 int], media_gap: Optional[int],\n                        target_scaler: Optional[preprocessing.CustomScaler],\n                        media_scaler: preprocessing.CustomScaler,\n                        geo_ratio: jnp.array,\n                        seed: Optional[int],\n                        media_values: jnp.ndarray) -> jnp.float64:\n  \"\"\"Objective function to calculate the sum of all predictions of the model.\n\n  Args:\n    extra_features: Extra features the model requires for prediction.\n    media_mix_model: Media mix model to use. Must have a predict method to be\n      used.\n    media_input_shape: Input shape of the data required by the model to get\n      predictions. This is needed since optimization might flatten some arrays\n      and they need to be reshaped before running new predictions.\n    media_gap: Media data gap between the end of training data and the start of\n      the out of sample media given. Eg. if 100 weeks of data were used for\n      training and prediction starts 2 months after training data finished we\n      need to provide the 8 weeks missing between the training data and the\n      prediction data so data transformations (adstock, carryover, ...) can take\n      place correctly.\n    target_scaler: Scaler that was used to scale the target before training.\n    media_scaler: Scaler that was used to scale the media data before training.\n    geo_ratio: The ratio to split channel media across geo. Should sum up to 1\n      for each channel and should have shape (c, g).\n    seed: Seed to use for PRNGKey during sampling. For replicability run\n      this function and any other function that gets predictions with the same\n      seed.\n    media_values: Media values required by the model to run predictions.\n\n  Returns:\n    The negative value of the sum of all predictions.\n  \"\"\""
  },
  {
    "id": "248",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilities for optimizing your media based on media mix models.\"\"\"\nimport functools\nfrom typing import Optional, Tuple, Union\nfrom absl import logging\nimport jax\nimport jax.numpy as jnp\nfrom scipy import optimize\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import preprocessing\n\n\n@functools.partial(\n    jax.jit,\n    static_argnames=(\"media_mix_model\", \"media_input_shape\", \"target_scaler\",\n                     \"media_scaler\"))\ndef _objective_function(extra_features: jnp.ndarray,\n                        media_mix_model: lightweight_mmm.LightweightMMM,\n                        media_input_shape: Tuple[int,\n                                                 int], media_gap: Optional[int],\n                        target_scaler: Optional[preprocessing.CustomScaler],\n                        media_scaler: preprocessing.CustomScaler,\n                        geo_ratio: jnp.array,\n                        seed: Optional[int],\n                        media_values: jnp.ndarray) -> jnp.float64:\n  \"\"\"Objective function to calculate the sum of all predictions of the model.\n\n  Args:\n    extra_features: Extra features the model requires for prediction.\n    media_mix_model: Media mix model to use. Must have a predict method to be\n      used.\n    media_input_shape: Input shape of the data required by the model to get\n      predictions. This is needed since optimization might flatten some arrays\n      and they need to be reshaped before running new predictions.\n    media_gap: Media data gap between the end of training data and the start of\n      the out of sample media given. Eg. if 100 weeks of data were used for\n      training and prediction starts 2 months after training data finished we\n      need to provide the 8 weeks missing between the training data and the\n      prediction data so data transformations (adstock, carryover, ...) can take\n      place correctly.\n    target_scaler: Scaler that was used to scale the target before training.\n    media_scaler: Scaler that was used to scale the media data before training.\n    geo_ratio: The ratio to split channel media across geo. Should sum up to 1\n      for each channel and should have shape (c, g).\n    seed: Seed to use for PRNGKey during sampling. For replicability run\n      this function and any other function that gets predictions with the same\n      seed.\n    media_values: Media values required by the model to run predictions.\n\n  Returns:\n    The negative value of the sum of all predictions.\n  \"\"\"\n  if hasattr(media_mix_model, \"n_geos\") and media_mix_model.n_geos > 1:\n    media_values = geo_ratio * jnp.expand_dims(media_values, axis=-1)\n  media_values = jnp.tile(\n      media_values / media_input_shape[0], reps=media_input_shape[0])\n  # Distribute budget of each channels across time.\n  media_values = jnp.reshape(a=media_values, newshape=media_input_shape)\n  media_values = media_scaler.transform(media_values)\n  return -jnp.sum(\n      media_mix_model.predict(\n          media=media_values.reshape(media_input_shape),\n          extra_features=extra_features,\n          media_gap=media_gap,\n          target_scaler=target_scaler,\n          seed=seed).mean(axis=0))\n\n\n@jax.jit\ndef _budget_constraint(media: jnp.ndarray,\n                       prices: jnp.ndarray,\n                       budget: jnp.ndarray) -> jnp.float64:\n  \"\"\"Calculates optimization constraint to keep spend equal to the budget.\n\n  Args:\n    media: Array with the values of the media for this iteration.\n    prices: Prices of each media channel at any given time.\n    budget: Total budget of the optimization.\n\n  Returns:\n    The result from substracting the total spending and the budget.\n  \"\"\"\n  media = media.reshape((-1, len(prices)))\n  return jnp.sum(media * prices) - budget\n\n\ndef _get_lower_and_upper_bounds(\n    media: jnp.ndarray,\n    n_time_periods: int,\n    lower_pct: jnp.ndarray,\n    upper_pct: jnp.ndarray,\n    media_scaler: Optional[preprocessing.CustomScaler] = None\n) -> optimize.Bounds:\n  \"\"\"Gets the lower and upper bounds for optimisation based on historic data.\n\n  It creates an upper bound based on a percentage above the mean value on\n  each channel and a lower bound based on a relative decrease of the mean\n  value.\n\n  Args:\n    media: Media data to get historic mean.\n    n_time_periods: Number of time periods to optimize for. If model is built on\n      weekly data, this would be the number of weeks ahead to optimize.\n    lower_pct: Relative percentage decrease from the mean value to consider as\n      new lower bound.\n    upper_pct: Relative percentage increase from the mean value to consider as\n      new upper bound.\n    media_scaler: Scaler that was used to scale the media data before training.\n\n  Returns:\n    A list of tuples with the lower and upper bound for each media channel.\n  \"\"\""
  },
  {
    "id": "249",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilities for optimizing your media based on media mix models.\"\"\"\nimport functools\nfrom typing import Optional, Tuple, Union\nfrom absl import logging\nimport jax\nimport jax.numpy as jnp\nfrom scipy import optimize\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import preprocessing\n\n\n@functools.partial(\n    jax.jit,\n    static_argnames=(\"media_mix_model\", \"media_input_shape\", \"target_scaler\",\n                     \"media_scaler\"))\ndef _objective_function(extra_features: jnp.ndarray,\n                        media_mix_model: lightweight_mmm.LightweightMMM,\n                        media_input_shape: Tuple[int,\n                                                 int], media_gap: Optional[int],\n                        target_scaler: Optional[preprocessing.CustomScaler],\n                        media_scaler: preprocessing.CustomScaler,\n                        geo_ratio: jnp.array,\n                        seed: Optional[int],\n                        media_values: jnp.ndarray) -> jnp.float64:\n  \"\"\"Objective function to calculate the sum of all predictions of the model.\n\n  Args:\n    extra_features: Extra features the model requires for prediction.\n    media_mix_model: Media mix model to use. Must have a predict method to be\n      used.\n    media_input_shape: Input shape of the data required by the model to get\n      predictions. This is needed since optimization might flatten some arrays\n      and they need to be reshaped before running new predictions.\n    media_gap: Media data gap between the end of training data and the start of\n      the out of sample media given. Eg. if 100 weeks of data were used for\n      training and prediction starts 2 months after training data finished we\n      need to provide the 8 weeks missing between the training data and the\n      prediction data so data transformations (adstock, carryover, ...) can take\n      place correctly.\n    target_scaler: Scaler that was used to scale the target before training.\n    media_scaler: Scaler that was used to scale the media data before training.\n    geo_ratio: The ratio to split channel media across geo. Should sum up to 1\n      for each channel and should have shape (c, g).\n    seed: Seed to use for PRNGKey during sampling. For replicability run\n      this function and any other function that gets predictions with the same\n      seed.\n    media_values: Media values required by the model to run predictions.\n\n  Returns:\n    The negative value of the sum of all predictions.\n  \"\"\"\n  if hasattr(media_mix_model, \"n_geos\") and media_mix_model.n_geos > 1:\n    media_values = geo_ratio * jnp.expand_dims(media_values, axis=-1)\n  media_values = jnp.tile(\n      media_values / media_input_shape[0], reps=media_input_shape[0])\n  # Distribute budget of each channels across time.\n  media_values = jnp.reshape(a=media_values, newshape=media_input_shape)\n  media_values = media_scaler.transform(media_values)\n  return -jnp.sum(\n      media_mix_model.predict(\n          media=media_values.reshape(media_input_shape),\n          extra_features=extra_features,\n          media_gap=media_gap,\n          target_scaler=target_scaler,\n          seed=seed).mean(axis=0))\n\n\n@jax.jit\ndef _budget_constraint(media: jnp.ndarray,\n                       prices: jnp.ndarray,\n                       budget: jnp.ndarray) -> jnp.float64:\n  \"\"\"Calculates optimization constraint to keep spend equal to the budget.\n\n  Args:\n    media: Array with the values of the media for this iteration.\n    prices: Prices of each media channel at any given time.\n    budget: Total budget of the optimization.\n\n  Returns:\n    The result from substracting the total spending and the budget.\n  \"\"\"\n  media = media.reshape((-1, len(prices)))\n  return jnp.sum(media * prices) - budget\n\n\ndef _get_lower_and_upper_bounds(\n    media: jnp.ndarray,\n    n_time_periods: int,\n    lower_pct: jnp.ndarray,\n    upper_pct: jnp.ndarray,\n    media_scaler: Optional[preprocessing.CustomScaler] = None\n) -> optimize.Bounds:\n  \"\"\"Gets the lower and upper bounds for optimisation based on historic data.\n\n  It creates an upper bound based on a percentage above the mean value on\n  each channel and a lower bound based on a relative decrease of the mean\n  value.\n\n  Args:\n    media: Media data to get historic mean.\n    n_time_periods: Number of time periods to optimize for. If model is built on\n      weekly data, this would be the number of weeks ahead to optimize.\n    lower_pct: Relative percentage decrease from the mean value to consider as\n      new lower bound.\n    upper_pct: Relative percentage increase from the mean value to consider as\n      new upper bound.\n    media_scaler: Scaler that was used to scale the media data before training.\n\n  Returns:\n    A list of tuples with the lower and upper bound for each media channel.\n  \"\"\"\n  if media.ndim == 3:\n    lower_pct = jnp.expand_dims(lower_pct, axis=-1)\n    upper_pct = jnp.expand_dims(upper_pct, axis=-1)\n\n  mean_data = media.mean(axis=0)\n  lower_bounds = jnp.maximum(mean_data * (1 - lower_pct), 0)\n  upper_bounds = mean_data * (1 + upper_pct)\n\n  if media_scaler:\n    lower_bounds = media_scaler.inverse_transform(lower_bounds)\n    upper_bounds = media_scaler.inverse_transform(upper_bounds)\n\n  if media.ndim == 3:\n    lower_bounds = lower_bounds.sum(axis=-1)\n    upper_bounds = upper_bounds.sum(axis=-1)\n\n  return optimize.Bounds(lb=lower_bounds * n_time_periods,\n                         ub=upper_bounds * n_time_periods)\n\n\ndef _generate_starting_values(\n    n_time_periods: int, media: jnp.ndarray,\n    media_scaler: preprocessing.CustomScaler,\n    budget: Union[float, int],\n    prices: jnp.ndarray,\n) -> jnp.ndarray:\n  \"\"\"Generates starting values based on historic allocation and budget.\n\n  In order to make a comparison we can take the allocation of the last\n  `n_time_periods` and scale it based on the given budget. Given this, one can\n  compare how this initial values (based on average historic allocation) compare\n  to the output of the optimisation in terms of sales/KPI.\n\n  Args:\n    n_time_periods: Number of time periods the optimization will be done with.\n    media: Historic media data the model was trained with.\n    media_scaler: Scaler that was used to scale the media data before training.\n    budget: Total budget to allocate during the optimization time.\n    prices: An array with shape (n_media_channels,) for the cost of each media\n      channel unit.\n\n  Returns:\n    An array with the starting value for each media channel for the\n      optimization.\n  \"\"\""
  },
  {
    "id": "250",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilities for preprocessing dataset for training LightweightMMM.\"\"\"\n\nimport copy\nfrom typing import Callable, List, Optional, Sequence, Tuple, Union\n\nimport jax.numpy as jnp\nimport pandas as pd\nfrom sklearn import base\n\nfrom statsmodels.stats.outliers_influence import variance_inflation_factor\nfrom statsmodels.tools.tools import add_constant\nfrom lightweight_mmm.core import core_utils\n\n\nclass NotFittedScalerError(Exception):\n  pass\n\n\nclass CustomScaler(base.TransformerMixin):\n  \"\"\"Class to scale your data based on multiplications and divisions.\n\n  This scaler can be used in two fashions for both the multiplication and\n  division operation.\n  - By specifying a value to use for the scaling operation.\n  - By specifying an operation used at column level to calculate the value\n    for the actual scaling operation.\n\n  Eg. if one wants to scale the dataset by multiply by 100 you can directly\n  pass multiply_by=100. Value can also be an array with as many values\n  as column has the data being scaled. But if you want to multiply by the mean\n  value of each column, then you can pass multiply_operation=jnp.mean (or any\n  other operation desired).\n\n  Operation parameters have the upper hand in the cases where both values and\n  operations are passed, values will be ignored in this case.\n\n  Scaler must be fit first in order to call the transform method.\n\n  Attributes.\n    divide_operation: Operation to apply over axis 0 of the fitting data to\n      obtain the value that will be used for division during scaling.\n    divide_by: Numbers(s) by which to divide data in the scaling process. Since\n      the scaler is applied to axis 0 of the data, the shape of divide_by must\n      be consistent with division into the data. For example, if data.shape =\n      (100, 3, 5) then divide_by.shape can be (3, 5) or (5,) or a number. If\n      divide_operation is given, this divide_by value will be ignored.\n    multiply_operation: Operation to apply over axis 0 of the fitting data to\n      obtain the value that will be used for multiplication during scaling.\n    multiply_by: Numbers(s) by which to multiply data in the scaling process.\n      Since the scaler is applied to axis 0 of the data, the shape of\n      multiply_by must be consistent with multiplication into the data. For\n      example, if data.shape = (100, 3, 5) then multiply_by.shape can be (3, 5)\n      or (5,) or a number. If multiply_operation is given, this multiply_by\n      value will be ignored.\n  \"\"\"\n\n  def __init__(\n      self,\n      divide_operation: Optional[Callable[[jnp.ndarray], jnp.float32]] = None,\n      divide_by: Optional[Union[float, int, jnp.ndarray]] = 1,\n      multiply_operation: Optional[Callable[[jnp.ndarray], jnp.float32]] = None,\n      multiply_by: Optional[Union[float, int, jnp.ndarray]] = 1.) -> None:\n    \"\"\"Constructor for the CustomScaler class.\"\"\"\n    if all([\n        divide_by is None, divide_operation is None, multiply_by is None,\n        multiply_operation is None\n    ]):\n      raise ValueError(\"No values for transformations were provided and this \"\n                       \"scaler will fail. Please instantiate a valid one\")\n\n    if divide_operation is None and divide_by is None:\n      raise ValueError(\n          \"Either a division operation or value needs to be passed. If \"\n          \"you dont want to use a division to scale your data just \"\n          \"pass divide_by=1.\")\n    elif divide_operation is not None:\n      self.divide_operation = divide_operation\n    else:\n      self.divide_by = divide_by\n\n    if multiply_operation is None and multiply_by is None:\n      raise ValueError(\n          \"Either a multiplication operation or value needs to be passed. If \"\n          \"you dont want to use a multiplication to scale your data just \"\n          \"pass multiply_by=1.\")\n    elif multiply_operation is not None:\n      self.multiply_operation = multiply_operation\n    else:\n      self.multiply_by = multiply_by\n\n  def fit(self, data: jnp.ndarray) -> None:\n    \"\"\"Figures out values for transformations based on the specified operations.\n\n    Args:\n      data: Input dataset to use for fitting.\n    \"\"\""
  },
  {
    "id": "251",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilities for preprocessing dataset for training LightweightMMM.\"\"\"\n\nimport copy\nfrom typing import Callable, List, Optional, Sequence, Tuple, Union\n\nimport jax.numpy as jnp\nimport pandas as pd\nfrom sklearn import base\n\nfrom statsmodels.stats.outliers_influence import variance_inflation_factor\nfrom statsmodels.tools.tools import add_constant\nfrom lightweight_mmm.core import core_utils\n\n\nclass NotFittedScalerError(Exception):\n  pass\n\n\nclass CustomScaler(base.TransformerMixin):\n  \"\"\"Class to scale your data based on multiplications and divisions.\n\n  This scaler can be used in two fashions for both the multiplication and\n  division operation.\n  - By specifying a value to use for the scaling operation.\n  - By specifying an operation used at column level to calculate the value\n    for the actual scaling operation.\n\n  Eg. if one wants to scale the dataset by multiply by 100 you can directly\n  pass multiply_by=100. Value can also be an array with as many values\n  as column has the data being scaled. But if you want to multiply by the mean\n  value of each column, then you can pass multiply_operation=jnp.mean (or any\n  other operation desired).\n\n  Operation parameters have the upper hand in the cases where both values and\n  operations are passed, values will be ignored in this case.\n\n  Scaler must be fit first in order to call the transform method.\n\n  Attributes.\n    divide_operation: Operation to apply over axis 0 of the fitting data to\n      obtain the value that will be used for division during scaling.\n    divide_by: Numbers(s) by which to divide data in the scaling process. Since\n      the scaler is applied to axis 0 of the data, the shape of divide_by must\n      be consistent with division into the data. For example, if data.shape =\n      (100, 3, 5) then divide_by.shape can be (3, 5) or (5,) or a number. If\n      divide_operation is given, this divide_by value will be ignored.\n    multiply_operation: Operation to apply over axis 0 of the fitting data to\n      obtain the value that will be used for multiplication during scaling.\n    multiply_by: Numbers(s) by which to multiply data in the scaling process.\n      Since the scaler is applied to axis 0 of the data, the shape of\n      multiply_by must be consistent with multiplication into the data. For\n      example, if data.shape = (100, 3, 5) then multiply_by.shape can be (3, 5)\n      or (5,) or a number. If multiply_operation is given, this multiply_by\n      value will be ignored.\n  \"\"\"\n\n  def __init__(\n      self,\n      divide_operation: Optional[Callable[[jnp.ndarray], jnp.float32]] = None,\n      divide_by: Optional[Union[float, int, jnp.ndarray]] = 1,\n      multiply_operation: Optional[Callable[[jnp.ndarray], jnp.float32]] = None,\n      multiply_by: Optional[Union[float, int, jnp.ndarray]] = 1.) -> None:\n    \"\"\"Constructor for the CustomScaler class.\"\"\"\n    if all([\n        divide_by is None, divide_operation is None, multiply_by is None,\n        multiply_operation is None\n    ]):\n      raise ValueError(\"No values for transformations were provided and this \"\n                       \"scaler will fail. Please instantiate a valid one\")\n\n    if divide_operation is None and divide_by is None:\n      raise ValueError(\n          \"Either a division operation or value needs to be passed. If \"\n          \"you dont want to use a division to scale your data just \"\n          \"pass divide_by=1.\")\n    elif divide_operation is not None:\n      self.divide_operation = divide_operation\n    else:\n      self.divide_by = divide_by\n\n    if multiply_operation is None and multiply_by is None:\n      raise ValueError(\n          \"Either a multiplication operation or value needs to be passed. If \"\n          \"you dont want to use a multiplication to scale your data just \"\n          \"pass multiply_by=1.\")\n    elif multiply_operation is not None:\n      self.multiply_operation = multiply_operation\n    else:\n      self.multiply_by = multiply_by\n\n  def fit(self, data: jnp.ndarray) -> None:\n    \"\"\"Figures out values for transformations based on the specified operations.\n\n    Args:\n      data: Input dataset to use for fitting.\n    \"\"\"\n    if hasattr(self, \"divide_operation\"):\n      self.divide_by = jnp.apply_along_axis(\n          func1d=self.divide_operation, axis=0, arr=data)\n    elif isinstance(self.divide_by, int) or isinstance(self.divide_by, float):\n      self.divide_by = self.divide_by * jnp.ones(data.shape[1:])\n    if hasattr(self, \"multiply_operation\"):\n      self.multiply_by = jnp.apply_along_axis(\n          func1d=self.multiply_operation, axis=0, arr=data)\n    elif isinstance(self.multiply_by, int) or isinstance(\n        self.multiply_by, float):\n      self.multiply_by = self.multiply_by * jnp.ones(data.shape[1:])\n\n  def transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Applies transformation based on fitted values.\n\n    It can only be called if scaler was fit first.\n\n    Args:\n      data: Input dataset to transform.\n\n    Returns:\n      Transformed array.\n    \"\"\""
  },
  {
    "id": "252",
    "text": " data to\n      obtain the value that will be used for multiplication during scaling.\n    multiply_by: Numbers(s) by which to multiply data in the scaling process.\n      Since the scaler is applied to axis 0 of the data, the shape of\n      multiply_by must be consistent with multiplication into the data. For\n      example, if data.shape = (100, 3, 5) then multiply_by.shape can be (3, 5)\n      or (5,) or a number. If multiply_operation is given, this multiply_by\n      value will be ignored.\n  \"\"\"\n\n  def __init__(\n      self,\n      divide_operation: Optional[Callable[[jnp.ndarray], jnp.float32]] = None,\n      divide_by: Optional[Union[float, int, jnp.ndarray]] = 1,\n      multiply_operation: Optional[Callable[[jnp.ndarray], jnp.float32]] = None,\n      multiply_by: Optional[Union[float, int, jnp.ndarray]] = 1.) -> None:\n    \"\"\"Constructor for the CustomScaler class.\"\"\"\n    if all([\n        divide_by is None, divide_operation is None, multiply_by is None,\n        multiply_operation is None\n    ]):\n      raise ValueError(\"No values for transformations were provided and this \"\n                       \"scaler will fail. Please instantiate a valid one\")\n\n    if divide_operation is None and divide_by is None:\n      raise ValueError(\n          \"Either a division operation or value needs to be passed. If \"\n          \"you dont want to use a division to scale your data just \"\n          \"pass divide_by=1.\")\n    elif divide_operation is not None:\n      self.divide_operation = divide_operation\n    else:\n      self.divide_by = divide_by\n\n    if multiply_operation is None and multiply_by is None:\n      raise ValueError(\n          \"Either a multiplication operation or value needs to be passed. If \"\n          \"you dont want to use a multiplication to scale your data just \"\n          \"pass multiply_by=1.\")\n    elif multiply_operation is not None:\n      self.multiply_operation = multiply_operation\n    else:\n      self.multiply_by = multiply_by\n\n  def fit(self, data: jnp.ndarray) -> None:\n    \"\"\"Figures out values for transformations based on the specified operations.\n\n    Args:\n      data: Input dataset to use for fitting.\n    \"\"\"\n    if hasattr(self, \"divide_operation\"):\n      self.divide_by = jnp.apply_along_axis(\n          func1d=self.divide_operation, axis=0, arr=data)\n    elif isinstance(self.divide_by, int) or isinstance(self.divide_by, float):\n      self.divide_by = self.divide_by * jnp.ones(data.shape[1:])\n    if hasattr(self, \"multiply_operation\"):\n      self.multiply_by = jnp.apply_along_axis(\n          func1d=self.multiply_operation, axis=0, arr=data)\n    elif isinstance(self.multiply_by, int) or isinstance(\n        self.multiply_by, float):\n      self.multiply_by = self.multiply_by * jnp.ones(data.shape[1:])\n\n  def transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Applies transformation based on fitted values.\n\n    It can only be called if scaler was fit first.\n\n    Args:\n      data: Input dataset to transform.\n\n    Returns:\n      Transformed array.\n    \"\"\"\n    if not hasattr(self, \"divide_by\") or not hasattr(self, \"multiply_by\"):\n      raise NotFittedScalerError(\n          \"transform is called without fit being called previously. Please \"\n          \"fit scaler first.\")\n    return self.multiply_by * data / self.divide_by\n\n  def fit_transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Fits the values and applies transformation to the input data.\n\n    Args:\n      data: Input dataset.\n\n    Returns:\n      Transformed array.\n    \"\"\"\n    self.fit(data)\n    return self.transform(data)\n\n  def inverse_transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Runs inverse transformation to get original values.\n\n    Args:\n      data: Input dataset.\n\n    Returns:\n      Dataset with the inverse transformation applied.\n    \"\"\"\n    return self.divide_by * data / self.multiply_by\n\n\ndef _compute_correlations(\n    features: jnp.ndarray,\n    target: jnp.ndarray,\n    feature_names: List[str],\n    ) -> List[pd.DataFrame]:\n  \"\"\"Computes feature-feature and feature-target correlations.\n\n  Helper function for DataQualityCheck.\n\n  Args:\n    features: Features for media mix model (media and non-media variables).\n    target: Target variable for media mix model.\n    feature_names: Names of media channels to be added to the output dataframes.\n\n  Returns:\n    List of dataframes containing Pearson correlation coefficients between each\n      feature, as well as between features and the target variable. For\n      national-level data the list contains just one dataframe, and for\n      geo-level data the list contains one dataframe for each geo.\n\n  Raises:\n    ValueError: If features and target have incompatible shapes (e.g. one is\n      geo-level and the other national-level).\n  \"\"\"\n  if not ((features.ndim == 2 and target.ndim == 1) or\n          (features.ndim == 3 and target.ndim == 2)):\n    raise ValueError(f\"Incompatible shapes between features {features.shape}\"\n                     f\" and target {target.shape}.\")\n\n  number_of_geos = core_utils.get_number_geos(features)\n  correlation_matrix_output = []\n  for i_geo in range(number_of_geos):\n\n    if number_of_geos == 1:\n      features_and_target = jnp.concatenate(\n          [features, jnp.expand_dims(target, axis=1)], axis=1)\n    else:\n      features_and_target = jnp.concatenate(\n          [features[:, :, i_geo],\n           jnp.expand_dims(target[:, i_geo], axis=1)],\n          axis=1)\n\n    covariance_matrix = jnp.cov(features_and_target, rowvar=False)\n    standard_deviations = jnp.std(features_and_target, axis=0, ddof=1)\n    correlation_matrix = covariance_matrix / jnp.outer(standard_deviations,\n                                                       standard_deviations)\n    correlation_matrix = pd.DataFrame(\n        correlation_matrix,\n        columns=feature_names + [\"target\"],\n        index=feature_names + [\"target\"],\n        dtype=float)\n    correlation_matrix_output.append(correlation_matrix)\n\n  return correlation_matrix_output\n\n\ndef _compute_variances(\n    features: jnp.ndarray,\n    feature_names: Sequence[str],\n    geo_names: Sequence[str],\n) -> pd.DataFrame:\n  \"\"\"Computes variances over time for each feature.\n\n  In general, higher variance is better since it creates more signal for the\n  regression analysis. However, if the features have not been scaled (divided by\n  the mean), then the variance can take any value and this analysis is not\n  meaningful.\n\n  Args:\n    features: Features for media mix model (media and non-media variables).\n    feature_names: Names of media channels to be added to the output dataframe.\n    geo_names: Names of geos to be added to the output dataframes.\n\n  Returns:\n    Dataframe containing the variance over time for each feature. This dataframe\n      contains one row per geo, and just a single row for national data.\n\n  Raises:\n    ValueError: If the number of geos in features does not match the number of\n    supplied geo_names.\n  \"\"\""
  },
  {
    "id": "253",
    "text": "ide_by = divide_by\n\n    if multiply_operation is None and multiply_by is None:\n      raise ValueError(\n          \"Either a multiplication operation or value needs to be passed. If \"\n          \"you dont want to use a multiplication to scale your data just \"\n          \"pass multiply_by=1.\")\n    elif multiply_operation is not None:\n      self.multiply_operation = multiply_operation\n    else:\n      self.multiply_by = multiply_by\n\n  def fit(self, data: jnp.ndarray) -> None:\n    \"\"\"Figures out values for transformations based on the specified operations.\n\n    Args:\n      data: Input dataset to use for fitting.\n    \"\"\"\n    if hasattr(self, \"divide_operation\"):\n      self.divide_by = jnp.apply_along_axis(\n          func1d=self.divide_operation, axis=0, arr=data)\n    elif isinstance(self.divide_by, int) or isinstance(self.divide_by, float):\n      self.divide_by = self.divide_by * jnp.ones(data.shape[1:])\n    if hasattr(self, \"multiply_operation\"):\n      self.multiply_by = jnp.apply_along_axis(\n          func1d=self.multiply_operation, axis=0, arr=data)\n    elif isinstance(self.multiply_by, int) or isinstance(\n        self.multiply_by, float):\n      self.multiply_by = self.multiply_by * jnp.ones(data.shape[1:])\n\n  def transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Applies transformation based on fitted values.\n\n    It can only be called if scaler was fit first.\n\n    Args:\n      data: Input dataset to transform.\n\n    Returns:\n      Transformed array.\n    \"\"\"\n    if not hasattr(self, \"divide_by\") or not hasattr(self, \"multiply_by\"):\n      raise NotFittedScalerError(\n          \"transform is called without fit being called previously. Please \"\n          \"fit scaler first.\")\n    return self.multiply_by * data / self.divide_by\n\n  def fit_transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Fits the values and applies transformation to the input data.\n\n    Args:\n      data: Input dataset.\n\n    Returns:\n      Transformed array.\n    \"\"\"\n    self.fit(data)\n    return self.transform(data)\n\n  def inverse_transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Runs inverse transformation to get original values.\n\n    Args:\n      data: Input dataset.\n\n    Returns:\n      Dataset with the inverse transformation applied.\n    \"\"\"\n    return self.divide_by * data / self.multiply_by\n\n\ndef _compute_correlations(\n    features: jnp.ndarray,\n    target: jnp.ndarray,\n    feature_names: List[str],\n    ) -> List[pd.DataFrame]:\n  \"\"\"Computes feature-feature and feature-target correlations.\n\n  Helper function for DataQualityCheck.\n\n  Args:\n    features: Features for media mix model (media and non-media variables).\n    target: Target variable for media mix model.\n    feature_names: Names of media channels to be added to the output dataframes.\n\n  Returns:\n    List of dataframes containing Pearson correlation coefficients between each\n      feature, as well as between features and the target variable. For\n      national-level data the list contains just one dataframe, and for\n      geo-level data the list contains one dataframe for each geo.\n\n  Raises:\n    ValueError: If features and target have incompatible shapes (e.g. one is\n      geo-level and the other national-level).\n  \"\"\"\n  if not ((features.ndim == 2 and target.ndim == 1) or\n          (features.ndim == 3 and target.ndim == 2)):\n    raise ValueError(f\"Incompatible shapes between features {features.shape}\"\n                     f\" and target {target.shape}.\")\n\n  number_of_geos = core_utils.get_number_geos(features)\n  correlation_matrix_output = []\n  for i_geo in range(number_of_geos):\n\n    if number_of_geos == 1:\n      features_and_target = jnp.concatenate(\n          [features, jnp.expand_dims(target, axis=1)], axis=1)\n    else:\n      features_and_target = jnp.concatenate(\n          [features[:, :, i_geo],\n           jnp.expand_dims(target[:, i_geo], axis=1)],\n          axis=1)\n\n    covariance_matrix = jnp.cov(features_and_target, rowvar=False)\n    standard_deviations = jnp.std(features_and_target, axis=0, ddof=1)\n    correlation_matrix = covariance_matrix / jnp.outer(standard_deviations,\n                                                       standard_deviations)\n    correlation_matrix = pd.DataFrame(\n        correlation_matrix,\n        columns=feature_names + [\"target\"],\n        index=feature_names + [\"target\"],\n        dtype=float)\n    correlation_matrix_output.append(correlation_matrix)\n\n  return correlation_matrix_output\n\n\ndef _compute_variances(\n    features: jnp.ndarray,\n    feature_names: Sequence[str],\n    geo_names: Sequence[str],\n) -> pd.DataFrame:\n  \"\"\"Computes variances over time for each feature.\n\n  In general, higher variance is better since it creates more signal for the\n  regression analysis. However, if the features have not been scaled (divided by\n  the mean), then the variance can take any value and this analysis is not\n  meaningful.\n\n  Args:\n    features: Features for media mix model (media and non-media variables).\n    feature_names: Names of media channels to be added to the output dataframe.\n    geo_names: Names of geos to be added to the output dataframes.\n\n  Returns:\n    Dataframe containing the variance over time for each feature. This dataframe\n      contains one row per geo, and just a single row for national data.\n\n  Raises:\n    ValueError: If the number of geos in features does not match the number of\n    supplied geo_names.\n  \"\"\"\n  number_of_geos = core_utils.get_number_geos(features)\n\n  if len(geo_names) != number_of_geos:\n    raise ValueError(\"The number of geos in features does not match the length \"\n                     \"of geo_names\")\n\n  variances_as_series = []\n  for i_geo in range(number_of_geos):\n    features_for_this_geo = features[...,\n                                     i_geo] if number_of_geos > 1 else features\n    variances_as_series.append(\n        pd.DataFrame(data=features_for_this_geo).var(axis=0, ddof=0))\n\n  variances = pd.concat(variances_as_series, axis=1)\n  variances.columns = geo_names\n  variances.index = copy.copy(feature_names)\n\n  return variances\n\n\ndef _compute_spend_fractions(\n    cost_data: jnp.ndarray,\n    channel_names: Optional[Sequence[str]] = None,\n    output_column_name: str = \"fraction of spend\") -> pd.DataFrame:\n  \"\"\"Computes fraction of total spend for each media channel.\n\n  Args:\n    cost_data: Spend (can be normalized or not) per channel.\n    channel_names: Names of media channels to be added to the output dataframe.\n    output_column_name: Name of the column in the output dataframe, denoting the\n      fraction of the total spend in each media channel.\n\n  Returns:\n    Dataframe containing fraction of the total spend in each channel.\n\n  Raises:\n    ValueError if any of the costs are zero or negative.\n  \"\"\""
  },
  {
    "id": "254",
    "text": ", axis=0, arr=data)\n    elif isinstance(self.multiply_by, int) or isinstance(\n        self.multiply_by, float):\n      self.multiply_by = self.multiply_by * jnp.ones(data.shape[1:])\n\n  def transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Applies transformation based on fitted values.\n\n    It can only be called if scaler was fit first.\n\n    Args:\n      data: Input dataset to transform.\n\n    Returns:\n      Transformed array.\n    \"\"\"\n    if not hasattr(self, \"divide_by\") or not hasattr(self, \"multiply_by\"):\n      raise NotFittedScalerError(\n          \"transform is called without fit being called previously. Please \"\n          \"fit scaler first.\")\n    return self.multiply_by * data / self.divide_by\n\n  def fit_transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Fits the values and applies transformation to the input data.\n\n    Args:\n      data: Input dataset.\n\n    Returns:\n      Transformed array.\n    \"\"\"\n    self.fit(data)\n    return self.transform(data)\n\n  def inverse_transform(self, data: jnp.ndarray) -> jnp.ndarray:\n    \"\"\"Runs inverse transformation to get original values.\n\n    Args:\n      data: Input dataset.\n\n    Returns:\n      Dataset with the inverse transformation applied.\n    \"\"\"\n    return self.divide_by * data / self.multiply_by\n\n\ndef _compute_correlations(\n    features: jnp.ndarray,\n    target: jnp.ndarray,\n    feature_names: List[str],\n    ) -> List[pd.DataFrame]:\n  \"\"\"Computes feature-feature and feature-target correlations.\n\n  Helper function for DataQualityCheck.\n\n  Args:\n    features: Features for media mix model (media and non-media variables).\n    target: Target variable for media mix model.\n    feature_names: Names of media channels to be added to the output dataframes.\n\n  Returns:\n    List of dataframes containing Pearson correlation coefficients between each\n      feature, as well as between features and the target variable. For\n      national-level data the list contains just one dataframe, and for\n      geo-level data the list contains one dataframe for each geo.\n\n  Raises:\n    ValueError: If features and target have incompatible shapes (e.g. one is\n      geo-level and the other national-level).\n  \"\"\"\n  if not ((features.ndim == 2 and target.ndim == 1) or\n          (features.ndim == 3 and target.ndim == 2)):\n    raise ValueError(f\"Incompatible shapes between features {features.shape}\"\n                     f\" and target {target.shape}.\")\n\n  number_of_geos = core_utils.get_number_geos(features)\n  correlation_matrix_output = []\n  for i_geo in range(number_of_geos):\n\n    if number_of_geos == 1:\n      features_and_target = jnp.concatenate(\n          [features, jnp.expand_dims(target, axis=1)], axis=1)\n    else:\n      features_and_target = jnp.concatenate(\n          [features[:, :, i_geo],\n           jnp.expand_dims(target[:, i_geo], axis=1)],\n          axis=1)\n\n    covariance_matrix = jnp.cov(features_and_target, rowvar=False)\n    standard_deviations = jnp.std(features_and_target, axis=0, ddof=1)\n    correlation_matrix = covariance_matrix / jnp.outer(standard_deviations,\n                                                       standard_deviations)\n    correlation_matrix = pd.DataFrame(\n        correlation_matrix,\n        columns=feature_names + [\"target\"],\n        index=feature_names + [\"target\"],\n        dtype=float)\n    correlation_matrix_output.append(correlation_matrix)\n\n  return correlation_matrix_output\n\n\ndef _compute_variances(\n    features: jnp.ndarray,\n    feature_names: Sequence[str],\n    geo_names: Sequence[str],\n) -> pd.DataFrame:\n  \"\"\"Computes variances over time for each feature.\n\n  In general, higher variance is better since it creates more signal for the\n  regression analysis. However, if the features have not been scaled (divided by\n  the mean), then the variance can take any value and this analysis is not\n  meaningful.\n\n  Args:\n    features: Features for media mix model (media and non-media variables).\n    feature_names: Names of media channels to be added to the output dataframe.\n    geo_names: Names of geos to be added to the output dataframes.\n\n  Returns:\n    Dataframe containing the variance over time for each feature. This dataframe\n      contains one row per geo, and just a single row for national data.\n\n  Raises:\n    ValueError: If the number of geos in features does not match the number of\n    supplied geo_names.\n  \"\"\"\n  number_of_geos = core_utils.get_number_geos(features)\n\n  if len(geo_names) != number_of_geos:\n    raise ValueError(\"The number of geos in features does not match the length \"\n                     \"of geo_names\")\n\n  variances_as_series = []\n  for i_geo in range(number_of_geos):\n    features_for_this_geo = features[...,\n                                     i_geo] if number_of_geos > 1 else features\n    variances_as_series.append(\n        pd.DataFrame(data=features_for_this_geo).var(axis=0, ddof=0))\n\n  variances = pd.concat(variances_as_series, axis=1)\n  variances.columns = geo_names\n  variances.index = copy.copy(feature_names)\n\n  return variances\n\n\ndef _compute_spend_fractions(\n    cost_data: jnp.ndarray,\n    channel_names: Optional[Sequence[str]] = None,\n    output_column_name: str = \"fraction of spend\") -> pd.DataFrame:\n  \"\"\"Computes fraction of total spend for each media channel.\n\n  Args:\n    cost_data: Spend (can be normalized or not) per channel.\n    channel_names: Names of media channels to be added to the output dataframe.\n    output_column_name: Name of the column in the output dataframe, denoting the\n      fraction of the total spend in each media channel.\n\n  Returns:\n    Dataframe containing fraction of the total spend in each channel.\n\n  Raises:\n    ValueError if any of the costs are zero or negative.\n  \"\"\"\n  cost_df = pd.DataFrame(\n      cost_data, index=channel_names, columns=[output_column_name])\n\n  if (cost_df[output_column_name] <= 0).any():\n    raise ValueError(\"Values in cost_data must all be positive.\")\n\n  normalized_cost_df = cost_df.div(cost_df.sum(axis=0), axis=1).round(4)\n  return normalized_cost_df\n\n\ndef _compute_variance_inflation_factors(\n    features: jnp.ndarray, feature_names: Sequence[str],\n    geo_names: Sequence[str]) -> pd.DataFrame:\n  \"\"\"Computes variance inflation factors for all features.\n\n  Helper function for DataQualityCheck.\n\n  Args:\n    features: Features for media mix model (media and non-media variables).\n    feature_names: Names of media channels to be added to the output dataframe.\n    geo_names: Names of geos to be added to the output dataframes.\n\n  Returns:\n    Dataframe containing variance inflation factors for each feature. For\n      national-level data the dataframe contains just one column, and for\n      geo-level data the list contains one column for each geo.\n\n  Raises:\n    ValueError: If the number of geos in features does not match the number of\n    supplied geo_names.\n  \"\"\""
  },
  {
    "id": "255",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set of utilities for LightweighMMM package.\"\"\"\nimport pickle\nimport time\nfrom typing import Any, List, Optional, Tuple\n\nfrom absl import logging\nfrom jax import random\nimport jax.numpy as jnp\nimport numpy as np\nimport pandas as pd\nfrom scipy import interpolate\nfrom scipy import optimize\nfrom scipy import spatial\nfrom scipy import stats\nfrom tensorflow.io import gfile\n\nfrom lightweight_mmm import media_transforms\n\n\ndef save_model(\n    media_mix_model: Any,\n    file_path: str\n    ) -> None:\n  \"\"\"Saves the given model in the given path.\n\n  Args:\n    media_mix_model: Model to save on disk.\n    file_path: File path where the model should be placed.\n  \"\"\"\n  with gfile.GFile(file_path, \"wb\") as file:\n    pickle.dump(obj=media_mix_model, file=file)\n\n\ndef load_model(file_path: str) -> Any:\n  \"\"\"Loads a model given a string path.\n\n  Args:\n    file_path: Path of the file containing the model.\n\n  Returns:\n    The LightweightMMM object that was stored in the given path.\n  \"\"\""
  },
  {
    "id": "256",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Set of utilities for LightweighMMM package.\"\"\"\nimport pickle\nimport time\nfrom typing import Any, List, Optional, Tuple\n\nfrom absl import logging\nfrom jax import random\nimport jax.numpy as jnp\nimport numpy as np\nimport pandas as pd\nfrom scipy import interpolate\nfrom scipy import optimize\nfrom scipy import spatial\nfrom scipy import stats\nfrom tensorflow.io import gfile\n\nfrom lightweight_mmm import media_transforms\n\n\ndef save_model(\n    media_mix_model: Any,\n    file_path: str\n    ) -> None:\n  \"\"\"Saves the given model in the given path.\n\n  Args:\n    media_mix_model: Model to save on disk.\n    file_path: File path where the model should be placed.\n  \"\"\"\n  with gfile.GFile(file_path, \"wb\") as file:\n    pickle.dump(obj=media_mix_model, file=file)\n\n\ndef load_model(file_path: str) -> Any:\n  \"\"\"Loads a model given a string path.\n\n  Args:\n    file_path: Path of the file containing the model.\n\n  Returns:\n    The LightweightMMM object that was stored in the given path.\n  \"\"\"\n  with gfile.GFile(file_path, \"rb\") as file:\n    media_mix_model = pickle.load(file=file)\n\n  for attr in dir(media_mix_model):\n    if attr.startswith(\"__\"):\n      continue\n    attr_value = getattr(media_mix_model, attr)\n    if isinstance(attr_value, np.ndarray):\n      setattr(media_mix_model, attr, jnp.array(attr_value))\n\n  return media_mix_model\n\n\ndef get_time_seed() -> int:\n  \"\"\"Generates an integer using the last decimals of time.time().\n\n  Returns:\n    Integer to be used as seed.\n  \"\"\"\n  # time.time() has the following format: 1645174953.0429401\n  return int(str(time.time()).split(\".\")[1])\n\n\ndef simulate_dummy_data(\n    data_size: int,\n    n_media_channels: int,\n    n_extra_features: int,\n    geos: int = 1,\n    seed: int = 5\n    ) -> Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray, jnp.ndarray]:\n  \"\"\"Simulates dummy data needed for media mix modelling.\n\n  This function's goal is to be super simple and not have many parameters,\n  although it does not generate a fully realistic dataset is only meant to be\n  used for demos/tutorial purposes. Uses carryover for lagging but has no\n  saturation and no trend.\n\n  The data simulated includes the media data, extra features, a target/KPI and\n  costs.\n\n  Args:\n    data_size: Number of rows to generate.\n    n_media_channels: Number of media channels to generate.\n    n_extra_features: Number of extra features to generate.\n    geos: Number of geos for geo level data (default = 1 for national).\n    seed: Random seed.\n\n  Returns:\n    The simulated media, extra features, target and costs.\n  \"\"\"\n  if data_size < 1 or n_media_channels < 1 or n_extra_features < 1:\n    raise ValueError(\n        \"Data size, n_media_channels and n_extra_features must be greater than\"\n        \" 0. Please check the values introduced are greater than zero.\")\n  data_offset = int(data_size * 0.2)\n  data_size += data_offset\n  key = random.PRNGKey(seed)\n  sub_keys = random.split(key=key, num=7)\n  media_data = random.normal(key=sub_keys[0],\n                             shape=(data_size, n_media_channels)) * 1.5 + 20\n\n  extra_features = random.normal(key=sub_keys[1],\n                                 shape=(data_size, n_extra_features)) + 5\n  # Reduce the costs to make ROI realistic.\n  costs = media_data[data_offset:].sum(axis=0) * .1\n\n  seasonality = media_transforms.calculate_seasonality(\n      number_periods=data_size,\n      degrees=2,\n      frequency=52,\n      gamma_seasonality=1)\n  target_noise = random.normal(key=sub_keys[2], shape=(data_size,)) + 3\n\n  # media_data_transformed = media_transforms.adstock(media_data)\n  media_data_transformed = media_transforms.carryover(\n      data=media_data,\n      ad_effect_retention_rate=jnp.full((n_media_channels,), fill_value=.5),\n      peak_effect_delay=jnp.full((n_media_channels,), fill_value=1.))\n  beta_media = random.normal(key=sub_keys[3], shape=(n_media_channels,)) + 1\n  beta_extra_features = random.normal(key=sub_keys[4],\n                                      shape=(n_extra_features,))\n  # There is no trend to keep this very simple.\n  target = 15 + seasonality + media_data_transformed.dot(\n      beta_media) + extra_features.dot(beta_extra_features) + target_noise\n\n  logging.info(\"Correlation between transformed media and target\")\n  logging.info([\n      np.corrcoef(target[data_offset:], media_data_transformed[data_offset:,\n                                                               i])[0, 1]\n      for i in range(n_media_channels)\n  ])\n\n  logging.info(\"True ROI for media channels\")\n  logging.info([\n      sum(media_data_transformed[data_offset:, i] * beta_media[i]) / costs[i]\n      for i in range(n_media_channels)\n  ])\n\n  if geos > 1:\n    # Distribute national data to geo and add some more noise.\n    weights = random.uniform(key=sub_keys[5], shape=(1, geos))\n    weights /= sum(weights)\n    target_noise = random.normal(key=sub_keys[6], shape=(data_size, geos)) * .5\n    target = target[:, np.newaxis].dot(weights) + target_noise\n    media_data = media_data[:, :, np.newaxis].dot(weights)\n    extra_features = extra_features[:, :, np.newaxis].dot(weights)\n\n  return (media_data[data_offset:], extra_features[data_offset:],\n          target[data_offset:], costs)\n\n\ndef _split_array_into_list(\n    dataframe: pd.DataFrame,\n    split_level_feature: str,\n    features: List[str],\n    national_model_flag: bool = True) -> List[np.ndarray]:\n  \"\"\"Splits data frame into list of jax arrays.\n\n  Args:\n    dataframe: Dataframe with all the modeling feature.\n    split_level_feature: Feature that will be used to split.\n    features: List of feature to export from data frame.\n    national_model_flag: Whether the data frame is used for national model.\n\n  Returns:\n    List of jax arrays.\n  \"\"\""
  },
  {
    "id": "257",
    "text": "adstock(media_data)\n  media_data_transformed = media_transforms.carryover(\n      data=media_data,\n      ad_effect_retention_rate=jnp.full((n_media_channels,), fill_value=.5),\n      peak_effect_delay=jnp.full((n_media_channels,), fill_value=1.))\n  beta_media = random.normal(key=sub_keys[3], shape=(n_media_channels,)) + 1\n  beta_extra_features = random.normal(key=sub_keys[4],\n                                      shape=(n_extra_features,))\n  # There is no trend to keep this very simple.\n  target = 15 + seasonality + media_data_transformed.dot(\n      beta_media) + extra_features.dot(beta_extra_features) + target_noise\n\n  logging.info(\"Correlation between transformed media and target\")\n  logging.info([\n      np.corrcoef(target[data_offset:], media_data_transformed[data_offset:,\n                                                               i])[0, 1]\n      for i in range(n_media_channels)\n  ])\n\n  logging.info(\"True ROI for media channels\")\n  logging.info([\n      sum(media_data_transformed[data_offset:, i] * beta_media[i]) / costs[i]\n      for i in range(n_media_channels)\n  ])\n\n  if geos > 1:\n    # Distribute national data to geo and add some more noise.\n    weights = random.uniform(key=sub_keys[5], shape=(1, geos))\n    weights /= sum(weights)\n    target_noise = random.normal(key=sub_keys[6], shape=(data_size, geos)) * .5\n    target = target[:, np.newaxis].dot(weights) + target_noise\n    media_data = media_data[:, :, np.newaxis].dot(weights)\n    extra_features = extra_features[:, :, np.newaxis].dot(weights)\n\n  return (media_data[data_offset:], extra_features[data_offset:],\n          target[data_offset:], costs)\n\n\ndef _split_array_into_list(\n    dataframe: pd.DataFrame,\n    split_level_feature: str,\n    features: List[str],\n    national_model_flag: bool = True) -> List[np.ndarray]:\n  \"\"\"Splits data frame into list of jax arrays.\n\n  Args:\n    dataframe: Dataframe with all the modeling feature.\n    split_level_feature: Feature that will be used to split.\n    features: List of feature to export from data frame.\n    national_model_flag: Whether the data frame is used for national model.\n\n  Returns:\n    List of jax arrays.\n  \"\"\"\n  split_level = dataframe[split_level_feature].unique()\n  array_list_by_level = [\n      dataframe.loc[dataframe[split_level_feature] == level, features].values.T\n      for level in split_level\n  ]\n  feature_array = jnp.stack(array_list_by_level)\n  if national_model_flag:\n    feature_array = jnp.squeeze(feature_array, axis=2)\n  return feature_array\n\n\ndef dataframe_to_jax(\n    dataframe: pd.DataFrame,\n    media_features: List[str],\n    extra_features: List[str],\n    date_feature: str,\n    target: str,\n    geo_feature: Optional[str] = None,\n    cost_features: Optional[List[str]] = None\n    ) -> Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray, jnp.ndarray]:\n  \"\"\"Converts pandas dataframe to right data format for media mix model.\n\n  This function's goal is to convert dataframe which is most familar with data\n  scientists to jax arrays to help the users who are not familar with array to\n  use the lightweight MMM library easier.\n\n  Args:\n    dataframe: Dataframe with geo, KPI, media and non-media features.\n    media_features: List of media feature names.\n    extra_features: List of non media feature names.\n    date_feature: Date feature name.\n    target: Target variables name.\n    geo_feature: Geo feature name and it is optional if the data is at national\n      level.\n    cost_features: List of media cost variables and it is optional if user\n      use actual media cost as their media features in the model.\n\n  Returns:\n    Media, extra features, target and costs arrays.\n\n  Raises:\n    ValueError: If each geo has unequal number of weeks or there is only one\n    value in the geo feature.\n  \"\"\"\n  if geo_feature is not None:\n    if dataframe[geo_feature].nunique() == 1:\n      raise ValueError(\n          \"Geo feature has at least two geos or keep default for national model\"\n          )\n    count_by_geo = dataframe.groupby(\n        geo_feature)[date_feature].count().reset_index()\n    unique_date_count = count_by_geo[date_feature].nunique()\n    if unique_date_count != 1:\n      raise ValueError(\"Not all the geos have same number of weeks.\")\n    national_model_flag = False\n    features_to_sort = [date_feature, geo_feature]\n  else:\n    national_model_flag = True\n    features_to_sort = [date_feature]\n\n  df_sorted = dataframe.sort_values(by=features_to_sort)\n  media_features_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=media_features,\n      national_model_flag=national_model_flag)\n\n  extra_features_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=extra_features,\n      national_model_flag=national_model_flag)\n\n  target_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=[target],\n      national_model_flag=national_model_flag)\n  target_data = jnp.squeeze(target_data)\n\n  if cost_features:\n    cost_data = jnp.dot(\n        jnp.full(len(dataframe), 1), dataframe[cost_features].values)\n  else:\n    cost_data = jnp.dot(\n        jnp.full(len(dataframe), 1), dataframe[media_features].values)\n  return (media_features_data, extra_features_data, target_data, cost_data)# jax-ndarray\n\n\ndef get_halfnormal_mean_from_scale(scale: float) -> float:\n  \"\"\"Returns the mean of the half-normal distribition.\"\"\"\n  # https://en.wikipedia.org/wiki/Half-normal_distribution\n  return scale * np.sqrt(2) / np.sqrt(np.pi)\n\n\ndef get_halfnormal_scale_from_mean(mean: float) -> float:\n  \"\"\"Returns the scale of the half-normal distribution.\"\"\"\n  # https://en.wikipedia.org/wiki/Half-normal_distribution\n  return mean * np.sqrt(np.pi) / np.sqrt(2)\n\n\ndef get_beta_params_from_mu_sigma(mu: float,\n                                  sigma: float,\n                                  bracket: Tuple[float, float] = (.5, 100.)\n                                  ) -> Tuple[float, float]:\n  \"\"\"Deterministically estimates (a, b) from (mu, sigma) of a beta variable.\n\n  https://en.wikipedia.org/wiki/Beta_distribution\n\n  Args:\n    mu: The sample mean of the beta distributed variable.\n    sigma: The sample standard deviation of the beta distributed variable.\n    bracket: Search bracket for b.\n\n  Returns:\n    Tuple of the (a, b) parameters.\n  \"\"\"\n  # Assume a = 1 to find b."
  },
  {
    "id": "258",
    "text": "_channels)\n  ])\n\n  logging.info(\"True ROI for media channels\")\n  logging.info([\n      sum(media_data_transformed[data_offset:, i] * beta_media[i]) / costs[i]\n      for i in range(n_media_channels)\n  ])\n\n  if geos > 1:\n    # Distribute national data to geo and add some more noise.\n    weights = random.uniform(key=sub_keys[5], shape=(1, geos))\n    weights /= sum(weights)\n    target_noise = random.normal(key=sub_keys[6], shape=(data_size, geos)) * .5\n    target = target[:, np.newaxis].dot(weights) + target_noise\n    media_data = media_data[:, :, np.newaxis].dot(weights)\n    extra_features = extra_features[:, :, np.newaxis].dot(weights)\n\n  return (media_data[data_offset:], extra_features[data_offset:],\n          target[data_offset:], costs)\n\n\ndef _split_array_into_list(\n    dataframe: pd.DataFrame,\n    split_level_feature: str,\n    features: List[str],\n    national_model_flag: bool = True) -> List[np.ndarray]:\n  \"\"\"Splits data frame into list of jax arrays.\n\n  Args:\n    dataframe: Dataframe with all the modeling feature.\n    split_level_feature: Feature that will be used to split.\n    features: List of feature to export from data frame.\n    national_model_flag: Whether the data frame is used for national model.\n\n  Returns:\n    List of jax arrays.\n  \"\"\"\n  split_level = dataframe[split_level_feature].unique()\n  array_list_by_level = [\n      dataframe.loc[dataframe[split_level_feature] == level, features].values.T\n      for level in split_level\n  ]\n  feature_array = jnp.stack(array_list_by_level)\n  if national_model_flag:\n    feature_array = jnp.squeeze(feature_array, axis=2)\n  return feature_array\n\n\ndef dataframe_to_jax(\n    dataframe: pd.DataFrame,\n    media_features: List[str],\n    extra_features: List[str],\n    date_feature: str,\n    target: str,\n    geo_feature: Optional[str] = None,\n    cost_features: Optional[List[str]] = None\n    ) -> Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray, jnp.ndarray]:\n  \"\"\"Converts pandas dataframe to right data format for media mix model.\n\n  This function's goal is to convert dataframe which is most familar with data\n  scientists to jax arrays to help the users who are not familar with array to\n  use the lightweight MMM library easier.\n\n  Args:\n    dataframe: Dataframe with geo, KPI, media and non-media features.\n    media_features: List of media feature names.\n    extra_features: List of non media feature names.\n    date_feature: Date feature name.\n    target: Target variables name.\n    geo_feature: Geo feature name and it is optional if the data is at national\n      level.\n    cost_features: List of media cost variables and it is optional if user\n      use actual media cost as their media features in the model.\n\n  Returns:\n    Media, extra features, target and costs arrays.\n\n  Raises:\n    ValueError: If each geo has unequal number of weeks or there is only one\n    value in the geo feature.\n  \"\"\"\n  if geo_feature is not None:\n    if dataframe[geo_feature].nunique() == 1:\n      raise ValueError(\n          \"Geo feature has at least two geos or keep default for national model\"\n          )\n    count_by_geo = dataframe.groupby(\n        geo_feature)[date_feature].count().reset_index()\n    unique_date_count = count_by_geo[date_feature].nunique()\n    if unique_date_count != 1:\n      raise ValueError(\"Not all the geos have same number of weeks.\")\n    national_model_flag = False\n    features_to_sort = [date_feature, geo_feature]\n  else:\n    national_model_flag = True\n    features_to_sort = [date_feature]\n\n  df_sorted = dataframe.sort_values(by=features_to_sort)\n  media_features_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=media_features,\n      national_model_flag=national_model_flag)\n\n  extra_features_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=extra_features,\n      national_model_flag=national_model_flag)\n\n  target_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=[target],\n      national_model_flag=national_model_flag)\n  target_data = jnp.squeeze(target_data)\n\n  if cost_features:\n    cost_data = jnp.dot(\n        jnp.full(len(dataframe), 1), dataframe[cost_features].values)\n  else:\n    cost_data = jnp.dot(\n        jnp.full(len(dataframe), 1), dataframe[media_features].values)\n  return (media_features_data, extra_features_data, target_data, cost_data)# jax-ndarray\n\n\ndef get_halfnormal_mean_from_scale(scale: float) -> float:\n  \"\"\"Returns the mean of the half-normal distribition.\"\"\"\n  # https://en.wikipedia.org/wiki/Half-normal_distribution\n  return scale * np.sqrt(2) / np.sqrt(np.pi)\n\n\ndef get_halfnormal_scale_from_mean(mean: float) -> float:\n  \"\"\"Returns the scale of the half-normal distribution.\"\"\"\n  # https://en.wikipedia.org/wiki/Half-normal_distribution\n  return mean * np.sqrt(np.pi) / np.sqrt(2)\n\n\ndef get_beta_params_from_mu_sigma(mu: float,\n                                  sigma: float,\n                                  bracket: Tuple[float, float] = (.5, 100.)\n                                  ) -> Tuple[float, float]:\n  \"\"\"Deterministically estimates (a, b) from (mu, sigma) of a beta variable.\n\n  https://en.wikipedia.org/wiki/Beta_distribution\n\n  Args:\n    mu: The sample mean of the beta distributed variable.\n    sigma: The sample standard deviation of the beta distributed variable.\n    bracket: Search bracket for b.\n\n  Returns:\n    Tuple of the (a, b) parameters.\n  \"\"\"\n  # Assume a = 1 to find b.\n  def _f(x):\n    return x ** 2 + 4 * x + 5 + 2 / x - 1 / sigma ** 2\n  b = optimize.root_scalar(_f, bracket=bracket, method=\"brentq\").root\n  # Given b, now find a better a.\n  a = b / (1 / mu - 1)\n  return a, b\n\n\ndef _estimate_pdf(p: jnp.ndarray, x: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Estimates smooth pdf with Gaussian kernel.\n\n  Args:\n    p: Samples.\n    x: The continuous x space (sorted).\n\n  Returns:\n    A density vector.\n  \"\"\"\n  density = sum(stats.norm(xi).pdf(x) for xi in p)\n  return density / density.sum()\n\n\ndef _pmf(p: jnp.ndarray, x: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Estimates discrete pmf.\n\n  Args:\n    p: Samples.\n    x: The discrete x space (sorted).\n\n  Returns:\n    A pmf vector.\n  \"\"\""
  },
  {
    "id": "259",
    "text": "], costs)\n\n\ndef _split_array_into_list(\n    dataframe: pd.DataFrame,\n    split_level_feature: str,\n    features: List[str],\n    national_model_flag: bool = True) -> List[np.ndarray]:\n  \"\"\"Splits data frame into list of jax arrays.\n\n  Args:\n    dataframe: Dataframe with all the modeling feature.\n    split_level_feature: Feature that will be used to split.\n    features: List of feature to export from data frame.\n    national_model_flag: Whether the data frame is used for national model.\n\n  Returns:\n    List of jax arrays.\n  \"\"\"\n  split_level = dataframe[split_level_feature].unique()\n  array_list_by_level = [\n      dataframe.loc[dataframe[split_level_feature] == level, features].values.T\n      for level in split_level\n  ]\n  feature_array = jnp.stack(array_list_by_level)\n  if national_model_flag:\n    feature_array = jnp.squeeze(feature_array, axis=2)\n  return feature_array\n\n\ndef dataframe_to_jax(\n    dataframe: pd.DataFrame,\n    media_features: List[str],\n    extra_features: List[str],\n    date_feature: str,\n    target: str,\n    geo_feature: Optional[str] = None,\n    cost_features: Optional[List[str]] = None\n    ) -> Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray, jnp.ndarray]:\n  \"\"\"Converts pandas dataframe to right data format for media mix model.\n\n  This function's goal is to convert dataframe which is most familar with data\n  scientists to jax arrays to help the users who are not familar with array to\n  use the lightweight MMM library easier.\n\n  Args:\n    dataframe: Dataframe with geo, KPI, media and non-media features.\n    media_features: List of media feature names.\n    extra_features: List of non media feature names.\n    date_feature: Date feature name.\n    target: Target variables name.\n    geo_feature: Geo feature name and it is optional if the data is at national\n      level.\n    cost_features: List of media cost variables and it is optional if user\n      use actual media cost as their media features in the model.\n\n  Returns:\n    Media, extra features, target and costs arrays.\n\n  Raises:\n    ValueError: If each geo has unequal number of weeks or there is only one\n    value in the geo feature.\n  \"\"\"\n  if geo_feature is not None:\n    if dataframe[geo_feature].nunique() == 1:\n      raise ValueError(\n          \"Geo feature has at least two geos or keep default for national model\"\n          )\n    count_by_geo = dataframe.groupby(\n        geo_feature)[date_feature].count().reset_index()\n    unique_date_count = count_by_geo[date_feature].nunique()\n    if unique_date_count != 1:\n      raise ValueError(\"Not all the geos have same number of weeks.\")\n    national_model_flag = False\n    features_to_sort = [date_feature, geo_feature]\n  else:\n    national_model_flag = True\n    features_to_sort = [date_feature]\n\n  df_sorted = dataframe.sort_values(by=features_to_sort)\n  media_features_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=media_features,\n      national_model_flag=national_model_flag)\n\n  extra_features_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=extra_features,\n      national_model_flag=national_model_flag)\n\n  target_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=[target],\n      national_model_flag=national_model_flag)\n  target_data = jnp.squeeze(target_data)\n\n  if cost_features:\n    cost_data = jnp.dot(\n        jnp.full(len(dataframe), 1), dataframe[cost_features].values)\n  else:\n    cost_data = jnp.dot(\n        jnp.full(len(dataframe), 1), dataframe[media_features].values)\n  return (media_features_data, extra_features_data, target_data, cost_data)# jax-ndarray\n\n\ndef get_halfnormal_mean_from_scale(scale: float) -> float:\n  \"\"\"Returns the mean of the half-normal distribition.\"\"\"\n  # https://en.wikipedia.org/wiki/Half-normal_distribution\n  return scale * np.sqrt(2) / np.sqrt(np.pi)\n\n\ndef get_halfnormal_scale_from_mean(mean: float) -> float:\n  \"\"\"Returns the scale of the half-normal distribution.\"\"\"\n  # https://en.wikipedia.org/wiki/Half-normal_distribution\n  return mean * np.sqrt(np.pi) / np.sqrt(2)\n\n\ndef get_beta_params_from_mu_sigma(mu: float,\n                                  sigma: float,\n                                  bracket: Tuple[float, float] = (.5, 100.)\n                                  ) -> Tuple[float, float]:\n  \"\"\"Deterministically estimates (a, b) from (mu, sigma) of a beta variable.\n\n  https://en.wikipedia.org/wiki/Beta_distribution\n\n  Args:\n    mu: The sample mean of the beta distributed variable.\n    sigma: The sample standard deviation of the beta distributed variable.\n    bracket: Search bracket for b.\n\n  Returns:\n    Tuple of the (a, b) parameters.\n  \"\"\"\n  # Assume a = 1 to find b.\n  def _f(x):\n    return x ** 2 + 4 * x + 5 + 2 / x - 1 / sigma ** 2\n  b = optimize.root_scalar(_f, bracket=bracket, method=\"brentq\").root\n  # Given b, now find a better a.\n  a = b / (1 / mu - 1)\n  return a, b\n\n\ndef _estimate_pdf(p: jnp.ndarray, x: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Estimates smooth pdf with Gaussian kernel.\n\n  Args:\n    p: Samples.\n    x: The continuous x space (sorted).\n\n  Returns:\n    A density vector.\n  \"\"\"\n  density = sum(stats.norm(xi).pdf(x) for xi in p)\n  return density / density.sum()\n\n\ndef _pmf(p: jnp.ndarray, x: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Estimates discrete pmf.\n\n  Args:\n    p: Samples.\n    x: The discrete x space (sorted).\n\n  Returns:\n    A pmf vector.\n  \"\"\"\n  p_cdf = jnp.array([jnp.sum(p <= x[i]) for i in range(len(x))])\n  p_pmf = np.concatenate([[p_cdf[0]], jnp.diff(p_cdf)])\n  return p_pmf / p_pmf.sum()\n\n\ndef distance_pior_posterior(p: jnp.ndarray, q: jnp.ndarray, method: str = \"KS\",\n                            discrete: bool = True) -> float:\n  \"\"\"Quantifies the distance between two distributions.\n\n  Note we do not use KL divergence because it's not defined when a probability\n  is 0.\n\n  https://en.wikipedia.org/wiki/Hellinger_distance\n\n  Args:\n    p: Samples for distribution 1.\n    q: Samples for distribution 2.\n    method: We can have four methods: KS, Hellinger, JS and min.\n    discrete: Whether input data is discrete or continuous.\n\n  Returns:\n    The distance metric (between 0 and 1).\n  \"\"\""
  },
  {
    "id": "260",
    "text": ": Dataframe with geo, KPI, media and non-media features.\n    media_features: List of media feature names.\n    extra_features: List of non media feature names.\n    date_feature: Date feature name.\n    target: Target variables name.\n    geo_feature: Geo feature name and it is optional if the data is at national\n      level.\n    cost_features: List of media cost variables and it is optional if user\n      use actual media cost as their media features in the model.\n\n  Returns:\n    Media, extra features, target and costs arrays.\n\n  Raises:\n    ValueError: If each geo has unequal number of weeks or there is only one\n    value in the geo feature.\n  \"\"\"\n  if geo_feature is not None:\n    if dataframe[geo_feature].nunique() == 1:\n      raise ValueError(\n          \"Geo feature has at least two geos or keep default for national model\"\n          )\n    count_by_geo = dataframe.groupby(\n        geo_feature)[date_feature].count().reset_index()\n    unique_date_count = count_by_geo[date_feature].nunique()\n    if unique_date_count != 1:\n      raise ValueError(\"Not all the geos have same number of weeks.\")\n    national_model_flag = False\n    features_to_sort = [date_feature, geo_feature]\n  else:\n    national_model_flag = True\n    features_to_sort = [date_feature]\n\n  df_sorted = dataframe.sort_values(by=features_to_sort)\n  media_features_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=media_features,\n      national_model_flag=national_model_flag)\n\n  extra_features_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=extra_features,\n      national_model_flag=national_model_flag)\n\n  target_data = _split_array_into_list(\n      dataframe=df_sorted,\n      split_level_feature=date_feature,\n      features=[target],\n      national_model_flag=national_model_flag)\n  target_data = jnp.squeeze(target_data)\n\n  if cost_features:\n    cost_data = jnp.dot(\n        jnp.full(len(dataframe), 1), dataframe[cost_features].values)\n  else:\n    cost_data = jnp.dot(\n        jnp.full(len(dataframe), 1), dataframe[media_features].values)\n  return (media_features_data, extra_features_data, target_data, cost_data)# jax-ndarray\n\n\ndef get_halfnormal_mean_from_scale(scale: float) -> float:\n  \"\"\"Returns the mean of the half-normal distribition.\"\"\"\n  # https://en.wikipedia.org/wiki/Half-normal_distribution\n  return scale * np.sqrt(2) / np.sqrt(np.pi)\n\n\ndef get_halfnormal_scale_from_mean(mean: float) -> float:\n  \"\"\"Returns the scale of the half-normal distribution.\"\"\"\n  # https://en.wikipedia.org/wiki/Half-normal_distribution\n  return mean * np.sqrt(np.pi) / np.sqrt(2)\n\n\ndef get_beta_params_from_mu_sigma(mu: float,\n                                  sigma: float,\n                                  bracket: Tuple[float, float] = (.5, 100.)\n                                  ) -> Tuple[float, float]:\n  \"\"\"Deterministically estimates (a, b) from (mu, sigma) of a beta variable.\n\n  https://en.wikipedia.org/wiki/Beta_distribution\n\n  Args:\n    mu: The sample mean of the beta distributed variable.\n    sigma: The sample standard deviation of the beta distributed variable.\n    bracket: Search bracket for b.\n\n  Returns:\n    Tuple of the (a, b) parameters.\n  \"\"\"\n  # Assume a = 1 to find b.\n  def _f(x):\n    return x ** 2 + 4 * x + 5 + 2 / x - 1 / sigma ** 2\n  b = optimize.root_scalar(_f, bracket=bracket, method=\"brentq\").root\n  # Given b, now find a better a.\n  a = b / (1 / mu - 1)\n  return a, b\n\n\ndef _estimate_pdf(p: jnp.ndarray, x: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Estimates smooth pdf with Gaussian kernel.\n\n  Args:\n    p: Samples.\n    x: The continuous x space (sorted).\n\n  Returns:\n    A density vector.\n  \"\"\"\n  density = sum(stats.norm(xi).pdf(x) for xi in p)\n  return density / density.sum()\n\n\ndef _pmf(p: jnp.ndarray, x: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Estimates discrete pmf.\n\n  Args:\n    p: Samples.\n    x: The discrete x space (sorted).\n\n  Returns:\n    A pmf vector.\n  \"\"\"\n  p_cdf = jnp.array([jnp.sum(p <= x[i]) for i in range(len(x))])\n  p_pmf = np.concatenate([[p_cdf[0]], jnp.diff(p_cdf)])\n  return p_pmf / p_pmf.sum()\n\n\ndef distance_pior_posterior(p: jnp.ndarray, q: jnp.ndarray, method: str = \"KS\",\n                            discrete: bool = True) -> float:\n  \"\"\"Quantifies the distance between two distributions.\n\n  Note we do not use KL divergence because it's not defined when a probability\n  is 0.\n\n  https://en.wikipedia.org/wiki/Hellinger_distance\n\n  Args:\n    p: Samples for distribution 1.\n    q: Samples for distribution 2.\n    method: We can have four methods: KS, Hellinger, JS and min.\n    discrete: Whether input data is discrete or continuous.\n\n  Returns:\n    The distance metric (between 0 and 1).\n  \"\"\"\n\n  if method == \"KS\":\n    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ks_2samp.html\n    return stats.ks_2samp(p, q).statistic\n  elif method in [\"Hellinger\", \"JS\", \"min\"]:\n    if discrete:\n      x = jnp.unique(jnp.concatenate((p, q)))\n      p_pdf = _pmf(p, x)\n      q_pdf = _pmf(q, x)\n    else:\n      minx, maxx = min(p.min(), q.min()), max(p.max(), q.max())\n      x = np.linspace(minx, maxx, 100)\n      p_pdf = _estimate_pdf(p, x)\n      q_pdf = _estimate_pdf(q, x)\n  if method == \"Hellinger\":\n    return np.sqrt(jnp.sum((np.sqrt(p_pdf) - np.sqrt(q_pdf)) ** 2)) / np.sqrt(2)\n  elif method == \"JS\":\n    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.jensenshannon.html\n    return spatial.distance.jensenshannon(p_pdf, q_pdf)\n  else:\n    return 1 - np.minimum(p_pdf, q_pdf).sum()\n\n\ndef interpolate_outliers(x: jnp.ndarray,\n                         outlier_idx: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Overwrites outliers in x with interpolated values.\n\n  Args:\n    x: The original univariate variable with outliers.\n    outlier_idx: Indices of the outliers in x.\n\n  Returns:\n    A cleaned x with outliers overwritten.\n\n  \"\"\""
  },
  {
    "id": "261",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for models.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import handlers\n\nfrom lightweight_mmm import models\n\n\nclass ModelsTest(parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      dict(testcase_name=\"one_channel\", shape=(10, 1)),\n      dict(testcase_name=\"five_channel\", shape=(10, 5)),\n      dict(testcase_name=\"same_channels_as_rows\", shape=(10, 10)),\n      dict(testcase_name=\"geo_shape_1\", shape=(10, 10, 5)),\n      dict(testcase_name=\"geo_shape_2\", shape=(10, 5, 2)),\n      dict(testcase_name=\"one_channel_one_row\", shape=(1, 1)))\n  def test_transform_adstock_produces_correct_output_shape(self, shape):\n\n    def mock_model_function(media_data):"
  },
  {
    "id": "262",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for models.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import handlers\n\nfrom lightweight_mmm import models\n\n\nclass ModelsTest(parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      dict(testcase_name=\"one_channel\", shape=(10, 1)),\n      dict(testcase_name=\"five_channel\", shape=(10, 5)),\n      dict(testcase_name=\"same_channels_as_rows\", shape=(10, 10)),\n      dict(testcase_name=\"geo_shape_1\", shape=(10, 10, 5)),\n      dict(testcase_name=\"geo_shape_2\", shape=(10, 5, 2)),\n      dict(testcase_name=\"one_channel_one_row\", shape=(1, 1)))\n  def test_transform_adstock_produces_correct_output_shape(self, shape):\n\n    def mock_model_function(media_data):\n      numpyro.deterministic(\n          \"transformed_media\",\n          models.transform_adstock(media_data, custom_priors={}))\n\n    media = jnp.ones(shape)\n    kernel = numpyro.infer.NUTS(model=mock_model_function)\n    mcmc = numpyro.infer.MCMC(\n        sampler=kernel, num_warmup=10, num_samples=10, num_chains=1)\n    rng_key = jax.random.PRNGKey(0)\n\n    mcmc.run(rng_key, media_data=media)\n    transformed_media = mcmc.get_samples()[\"transformed_media\"].mean(axis=0)\n\n    self.assertEqual(media.shape, transformed_media.shape)\n\n  @parameterized.named_parameters(\n      dict(testcase_name=\"one_channel\", shape=(10, 1)),\n      dict(testcase_name=\"five_channel\", shape=(10, 5)),\n      dict(testcase_name=\"same_channels_as_rows\", shape=(10, 10)),\n      dict(testcase_name=\"geo_shape_1\", shape=(10, 10, 5)),\n      dict(testcase_name=\"geo_shape_2\", shape=(10, 5, 2)),\n      dict(testcase_name=\"one_channel_one_row\", shape=(1, 1)))\n  def test_transform_hill_adstock_produces_correct_output_shape(self, shape):\n\n    def mock_model_function(media_data):"
  },
  {
    "id": "263",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for models.\"\"\"\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport jax.numpy as jnp\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import handlers\n\nfrom lightweight_mmm import models\n\n\nclass ModelsTest(parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      dict(testcase_name=\"one_channel\", shape=(10, 1)),\n      dict(testcase_name=\"five_channel\", shape=(10, 5)),\n      dict(testcase_name=\"same_channels_as_rows\", shape=(10, 10)),\n      dict(testcase_name=\"geo_shape_1\", shape=(10, 10, 5)),\n      dict(testcase_name=\"geo_shape_2\", shape=(10, 5, 2)),\n      dict(testcase_name=\"one_channel_one_row\", shape=(1, 1)))\n  def test_transform_adstock_produces_correct_output_shape(self, shape):\n\n    def mock_model_function(media_data):\n      numpyro.deterministic(\n          \"transformed_media\",\n          models.transform_adstock(media_data, custom_priors={}))\n\n    media = jnp.ones(shape)\n    kernel = numpyro.infer.NUTS(model=mock_model_function)\n    mcmc = numpyro.infer.MCMC(\n        sampler=kernel, num_warmup=10, num_samples=10, num_chains=1)\n    rng_key = jax.random.PRNGKey(0)\n\n    mcmc.run(rng_key, media_data=media)\n    transformed_media = mcmc.get_samples()[\"transformed_media\"].mean(axis=0)\n\n    self.assertEqual(media.shape, transformed_media.shape)\n\n  @parameterized.named_parameters(\n      dict(testcase_name=\"one_channel\", shape=(10, 1)),\n      dict(testcase_name=\"five_channel\", shape=(10, 5)),\n      dict(testcase_name=\"same_channels_as_rows\", shape=(10, 10)),\n      dict(testcase_name=\"geo_shape_1\", shape=(10, 10, 5)),\n      dict(testcase_name=\"geo_shape_2\", shape=(10, 5, 2)),\n      dict(testcase_name=\"one_channel_one_row\", shape=(1, 1)))\n  def test_transform_hill_adstock_produces_correct_output_shape(self, shape):\n\n    def mock_model_function(media_data):\n      numpyro.deterministic(\n          \"transformed_media\",\n          models.transform_hill_adstock(media_data, custom_priors={}))\n\n    media = jnp.ones(shape)\n    kernel = numpyro.infer.NUTS(model=mock_model_function)\n    mcmc = numpyro.infer.MCMC(\n        sampler=kernel, num_warmup=10, num_samples=10, num_chains=1)\n    rng_key = jax.random.PRNGKey(0)\n\n    mcmc.run(rng_key, media_data=media)\n    transformed_media = mcmc.get_samples()[\"transformed_media\"].mean(axis=0)\n\n    self.assertEqual(media.shape, transformed_media.shape)\n\n  @parameterized.named_parameters(\n      dict(testcase_name=\"one_channel\", shape=(10, 1)),\n      dict(testcase_name=\"five_channel\", shape=(10, 5)),\n      dict(testcase_name=\"same_channels_as_rows\", shape=(10, 10)),\n      dict(testcase_name=\"geo_shape_1\", shape=(10, 10, 5)),\n      dict(testcase_name=\"geo_shape_2\", shape=(10, 5, 2)),\n      dict(testcase_name=\"one_channel_one_row\", shape=(1, 1)))\n  def test_transform_carryover_produces_correct_output_shape(self, shape):\n\n    def mock_model_function(media_data):"
  },
  {
    "id": "264",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for optimize_media.\"\"\"\nfrom unittest import mock\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import optimize_media\nfrom lightweight_mmm import preprocessing\n\n\nclass OptimizeMediaTest(parameterized.TestCase):\n\n  @classmethod\n  def setUpClass(cls):"
  },
  {
    "id": "265",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for optimize_media.\"\"\"\nfrom unittest import mock\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import optimize_media\nfrom lightweight_mmm import preprocessing\n\n\nclass OptimizeMediaTest(parameterized.TestCase):\n\n  @classmethod\n  def setUpClass(cls):\n    super(OptimizeMediaTest, cls).setUpClass()\n    cls.national_mmm = lightweight_mmm.LightweightMMM()\n    cls.national_mmm.fit(\n        media=jnp.ones((50, 5)),\n        target=jnp.ones(50),\n        media_prior=jnp.ones(5) * 50,\n        number_warmup=2,\n        number_samples=2,\n        number_chains=1)\n    cls.geo_mmm = lightweight_mmm.LightweightMMM()\n    cls.geo_mmm.fit(\n        media=jnp.ones((50, 5, 3)),\n        target=jnp.ones((50, 3)),\n        media_prior=jnp.ones(5) * 50,\n        number_warmup=2,\n        number_samples=2,\n        number_chains=1)\n\n  def setUp(self):"
  },
  {
    "id": "266",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Media transformations for accounting for lagging or media effects.\"\"\"\n\nimport functools\nfrom typing import Union\n\nimport jax\nimport jax.numpy as jnp\n\n\n@functools.partial(jax.jit, static_argnums=[0, 1])\ndef calculate_seasonality(\n    number_periods: int,\n    degrees: int,\n    gamma_seasonality: Union[int, float, jnp.ndarray],\n    frequency: int = 52,\n) -> jnp.ndarray:\n  \"\"\"Calculates cyclic variation seasonality using Fourier terms.\n\n  For detailed info check:\n    https://en.wikipedia.org/wiki/Seasonality#Modeling\n\n  Args:\n    number_periods: Number of seasonal periods in the data. Eg. for 1 year of\n      seasonal data it will be 52, for 3 years of the same kind 156.\n    degrees: Number of degrees to use. Must be greater or equal than 1.\n    gamma_seasonality: Factor to multiply to each degree calculation. Shape must\n      be aligned with the number of degrees.\n    frequency: Frequency of the seasonality being computed. By default is 52 for\n      weekly data (52 weeks in a year).\n\n  Returns:\n    An array with the seasonality values.\n  \"\"\""
  },
  {
    "id": "267",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Media transformations for accounting for lagging or media effects.\"\"\"\n\nimport functools\nfrom typing import Union\n\nimport jax\nimport jax.numpy as jnp\n\n\n@functools.partial(jax.jit, static_argnums=[0, 1])\ndef calculate_seasonality(\n    number_periods: int,\n    degrees: int,\n    gamma_seasonality: Union[int, float, jnp.ndarray],\n    frequency: int = 52,\n) -> jnp.ndarray:\n  \"\"\"Calculates cyclic variation seasonality using Fourier terms.\n\n  For detailed info check:\n    https://en.wikipedia.org/wiki/Seasonality#Modeling\n\n  Args:\n    number_periods: Number of seasonal periods in the data. Eg. for 1 year of\n      seasonal data it will be 52, for 3 years of the same kind 156.\n    degrees: Number of degrees to use. Must be greater or equal than 1.\n    gamma_seasonality: Factor to multiply to each degree calculation. Shape must\n      be aligned with the number of degrees.\n    frequency: Frequency of the seasonality being computed. By default is 52 for\n      weekly data (52 weeks in a year).\n\n  Returns:\n    An array with the seasonality values.\n  \"\"\"\n\n  seasonality_range = jnp.expand_dims(a=jnp.arange(number_periods), axis=-1)\n  degrees_range = jnp.arange(1, degrees+1)\n  inner_value = seasonality_range * 2 * jnp.pi * degrees_range / frequency\n  season_matrix_sin = jnp.sin(inner_value)\n  season_matrix_cos = jnp.cos(inner_value)\n  season_matrix = jnp.concatenate([\n      jnp.expand_dims(a=season_matrix_sin, axis=-1),\n      jnp.expand_dims(a=season_matrix_cos, axis=-1)\n  ],\n                                  axis=-1)\n  return (season_matrix * gamma_seasonality).sum(axis=2).sum(axis=1)\n\n\n@jax.jit\ndef adstock(data: jnp.ndarray,\n            lag_weight: float = .9,\n            normalise: bool = True) -> jnp.ndarray:\n  \"\"\"Calculates the adstock value of a given array.\n\n  To learn more about advertising lag:\n  https://en.wikipedia.org/wiki/Advertising_adstock\n\n  Args:\n    data: Input array.\n    lag_weight: lag_weight effect of the adstock function. Default is 0.9.\n    normalise: Whether to normalise the output value. This normalization will\n      divide the output values by (1 / (1 - lag_weight)).\n\n  Returns:\n    The adstock output of the input array.\n  \"\"\""
  },
  {
    "id": "268",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Media transformations for accounting for lagging or media effects.\"\"\"\n\nimport functools\nfrom typing import Union\n\nimport jax\nimport jax.numpy as jnp\n\n\n@functools.partial(jax.jit, static_argnums=[0, 1])\ndef calculate_seasonality(\n    number_periods: int,\n    degrees: int,\n    gamma_seasonality: Union[int, float, jnp.ndarray],\n    frequency: int = 52,\n) -> jnp.ndarray:\n  \"\"\"Calculates cyclic variation seasonality using Fourier terms.\n\n  For detailed info check:\n    https://en.wikipedia.org/wiki/Seasonality#Modeling\n\n  Args:\n    number_periods: Number of seasonal periods in the data. Eg. for 1 year of\n      seasonal data it will be 52, for 3 years of the same kind 156.\n    degrees: Number of degrees to use. Must be greater or equal than 1.\n    gamma_seasonality: Factor to multiply to each degree calculation. Shape must\n      be aligned with the number of degrees.\n    frequency: Frequency of the seasonality being computed. By default is 52 for\n      weekly data (52 weeks in a year).\n\n  Returns:\n    An array with the seasonality values.\n  \"\"\"\n\n  seasonality_range = jnp.expand_dims(a=jnp.arange(number_periods), axis=-1)\n  degrees_range = jnp.arange(1, degrees+1)\n  inner_value = seasonality_range * 2 * jnp.pi * degrees_range / frequency\n  season_matrix_sin = jnp.sin(inner_value)\n  season_matrix_cos = jnp.cos(inner_value)\n  season_matrix = jnp.concatenate([\n      jnp.expand_dims(a=season_matrix_sin, axis=-1),\n      jnp.expand_dims(a=season_matrix_cos, axis=-1)\n  ],\n                                  axis=-1)\n  return (season_matrix * gamma_seasonality).sum(axis=2).sum(axis=1)\n\n\n@jax.jit\ndef adstock(data: jnp.ndarray,\n            lag_weight: float = .9,\n            normalise: bool = True) -> jnp.ndarray:\n  \"\"\"Calculates the adstock value of a given array.\n\n  To learn more about advertising lag:\n  https://en.wikipedia.org/wiki/Advertising_adstock\n\n  Args:\n    data: Input array.\n    lag_weight: lag_weight effect of the adstock function. Default is 0.9.\n    normalise: Whether to normalise the output value. This normalization will\n      divide the output values by (1 / (1 - lag_weight)).\n\n  Returns:\n    The adstock output of the input array.\n  \"\"\"\n\n  def adstock_internal(prev_adstock: jnp.ndarray,\n                       data: jnp.ndarray,\n                       lag_weight: float = lag_weight) -> jnp.ndarray:\n    adstock_value = prev_adstock * lag_weight + data\n    return adstock_value, adstock_value# jax-ndarray\n\n  _, adstock_values = jax.lax.scan(\n      f=adstock_internal, init=data[0, ...], xs=data[1:, ...])\n  adstock_values = jnp.concatenate([jnp.array([data[0, ...]]), adstock_values])\n  return jax.lax.cond(\n      normalise,\n      lambda adstock_values: adstock_values / (1. / (1 - lag_weight)),\n      lambda adstock_values: adstock_values,\n      operand=adstock_values)\n\n\n@jax.jit\ndef hill(data: jnp.ndarray, half_max_effective_concentration: jnp.ndarray,\n         slope: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Calculates the hill function for a given array of values.\n\n  Refer to the following link for detailed information on this equation:\n    https://en.wikipedia.org/wiki/Hill_equation_(biochemistry)\n\n  Args:\n    data: Input data.\n    half_max_effective_concentration: ec50 value for the hill function.\n    slope: Slope of the hill function.\n\n  Returns:\n    The hill values for the respective input data.\n  \"\"\""
  },
  {
    "id": "269",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Media transformations for accounting for lagging or media effects.\"\"\"\n\nimport functools\nfrom typing import Union\n\nimport jax\nimport jax.numpy as jnp\n\n\n@functools.partial(jax.jit, static_argnums=[0, 1])\ndef calculate_seasonality(\n    number_periods: int,\n    degrees: int,\n    gamma_seasonality: Union[int, float, jnp.ndarray],\n    frequency: int = 52,\n) -> jnp.ndarray:\n  \"\"\"Calculates cyclic variation seasonality using Fourier terms.\n\n  For detailed info check:\n    https://en.wikipedia.org/wiki/Seasonality#Modeling\n\n  Args:\n    number_periods: Number of seasonal periods in the data. Eg. for 1 year of\n      seasonal data it will be 52, for 3 years of the same kind 156.\n    degrees: Number of degrees to use. Must be greater or equal than 1.\n    gamma_seasonality: Factor to multiply to each degree calculation. Shape must\n      be aligned with the number of degrees.\n    frequency: Frequency of the seasonality being computed. By default is 52 for\n      weekly data (52 weeks in a year).\n\n  Returns:\n    An array with the seasonality values.\n  \"\"\"\n\n  seasonality_range = jnp.expand_dims(a=jnp.arange(number_periods), axis=-1)\n  degrees_range = jnp.arange(1, degrees+1)\n  inner_value = seasonality_range * 2 * jnp.pi * degrees_range / frequency\n  season_matrix_sin = jnp.sin(inner_value)\n  season_matrix_cos = jnp.cos(inner_value)\n  season_matrix = jnp.concatenate([\n      jnp.expand_dims(a=season_matrix_sin, axis=-1),\n      jnp.expand_dims(a=season_matrix_cos, axis=-1)\n  ],\n                                  axis=-1)\n  return (season_matrix * gamma_seasonality).sum(axis=2).sum(axis=1)\n\n\n@jax.jit\ndef adstock(data: jnp.ndarray,\n            lag_weight: float = .9,\n            normalise: bool = True) -> jnp.ndarray:\n  \"\"\"Calculates the adstock value of a given array.\n\n  To learn more about advertising lag:\n  https://en.wikipedia.org/wiki/Advertising_adstock\n\n  Args:\n    data: Input array.\n    lag_weight: lag_weight effect of the adstock function. Default is 0.9.\n    normalise: Whether to normalise the output value. This normalization will\n      divide the output values by (1 / (1 - lag_weight)).\n\n  Returns:\n    The adstock output of the input array.\n  \"\"\"\n\n  def adstock_internal(prev_adstock: jnp.ndarray,\n                       data: jnp.ndarray,\n                       lag_weight: float = lag_weight) -> jnp.ndarray:\n    adstock_value = prev_adstock * lag_weight + data\n    return adstock_value, adstock_value# jax-ndarray\n\n  _, adstock_values = jax.lax.scan(\n      f=adstock_internal, init=data[0, ...], xs=data[1:, ...])\n  adstock_values = jnp.concatenate([jnp.array([data[0, ...]]), adstock_values])\n  return jax.lax.cond(\n      normalise,\n      lambda adstock_values: adstock_values / (1. / (1 - lag_weight)),\n      lambda adstock_values: adstock_values,\n      operand=adstock_values)\n\n\n@jax.jit\ndef hill(data: jnp.ndarray, half_max_effective_concentration: jnp.ndarray,\n         slope: jnp.ndarray) -> jnp.ndarray:\n  \"\"\"Calculates the hill function for a given array of values.\n\n  Refer to the following link for detailed information on this equation:\n    https://en.wikipedia.org/wiki/Hill_equation_(biochemistry)\n\n  Args:\n    data: Input data.\n    half_max_effective_concentration: ec50 value for the hill function.\n    slope: Slope of the hill function.\n\n  Returns:\n    The hill values for the respective input data.\n  \"\"\"\n  save_transform = apply_exponent_safe(\n      data=data / half_max_effective_concentration, exponent=-slope)\n  return jnp.where(save_transform == 0, x=0, y=1. / (1 + save_transform))\n\n\n@functools.partial(jax.vmap, in_axes=(1, 1, None), out_axes=1)\ndef _carryover_convolve(data: jnp.ndarray,\n                        weights: jnp.ndarray,\n                        number_lags: int) -> jnp.ndarray:\n  \"\"\"Applies the convolution between the data and the weights for the carryover.\n\n  Args:\n    data: Input data.\n    weights: Window weights for the carryover.\n    number_lags: Number of lags the window has.\n\n  Returns:\n    The result values from convolving the data and the weights with padding.\n  \"\"\"\n  window = jnp.concatenate([jnp.zeros(number_lags - 1), weights])\n  return jax.scipy.signal.convolve(data, window, mode=\"same\") / weights.sum()\n\n\n@functools.partial(jax.jit, static_argnames=(\"number_lags\",))\ndef carryover(data: jnp.ndarray,\n              ad_effect_retention_rate: jnp.ndarray,\n              peak_effect_delay: jnp.ndarray,\n              number_lags: int = 13) -> jnp.ndarray:\n  \"\"\"Calculates media carryover.\n\n  More details about this function can be found in:\n  https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46001.pdf\n\n  Args:\n    data: Input data. It is expected that data has either 2 dimensions for\n      national models and 3 for geo models.\n    ad_effect_retention_rate: Retention rate of the advertisement effect.\n      Default is 0.5.\n    peak_effect_delay: Delay of the peak effect in the carryover function.\n      Default is 1.\n    number_lags: Number of lags to include in the carryover calculation. Default\n      is 13.\n\n  Returns:\n    The carryover values for the given data with the given parameters.\n  \"\"\""
  },
  {
    "id": "270",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for lightweight_mmm.\"\"\"\n\nimport copy\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro.distributions as dist\n\nfrom lightweight_mmm import lightweight_mmm\nfrom lightweight_mmm import models\n\n\nclass LightweightMmmTest(parameterized.TestCase):\n\n  @classmethod\n  def setUpClass(cls):"
  },
  {
    "id": "271",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"A simple and lightweight library for Media Mix Modelling.\n\nSimple usage of this class goes as following:\n\n```\nmmm = lightweight_mmm.LightweightMMM()\nmmm.fit(media=media_data,\n        extra_features=extra_features,\n        media_prior=costs,\n        target=target,\n        number_samples=1000,\n        number_chains=2)\n\n# For obtaining media contribution percentage and ROI\npredictions, media_contribution_hat_pct, roi_hat = mmm.get_posterior_metrics()\n\n# For running predictions on unseen data\nmmm.predict(media=media_data_test, extra_features=extra_features_test)\n```\n\"\"\"\n\nimport collections\nimport dataclasses\nimport functools\nimport itertools\nimport logging\nimport numbers\nfrom typing import Any, Callable, Dict, Mapping, MutableMapping, Optional, Sequence, Tuple, Union\n\nfrom absl import logging\nimport immutabledict\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import infer\n\nfrom lightweight_mmm import models\nfrom lightweight_mmm import preprocessing\nfrom lightweight_mmm import utils\n\nPrior = Union[\n    dist.Distribution,\n    Dict[str, float],\n    Sequence[float],\n    float\n]\n\n_NAMES_TO_MODEL_TRANSFORMS = immutabledict.immutabledict({\n    \"hill_adstock\": models.transform_hill_adstock,\n    \"adstock\": models.transform_adstock,\n    \"carryover\": models.transform_carryover\n})\n_MODEL_FUNCTION = models.media_mix_model\n\n\ndef _compare_equality_for_lmmm(item_1: Any, item_2: Any) -> bool:\n  \"\"\"Compares two items for equality.\n\n  Helper function for the __eq__ method of LightweightmMM. First checks if items\n  are strings or lists of strings (it's okay if empty lists compare True), then\n  uses jnp.array_equal if the items are jax.numpy.DeviceArray or other related\n  sequences, and uses items' __eq__ otherwise.\n\n  Note: this implementation does not cover every possible data structure, but\n  it does cover all the data structures seen in attributes used by\n  LightweightMMM. Sometimes the DeviceArray is hidden in the value of a\n  MutableMapping, hence the recursion.\n\n  Args:\n    item_1: First item to be compared.\n    item_2: Second item to be compared.\n\n  Returns:\n    Boolean for whether item_1 equals item_2.\n  \"\"\"\n\n  # This is pretty strict but LMMM classes don't need to compare equal unless\n  # they are exact copies."
  },
  {
    "id": "272",
    "text": "# Copyright 2023 Google LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"A simple and lightweight library for Media Mix Modelling.\n\nSimple usage of this class goes as following:\n\n```\nmmm = lightweight_mmm.LightweightMMM()\nmmm.fit(media=media_data,\n        extra_features=extra_features,\n        media_prior=costs,\n        target=target,\n        number_samples=1000,\n        number_chains=2)\n\n# For obtaining media contribution percentage and ROI\npredictions, media_contribution_hat_pct, roi_hat = mmm.get_posterior_metrics()\n\n# For running predictions on unseen data\nmmm.predict(media=media_data_test, extra_features=extra_features_test)\n```\n\"\"\"\n\nimport collections\nimport dataclasses\nimport functools\nimport itertools\nimport logging\nimport numbers\nfrom typing import Any, Callable, Dict, Mapping, MutableMapping, Optional, Sequence, Tuple, Union\n\nfrom absl import logging\nimport immutabledict\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import infer\n\nfrom lightweight_mmm import models\nfrom lightweight_mmm import preprocessing\nfrom lightweight_mmm import utils\n\nPrior = Union[\n    dist.Distribution,\n    Dict[str, float],\n    Sequence[float],\n    float\n]\n\n_NAMES_TO_MODEL_TRANSFORMS = immutabledict.immutabledict({\n    \"hill_adstock\": models.transform_hill_adstock,\n    \"adstock\": models.transform_adstock,\n    \"carryover\": models.transform_carryover\n})\n_MODEL_FUNCTION = models.media_mix_model\n\n\ndef _compare_equality_for_lmmm(item_1: Any, item_2: Any) -> bool:\n  \"\"\"Compares two items for equality.\n\n  Helper function for the __eq__ method of LightweightmMM. First checks if items\n  are strings or lists of strings (it's okay if empty lists compare True), then\n  uses jnp.array_equal if the items are jax.numpy.DeviceArray or other related\n  sequences, and uses items' __eq__ otherwise.\n\n  Note: this implementation does not cover every possible data structure, but\n  it does cover all the data structures seen in attributes used by\n  LightweightMMM. Sometimes the DeviceArray is hidden in the value of a\n  MutableMapping, hence the recursion.\n\n  Args:\n    item_1: First item to be compared.\n    item_2: Second item to be compared.\n\n  Returns:\n    Boolean for whether item_1 equals item_2.\n  \"\"\"\n\n  # This is pretty strict but LMMM classes don't need to compare equal unless\n  # they are exact copies.\n  if type(item_1) != type(item_2):\n    is_equal = False\n  elif isinstance(item_1, str):\n    is_equal = item_1 == item_2\n  elif isinstance(item_1, (jax.Array, np.ndarray, Sequence)):\n    if all(isinstance(x, str) for x in item_1) and all(\n        isinstance(x, str) for x in item_2):\n      is_equal = item_1 == item_2\n    else:\n      is_equal = np.array_equal(item_1, item_2, equal_nan=True)\n  elif isinstance(item_1, MutableMapping):\n    is_equal = all([\n        _compare_equality_for_lmmm(item_1[x], item_2[x])\n        for x in item_1.keys() | item_2.keys()\n    ])\n  else:\n    is_equal = item_1 == item_2\n\n  return is_equal\n\n\nclass NotFittedModelError(Exception):\n  pass\n\n\n@dataclasses.dataclass(unsafe_hash=True, eq=False)\nclass LightweightMMM:\n  \"\"\"Lightweight Media Mix Modelling wrapper for bayesian models.\n\n  The currently available models are the following:\n   - hill_adstock\n   - adstock\n   - carryover\n\n  It also offers the necessary utilities for calculating media contribution and\n  media ROI based on models' results.\n\n  Attributes:\n    trace: Sampling trace of the bayesian model once fitted.\n    n_media_channels: Number of media channels the model was trained with.\n    n_geos: Number of geos for geo models or 1 for national models.\n    model_name: Name of the model.\n    media: The media data the model is trained on. Usefull for a variety of\n      insights post model fitting.\n    media_names: Names of the media channels passed at fitting time.\n    custom_priors: The set of custom priors the model was trained with. An empty\n      dictionary if none were passed.\n  \"\"\"\n  model_name: str = \"hill_adstock\"\n  n_media_channels: int = dataclasses.field(init=False, repr=False)\n  n_geos: int = dataclasses.field(init=False, repr=False)\n  media: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  media_names: Sequence[str] = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  trace: Dict[str, jnp.DeviceArray] = dataclasses.field(\n      init=False, repr=False, hash=False, compare=False)\n  custom_priors: MutableMapping[str, Prior] = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _degrees_seasonality: int = dataclasses.field(init=False, repr=False)\n  _weekday_seasonality: bool = dataclasses.field(init=False, repr=False)\n  _media_prior: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _extra_features: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _target: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _train_media_size: int = dataclasses.field(\n      init=False, repr=False, hash=True, compare=False)\n  _mcmc: numpyro.infer.MCMC = dataclasses.field(\n      init=False, repr=False, hash=False, compare=False)\n\n  def __post_init__(self):"
  },
  {
    "id": "273",
    "text": ",\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"A simple and lightweight library for Media Mix Modelling.\n\nSimple usage of this class goes as following:\n\n```\nmmm = lightweight_mmm.LightweightMMM()\nmmm.fit(media=media_data,\n        extra_features=extra_features,\n        media_prior=costs,\n        target=target,\n        number_samples=1000,\n        number_chains=2)\n\n# For obtaining media contribution percentage and ROI\npredictions, media_contribution_hat_pct, roi_hat = mmm.get_posterior_metrics()\n\n# For running predictions on unseen data\nmmm.predict(media=media_data_test, extra_features=extra_features_test)\n```\n\"\"\"\n\nimport collections\nimport dataclasses\nimport functools\nimport itertools\nimport logging\nimport numbers\nfrom typing import Any, Callable, Dict, Mapping, MutableMapping, Optional, Sequence, Tuple, Union\n\nfrom absl import logging\nimport immutabledict\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import infer\n\nfrom lightweight_mmm import models\nfrom lightweight_mmm import preprocessing\nfrom lightweight_mmm import utils\n\nPrior = Union[\n    dist.Distribution,\n    Dict[str, float],\n    Sequence[float],\n    float\n]\n\n_NAMES_TO_MODEL_TRANSFORMS = immutabledict.immutabledict({\n    \"hill_adstock\": models.transform_hill_adstock,\n    \"adstock\": models.transform_adstock,\n    \"carryover\": models.transform_carryover\n})\n_MODEL_FUNCTION = models.media_mix_model\n\n\ndef _compare_equality_for_lmmm(item_1: Any, item_2: Any) -> bool:\n  \"\"\"Compares two items for equality.\n\n  Helper function for the __eq__ method of LightweightmMM. First checks if items\n  are strings or lists of strings (it's okay if empty lists compare True), then\n  uses jnp.array_equal if the items are jax.numpy.DeviceArray or other related\n  sequences, and uses items' __eq__ otherwise.\n\n  Note: this implementation does not cover every possible data structure, but\n  it does cover all the data structures seen in attributes used by\n  LightweightMMM. Sometimes the DeviceArray is hidden in the value of a\n  MutableMapping, hence the recursion.\n\n  Args:\n    item_1: First item to be compared.\n    item_2: Second item to be compared.\n\n  Returns:\n    Boolean for whether item_1 equals item_2.\n  \"\"\"\n\n  # This is pretty strict but LMMM classes don't need to compare equal unless\n  # they are exact copies.\n  if type(item_1) != type(item_2):\n    is_equal = False\n  elif isinstance(item_1, str):\n    is_equal = item_1 == item_2\n  elif isinstance(item_1, (jax.Array, np.ndarray, Sequence)):\n    if all(isinstance(x, str) for x in item_1) and all(\n        isinstance(x, str) for x in item_2):\n      is_equal = item_1 == item_2\n    else:\n      is_equal = np.array_equal(item_1, item_2, equal_nan=True)\n  elif isinstance(item_1, MutableMapping):\n    is_equal = all([\n        _compare_equality_for_lmmm(item_1[x], item_2[x])\n        for x in item_1.keys() | item_2.keys()\n    ])\n  else:\n    is_equal = item_1 == item_2\n\n  return is_equal\n\n\nclass NotFittedModelError(Exception):\n  pass\n\n\n@dataclasses.dataclass(unsafe_hash=True, eq=False)\nclass LightweightMMM:\n  \"\"\"Lightweight Media Mix Modelling wrapper for bayesian models.\n\n  The currently available models are the following:\n   - hill_adstock\n   - adstock\n   - carryover\n\n  It also offers the necessary utilities for calculating media contribution and\n  media ROI based on models' results.\n\n  Attributes:\n    trace: Sampling trace of the bayesian model once fitted.\n    n_media_channels: Number of media channels the model was trained with.\n    n_geos: Number of geos for geo models or 1 for national models.\n    model_name: Name of the model.\n    media: The media data the model is trained on. Usefull for a variety of\n      insights post model fitting.\n    media_names: Names of the media channels passed at fitting time.\n    custom_priors: The set of custom priors the model was trained with. An empty\n      dictionary if none were passed.\n  \"\"\"\n  model_name: str = \"hill_adstock\"\n  n_media_channels: int = dataclasses.field(init=False, repr=False)\n  n_geos: int = dataclasses.field(init=False, repr=False)\n  media: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  media_names: Sequence[str] = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  trace: Dict[str, jnp.DeviceArray] = dataclasses.field(\n      init=False, repr=False, hash=False, compare=False)\n  custom_priors: MutableMapping[str, Prior] = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _degrees_seasonality: int = dataclasses.field(init=False, repr=False)\n  _weekday_seasonality: bool = dataclasses.field(init=False, repr=False)\n  _media_prior: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _extra_features: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _target: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _train_media_size: int = dataclasses.field(\n      init=False, repr=False, hash=True, compare=False)\n  _mcmc: numpyro.infer.MCMC = dataclasses.field(\n      init=False, repr=False, hash=False, compare=False)\n\n  def __post_init__(self):\n    if self.model_name not in _NAMES_TO_MODEL_TRANSFORMS:\n      raise ValueError(\"Model name passed not valid. Please use any of the\"\n                       \"following: 'hill_adstock', 'adstock', 'carryover'.\")\n    self._model_function = _MODEL_FUNCTION\n    self._model_transform_function = _NAMES_TO_MODEL_TRANSFORMS[self.model_name]\n    self._prior_names = models.MODEL_PRIORS_NAMES.union(\n        models.TRANSFORM_PRIORS_NAMES[self.model_name])\n\n  def __eq__(self, other: Any) -> bool:\n    \"\"\"Equality method for LightweightMMMM.\n\n    We need a special method here to handle a couple of issues. First, some of\n    the attributes for LightweightMMM are arrays, which contain multiple values\n    and cannot be evaluated with the default __eq__ method. Second, some\n    attributes are initially undefined and only get values after fitting a\n    model. The latter is dealt with within this function, and the former within\n    the helper function _compare_equality_for_lmmm().\n\n    Args:\n      other: Dataclass to compare against.\n\n    Returns:\n      Boolean for whether self == other; NotImplemented if other is not a\n      LightweightMMM.\n    \"\"\""
  },
  {
    "id": "274",
    "text": "\n\nSimple usage of this class goes as following:\n\n```\nmmm = lightweight_mmm.LightweightMMM()\nmmm.fit(media=media_data,\n        extra_features=extra_features,\n        media_prior=costs,\n        target=target,\n        number_samples=1000,\n        number_chains=2)\n\n# For obtaining media contribution percentage and ROI\npredictions, media_contribution_hat_pct, roi_hat = mmm.get_posterior_metrics()\n\n# For running predictions on unseen data\nmmm.predict(media=media_data_test, extra_features=extra_features_test)\n```\n\"\"\"\n\nimport collections\nimport dataclasses\nimport functools\nimport itertools\nimport logging\nimport numbers\nfrom typing import Any, Callable, Dict, Mapping, MutableMapping, Optional, Sequence, Tuple, Union\n\nfrom absl import logging\nimport immutabledict\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro\nfrom numpyro import distributions as dist\nfrom numpyro import infer\n\nfrom lightweight_mmm import models\nfrom lightweight_mmm import preprocessing\nfrom lightweight_mmm import utils\n\nPrior = Union[\n    dist.Distribution,\n    Dict[str, float],\n    Sequence[float],\n    float\n]\n\n_NAMES_TO_MODEL_TRANSFORMS = immutabledict.immutabledict({\n    \"hill_adstock\": models.transform_hill_adstock,\n    \"adstock\": models.transform_adstock,\n    \"carryover\": models.transform_carryover\n})\n_MODEL_FUNCTION = models.media_mix_model\n\n\ndef _compare_equality_for_lmmm(item_1: Any, item_2: Any) -> bool:\n  \"\"\"Compares two items for equality.\n\n  Helper function for the __eq__ method of LightweightmMM. First checks if items\n  are strings or lists of strings (it's okay if empty lists compare True), then\n  uses jnp.array_equal if the items are jax.numpy.DeviceArray or other related\n  sequences, and uses items' __eq__ otherwise.\n\n  Note: this implementation does not cover every possible data structure, but\n  it does cover all the data structures seen in attributes used by\n  LightweightMMM. Sometimes the DeviceArray is hidden in the value of a\n  MutableMapping, hence the recursion.\n\n  Args:\n    item_1: First item to be compared.\n    item_2: Second item to be compared.\n\n  Returns:\n    Boolean for whether item_1 equals item_2.\n  \"\"\"\n\n  # This is pretty strict but LMMM classes don't need to compare equal unless\n  # they are exact copies.\n  if type(item_1) != type(item_2):\n    is_equal = False\n  elif isinstance(item_1, str):\n    is_equal = item_1 == item_2\n  elif isinstance(item_1, (jax.Array, np.ndarray, Sequence)):\n    if all(isinstance(x, str) for x in item_1) and all(\n        isinstance(x, str) for x in item_2):\n      is_equal = item_1 == item_2\n    else:\n      is_equal = np.array_equal(item_1, item_2, equal_nan=True)\n  elif isinstance(item_1, MutableMapping):\n    is_equal = all([\n        _compare_equality_for_lmmm(item_1[x], item_2[x])\n        for x in item_1.keys() | item_2.keys()\n    ])\n  else:\n    is_equal = item_1 == item_2\n\n  return is_equal\n\n\nclass NotFittedModelError(Exception):\n  pass\n\n\n@dataclasses.dataclass(unsafe_hash=True, eq=False)\nclass LightweightMMM:\n  \"\"\"Lightweight Media Mix Modelling wrapper for bayesian models.\n\n  The currently available models are the following:\n   - hill_adstock\n   - adstock\n   - carryover\n\n  It also offers the necessary utilities for calculating media contribution and\n  media ROI based on models' results.\n\n  Attributes:\n    trace: Sampling trace of the bayesian model once fitted.\n    n_media_channels: Number of media channels the model was trained with.\n    n_geos: Number of geos for geo models or 1 for national models.\n    model_name: Name of the model.\n    media: The media data the model is trained on. Usefull for a variety of\n      insights post model fitting.\n    media_names: Names of the media channels passed at fitting time.\n    custom_priors: The set of custom priors the model was trained with. An empty\n      dictionary if none were passed.\n  \"\"\"\n  model_name: str = \"hill_adstock\"\n  n_media_channels: int = dataclasses.field(init=False, repr=False)\n  n_geos: int = dataclasses.field(init=False, repr=False)\n  media: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  media_names: Sequence[str] = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  trace: Dict[str, jnp.DeviceArray] = dataclasses.field(\n      init=False, repr=False, hash=False, compare=False)\n  custom_priors: MutableMapping[str, Prior] = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _degrees_seasonality: int = dataclasses.field(init=False, repr=False)\n  _weekday_seasonality: bool = dataclasses.field(init=False, repr=False)\n  _media_prior: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _extra_features: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _target: jnp.DeviceArray = dataclasses.field(\n      init=False, repr=False, hash=False, compare=True)\n  _train_media_size: int = dataclasses.field(\n      init=False, repr=False, hash=True, compare=False)\n  _mcmc: numpyro.infer.MCMC = dataclasses.field(\n      init=False, repr=False, hash=False, compare=False)\n\n  def __post_init__(self):\n    if self.model_name not in _NAMES_TO_MODEL_TRANSFORMS:\n      raise ValueError(\"Model name passed not valid. Please use any of the\"\n                       \"following: 'hill_adstock', 'adstock', 'carryover'.\")\n    self._model_function = _MODEL_FUNCTION\n    self._model_transform_function = _NAMES_TO_MODEL_TRANSFORMS[self.model_name]\n    self._prior_names = models.MODEL_PRIORS_NAMES.union(\n        models.TRANSFORM_PRIORS_NAMES[self.model_name])\n\n  def __eq__(self, other: Any) -> bool:\n    \"\"\"Equality method for LightweightMMMM.\n\n    We need a special method here to handle a couple of issues. First, some of\n    the attributes for LightweightMMM are arrays, which contain multiple values\n    and cannot be evaluated with the default __eq__ method. Second, some\n    attributes are initially undefined and only get values after fitting a\n    model. The latter is dealt with within this function, and the former within\n    the helper function _compare_equality_for_lmmm().\n\n    Args:\n      other: Dataclass to compare against.\n\n    Returns:\n      Boolean for whether self == other; NotImplemented if other is not a\n      LightweightMMM.\n    \"\"\"\n    if not isinstance(other, LightweightMMM):\n      return NotImplemented\n\n    def _create_list_of_attributes_to_compare(\n        mmm_instance: Any) -> Sequence[str]:"
  },
  {
    "id": "275",
    "text": ".\n\n    For detailed information on the selected model please refer to its\n    respective function in the models.py file.\n\n    Args:\n      media: Media input data. Media data must have either 2 dims for national\n        model or 3 for geo models.\n      media_prior: Costs of each media channel. The number of cost values must\n        be equal to the number of media channels.\n      target: Target KPI to use, like for example sales.\n      extra_features: Other variables to add to the model.\n      degrees_seasonality: Number of degrees to use for seasonality. Default is\n        2.\n      seasonality_frequency: Frequency of the time period used. Default is 52 as\n        in 52 weeks per year.\n      weekday_seasonality: In case of daily data, also estimate seven weekday\n        parameters.\n      media_names: Names of the media channels passed.\n      number_warmup: Number of warm up samples. Default is 1000.\n      number_samples: Number of samples during sampling. Default is 1000.\n      number_chains: Number of chains to sample. Default is 2.\n      target_accept_prob: Target acceptance probability for step size in the\n        NUTS sampler. Default is .85.\n      init_strategy: Initialization function for numpyro NUTS. The available\n        options can be found in\n        https://num.pyro.ai/en/stable/utilities.html#initialization-strategies.\n        Default is numpyro.infer.init_to_median.\n      custom_priors: The custom priors we want the model to take instead of the\n        default ones. Refer to the full documentation on custom priors for\n        details.\n      seed: Seed to use for PRNGKey during training. For better replicability\n        run all different trainings with the same seed.\n    \"\"\"\n    if media.ndim not in (2, 3):\n      raise ValueError(\n          \"Media data must have either 2 dims for national model or 3 for geo \"\n          \"models.\")\n    if media.ndim == 3 and media_prior.ndim == 1:\n      media_prior = jnp.expand_dims(media_prior, axis=-1)\n\n    if media.shape[1] != len(media_prior):\n      raise ValueError(\"The number of data channels provided must match the \"\n                       \"number of cost values.\")\n    if media.min() < 0:\n      raise ValueError(\"Media values must be greater or equal to zero.\")\n\n    if custom_priors:\n      not_used_custom_priors = set(custom_priors.keys()).difference(\n          self._prior_names)\n      if not_used_custom_priors:\n        raise ValueError(\n            \"The following passed custom priors dont have a match in the model.\"\n            \" Please double check the names have been written correctly: %s\" %\n            not_used_custom_priors)\n      custom_priors = self._preprocess_custom_priors(\n          custom_priors=custom_priors)\n      geo_custom_priors = set(custom_priors.keys()).intersection(\n          models.GEO_ONLY_PRIORS)\n      if media.ndim == 2 and geo_custom_priors:\n        raise ValueError(\n            \"The given data is for national models but custom_prior contains \"\n            \"priors for the geo version of the model. Please either remove geo \"\n            \"priors for national model or pass media data with geo dimension.\")\n    else:\n      custom_priors = {}\n\n    if weekday_seasonality and seasonality_frequency == 52:\n      logging.warn(\"You have chosen daily seasonality and frequency 52 \"\n                   \"(weekly), please check you made the right seasonality \"\n                   \"choices.\")\n\n    if extra_features is not None:\n      extra_features = jnp.array(extra_features)\n\n    if seed is None:\n      seed = utils.get_time_seed()\n\n    train_media_size = media.shape[0]\n    kernel = numpyro.infer.NUTS(\n        model=self._model_function,\n        target_accept_prob=target_accept_prob,\n        init_strategy=init_strategy)\n\n    mcmc = numpyro.infer.MCMC(\n        sampler=kernel,\n        num_warmup=number_warmup,\n        num_samples=number_samples,\n        num_chains=number_chains)\n    mcmc.run(\n        rng_key=jax.random.PRNGKey(seed),\n        media_data=jnp.array(media),\n        extra_features=extra_features,\n        target_data=jnp.array(target),\n        media_prior=jnp.array(media_prior),\n        degrees_seasonality=degrees_seasonality,\n        frequency=seasonality_frequency,\n        transform_function=self._model_transform_function,\n        weekday_seasonality=weekday_seasonality,\n        custom_priors=custom_priors)\n\n    self.custom_priors = custom_priors\n    if media_names is not None:\n      self.media_names = media_names\n    else:\n      self.media_names = [f\"channel_{i}\" for i in range(media.shape[1])]\n    self.n_media_channels = media.shape[1]\n    self.n_geos = media.shape[2] if media.ndim == 3 else 1\n    self._media_prior = media_prior\n    self.trace = mcmc.get_samples()\n    self._number_warmup = number_warmup\n    self._number_samples = number_samples\n    self._number_chains = number_chains\n    self._target = target\n    self._train_media_size = train_media_size\n    self._degrees_seasonality = degrees_seasonality\n    self._seasonality_frequency = seasonality_frequency\n    self._weekday_seasonality = weekday_seasonality\n    self.media = media\n    self._extra_features = extra_features# jax-devicearray\n    self._mcmc = mcmc\n    logging.info(\"Model has been fitted\")\n\n  def print_summary(self) -> None:\n    \"\"\"Calls print_summary function from numpyro to print parameters summary.\n    \"\"\"\n    # TODO(): add name selection for print.\n    self._mcmc.print_summary()\n\n  @functools.partial(\n      jax.jit,\n      static_argnums=(0,),\n      static_argnames=(\"degrees_seasonality\", \"weekday_seasonality\",\n                       \"transform_function\", \"model\"))\n  def _predict(\n      self,\n      rng_key: jnp.ndarray,\n      media_data: jnp.ndarray,\n      extra_features: Optional[jnp.ndarray],\n      media_prior: jnp.ndarray,\n      degrees_seasonality: int, frequency: int,\n      transform_function: Callable[[Any], jnp.ndarray],\n      weekday_seasonality: bool,\n      model: Callable[[Any], None],\n      posterior_samples: Dict[str, jnp.ndarray],\n      custom_priors: Dict[str, Prior]\n      ) -> Dict[str, jnp.ndarray]:\n    \"\"\"Encapsulates the numpyro.infer.Predictive function for predict method.\n\n    It serves as a helper jitted function for running predictions.\n\n    Args:\n      rng_key: A jax.random.PRNGKey.\n      media_data: Media array for needed for the model to run predictions.\n      extra_features: Extra features for needed for the model to run.\n      media_prior: Cost prior used for training the model.\n      degrees_seasonality: Number of degrees for the seasonality.\n      frequency: Frequency of the seasonality.\n      transform_function: Media transform function to use within the model.\n      weekday_seasonality: Allow daily weekday estimation.\n      model: Numpyro model to use for numpyro.infer.Predictive.\n      posterior_samples: Mapping of the posterior samples.\n      custom_priors: The custom priors we want the model to take instead of the\n        default ones. Refer to the full documentation on custom priors for\n        details.\n\n    Returns:\n      The predictions for the given data.\n    \"\"\""
  },
  {
    "id": "276",
    "text": "priors)\n\n    self.custom_priors = custom_priors\n    if media_names is not None:\n      self.media_names = media_names\n    else:\n      self.media_names = [f\"channel_{i}\" for i in range(media.shape[1])]\n    self.n_media_channels = media.shape[1]\n    self.n_geos = media.shape[2] if media.ndim == 3 else 1\n    self._media_prior = media_prior\n    self.trace = mcmc.get_samples()\n    self._number_warmup = number_warmup\n    self._number_samples = number_samples\n    self._number_chains = number_chains\n    self._target = target\n    self._train_media_size = train_media_size\n    self._degrees_seasonality = degrees_seasonality\n    self._seasonality_frequency = seasonality_frequency\n    self._weekday_seasonality = weekday_seasonality\n    self.media = media\n    self._extra_features = extra_features# jax-devicearray\n    self._mcmc = mcmc\n    logging.info(\"Model has been fitted\")\n\n  def print_summary(self) -> None:\n    \"\"\"Calls print_summary function from numpyro to print parameters summary.\n    \"\"\"\n    # TODO(): add name selection for print.\n    self._mcmc.print_summary()\n\n  @functools.partial(\n      jax.jit,\n      static_argnums=(0,),\n      static_argnames=(\"degrees_seasonality\", \"weekday_seasonality\",\n                       \"transform_function\", \"model\"))\n  def _predict(\n      self,\n      rng_key: jnp.ndarray,\n      media_data: jnp.ndarray,\n      extra_features: Optional[jnp.ndarray],\n      media_prior: jnp.ndarray,\n      degrees_seasonality: int, frequency: int,\n      transform_function: Callable[[Any], jnp.ndarray],\n      weekday_seasonality: bool,\n      model: Callable[[Any], None],\n      posterior_samples: Dict[str, jnp.ndarray],\n      custom_priors: Dict[str, Prior]\n      ) -> Dict[str, jnp.ndarray]:\n    \"\"\"Encapsulates the numpyro.infer.Predictive function for predict method.\n\n    It serves as a helper jitted function for running predictions.\n\n    Args:\n      rng_key: A jax.random.PRNGKey.\n      media_data: Media array for needed for the model to run predictions.\n      extra_features: Extra features for needed for the model to run.\n      media_prior: Cost prior used for training the model.\n      degrees_seasonality: Number of degrees for the seasonality.\n      frequency: Frequency of the seasonality.\n      transform_function: Media transform function to use within the model.\n      weekday_seasonality: Allow daily weekday estimation.\n      model: Numpyro model to use for numpyro.infer.Predictive.\n      posterior_samples: Mapping of the posterior samples.\n      custom_priors: The custom priors we want the model to take instead of the\n        default ones. Refer to the full documentation on custom priors for\n        details.\n\n    Returns:\n      The predictions for the given data.\n    \"\"\"\n    return infer.Predictive(\n        model=model, posterior_samples=posterior_samples)(\n            rng_key=rng_key,\n            media_data=media_data,\n            extra_features=extra_features,\n            media_prior=media_prior,\n            target_data=None,\n            degrees_seasonality=degrees_seasonality,\n            frequency=frequency,\n            transform_function=transform_function,\n            custom_priors=custom_priors,\n            weekday_seasonality=weekday_seasonality)\n\n  def predict(\n      self,\n      media: jnp.ndarray,\n      extra_features: Optional[jnp.ndarray] = None,\n      media_gap: Optional[jnp.ndarray] = None,\n      target_scaler: Optional[preprocessing.CustomScaler] = None,\n      seed: Optional[int] = None\n  ) -> jnp.ndarray:\n    \"\"\"Runs the model to obtain predictions for the given input data.\n\n    Predictions returned are distributions, if point estimates are desired one\n    can calculate those based on the given distribution.\n\n    Args:\n      media: Media array for needed for the model to run predictions.\n      extra_features: Extra features for needed for the model to run.\n      media_gap: Media data gap between the end of training data and the start\n        of the out of sample media given. Eg. if 100 weeks of data were used for\n        training and prediction starts 2 months after training data finished we\n        need to provide the 8 weeks missing between the training data and the\n        prediction data so data transformations (adstock, carryover, ...) can\n        take place correctly.\n      target_scaler: Scaler that was used to scale the target before training.\n      seed: Seed to use for PRNGKey during sampling. For replicability run\n        this function and any other function that utilises predictions with the\n        same seed.\n\n    Returns:\n      Predictions for the given media and extra features at a given date index.\n\n    Raises:\n      NotFittedModelError: When the model has not been fitted before running\n        predict.\n    \"\"\"\n    if not hasattr(self, \"trace\"):\n      raise NotFittedModelError(\"Need to fit the model before running \"\n                                \"predictions.\")\n    if media_gap is not None:\n      if media.ndim != media_gap.ndim:\n        raise ValueError(\"Original media data and media gap must have the same \"\n                         \"number of dimensions.\")\n      if media.ndim > 1 and media.shape[1] != media_gap.shape[1]:\n        raise ValueError(\"Media gap must have the same numer of media channels\"\n                         \"as the original media data.\")\n      previous_media = jnp.concatenate(arrays=[self.media, media_gap], axis=0)\n      if extra_features is not None:\n        previous_extra_features = jnp.concatenate(\n            arrays=[\n                self._extra_features,\n                jnp.zeros((media_gap.shape[0], *self._extra_features.shape[1:]))\n            ],\n            axis=0)\n    else:\n      previous_media = self.media\n      previous_extra_features = self._extra_features\n\n    full_media = jnp.concatenate(arrays=[previous_media, media], axis=0)\n    if extra_features is not None:\n      full_extra_features = jnp.concatenate(\n          arrays=[previous_extra_features, extra_features], axis=0)\n    else:\n      full_extra_features = None\n    if seed is None:\n      seed = utils.get_time_seed()\n    prediction = self._predict(\n        rng_key=jax.random.PRNGKey(seed=seed),\n        media_data=full_media,\n        extra_features=full_extra_features,\n        media_prior=jnp.array(self._media_prior),\n        degrees_seasonality=self._degrees_seasonality,\n        frequency=self._seasonality_frequency,\n        weekday_seasonality=self._weekday_seasonality,\n        transform_function=self._model_transform_function,\n        model=self._model_function,\n        custom_priors=self.custom_priors,\n        posterior_samples=self.trace)[\"mu\"][:, previous_media.shape[0]:]\n    if target_scaler:\n      prediction = target_scaler.inverse_transform(prediction)\n\n    return prediction\n\n  def reduce_trace(self, nsample: int = 100, seed: int = 0) -> None:\n    \"\"\"Reduces the samples in `trace` to speed up `predict` and optimize.\n\n    Please note this step is not reversible. Only do this after you have\n    investigated convergence of the model.\n\n    Args:\n      nsample: Target number of samples.\n      seed: Random seed for down sampling.\n\n    Raises:\n      ValueError: if `nsample` is too big.\n    \"\"\""
  },
  {
    "id": "277",
    "text": "import abc\nfrom typing import Union\n\nimport numpy as np\nimport torch\nimport tqdm\n\n\nclass IdentitySampler:\n    def run(\n        self, features: Union[torch.Tensor, np.ndarray]\n    ) -> Union[torch.Tensor, np.ndarray]:\n        return features\n\n\nclass BaseSampler(abc.ABC):\n    def __init__(self, percentage: float):"
  },
  {
    "id": "278",
    "text": "import abc\nfrom typing import Union\n\nimport numpy as np\nimport torch\nimport tqdm\n\n\nclass IdentitySampler:\n    def run(\n        self, features: Union[torch.Tensor, np.ndarray]\n    ) -> Union[torch.Tensor, np.ndarray]:\n        return features\n\n\nclass BaseSampler(abc.ABC):\n    def __init__(self, percentage: float):\n        if not 0 < percentage < 1:\n            raise ValueError(\"Percentage value not in (0, 1).\")\n        self.percentage = percentage\n\n    @abc.abstractmethod\n    def run(\n        self, features: Union[torch.Tensor, np.ndarray]\n    ) -> Union[torch.Tensor, np.ndarray]:\n        pass\n\n    def _store_type(self, features: Union[torch.Tensor, np.ndarray]) -> None:\n        self.features_is_numpy = isinstance(features, np.ndarray)\n        if not self.features_is_numpy:\n            self.features_device = features.device\n\n    def _restore_type(self, features: torch.Tensor) -> Union[torch.Tensor, np.ndarray]:\n        if self.features_is_numpy:\n            return features.cpu().numpy()\n        return features.to(self.features_device)\n\n\nclass GreedyCoresetSampler(BaseSampler):\n    def __init__(\n        self,\n        percentage: float,\n        device: torch.device,\n        dimension_to_project_features_to=128,\n    ):\n        \"\"\"Greedy Coreset sampling base class.\"\"\""
  },
  {
    "id": "279",
    "text": "\"\"\"PatchCore and PatchCore detection methods.\"\"\"\nimport logging\nimport os\nimport pickle\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nimport tqdm\n\nimport patchcore\nimport patchcore.backbones\nimport patchcore.common\nimport patchcore.sampler\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass PatchCore(torch.nn.Module):\n    def __init__(self, device):\n        \"\"\"PatchCore anomaly detection class.\"\"\"\n        super(PatchCore, self).__init__()\n        self.device = device\n\n    def load(\n        self,\n        backbone,\n        layers_to_extract_from,\n        device,\n        input_shape,\n        pretrain_embed_dimension,\n        target_embed_dimension,\n        patchsize=3,\n        patchstride=1,\n        anomaly_score_num_nn=1,\n        featuresampler=patchcore.sampler.IdentitySampler(),\n        nn_method=patchcore.common.FaissNN(False, 4),\n        **kwargs,\n    ):\n        self.backbone = backbone.to(device)\n        self.layers_to_extract_from = layers_to_extract_from\n        self.input_shape = input_shape\n\n        self.device = device\n        self.patch_maker = PatchMaker(patchsize, stride=patchstride)\n\n        self.forward_modules = torch.nn.ModuleDict({})\n\n        feature_aggregator = patchcore.common.NetworkFeatureAggregator(\n            self.backbone, self.layers_to_extract_from, self.device\n        )\n        feature_dimensions = feature_aggregator.feature_dimensions(input_shape)\n        self.forward_modules[\"feature_aggregator\"] = feature_aggregator\n\n        preprocessing = patchcore.common.Preprocessing(\n            feature_dimensions, pretrain_embed_dimension\n        )\n        self.forward_modules[\"preprocessing\"] = preprocessing\n\n        self.target_embed_dimension = target_embed_dimension\n        preadapt_aggregator = patchcore.common.Aggregator(\n            target_dim=target_embed_dimension\n        )\n\n        _ = preadapt_aggregator.to(self.device)\n\n        self.forward_modules[\"preadapt_aggregator\"] = preadapt_aggregator\n\n        self.anomaly_scorer = patchcore.common.NearestNeighbourScorer(\n            n_nearest_neighbours=anomaly_score_num_nn, nn_method=nn_method\n        )\n\n        self.anomaly_segmentor = patchcore.common.RescaleSegmentor(\n            device=self.device, target_size=input_shape[-2:]\n        )\n\n        self.featuresampler = featuresampler\n\n    def embed(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            features = []\n            for image in data:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                with torch.no_grad():\n                    input_image = image.to(torch.float).to(self.device)\n                    features.append(self._embed(input_image))\n            return features\n        return self._embed(data)\n\n    def _embed(self, images, detach=True, provide_patch_shapes=False):\n        \"\"\"Returns feature embeddings for images.\"\"\"\n\n        def _detach(features):"
  },
  {
    "id": "280",
    "text": "\"\"\"PatchCore and PatchCore detection methods.\"\"\"\nimport logging\nimport os\nimport pickle\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nimport tqdm\n\nimport patchcore\nimport patchcore.backbones\nimport patchcore.common\nimport patchcore.sampler\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass PatchCore(torch.nn.Module):\n    def __init__(self, device):\n        \"\"\"PatchCore anomaly detection class.\"\"\"\n        super(PatchCore, self).__init__()\n        self.device = device\n\n    def load(\n        self,\n        backbone,\n        layers_to_extract_from,\n        device,\n        input_shape,\n        pretrain_embed_dimension,\n        target_embed_dimension,\n        patchsize=3,\n        patchstride=1,\n        anomaly_score_num_nn=1,\n        featuresampler=patchcore.sampler.IdentitySampler(),\n        nn_method=patchcore.common.FaissNN(False, 4),\n        **kwargs,\n    ):\n        self.backbone = backbone.to(device)\n        self.layers_to_extract_from = layers_to_extract_from\n        self.input_shape = input_shape\n\n        self.device = device\n        self.patch_maker = PatchMaker(patchsize, stride=patchstride)\n\n        self.forward_modules = torch.nn.ModuleDict({})\n\n        feature_aggregator = patchcore.common.NetworkFeatureAggregator(\n            self.backbone, self.layers_to_extract_from, self.device\n        )\n        feature_dimensions = feature_aggregator.feature_dimensions(input_shape)\n        self.forward_modules[\"feature_aggregator\"] = feature_aggregator\n\n        preprocessing = patchcore.common.Preprocessing(\n            feature_dimensions, pretrain_embed_dimension\n        )\n        self.forward_modules[\"preprocessing\"] = preprocessing\n\n        self.target_embed_dimension = target_embed_dimension\n        preadapt_aggregator = patchcore.common.Aggregator(\n            target_dim=target_embed_dimension\n        )\n\n        _ = preadapt_aggregator.to(self.device)\n\n        self.forward_modules[\"preadapt_aggregator\"] = preadapt_aggregator\n\n        self.anomaly_scorer = patchcore.common.NearestNeighbourScorer(\n            n_nearest_neighbours=anomaly_score_num_nn, nn_method=nn_method\n        )\n\n        self.anomaly_segmentor = patchcore.common.RescaleSegmentor(\n            device=self.device, target_size=input_shape[-2:]\n        )\n\n        self.featuresampler = featuresampler\n\n    def embed(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            features = []\n            for image in data:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                with torch.no_grad():\n                    input_image = image.to(torch.float).to(self.device)\n                    features.append(self._embed(input_image))\n            return features\n        return self._embed(data)\n\n    def _embed(self, images, detach=True, provide_patch_shapes=False):\n        \"\"\"Returns feature embeddings for images.\"\"\"\n\n        def _detach(features):\n            if detach:\n                return [x.detach().cpu().numpy() for x in features]\n            return features\n\n        _ = self.forward_modules[\"feature_aggregator\"].eval()\n        with torch.no_grad():\n            features = self.forward_modules[\"feature_aggregator\"](images)\n\n        features = [features[layer] for layer in self.layers_to_extract_from]\n\n        features = [\n            self.patch_maker.patchify(x, return_spatial_info=True) for x in features\n        ]\n        patch_shapes = [x[1] for x in features]\n        features = [x[0] for x in features]\n        ref_num_patches = patch_shapes[0]\n\n        for i in range(1, len(features)):\n            _features = features[i]\n            patch_dims = patch_shapes[i]\n\n            # TODO(pgehler): Add comments\n            _features = _features.reshape(\n                _features.shape[0], patch_dims[0], patch_dims[1], *_features.shape[2:]\n            )\n            _features = _features.permute(0, -3, -2, -1, 1, 2)\n            perm_base_shape = _features.shape\n            _features = _features.reshape(-1, *_features.shape[-2:])\n            _features = F.interpolate(\n                _features.unsqueeze(1),\n                size=(ref_num_patches[0], ref_num_patches[1]),\n                mode=\"bilinear\",\n                align_corners=False,\n            )\n            _features = _features.squeeze(1)\n            _features = _features.reshape(\n                *perm_base_shape[:-2], ref_num_patches[0], ref_num_patches[1]\n            )\n            _features = _features.permute(0, -2, -1, 1, 2, 3)\n            _features = _features.reshape(len(_features), -1, *_features.shape[-3:])\n            features[i] = _features\n        features = [x.reshape(-1, *x.shape[-3:]) for x in features]\n\n        # As different feature backbones & patching provide differently\n        # sized features, these are brought into the correct form here.\n        features = self.forward_modules[\"preprocessing\"](features)\n        features = self.forward_modules[\"preadapt_aggregator\"](features)\n\n        if provide_patch_shapes:\n            return _detach(features), patch_shapes\n        return _detach(features)\n\n    def fit(self, training_data):\n        \"\"\"PatchCore training.\n\n        This function computes the embeddings of the training data and fills the\n        memory bank of SPADE.\n        \"\"\"\n        self._fill_memory_bank(training_data)\n\n    def _fill_memory_bank(self, input_data):\n        \"\"\"Computes and sets the support features for SPADE.\"\"\""
  },
  {
    "id": "281",
    "text": "\"\"\"PatchCore and PatchCore detection methods.\"\"\"\nimport logging\nimport os\nimport pickle\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nimport tqdm\n\nimport patchcore\nimport patchcore.backbones\nimport patchcore.common\nimport patchcore.sampler\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass PatchCore(torch.nn.Module):\n    def __init__(self, device):\n        \"\"\"PatchCore anomaly detection class.\"\"\"\n        super(PatchCore, self).__init__()\n        self.device = device\n\n    def load(\n        self,\n        backbone,\n        layers_to_extract_from,\n        device,\n        input_shape,\n        pretrain_embed_dimension,\n        target_embed_dimension,\n        patchsize=3,\n        patchstride=1,\n        anomaly_score_num_nn=1,\n        featuresampler=patchcore.sampler.IdentitySampler(),\n        nn_method=patchcore.common.FaissNN(False, 4),\n        **kwargs,\n    ):\n        self.backbone = backbone.to(device)\n        self.layers_to_extract_from = layers_to_extract_from\n        self.input_shape = input_shape\n\n        self.device = device\n        self.patch_maker = PatchMaker(patchsize, stride=patchstride)\n\n        self.forward_modules = torch.nn.ModuleDict({})\n\n        feature_aggregator = patchcore.common.NetworkFeatureAggregator(\n            self.backbone, self.layers_to_extract_from, self.device\n        )\n        feature_dimensions = feature_aggregator.feature_dimensions(input_shape)\n        self.forward_modules[\"feature_aggregator\"] = feature_aggregator\n\n        preprocessing = patchcore.common.Preprocessing(\n            feature_dimensions, pretrain_embed_dimension\n        )\n        self.forward_modules[\"preprocessing\"] = preprocessing\n\n        self.target_embed_dimension = target_embed_dimension\n        preadapt_aggregator = patchcore.common.Aggregator(\n            target_dim=target_embed_dimension\n        )\n\n        _ = preadapt_aggregator.to(self.device)\n\n        self.forward_modules[\"preadapt_aggregator\"] = preadapt_aggregator\n\n        self.anomaly_scorer = patchcore.common.NearestNeighbourScorer(\n            n_nearest_neighbours=anomaly_score_num_nn, nn_method=nn_method\n        )\n\n        self.anomaly_segmentor = patchcore.common.RescaleSegmentor(\n            device=self.device, target_size=input_shape[-2:]\n        )\n\n        self.featuresampler = featuresampler\n\n    def embed(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            features = []\n            for image in data:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                with torch.no_grad():\n                    input_image = image.to(torch.float).to(self.device)\n                    features.append(self._embed(input_image))\n            return features\n        return self._embed(data)\n\n    def _embed(self, images, detach=True, provide_patch_shapes=False):\n        \"\"\"Returns feature embeddings for images.\"\"\"\n\n        def _detach(features):\n            if detach:\n                return [x.detach().cpu().numpy() for x in features]\n            return features\n\n        _ = self.forward_modules[\"feature_aggregator\"].eval()\n        with torch.no_grad():\n            features = self.forward_modules[\"feature_aggregator\"](images)\n\n        features = [features[layer] for layer in self.layers_to_extract_from]\n\n        features = [\n            self.patch_maker.patchify(x, return_spatial_info=True) for x in features\n        ]\n        patch_shapes = [x[1] for x in features]\n        features = [x[0] for x in features]\n        ref_num_patches = patch_shapes[0]\n\n        for i in range(1, len(features)):\n            _features = features[i]\n            patch_dims = patch_shapes[i]\n\n            # TODO(pgehler): Add comments\n            _features = _features.reshape(\n                _features.shape[0], patch_dims[0], patch_dims[1], *_features.shape[2:]\n            )\n            _features = _features.permute(0, -3, -2, -1, 1, 2)\n            perm_base_shape = _features.shape\n            _features = _features.reshape(-1, *_features.shape[-2:])\n            _features = F.interpolate(\n                _features.unsqueeze(1),\n                size=(ref_num_patches[0], ref_num_patches[1]),\n                mode=\"bilinear\",\n                align_corners=False,\n            )\n            _features = _features.squeeze(1)\n            _features = _features.reshape(\n                *perm_base_shape[:-2], ref_num_patches[0], ref_num_patches[1]\n            )\n            _features = _features.permute(0, -2, -1, 1, 2, 3)\n            _features = _features.reshape(len(_features), -1, *_features.shape[-3:])\n            features[i] = _features\n        features = [x.reshape(-1, *x.shape[-3:]) for x in features]\n\n        # As different feature backbones & patching provide differently\n        # sized features, these are brought into the correct form here.\n        features = self.forward_modules[\"preprocessing\"](features)\n        features = self.forward_modules[\"preadapt_aggregator\"](features)\n\n        if provide_patch_shapes:\n            return _detach(features), patch_shapes\n        return _detach(features)\n\n    def fit(self, training_data):\n        \"\"\"PatchCore training.\n\n        This function computes the embeddings of the training data and fills the\n        memory bank of SPADE.\n        \"\"\"\n        self._fill_memory_bank(training_data)\n\n    def _fill_memory_bank(self, input_data):\n        \"\"\"Computes and sets the support features for SPADE.\"\"\"\n        _ = self.forward_modules.eval()\n\n        def _image_to_features(input_image):"
  },
  {
    "id": "282",
    "text": "\"\"\"PatchCore and PatchCore detection methods.\"\"\"\nimport logging\nimport os\nimport pickle\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nimport tqdm\n\nimport patchcore\nimport patchcore.backbones\nimport patchcore.common\nimport patchcore.sampler\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass PatchCore(torch.nn.Module):\n    def __init__(self, device):\n        \"\"\"PatchCore anomaly detection class.\"\"\"\n        super(PatchCore, self).__init__()\n        self.device = device\n\n    def load(\n        self,\n        backbone,\n        layers_to_extract_from,\n        device,\n        input_shape,\n        pretrain_embed_dimension,\n        target_embed_dimension,\n        patchsize=3,\n        patchstride=1,\n        anomaly_score_num_nn=1,\n        featuresampler=patchcore.sampler.IdentitySampler(),\n        nn_method=patchcore.common.FaissNN(False, 4),\n        **kwargs,\n    ):\n        self.backbone = backbone.to(device)\n        self.layers_to_extract_from = layers_to_extract_from\n        self.input_shape = input_shape\n\n        self.device = device\n        self.patch_maker = PatchMaker(patchsize, stride=patchstride)\n\n        self.forward_modules = torch.nn.ModuleDict({})\n\n        feature_aggregator = patchcore.common.NetworkFeatureAggregator(\n            self.backbone, self.layers_to_extract_from, self.device\n        )\n        feature_dimensions = feature_aggregator.feature_dimensions(input_shape)\n        self.forward_modules[\"feature_aggregator\"] = feature_aggregator\n\n        preprocessing = patchcore.common.Preprocessing(\n            feature_dimensions, pretrain_embed_dimension\n        )\n        self.forward_modules[\"preprocessing\"] = preprocessing\n\n        self.target_embed_dimension = target_embed_dimension\n        preadapt_aggregator = patchcore.common.Aggregator(\n            target_dim=target_embed_dimension\n        )\n\n        _ = preadapt_aggregator.to(self.device)\n\n        self.forward_modules[\"preadapt_aggregator\"] = preadapt_aggregator\n\n        self.anomaly_scorer = patchcore.common.NearestNeighbourScorer(\n            n_nearest_neighbours=anomaly_score_num_nn, nn_method=nn_method\n        )\n\n        self.anomaly_segmentor = patchcore.common.RescaleSegmentor(\n            device=self.device, target_size=input_shape[-2:]\n        )\n\n        self.featuresampler = featuresampler\n\n    def embed(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            features = []\n            for image in data:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                with torch.no_grad():\n                    input_image = image.to(torch.float).to(self.device)\n                    features.append(self._embed(input_image))\n            return features\n        return self._embed(data)\n\n    def _embed(self, images, detach=True, provide_patch_shapes=False):\n        \"\"\"Returns feature embeddings for images.\"\"\"\n\n        def _detach(features):\n            if detach:\n                return [x.detach().cpu().numpy() for x in features]\n            return features\n\n        _ = self.forward_modules[\"feature_aggregator\"].eval()\n        with torch.no_grad():\n            features = self.forward_modules[\"feature_aggregator\"](images)\n\n        features = [features[layer] for layer in self.layers_to_extract_from]\n\n        features = [\n            self.patch_maker.patchify(x, return_spatial_info=True) for x in features\n        ]\n        patch_shapes = [x[1] for x in features]\n        features = [x[0] for x in features]\n        ref_num_patches = patch_shapes[0]\n\n        for i in range(1, len(features)):\n            _features = features[i]\n            patch_dims = patch_shapes[i]\n\n            # TODO(pgehler): Add comments\n            _features = _features.reshape(\n                _features.shape[0], patch_dims[0], patch_dims[1], *_features.shape[2:]\n            )\n            _features = _features.permute(0, -3, -2, -1, 1, 2)\n            perm_base_shape = _features.shape\n            _features = _features.reshape(-1, *_features.shape[-2:])\n            _features = F.interpolate(\n                _features.unsqueeze(1),\n                size=(ref_num_patches[0], ref_num_patches[1]),\n                mode=\"bilinear\",\n                align_corners=False,\n            )\n            _features = _features.squeeze(1)\n            _features = _features.reshape(\n                *perm_base_shape[:-2], ref_num_patches[0], ref_num_patches[1]\n            )\n            _features = _features.permute(0, -2, -1, 1, 2, 3)\n            _features = _features.reshape(len(_features), -1, *_features.shape[-3:])\n            features[i] = _features\n        features = [x.reshape(-1, *x.shape[-3:]) for x in features]\n\n        # As different feature backbones & patching provide differently\n        # sized features, these are brought into the correct form here.\n        features = self.forward_modules[\"preprocessing\"](features)\n        features = self.forward_modules[\"preadapt_aggregator\"](features)\n\n        if provide_patch_shapes:\n            return _detach(features), patch_shapes\n        return _detach(features)\n\n    def fit(self, training_data):\n        \"\"\"PatchCore training.\n\n        This function computes the embeddings of the training data and fills the\n        memory bank of SPADE.\n        \"\"\"\n        self._fill_memory_bank(training_data)\n\n    def _fill_memory_bank(self, input_data):\n        \"\"\"Computes and sets the support features for SPADE.\"\"\"\n        _ = self.forward_modules.eval()\n\n        def _image_to_features(input_image):\n            with torch.no_grad():\n                input_image = input_image.to(torch.float).to(self.device)\n                return self._embed(input_image)\n\n        features = []\n        with tqdm.tqdm(\n            input_data, desc=\"Computing support features...\", position=1, leave=False\n        ) as data_iterator:\n            for image in data_iterator:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                features.append(_image_to_features(image))\n\n        features = np.concatenate(features, axis=0)\n        features = self.featuresampler.run(features)\n\n        self.anomaly_scorer.fit(detection_features=[features])\n\n    def predict(self, data):"
  },
  {
    "id": "283",
    "text": "\"\"\"PatchCore and PatchCore detection methods.\"\"\"\nimport logging\nimport os\nimport pickle\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nimport tqdm\n\nimport patchcore\nimport patchcore.backbones\nimport patchcore.common\nimport patchcore.sampler\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass PatchCore(torch.nn.Module):\n    def __init__(self, device):\n        \"\"\"PatchCore anomaly detection class.\"\"\"\n        super(PatchCore, self).__init__()\n        self.device = device\n\n    def load(\n        self,\n        backbone,\n        layers_to_extract_from,\n        device,\n        input_shape,\n        pretrain_embed_dimension,\n        target_embed_dimension,\n        patchsize=3,\n        patchstride=1,\n        anomaly_score_num_nn=1,\n        featuresampler=patchcore.sampler.IdentitySampler(),\n        nn_method=patchcore.common.FaissNN(False, 4),\n        **kwargs,\n    ):\n        self.backbone = backbone.to(device)\n        self.layers_to_extract_from = layers_to_extract_from\n        self.input_shape = input_shape\n\n        self.device = device\n        self.patch_maker = PatchMaker(patchsize, stride=patchstride)\n\n        self.forward_modules = torch.nn.ModuleDict({})\n\n        feature_aggregator = patchcore.common.NetworkFeatureAggregator(\n            self.backbone, self.layers_to_extract_from, self.device\n        )\n        feature_dimensions = feature_aggregator.feature_dimensions(input_shape)\n        self.forward_modules[\"feature_aggregator\"] = feature_aggregator\n\n        preprocessing = patchcore.common.Preprocessing(\n            feature_dimensions, pretrain_embed_dimension\n        )\n        self.forward_modules[\"preprocessing\"] = preprocessing\n\n        self.target_embed_dimension = target_embed_dimension\n        preadapt_aggregator = patchcore.common.Aggregator(\n            target_dim=target_embed_dimension\n        )\n\n        _ = preadapt_aggregator.to(self.device)\n\n        self.forward_modules[\"preadapt_aggregator\"] = preadapt_aggregator\n\n        self.anomaly_scorer = patchcore.common.NearestNeighbourScorer(\n            n_nearest_neighbours=anomaly_score_num_nn, nn_method=nn_method\n        )\n\n        self.anomaly_segmentor = patchcore.common.RescaleSegmentor(\n            device=self.device, target_size=input_shape[-2:]\n        )\n\n        self.featuresampler = featuresampler\n\n    def embed(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            features = []\n            for image in data:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                with torch.no_grad():\n                    input_image = image.to(torch.float).to(self.device)\n                    features.append(self._embed(input_image))\n            return features\n        return self._embed(data)\n\n    def _embed(self, images, detach=True, provide_patch_shapes=False):\n        \"\"\"Returns feature embeddings for images.\"\"\"\n\n        def _detach(features):\n            if detach:\n                return [x.detach().cpu().numpy() for x in features]\n            return features\n\n        _ = self.forward_modules[\"feature_aggregator\"].eval()\n        with torch.no_grad():\n            features = self.forward_modules[\"feature_aggregator\"](images)\n\n        features = [features[layer] for layer in self.layers_to_extract_from]\n\n        features = [\n            self.patch_maker.patchify(x, return_spatial_info=True) for x in features\n        ]\n        patch_shapes = [x[1] for x in features]\n        features = [x[0] for x in features]\n        ref_num_patches = patch_shapes[0]\n\n        for i in range(1, len(features)):\n            _features = features[i]\n            patch_dims = patch_shapes[i]\n\n            # TODO(pgehler): Add comments\n            _features = _features.reshape(\n                _features.shape[0], patch_dims[0], patch_dims[1], *_features.shape[2:]\n            )\n            _features = _features.permute(0, -3, -2, -1, 1, 2)\n            perm_base_shape = _features.shape\n            _features = _features.reshape(-1, *_features.shape[-2:])\n            _features = F.interpolate(\n                _features.unsqueeze(1),\n                size=(ref_num_patches[0], ref_num_patches[1]),\n                mode=\"bilinear\",\n                align_corners=False,\n            )\n            _features = _features.squeeze(1)\n            _features = _features.reshape(\n                *perm_base_shape[:-2], ref_num_patches[0], ref_num_patches[1]\n            )\n            _features = _features.permute(0, -2, -1, 1, 2, 3)\n            _features = _features.reshape(len(_features), -1, *_features.shape[-3:])\n            features[i] = _features\n        features = [x.reshape(-1, *x.shape[-3:]) for x in features]\n\n        # As different feature backbones & patching provide differently\n        # sized features, these are brought into the correct form here.\n        features = self.forward_modules[\"preprocessing\"](features)\n        features = self.forward_modules[\"preadapt_aggregator\"](features)\n\n        if provide_patch_shapes:\n            return _detach(features), patch_shapes\n        return _detach(features)\n\n    def fit(self, training_data):\n        \"\"\"PatchCore training.\n\n        This function computes the embeddings of the training data and fills the\n        memory bank of SPADE.\n        \"\"\"\n        self._fill_memory_bank(training_data)\n\n    def _fill_memory_bank(self, input_data):\n        \"\"\"Computes and sets the support features for SPADE.\"\"\"\n        _ = self.forward_modules.eval()\n\n        def _image_to_features(input_image):\n            with torch.no_grad():\n                input_image = input_image.to(torch.float).to(self.device)\n                return self._embed(input_image)\n\n        features = []\n        with tqdm.tqdm(\n            input_data, desc=\"Computing support features...\", position=1, leave=False\n        ) as data_iterator:\n            for image in data_iterator:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                features.append(_image_to_features(image))\n\n        features = np.concatenate(features, axis=0)\n        features = self.featuresampler.run(features)\n\n        self.anomaly_scorer.fit(detection_features=[features])\n\n    def predict(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            return self._predict_dataloader(data)\n        return self._predict(data)\n\n    def _predict_dataloader(self, dataloader):\n        \"\"\"This function provides anomaly scores/maps for full dataloaders.\"\"\""
  },
  {
    "id": "284",
    "text": "[\"preprocessing\"] = preprocessing\n\n        self.target_embed_dimension = target_embed_dimension\n        preadapt_aggregator = patchcore.common.Aggregator(\n            target_dim=target_embed_dimension\n        )\n\n        _ = preadapt_aggregator.to(self.device)\n\n        self.forward_modules[\"preadapt_aggregator\"] = preadapt_aggregator\n\n        self.anomaly_scorer = patchcore.common.NearestNeighbourScorer(\n            n_nearest_neighbours=anomaly_score_num_nn, nn_method=nn_method\n        )\n\n        self.anomaly_segmentor = patchcore.common.RescaleSegmentor(\n            device=self.device, target_size=input_shape[-2:]\n        )\n\n        self.featuresampler = featuresampler\n\n    def embed(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            features = []\n            for image in data:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                with torch.no_grad():\n                    input_image = image.to(torch.float).to(self.device)\n                    features.append(self._embed(input_image))\n            return features\n        return self._embed(data)\n\n    def _embed(self, images, detach=True, provide_patch_shapes=False):\n        \"\"\"Returns feature embeddings for images.\"\"\"\n\n        def _detach(features):\n            if detach:\n                return [x.detach().cpu().numpy() for x in features]\n            return features\n\n        _ = self.forward_modules[\"feature_aggregator\"].eval()\n        with torch.no_grad():\n            features = self.forward_modules[\"feature_aggregator\"](images)\n\n        features = [features[layer] for layer in self.layers_to_extract_from]\n\n        features = [\n            self.patch_maker.patchify(x, return_spatial_info=True) for x in features\n        ]\n        patch_shapes = [x[1] for x in features]\n        features = [x[0] for x in features]\n        ref_num_patches = patch_shapes[0]\n\n        for i in range(1, len(features)):\n            _features = features[i]\n            patch_dims = patch_shapes[i]\n\n            # TODO(pgehler): Add comments\n            _features = _features.reshape(\n                _features.shape[0], patch_dims[0], patch_dims[1], *_features.shape[2:]\n            )\n            _features = _features.permute(0, -3, -2, -1, 1, 2)\n            perm_base_shape = _features.shape\n            _features = _features.reshape(-1, *_features.shape[-2:])\n            _features = F.interpolate(\n                _features.unsqueeze(1),\n                size=(ref_num_patches[0], ref_num_patches[1]),\n                mode=\"bilinear\",\n                align_corners=False,\n            )\n            _features = _features.squeeze(1)\n            _features = _features.reshape(\n                *perm_base_shape[:-2], ref_num_patches[0], ref_num_patches[1]\n            )\n            _features = _features.permute(0, -2, -1, 1, 2, 3)\n            _features = _features.reshape(len(_features), -1, *_features.shape[-3:])\n            features[i] = _features\n        features = [x.reshape(-1, *x.shape[-3:]) for x in features]\n\n        # As different feature backbones & patching provide differently\n        # sized features, these are brought into the correct form here.\n        features = self.forward_modules[\"preprocessing\"](features)\n        features = self.forward_modules[\"preadapt_aggregator\"](features)\n\n        if provide_patch_shapes:\n            return _detach(features), patch_shapes\n        return _detach(features)\n\n    def fit(self, training_data):\n        \"\"\"PatchCore training.\n\n        This function computes the embeddings of the training data and fills the\n        memory bank of SPADE.\n        \"\"\"\n        self._fill_memory_bank(training_data)\n\n    def _fill_memory_bank(self, input_data):\n        \"\"\"Computes and sets the support features for SPADE.\"\"\"\n        _ = self.forward_modules.eval()\n\n        def _image_to_features(input_image):\n            with torch.no_grad():\n                input_image = input_image.to(torch.float).to(self.device)\n                return self._embed(input_image)\n\n        features = []\n        with tqdm.tqdm(\n            input_data, desc=\"Computing support features...\", position=1, leave=False\n        ) as data_iterator:\n            for image in data_iterator:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                features.append(_image_to_features(image))\n\n        features = np.concatenate(features, axis=0)\n        features = self.featuresampler.run(features)\n\n        self.anomaly_scorer.fit(detection_features=[features])\n\n    def predict(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            return self._predict_dataloader(data)\n        return self._predict(data)\n\n    def _predict_dataloader(self, dataloader):\n        \"\"\"This function provides anomaly scores/maps for full dataloaders.\"\"\"\n        _ = self.forward_modules.eval()\n\n        scores = []\n        masks = []\n        labels_gt = []\n        masks_gt = []\n        with tqdm.tqdm(dataloader, desc=\"Inferring...\", leave=False) as data_iterator:\n            for image in data_iterator:\n                if isinstance(image, dict):\n                    labels_gt.extend(image[\"is_anomaly\"].numpy().tolist())\n                    masks_gt.extend(image[\"mask\"].numpy().tolist())\n                    image = image[\"image\"]\n                _scores, _masks = self._predict(image)\n                for score, mask in zip(_scores, _masks):\n                    scores.append(score)\n                    masks.append(mask)\n        return scores, masks, labels_gt, masks_gt\n\n    def _predict(self, images):\n        \"\"\"Infer score and mask for a batch of images.\"\"\"\n        images = images.to(torch.float).to(self.device)\n        _ = self.forward_modules.eval()\n\n        batchsize = images.shape[0]\n        with torch.no_grad():\n            features, patch_shapes = self._embed(images, provide_patch_shapes=True)\n            features = np.asarray(features)\n\n            patch_scores = image_scores = self.anomaly_scorer.predict([features])[0]\n            image_scores = self.patch_maker.unpatch_scores(\n                image_scores, batchsize=batchsize\n            )\n            image_scores = image_scores.reshape(*image_scores.shape[:2], -1)\n            image_scores = self.patch_maker.score(image_scores)\n\n            patch_scores = self.patch_maker.unpatch_scores(\n                patch_scores, batchsize=batchsize\n            )\n            scales = patch_shapes[0]\n            patch_scores = patch_scores.reshape(batchsize, scales[0], scales[1])\n\n            masks = self.anomaly_segmentor.convert_to_segmentation(patch_scores)\n\n        return [score for score in image_scores], [mask for mask in masks]\n\n    @staticmethod\n    def _params_file(filepath, prepend=\"\"):\n        return os.path.join(filepath, prepend + \"patchcore_params.pkl\")\n\n    def save_to_path(self, save_path: str, prepend: str = \"\") -> None:"
  },
  {
    "id": "285",
    "text": "features.shape\n            _features = _features.reshape(-1, *_features.shape[-2:])\n            _features = F.interpolate(\n                _features.unsqueeze(1),\n                size=(ref_num_patches[0], ref_num_patches[1]),\n                mode=\"bilinear\",\n                align_corners=False,\n            )\n            _features = _features.squeeze(1)\n            _features = _features.reshape(\n                *perm_base_shape[:-2], ref_num_patches[0], ref_num_patches[1]\n            )\n            _features = _features.permute(0, -2, -1, 1, 2, 3)\n            _features = _features.reshape(len(_features), -1, *_features.shape[-3:])\n            features[i] = _features\n        features = [x.reshape(-1, *x.shape[-3:]) for x in features]\n\n        # As different feature backbones & patching provide differently\n        # sized features, these are brought into the correct form here.\n        features = self.forward_modules[\"preprocessing\"](features)\n        features = self.forward_modules[\"preadapt_aggregator\"](features)\n\n        if provide_patch_shapes:\n            return _detach(features), patch_shapes\n        return _detach(features)\n\n    def fit(self, training_data):\n        \"\"\"PatchCore training.\n\n        This function computes the embeddings of the training data and fills the\n        memory bank of SPADE.\n        \"\"\"\n        self._fill_memory_bank(training_data)\n\n    def _fill_memory_bank(self, input_data):\n        \"\"\"Computes and sets the support features for SPADE.\"\"\"\n        _ = self.forward_modules.eval()\n\n        def _image_to_features(input_image):\n            with torch.no_grad():\n                input_image = input_image.to(torch.float).to(self.device)\n                return self._embed(input_image)\n\n        features = []\n        with tqdm.tqdm(\n            input_data, desc=\"Computing support features...\", position=1, leave=False\n        ) as data_iterator:\n            for image in data_iterator:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                features.append(_image_to_features(image))\n\n        features = np.concatenate(features, axis=0)\n        features = self.featuresampler.run(features)\n\n        self.anomaly_scorer.fit(detection_features=[features])\n\n    def predict(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            return self._predict_dataloader(data)\n        return self._predict(data)\n\n    def _predict_dataloader(self, dataloader):\n        \"\"\"This function provides anomaly scores/maps for full dataloaders.\"\"\"\n        _ = self.forward_modules.eval()\n\n        scores = []\n        masks = []\n        labels_gt = []\n        masks_gt = []\n        with tqdm.tqdm(dataloader, desc=\"Inferring...\", leave=False) as data_iterator:\n            for image in data_iterator:\n                if isinstance(image, dict):\n                    labels_gt.extend(image[\"is_anomaly\"].numpy().tolist())\n                    masks_gt.extend(image[\"mask\"].numpy().tolist())\n                    image = image[\"image\"]\n                _scores, _masks = self._predict(image)\n                for score, mask in zip(_scores, _masks):\n                    scores.append(score)\n                    masks.append(mask)\n        return scores, masks, labels_gt, masks_gt\n\n    def _predict(self, images):\n        \"\"\"Infer score and mask for a batch of images.\"\"\"\n        images = images.to(torch.float).to(self.device)\n        _ = self.forward_modules.eval()\n\n        batchsize = images.shape[0]\n        with torch.no_grad():\n            features, patch_shapes = self._embed(images, provide_patch_shapes=True)\n            features = np.asarray(features)\n\n            patch_scores = image_scores = self.anomaly_scorer.predict([features])[0]\n            image_scores = self.patch_maker.unpatch_scores(\n                image_scores, batchsize=batchsize\n            )\n            image_scores = image_scores.reshape(*image_scores.shape[:2], -1)\n            image_scores = self.patch_maker.score(image_scores)\n\n            patch_scores = self.patch_maker.unpatch_scores(\n                patch_scores, batchsize=batchsize\n            )\n            scales = patch_shapes[0]\n            patch_scores = patch_scores.reshape(batchsize, scales[0], scales[1])\n\n            masks = self.anomaly_segmentor.convert_to_segmentation(patch_scores)\n\n        return [score for score in image_scores], [mask for mask in masks]\n\n    @staticmethod\n    def _params_file(filepath, prepend=\"\"):\n        return os.path.join(filepath, prepend + \"patchcore_params.pkl\")\n\n    def save_to_path(self, save_path: str, prepend: str = \"\") -> None:\n        LOGGER.info(\"Saving PatchCore data.\")\n        self.anomaly_scorer.save(\n            save_path, save_features_separately=False, prepend=prepend\n        )\n        patchcore_params = {\n            \"backbone.name\": self.backbone.name,\n            \"layers_to_extract_from\": self.layers_to_extract_from,\n            \"input_shape\": self.input_shape,\n            \"pretrain_embed_dimension\": self.forward_modules[\n                \"preprocessing\"\n            ].output_dim,\n            \"target_embed_dimension\": self.forward_modules[\n                \"preadapt_aggregator\"\n            ].target_dim,\n            \"patchsize\": self.patch_maker.patchsize,\n            \"patchstride\": self.patch_maker.stride,\n            \"anomaly_scorer_num_nn\": self.anomaly_scorer.n_nearest_neighbours,\n        }\n        with open(self._params_file(save_path, prepend), \"wb\") as save_file:\n            pickle.dump(patchcore_params, save_file, pickle.HIGHEST_PROTOCOL)\n\n    def load_from_path(\n        self,\n        load_path: str,\n        device: torch.device,\n        nn_method: patchcore.common.FaissNN(False, 4),\n        prepend: str = \"\",\n    ) -> None:\n        LOGGER.info(\"Loading and initializing PatchCore.\")\n        with open(self._params_file(load_path, prepend), \"rb\") as load_file:\n            patchcore_params = pickle.load(load_file)\n        patchcore_params[\"backbone\"] = patchcore.backbones.load(\n            patchcore_params[\"backbone.name\"]\n        )\n        patchcore_params[\"backbone\"].name = patchcore_params[\"backbone.name\"]\n        del patchcore_params[\"backbone.name\"]\n        self.load(**patchcore_params, device=device, nn_method=nn_method)\n\n        self.anomaly_scorer.load(load_path, prepend)\n\n\n# Image handling classes.\nclass PatchMaker:\n    def __init__(self, patchsize, stride=None):\n        self.patchsize = patchsize\n        self.stride = stride\n\n    def patchify(self, features, return_spatial_info=False):\n        \"\"\"Convert a tensor into a tensor of respective patches.\n        Args:\n            x: [torch.Tensor, bs x c x w x h]\n        Returns:\n            x: [torch.Tensor, bs * w//stride * h//stride, c, patchsize,\n            patchsize]\n        \"\"\""
  },
  {
    "id": "286",
    "text": "[\"preadapt_aggregator\"](features)\n\n        if provide_patch_shapes:\n            return _detach(features), patch_shapes\n        return _detach(features)\n\n    def fit(self, training_data):\n        \"\"\"PatchCore training.\n\n        This function computes the embeddings of the training data and fills the\n        memory bank of SPADE.\n        \"\"\"\n        self._fill_memory_bank(training_data)\n\n    def _fill_memory_bank(self, input_data):\n        \"\"\"Computes and sets the support features for SPADE.\"\"\"\n        _ = self.forward_modules.eval()\n\n        def _image_to_features(input_image):\n            with torch.no_grad():\n                input_image = input_image.to(torch.float).to(self.device)\n                return self._embed(input_image)\n\n        features = []\n        with tqdm.tqdm(\n            input_data, desc=\"Computing support features...\", position=1, leave=False\n        ) as data_iterator:\n            for image in data_iterator:\n                if isinstance(image, dict):\n                    image = image[\"image\"]\n                features.append(_image_to_features(image))\n\n        features = np.concatenate(features, axis=0)\n        features = self.featuresampler.run(features)\n\n        self.anomaly_scorer.fit(detection_features=[features])\n\n    def predict(self, data):\n        if isinstance(data, torch.utils.data.DataLoader):\n            return self._predict_dataloader(data)\n        return self._predict(data)\n\n    def _predict_dataloader(self, dataloader):\n        \"\"\"This function provides anomaly scores/maps for full dataloaders.\"\"\"\n        _ = self.forward_modules.eval()\n\n        scores = []\n        masks = []\n        labels_gt = []\n        masks_gt = []\n        with tqdm.tqdm(dataloader, desc=\"Inferring...\", leave=False) as data_iterator:\n            for image in data_iterator:\n                if isinstance(image, dict):\n                    labels_gt.extend(image[\"is_anomaly\"].numpy().tolist())\n                    masks_gt.extend(image[\"mask\"].numpy().tolist())\n                    image = image[\"image\"]\n                _scores, _masks = self._predict(image)\n                for score, mask in zip(_scores, _masks):\n                    scores.append(score)\n                    masks.append(mask)\n        return scores, masks, labels_gt, masks_gt\n\n    def _predict(self, images):\n        \"\"\"Infer score and mask for a batch of images.\"\"\"\n        images = images.to(torch.float).to(self.device)\n        _ = self.forward_modules.eval()\n\n        batchsize = images.shape[0]\n        with torch.no_grad():\n            features, patch_shapes = self._embed(images, provide_patch_shapes=True)\n            features = np.asarray(features)\n\n            patch_scores = image_scores = self.anomaly_scorer.predict([features])[0]\n            image_scores = self.patch_maker.unpatch_scores(\n                image_scores, batchsize=batchsize\n            )\n            image_scores = image_scores.reshape(*image_scores.shape[:2], -1)\n            image_scores = self.patch_maker.score(image_scores)\n\n            patch_scores = self.patch_maker.unpatch_scores(\n                patch_scores, batchsize=batchsize\n            )\n            scales = patch_shapes[0]\n            patch_scores = patch_scores.reshape(batchsize, scales[0], scales[1])\n\n            masks = self.anomaly_segmentor.convert_to_segmentation(patch_scores)\n\n        return [score for score in image_scores], [mask for mask in masks]\n\n    @staticmethod\n    def _params_file(filepath, prepend=\"\"):\n        return os.path.join(filepath, prepend + \"patchcore_params.pkl\")\n\n    def save_to_path(self, save_path: str, prepend: str = \"\") -> None:\n        LOGGER.info(\"Saving PatchCore data.\")\n        self.anomaly_scorer.save(\n            save_path, save_features_separately=False, prepend=prepend\n        )\n        patchcore_params = {\n            \"backbone.name\": self.backbone.name,\n            \"layers_to_extract_from\": self.layers_to_extract_from,\n            \"input_shape\": self.input_shape,\n            \"pretrain_embed_dimension\": self.forward_modules[\n                \"preprocessing\"\n            ].output_dim,\n            \"target_embed_dimension\": self.forward_modules[\n                \"preadapt_aggregator\"\n            ].target_dim,\n            \"patchsize\": self.patch_maker.patchsize,\n            \"patchstride\": self.patch_maker.stride,\n            \"anomaly_scorer_num_nn\": self.anomaly_scorer.n_nearest_neighbours,\n        }\n        with open(self._params_file(save_path, prepend), \"wb\") as save_file:\n            pickle.dump(patchcore_params, save_file, pickle.HIGHEST_PROTOCOL)\n\n    def load_from_path(\n        self,\n        load_path: str,\n        device: torch.device,\n        nn_method: patchcore.common.FaissNN(False, 4),\n        prepend: str = \"\",\n    ) -> None:\n        LOGGER.info(\"Loading and initializing PatchCore.\")\n        with open(self._params_file(load_path, prepend), \"rb\") as load_file:\n            patchcore_params = pickle.load(load_file)\n        patchcore_params[\"backbone\"] = patchcore.backbones.load(\n            patchcore_params[\"backbone.name\"]\n        )\n        patchcore_params[\"backbone\"].name = patchcore_params[\"backbone.name\"]\n        del patchcore_params[\"backbone.name\"]\n        self.load(**patchcore_params, device=device, nn_method=nn_method)\n\n        self.anomaly_scorer.load(load_path, prepend)\n\n\n# Image handling classes.\nclass PatchMaker:\n    def __init__(self, patchsize, stride=None):\n        self.patchsize = patchsize\n        self.stride = stride\n\n    def patchify(self, features, return_spatial_info=False):\n        \"\"\"Convert a tensor into a tensor of respective patches.\n        Args:\n            x: [torch.Tensor, bs x c x w x h]\n        Returns:\n            x: [torch.Tensor, bs * w//stride * h//stride, c, patchsize,\n            patchsize]\n        \"\"\"\n        padding = int((self.patchsize - 1) / 2)\n        unfolder = torch.nn.Unfold(\n            kernel_size=self.patchsize, stride=self.stride, padding=padding, dilation=1\n        )\n        unfolded_features = unfolder(features)\n        number_of_total_patches = []\n        for s in features.shape[-2:]:\n            n_patches = (\n                s + 2 * padding - 1 * (self.patchsize - 1) - 1\n            ) / self.stride + 1\n            number_of_total_patches.append(int(n_patches))\n        unfolded_features = unfolded_features.reshape(\n            *features.shape[:2], self.patchsize, self.patchsize, -1\n        )\n        unfolded_features = unfolded_features.permute(0, 4, 1, 2, 3)\n\n        if return_spatial_info:\n            return unfolded_features, number_of_total_patches\n        return unfolded_features\n\n    def unpatch_scores(self, x, batchsize):\n        return x.reshape(batchsize, -1, *x.shape[1:])\n\n    def score(self, x):"
  },
  {
    "id": "287",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\""
  },
  {
    "id": "288",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):"
  },
  {
    "id": "289",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):"
  },
  {
    "id": "290",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):"
  },
  {
    "id": "291",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\""
  },
  {
    "id": "292",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\"\n        if self.search_index:\n            self.reset_index()\n        self.search_index = self._create_index(features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\""
  },
  {
    "id": "293",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\"\n        if self.search_index:\n            self.reset_index()\n        self.search_index = self._create_index(features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):"
  },
  {
    "id": "294",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\"\n        if self.search_index:\n            self.reset_index()\n        self.search_index = self._create_index(features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):"
  },
  {
    "id": "295",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\"\n        if self.search_index:\n            self.reset_index()\n        self.search_index = self._create_index(features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC"
  },
  {
    "id": "296",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\"\n        if self.search_index:\n            self.reset_index()\n        self.search_index = self._create_index(features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):"
  },
  {
    "id": "297",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\"\n        if self.search_index:\n            self.reset_index()\n        self.search_index = self._create_index(features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):"
  },
  {
    "id": "298",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\"\n        if self.search_index:\n            self.reset_index()\n        self.search_index = self._create_index(features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim"
  },
  {
    "id": "299",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\"\n        if self.search_index:\n            self.reset_index()\n        self.search_index = self._create_index(features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim\n        features = features.reshape(len(features), 1, -1)\n        features = F.adaptive_avg_pool1d(features, self.target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):"
  },
  {
    "id": "300",
    "text": "import copy\nimport os\nimport pickle\nfrom typing import List\nfrom typing import Union\n\nimport faiss\nimport numpy as np\nimport scipy.ndimage as ndimage\nimport torch\nimport torch.nn.functional as F\n\n\nclass FaissNN(object):\n    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:\n        \"\"\"FAISS Nearest neighbourhood search.\n\n        Args:\n            on_gpu: If set true, nearest neighbour searches are done on GPU.\n            num_workers: Number of workers to use with FAISS for similarity search.\n        \"\"\"\n        faiss.omp_set_num_threads(num_workers)\n        self.on_gpu = on_gpu\n        self.search_index = None\n\n    def _gpu_cloner_options(self):\n        return faiss.GpuClonerOptions()\n\n    def _index_to_gpu(self, index):\n        if self.on_gpu:\n            # For the non-gpu faiss python package, there is no GpuClonerOptions\n            # so we can not make a default in the function header.\n            return faiss.index_cpu_to_gpu(\n                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()\n            )\n        return index\n\n    def _index_to_cpu(self, index):\n        if self.on_gpu:\n            return faiss.index_gpu_to_cpu(index)\n        return index\n\n    def _create_index(self, dimension):\n        if self.on_gpu:\n            return faiss.GpuIndexFlatL2(\n                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()\n            )\n        return faiss.IndexFlatL2(dimension)\n\n    def fit(self, features: np.ndarray) -> None:\n        \"\"\"\n        Adds features to the FAISS search index.\n\n        Args:\n            features: Array of size NxD.\n        \"\"\"\n        if self.search_index:\n            self.reset_index()\n        self.search_index = self._create_index(features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim\n        features = features.reshape(len(features), 1, -1)\n        features = F.adaptive_avg_pool1d(features, self.target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):\n        self.device = device\n        self.target_size = target_size\n        self.smoothing = 4\n\n    def convert_to_segmentation(self, patch_scores):"
  },
  {
    "id": "301",
    "text": "features.shape[-1])\n        self._train(self.search_index, features)\n        self.search_index.add(features)\n\n    def _train(self, _index, _features):\n        pass\n\n    def run(\n        self,\n        n_nearest_neighbours,\n        query_features: np.ndarray,\n        index_features: np.ndarray = None,\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim\n        features = features.reshape(len(features), 1, -1)\n        features = F.adaptive_avg_pool1d(features, self.target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):\n        self.device = device\n        self.target_size = target_size\n        self.smoothing = 4\n\n    def convert_to_segmentation(self, patch_scores):\n\n        with torch.no_grad():\n            if isinstance(patch_scores, np.ndarray):\n                patch_scores = torch.from_numpy(patch_scores)\n            _scores = patch_scores.to(self.device)\n            _scores = _scores.unsqueeze(1)\n            _scores = F.interpolate(\n                _scores, size=self.target_size, mode=\"bilinear\", align_corners=False\n            )\n            _scores = _scores.squeeze(1)\n            patch_scores = _scores.cpu().numpy()\n\n        return [\n            ndimage.gaussian_filter(patch_score, sigma=self.smoothing)\n            for patch_score in patch_scores\n        ]\n\n\nclass NetworkFeatureAggregator(torch.nn.Module):\n    \"\"\"Efficient extraction of network features.\"\"\"\n\n    def __init__(self, backbone, layers_to_extract_from, device):\n        super(NetworkFeatureAggregator, self).__init__()\n        \"\"\"Extraction of network features.\n\n        Runs a network only to the last layer of the list of layers where\n        network features should be extracted from.\n\n        Args:\n            backbone: torchvision.model\n            layers_to_extract_from: [list of str]\n        \"\"\"\n        self.layers_to_extract_from = layers_to_extract_from\n        self.backbone = backbone\n        self.device = device\n        if not hasattr(backbone, \"hook_handles\"):\n            self.backbone.hook_handles = []\n        for handle in self.backbone.hook_handles:\n            handle.remove()\n        self.outputs = {}\n\n        for extract_layer in layers_to_extract_from:\n            forward_hook = ForwardHook(\n                self.outputs, extract_layer, layers_to_extract_from[-1]\n            )\n            if \".\" in extract_layer:\n                extract_block, extract_idx = extract_layer.split(\".\")\n                network_layer = backbone.__dict__[\"_modules\"][extract_block]\n                if extract_idx.isnumeric():\n                    extract_idx = int(extract_idx)\n                    network_layer = network_layer[extract_idx]\n                else:\n                    network_layer = network_layer.__dict__[\"_modules\"][extract_idx]\n            else:\n                network_layer = backbone.__dict__[\"_modules\"][extract_layer]\n\n            if isinstance(network_layer, torch.nn.Sequential):\n                self.backbone.hook_handles.append(\n                    network_layer[-1].register_forward_hook(forward_hook)\n                )\n            else:\n                self.backbone.hook_handles.append(\n                    network_layer.register_forward_hook(forward_hook)\n                )\n        self.to(self.device)\n\n    def forward(self, images):"
  },
  {
    "id": "302",
    "text": "]:\n        \"\"\"\n        Returns distances and indices of nearest neighbour search.\n\n        Args:\n            query_features: Features to retrieve.\n            index_features: [optional] Index features to search in.\n        \"\"\"\n        if index_features is None:\n            return self.search_index.search(query_features, n_nearest_neighbours)\n\n        # Build a search index just for this search.\n        search_index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim\n        features = features.reshape(len(features), 1, -1)\n        features = F.adaptive_avg_pool1d(features, self.target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):\n        self.device = device\n        self.target_size = target_size\n        self.smoothing = 4\n\n    def convert_to_segmentation(self, patch_scores):\n\n        with torch.no_grad():\n            if isinstance(patch_scores, np.ndarray):\n                patch_scores = torch.from_numpy(patch_scores)\n            _scores = patch_scores.to(self.device)\n            _scores = _scores.unsqueeze(1)\n            _scores = F.interpolate(\n                _scores, size=self.target_size, mode=\"bilinear\", align_corners=False\n            )\n            _scores = _scores.squeeze(1)\n            patch_scores = _scores.cpu().numpy()\n\n        return [\n            ndimage.gaussian_filter(patch_score, sigma=self.smoothing)\n            for patch_score in patch_scores\n        ]\n\n\nclass NetworkFeatureAggregator(torch.nn.Module):\n    \"\"\"Efficient extraction of network features.\"\"\"\n\n    def __init__(self, backbone, layers_to_extract_from, device):\n        super(NetworkFeatureAggregator, self).__init__()\n        \"\"\"Extraction of network features.\n\n        Runs a network only to the last layer of the list of layers where\n        network features should be extracted from.\n\n        Args:\n            backbone: torchvision.model\n            layers_to_extract_from: [list of str]\n        \"\"\"\n        self.layers_to_extract_from = layers_to_extract_from\n        self.backbone = backbone\n        self.device = device\n        if not hasattr(backbone, \"hook_handles\"):\n            self.backbone.hook_handles = []\n        for handle in self.backbone.hook_handles:\n            handle.remove()\n        self.outputs = {}\n\n        for extract_layer in layers_to_extract_from:\n            forward_hook = ForwardHook(\n                self.outputs, extract_layer, layers_to_extract_from[-1]\n            )\n            if \".\" in extract_layer:\n                extract_block, extract_idx = extract_layer.split(\".\")\n                network_layer = backbone.__dict__[\"_modules\"][extract_block]\n                if extract_idx.isnumeric():\n                    extract_idx = int(extract_idx)\n                    network_layer = network_layer[extract_idx]\n                else:\n                    network_layer = network_layer.__dict__[\"_modules\"][extract_idx]\n            else:\n                network_layer = backbone.__dict__[\"_modules\"][extract_layer]\n\n            if isinstance(network_layer, torch.nn.Sequential):\n                self.backbone.hook_handles.append(\n                    network_layer[-1].register_forward_hook(forward_hook)\n                )\n            else:\n                self.backbone.hook_handles.append(\n                    network_layer.register_forward_hook(forward_hook)\n                )\n        self.to(self.device)\n\n    def forward(self, images):\n        self.outputs.clear()\n        with torch.no_grad():\n            # The backbone will throw an Exception once it reached the last\n            # layer to compute features from. Computation will stop there.\n            try:\n                _ = self.backbone(images)\n            except LastLayerToExtractReachedException:\n                pass\n        return self.outputs\n\n    def feature_dimensions(self, input_shape):\n        \"\"\"Computes the feature dimensions for all layers given input_shape.\"\"\""
  },
  {
    "id": "303",
    "text": "index = self._create_index(index_features.shape[-1])\n        self._train(search_index, index_features)\n        search_index.add(index_features)\n        return search_index.search(query_features, n_nearest_neighbours)\n\n    def save(self, filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim\n        features = features.reshape(len(features), 1, -1)\n        features = F.adaptive_avg_pool1d(features, self.target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):\n        self.device = device\n        self.target_size = target_size\n        self.smoothing = 4\n\n    def convert_to_segmentation(self, patch_scores):\n\n        with torch.no_grad():\n            if isinstance(patch_scores, np.ndarray):\n                patch_scores = torch.from_numpy(patch_scores)\n            _scores = patch_scores.to(self.device)\n            _scores = _scores.unsqueeze(1)\n            _scores = F.interpolate(\n                _scores, size=self.target_size, mode=\"bilinear\", align_corners=False\n            )\n            _scores = _scores.squeeze(1)\n            patch_scores = _scores.cpu().numpy()\n\n        return [\n            ndimage.gaussian_filter(patch_score, sigma=self.smoothing)\n            for patch_score in patch_scores\n        ]\n\n\nclass NetworkFeatureAggregator(torch.nn.Module):\n    \"\"\"Efficient extraction of network features.\"\"\"\n\n    def __init__(self, backbone, layers_to_extract_from, device):\n        super(NetworkFeatureAggregator, self).__init__()\n        \"\"\"Extraction of network features.\n\n        Runs a network only to the last layer of the list of layers where\n        network features should be extracted from.\n\n        Args:\n            backbone: torchvision.model\n            layers_to_extract_from: [list of str]\n        \"\"\"\n        self.layers_to_extract_from = layers_to_extract_from\n        self.backbone = backbone\n        self.device = device\n        if not hasattr(backbone, \"hook_handles\"):\n            self.backbone.hook_handles = []\n        for handle in self.backbone.hook_handles:\n            handle.remove()\n        self.outputs = {}\n\n        for extract_layer in layers_to_extract_from:\n            forward_hook = ForwardHook(\n                self.outputs, extract_layer, layers_to_extract_from[-1]\n            )\n            if \".\" in extract_layer:\n                extract_block, extract_idx = extract_layer.split(\".\")\n                network_layer = backbone.__dict__[\"_modules\"][extract_block]\n                if extract_idx.isnumeric():\n                    extract_idx = int(extract_idx)\n                    network_layer = network_layer[extract_idx]\n                else:\n                    network_layer = network_layer.__dict__[\"_modules\"][extract_idx]\n            else:\n                network_layer = backbone.__dict__[\"_modules\"][extract_layer]\n\n            if isinstance(network_layer, torch.nn.Sequential):\n                self.backbone.hook_handles.append(\n                    network_layer[-1].register_forward_hook(forward_hook)\n                )\n            else:\n                self.backbone.hook_handles.append(\n                    network_layer.register_forward_hook(forward_hook)\n                )\n        self.to(self.device)\n\n    def forward(self, images):\n        self.outputs.clear()\n        with torch.no_grad():\n            # The backbone will throw an Exception once it reached the last\n            # layer to compute features from. Computation will stop there.\n            try:\n                _ = self.backbone(images)\n            except LastLayerToExtractReachedException:\n                pass\n        return self.outputs\n\n    def feature_dimensions(self, input_shape):\n        \"\"\"Computes the feature dimensions for all layers given input_shape.\"\"\"\n        _input = torch.ones([1] + list(input_shape)).to(self.device)\n        _output = self(_input)\n        return [_output[layer].shape[1] for layer in self.layers_to_extract_from]\n\n\nclass ForwardHook:\n    def __init__(self, hook_dict, layer_name: str, last_layer_to_extract: str):"
  },
  {
    "id": "304",
    "text": ", filename: str) -> None:\n        faiss.write_index(self._index_to_cpu(self.search_index), filename)\n\n    def load(self, filename: str) -> None:\n        self.search_index = self._index_to_gpu(faiss.read_index(filename))\n\n    def reset_index(self):\n        if self.search_index:\n            self.search_index.reset()\n            self.search_index = None\n\n\nclass ApproximateFaissNN(FaissNN):\n    def _train(self, index, features):\n        index.train(features)\n\n    def _gpu_cloner_options(self):\n        cloner = faiss.GpuClonerOptions()\n        cloner.useFloat16 = True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim\n        features = features.reshape(len(features), 1, -1)\n        features = F.adaptive_avg_pool1d(features, self.target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):\n        self.device = device\n        self.target_size = target_size\n        self.smoothing = 4\n\n    def convert_to_segmentation(self, patch_scores):\n\n        with torch.no_grad():\n            if isinstance(patch_scores, np.ndarray):\n                patch_scores = torch.from_numpy(patch_scores)\n            _scores = patch_scores.to(self.device)\n            _scores = _scores.unsqueeze(1)\n            _scores = F.interpolate(\n                _scores, size=self.target_size, mode=\"bilinear\", align_corners=False\n            )\n            _scores = _scores.squeeze(1)\n            patch_scores = _scores.cpu().numpy()\n\n        return [\n            ndimage.gaussian_filter(patch_score, sigma=self.smoothing)\n            for patch_score in patch_scores\n        ]\n\n\nclass NetworkFeatureAggregator(torch.nn.Module):\n    \"\"\"Efficient extraction of network features.\"\"\"\n\n    def __init__(self, backbone, layers_to_extract_from, device):\n        super(NetworkFeatureAggregator, self).__init__()\n        \"\"\"Extraction of network features.\n\n        Runs a network only to the last layer of the list of layers where\n        network features should be extracted from.\n\n        Args:\n            backbone: torchvision.model\n            layers_to_extract_from: [list of str]\n        \"\"\"\n        self.layers_to_extract_from = layers_to_extract_from\n        self.backbone = backbone\n        self.device = device\n        if not hasattr(backbone, \"hook_handles\"):\n            self.backbone.hook_handles = []\n        for handle in self.backbone.hook_handles:\n            handle.remove()\n        self.outputs = {}\n\n        for extract_layer in layers_to_extract_from:\n            forward_hook = ForwardHook(\n                self.outputs, extract_layer, layers_to_extract_from[-1]\n            )\n            if \".\" in extract_layer:\n                extract_block, extract_idx = extract_layer.split(\".\")\n                network_layer = backbone.__dict__[\"_modules\"][extract_block]\n                if extract_idx.isnumeric():\n                    extract_idx = int(extract_idx)\n                    network_layer = network_layer[extract_idx]\n                else:\n                    network_layer = network_layer.__dict__[\"_modules\"][extract_idx]\n            else:\n                network_layer = backbone.__dict__[\"_modules\"][extract_layer]\n\n            if isinstance(network_layer, torch.nn.Sequential):\n                self.backbone.hook_handles.append(\n                    network_layer[-1].register_forward_hook(forward_hook)\n                )\n            else:\n                self.backbone.hook_handles.append(\n                    network_layer.register_forward_hook(forward_hook)\n                )\n        self.to(self.device)\n\n    def forward(self, images):\n        self.outputs.clear()\n        with torch.no_grad():\n            # The backbone will throw an Exception once it reached the last\n            # layer to compute features from. Computation will stop there.\n            try:\n                _ = self.backbone(images)\n            except LastLayerToExtractReachedException:\n                pass\n        return self.outputs\n\n    def feature_dimensions(self, input_shape):\n        \"\"\"Computes the feature dimensions for all layers given input_shape.\"\"\"\n        _input = torch.ones([1] + list(input_shape)).to(self.device)\n        _output = self(_input)\n        return [_output[layer].shape[1] for layer in self.layers_to_extract_from]\n\n\nclass ForwardHook:\n    def __init__(self, hook_dict, layer_name: str, last_layer_to_extract: str):\n        self.hook_dict = hook_dict\n        self.layer_name = layer_name\n        self.raise_exception_to_break = copy.deepcopy(\n            layer_name == last_layer_to_extract\n        )\n\n    def __call__(self, module, input, output):"
  },
  {
    "id": "305",
    "text": " True\n        return cloner\n\n    def _create_index(self, dimension):\n        index = faiss.IndexIVFPQ(\n            faiss.IndexFlatL2(dimension),\n            dimension,\n            512,  # n_centroids\n            64,  # sub-quantizers\n            8,\n        )  # nbits per code\n        return self._index_to_gpu(index)\n\n\nclass _BaseMerger:\n    def __init__(self):\n        \"\"\"Merges feature embedding by name.\"\"\"\n\n    def merge(self, features: list):\n        features = [self._reduce(feature) for feature in features]\n        return np.concatenate(features, axis=1)\n\n\nclass AverageMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxC\n        return features.reshape([features.shape[0], features.shape[1], -1]).mean(\n            axis=-1\n        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim\n        features = features.reshape(len(features), 1, -1)\n        features = F.adaptive_avg_pool1d(features, self.target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):\n        self.device = device\n        self.target_size = target_size\n        self.smoothing = 4\n\n    def convert_to_segmentation(self, patch_scores):\n\n        with torch.no_grad():\n            if isinstance(patch_scores, np.ndarray):\n                patch_scores = torch.from_numpy(patch_scores)\n            _scores = patch_scores.to(self.device)\n            _scores = _scores.unsqueeze(1)\n            _scores = F.interpolate(\n                _scores, size=self.target_size, mode=\"bilinear\", align_corners=False\n            )\n            _scores = _scores.squeeze(1)\n            patch_scores = _scores.cpu().numpy()\n\n        return [\n            ndimage.gaussian_filter(patch_score, sigma=self.smoothing)\n            for patch_score in patch_scores\n        ]\n\n\nclass NetworkFeatureAggregator(torch.nn.Module):\n    \"\"\"Efficient extraction of network features.\"\"\"\n\n    def __init__(self, backbone, layers_to_extract_from, device):\n        super(NetworkFeatureAggregator, self).__init__()\n        \"\"\"Extraction of network features.\n\n        Runs a network only to the last layer of the list of layers where\n        network features should be extracted from.\n\n        Args:\n            backbone: torchvision.model\n            layers_to_extract_from: [list of str]\n        \"\"\"\n        self.layers_to_extract_from = layers_to_extract_from\n        self.backbone = backbone\n        self.device = device\n        if not hasattr(backbone, \"hook_handles\"):\n            self.backbone.hook_handles = []\n        for handle in self.backbone.hook_handles:\n            handle.remove()\n        self.outputs = {}\n\n        for extract_layer in layers_to_extract_from:\n            forward_hook = ForwardHook(\n                self.outputs, extract_layer, layers_to_extract_from[-1]\n            )\n            if \".\" in extract_layer:\n                extract_block, extract_idx = extract_layer.split(\".\")\n                network_layer = backbone.__dict__[\"_modules\"][extract_block]\n                if extract_idx.isnumeric():\n                    extract_idx = int(extract_idx)\n                    network_layer = network_layer[extract_idx]\n                else:\n                    network_layer = network_layer.__dict__[\"_modules\"][extract_idx]\n            else:\n                network_layer = backbone.__dict__[\"_modules\"][extract_layer]\n\n            if isinstance(network_layer, torch.nn.Sequential):\n                self.backbone.hook_handles.append(\n                    network_layer[-1].register_forward_hook(forward_hook)\n                )\n            else:\n                self.backbone.hook_handles.append(\n                    network_layer.register_forward_hook(forward_hook)\n                )\n        self.to(self.device)\n\n    def forward(self, images):\n        self.outputs.clear()\n        with torch.no_grad():\n            # The backbone will throw an Exception once it reached the last\n            # layer to compute features from. Computation will stop there.\n            try:\n                _ = self.backbone(images)\n            except LastLayerToExtractReachedException:\n                pass\n        return self.outputs\n\n    def feature_dimensions(self, input_shape):\n        \"\"\"Computes the feature dimensions for all layers given input_shape.\"\"\"\n        _input = torch.ones([1] + list(input_shape)).to(self.device)\n        _output = self(_input)\n        return [_output[layer].shape[1] for layer in self.layers_to_extract_from]\n\n\nclass ForwardHook:\n    def __init__(self, hook_dict, layer_name: str, last_layer_to_extract: str):\n        self.hook_dict = hook_dict\n        self.layer_name = layer_name\n        self.raise_exception_to_break = copy.deepcopy(\n            layer_name == last_layer_to_extract\n        )\n\n    def __call__(self, module, input, output):\n        self.hook_dict[self.layer_name] = output\n        if self.raise_exception_to_break:\n            raise LastLayerToExtractReachedException()\n        return None\n\n\nclass LastLayerToExtractReachedException(Exception):\n    pass\n\n\nclass NearestNeighbourScorer(object):\n    def __init__(self, n_nearest_neighbours: int, nn_method=FaissNN(False, 4)) -> None:\n        \"\"\"\n        Neearest-Neighbourhood Anomaly Scorer class.\n\n        Args:\n            n_nearest_neighbours: [int] Number of nearest neighbours used to\n                determine anomalous pixels.\n            nn_method: Nearest neighbour search method.\n        \"\"\""
  },
  {
    "id": "306",
    "text": "        )\n\n\nclass ConcatMerger(_BaseMerger):\n    @staticmethod\n    def _reduce(features):\n        # NxCxWxH -> NxCWH\n        return features.reshape(len(features), -1)\n\n\nclass Preprocessing(torch.nn.Module):\n    def __init__(self, input_dims, output_dim):\n        super(Preprocessing, self).__init__()\n        self.input_dims = input_dims\n        self.output_dim = output_dim\n\n        self.preprocessing_modules = torch.nn.ModuleList()\n        for input_dim in input_dims:\n            module = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim\n        features = features.reshape(len(features), 1, -1)\n        features = F.adaptive_avg_pool1d(features, self.target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):\n        self.device = device\n        self.target_size = target_size\n        self.smoothing = 4\n\n    def convert_to_segmentation(self, patch_scores):\n\n        with torch.no_grad():\n            if isinstance(patch_scores, np.ndarray):\n                patch_scores = torch.from_numpy(patch_scores)\n            _scores = patch_scores.to(self.device)\n            _scores = _scores.unsqueeze(1)\n            _scores = F.interpolate(\n                _scores, size=self.target_size, mode=\"bilinear\", align_corners=False\n            )\n            _scores = _scores.squeeze(1)\n            patch_scores = _scores.cpu().numpy()\n\n        return [\n            ndimage.gaussian_filter(patch_score, sigma=self.smoothing)\n            for patch_score in patch_scores\n        ]\n\n\nclass NetworkFeatureAggregator(torch.nn.Module):\n    \"\"\"Efficient extraction of network features.\"\"\"\n\n    def __init__(self, backbone, layers_to_extract_from, device):\n        super(NetworkFeatureAggregator, self).__init__()\n        \"\"\"Extraction of network features.\n\n        Runs a network only to the last layer of the list of layers where\n        network features should be extracted from.\n\n        Args:\n            backbone: torchvision.model\n            layers_to_extract_from: [list of str]\n        \"\"\"\n        self.layers_to_extract_from = layers_to_extract_from\n        self.backbone = backbone\n        self.device = device\n        if not hasattr(backbone, \"hook_handles\"):\n            self.backbone.hook_handles = []\n        for handle in self.backbone.hook_handles:\n            handle.remove()\n        self.outputs = {}\n\n        for extract_layer in layers_to_extract_from:\n            forward_hook = ForwardHook(\n                self.outputs, extract_layer, layers_to_extract_from[-1]\n            )\n            if \".\" in extract_layer:\n                extract_block, extract_idx = extract_layer.split(\".\")\n                network_layer = backbone.__dict__[\"_modules\"][extract_block]\n                if extract_idx.isnumeric():\n                    extract_idx = int(extract_idx)\n                    network_layer = network_layer[extract_idx]\n                else:\n                    network_layer = network_layer.__dict__[\"_modules\"][extract_idx]\n            else:\n                network_layer = backbone.__dict__[\"_modules\"][extract_layer]\n\n            if isinstance(network_layer, torch.nn.Sequential):\n                self.backbone.hook_handles.append(\n                    network_layer[-1].register_forward_hook(forward_hook)\n                )\n            else:\n                self.backbone.hook_handles.append(\n                    network_layer.register_forward_hook(forward_hook)\n                )\n        self.to(self.device)\n\n    def forward(self, images):\n        self.outputs.clear()\n        with torch.no_grad():\n            # The backbone will throw an Exception once it reached the last\n            # layer to compute features from. Computation will stop there.\n            try:\n                _ = self.backbone(images)\n            except LastLayerToExtractReachedException:\n                pass\n        return self.outputs\n\n    def feature_dimensions(self, input_shape):\n        \"\"\"Computes the feature dimensions for all layers given input_shape.\"\"\"\n        _input = torch.ones([1] + list(input_shape)).to(self.device)\n        _output = self(_input)\n        return [_output[layer].shape[1] for layer in self.layers_to_extract_from]\n\n\nclass ForwardHook:\n    def __init__(self, hook_dict, layer_name: str, last_layer_to_extract: str):\n        self.hook_dict = hook_dict\n        self.layer_name = layer_name\n        self.raise_exception_to_break = copy.deepcopy(\n            layer_name == last_layer_to_extract\n        )\n\n    def __call__(self, module, input, output):\n        self.hook_dict[self.layer_name] = output\n        if self.raise_exception_to_break:\n            raise LastLayerToExtractReachedException()\n        return None\n\n\nclass LastLayerToExtractReachedException(Exception):\n    pass\n\n\nclass NearestNeighbourScorer(object):\n    def __init__(self, n_nearest_neighbours: int, nn_method=FaissNN(False, 4)) -> None:\n        \"\"\"\n        Neearest-Neighbourhood Anomaly Scorer class.\n\n        Args:\n            n_nearest_neighbours: [int] Number of nearest neighbours used to\n                determine anomalous pixels.\n            nn_method: Nearest neighbour search method.\n        \"\"\"\n        self.feature_merger = ConcatMerger()\n\n        self.n_nearest_neighbours = n_nearest_neighbours\n        self.nn_method = nn_method\n\n        self.imagelevel_nn = lambda query: self.nn_method.run(\n            n_nearest_neighbours, query\n        )\n        self.pixelwise_nn = lambda query, index: self.nn_method.run(1, query, index)\n\n    def fit(self, detection_features: List[np.ndarray]) -> None:\n        \"\"\"Calls the fit function of the nearest neighbour method.\n\n        Args:\n            detection_features: [list of np.arrays]\n                [[bs x d_i] for i in n] Contains a list of\n                np.arrays for all training images corresponding to respective\n                features VECTORS (or maps, but will be resized) produced by\n                some backbone network which should be used for image-level\n                anomaly detection.\n        \"\"\""
  },
  {
    "id": "307",
    "text": " = MeanMapper(output_dim)\n            self.preprocessing_modules.append(module)\n\n    def forward(self, features):\n        _features = []\n        for module, feature in zip(self.preprocessing_modules, features):\n            _features.append(module(feature))\n        return torch.stack(_features, dim=1)\n\n\nclass MeanMapper(torch.nn.Module):\n    def __init__(self, preprocessing_dim):\n        super(MeanMapper, self).__init__()\n        self.preprocessing_dim = preprocessing_dim\n\n    def forward(self, features):\n        features = features.reshape(len(features), 1, -1)\n        return F.adaptive_avg_pool1d(features, self.preprocessing_dim).squeeze(1)\n\n\nclass Aggregator(torch.nn.Module):\n    def __init__(self, target_dim):\n        super(Aggregator, self).__init__()\n        self.target_dim = target_dim\n\n    def forward(self, features):\n        \"\"\"Returns reshaped and average pooled features.\"\"\"\n        # batchsize x number_of_layers x input_dim -> batchsize x target_dim\n        features = features.reshape(len(features), 1, -1)\n        features = F.adaptive_avg_pool1d(features, self.target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):\n        self.device = device\n        self.target_size = target_size\n        self.smoothing = 4\n\n    def convert_to_segmentation(self, patch_scores):\n\n        with torch.no_grad():\n            if isinstance(patch_scores, np.ndarray):\n                patch_scores = torch.from_numpy(patch_scores)\n            _scores = patch_scores.to(self.device)\n            _scores = _scores.unsqueeze(1)\n            _scores = F.interpolate(\n                _scores, size=self.target_size, mode=\"bilinear\", align_corners=False\n            )\n            _scores = _scores.squeeze(1)\n            patch_scores = _scores.cpu().numpy()\n\n        return [\n            ndimage.gaussian_filter(patch_score, sigma=self.smoothing)\n            for patch_score in patch_scores\n        ]\n\n\nclass NetworkFeatureAggregator(torch.nn.Module):\n    \"\"\"Efficient extraction of network features.\"\"\"\n\n    def __init__(self, backbone, layers_to_extract_from, device):\n        super(NetworkFeatureAggregator, self).__init__()\n        \"\"\"Extraction of network features.\n\n        Runs a network only to the last layer of the list of layers where\n        network features should be extracted from.\n\n        Args:\n            backbone: torchvision.model\n            layers_to_extract_from: [list of str]\n        \"\"\"\n        self.layers_to_extract_from = layers_to_extract_from\n        self.backbone = backbone\n        self.device = device\n        if not hasattr(backbone, \"hook_handles\"):\n            self.backbone.hook_handles = []\n        for handle in self.backbone.hook_handles:\n            handle.remove()\n        self.outputs = {}\n\n        for extract_layer in layers_to_extract_from:\n            forward_hook = ForwardHook(\n                self.outputs, extract_layer, layers_to_extract_from[-1]\n            )\n            if \".\" in extract_layer:\n                extract_block, extract_idx = extract_layer.split(\".\")\n                network_layer = backbone.__dict__[\"_modules\"][extract_block]\n                if extract_idx.isnumeric():\n                    extract_idx = int(extract_idx)\n                    network_layer = network_layer[extract_idx]\n                else:\n                    network_layer = network_layer.__dict__[\"_modules\"][extract_idx]\n            else:\n                network_layer = backbone.__dict__[\"_modules\"][extract_layer]\n\n            if isinstance(network_layer, torch.nn.Sequential):\n                self.backbone.hook_handles.append(\n                    network_layer[-1].register_forward_hook(forward_hook)\n                )\n            else:\n                self.backbone.hook_handles.append(\n                    network_layer.register_forward_hook(forward_hook)\n                )\n        self.to(self.device)\n\n    def forward(self, images):\n        self.outputs.clear()\n        with torch.no_grad():\n            # The backbone will throw an Exception once it reached the last\n            # layer to compute features from. Computation will stop there.\n            try:\n                _ = self.backbone(images)\n            except LastLayerToExtractReachedException:\n                pass\n        return self.outputs\n\n    def feature_dimensions(self, input_shape):\n        \"\"\"Computes the feature dimensions for all layers given input_shape.\"\"\"\n        _input = torch.ones([1] + list(input_shape)).to(self.device)\n        _output = self(_input)\n        return [_output[layer].shape[1] for layer in self.layers_to_extract_from]\n\n\nclass ForwardHook:\n    def __init__(self, hook_dict, layer_name: str, last_layer_to_extract: str):\n        self.hook_dict = hook_dict\n        self.layer_name = layer_name\n        self.raise_exception_to_break = copy.deepcopy(\n            layer_name == last_layer_to_extract\n        )\n\n    def __call__(self, module, input, output):\n        self.hook_dict[self.layer_name] = output\n        if self.raise_exception_to_break:\n            raise LastLayerToExtractReachedException()\n        return None\n\n\nclass LastLayerToExtractReachedException(Exception):\n    pass\n\n\nclass NearestNeighbourScorer(object):\n    def __init__(self, n_nearest_neighbours: int, nn_method=FaissNN(False, 4)) -> None:\n        \"\"\"\n        Neearest-Neighbourhood Anomaly Scorer class.\n\n        Args:\n            n_nearest_neighbours: [int] Number of nearest neighbours used to\n                determine anomalous pixels.\n            nn_method: Nearest neighbour search method.\n        \"\"\"\n        self.feature_merger = ConcatMerger()\n\n        self.n_nearest_neighbours = n_nearest_neighbours\n        self.nn_method = nn_method\n\n        self.imagelevel_nn = lambda query: self.nn_method.run(\n            n_nearest_neighbours, query\n        )\n        self.pixelwise_nn = lambda query, index: self.nn_method.run(1, query, index)\n\n    def fit(self, detection_features: List[np.ndarray]) -> None:\n        \"\"\"Calls the fit function of the nearest neighbour method.\n\n        Args:\n            detection_features: [list of np.arrays]\n                [[bs x d_i] for i in n] Contains a list of\n                np.arrays for all training images corresponding to respective\n                features VECTORS (or maps, but will be resized) produced by\n                some backbone network which should be used for image-level\n                anomaly detection.\n        \"\"\"\n        self.detection_features = self.feature_merger.merge(\n            detection_features,\n        )\n        self.nn_method.fit(self.detection_features)\n\n    def predict(\n        self, query_features: List[np.ndarray]\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Predicts anomaly score.\n\n        Searches for nearest neighbours of test images in all\n        support training images.\n\n        Args:\n             detection_query_features: [dict of np.arrays] List of np.arrays\n                 corresponding to the test features generated by\n                 some backbone network.\n        \"\"\""
  },
  {
    "id": "308",
    "text": "target_dim)\n        return features.reshape(len(features), -1)\n\n\nclass RescaleSegmentor:\n    def __init__(self, device, target_size=224):\n        self.device = device\n        self.target_size = target_size\n        self.smoothing = 4\n\n    def convert_to_segmentation(self, patch_scores):\n\n        with torch.no_grad():\n            if isinstance(patch_scores, np.ndarray):\n                patch_scores = torch.from_numpy(patch_scores)\n            _scores = patch_scores.to(self.device)\n            _scores = _scores.unsqueeze(1)\n            _scores = F.interpolate(\n                _scores, size=self.target_size, mode=\"bilinear\", align_corners=False\n            )\n            _scores = _scores.squeeze(1)\n            patch_scores = _scores.cpu().numpy()\n\n        return [\n            ndimage.gaussian_filter(patch_score, sigma=self.smoothing)\n            for patch_score in patch_scores\n        ]\n\n\nclass NetworkFeatureAggregator(torch.nn.Module):\n    \"\"\"Efficient extraction of network features.\"\"\"\n\n    def __init__(self, backbone, layers_to_extract_from, device):\n        super(NetworkFeatureAggregator, self).__init__()\n        \"\"\"Extraction of network features.\n\n        Runs a network only to the last layer of the list of layers where\n        network features should be extracted from.\n\n        Args:\n            backbone: torchvision.model\n            layers_to_extract_from: [list of str]\n        \"\"\"\n        self.layers_to_extract_from = layers_to_extract_from\n        self.backbone = backbone\n        self.device = device\n        if not hasattr(backbone, \"hook_handles\"):\n            self.backbone.hook_handles = []\n        for handle in self.backbone.hook_handles:\n            handle.remove()\n        self.outputs = {}\n\n        for extract_layer in layers_to_extract_from:\n            forward_hook = ForwardHook(\n                self.outputs, extract_layer, layers_to_extract_from[-1]\n            )\n            if \".\" in extract_layer:\n                extract_block, extract_idx = extract_layer.split(\".\")\n                network_layer = backbone.__dict__[\"_modules\"][extract_block]\n                if extract_idx.isnumeric():\n                    extract_idx = int(extract_idx)\n                    network_layer = network_layer[extract_idx]\n                else:\n                    network_layer = network_layer.__dict__[\"_modules\"][extract_idx]\n            else:\n                network_layer = backbone.__dict__[\"_modules\"][extract_layer]\n\n            if isinstance(network_layer, torch.nn.Sequential):\n                self.backbone.hook_handles.append(\n                    network_layer[-1].register_forward_hook(forward_hook)\n                )\n            else:\n                self.backbone.hook_handles.append(\n                    network_layer.register_forward_hook(forward_hook)\n                )\n        self.to(self.device)\n\n    def forward(self, images):\n        self.outputs.clear()\n        with torch.no_grad():\n            # The backbone will throw an Exception once it reached the last\n            # layer to compute features from. Computation will stop there.\n            try:\n                _ = self.backbone(images)\n            except LastLayerToExtractReachedException:\n                pass\n        return self.outputs\n\n    def feature_dimensions(self, input_shape):\n        \"\"\"Computes the feature dimensions for all layers given input_shape.\"\"\"\n        _input = torch.ones([1] + list(input_shape)).to(self.device)\n        _output = self(_input)\n        return [_output[layer].shape[1] for layer in self.layers_to_extract_from]\n\n\nclass ForwardHook:\n    def __init__(self, hook_dict, layer_name: str, last_layer_to_extract: str):\n        self.hook_dict = hook_dict\n        self.layer_name = layer_name\n        self.raise_exception_to_break = copy.deepcopy(\n            layer_name == last_layer_to_extract\n        )\n\n    def __call__(self, module, input, output):\n        self.hook_dict[self.layer_name] = output\n        if self.raise_exception_to_break:\n            raise LastLayerToExtractReachedException()\n        return None\n\n\nclass LastLayerToExtractReachedException(Exception):\n    pass\n\n\nclass NearestNeighbourScorer(object):\n    def __init__(self, n_nearest_neighbours: int, nn_method=FaissNN(False, 4)) -> None:\n        \"\"\"\n        Neearest-Neighbourhood Anomaly Scorer class.\n\n        Args:\n            n_nearest_neighbours: [int] Number of nearest neighbours used to\n                determine anomalous pixels.\n            nn_method: Nearest neighbour search method.\n        \"\"\"\n        self.feature_merger = ConcatMerger()\n\n        self.n_nearest_neighbours = n_nearest_neighbours\n        self.nn_method = nn_method\n\n        self.imagelevel_nn = lambda query: self.nn_method.run(\n            n_nearest_neighbours, query\n        )\n        self.pixelwise_nn = lambda query, index: self.nn_method.run(1, query, index)\n\n    def fit(self, detection_features: List[np.ndarray]) -> None:\n        \"\"\"Calls the fit function of the nearest neighbour method.\n\n        Args:\n            detection_features: [list of np.arrays]\n                [[bs x d_i] for i in n] Contains a list of\n                np.arrays for all training images corresponding to respective\n                features VECTORS (or maps, but will be resized) produced by\n                some backbone network which should be used for image-level\n                anomaly detection.\n        \"\"\"\n        self.detection_features = self.feature_merger.merge(\n            detection_features,\n        )\n        self.nn_method.fit(self.detection_features)\n\n    def predict(\n        self, query_features: List[np.ndarray]\n    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Predicts anomaly score.\n\n        Searches for nearest neighbours of test images in all\n        support training images.\n\n        Args:\n             detection_query_features: [dict of np.arrays] List of np.arrays\n                 corresponding to the test features generated by\n                 some backbone network.\n        \"\"\"\n        query_features = self.feature_merger.merge(\n            query_features,\n        )\n        query_distances, query_nns = self.imagelevel_nn(query_features)\n        anomaly_scores = np.mean(query_distances, axis=-1)\n        return anomaly_scores, query_distances, query_nns\n\n    @staticmethod\n    def _detection_file(folder, prepend=\"\"):\n        return os.path.join(folder, prepend + \"nnscorer_features.pkl\")\n\n    @staticmethod\n    def _index_file(folder, prepend=\"\"):\n        return os.path.join(folder, prepend + \"nnscorer_search_index.faiss\")\n\n    @staticmethod\n    def _save(filename, features):\n        if features is None:\n            return\n        with open(filename, \"wb\") as save_file:\n            pickle.dump(features, save_file, pickle.HIGHEST_PROTOCOL)\n\n    @staticmethod\n    def _load(filename: str):\n        with open(filename, \"rb\") as load_file:\n            return pickle.load(load_file)\n\n    def save(\n        self,\n        save_folder: str,\n        save_features_separately: bool = False,\n        prepend: str = \"\",\n    ) -> None:"
  },
  {
    "id": "309",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport fnmatch\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Set, Type, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom iopath.common.file_io import g_pathmgr\nfrom omegaconf import OmegaConf\n\nfrom .model_wrappers import MIMOHeadWrapper\n\n\ndef _unix_pattern_to_parameter_names(\n    constraints: List[str], all_parameter_names: Set[str]\n) -> Union[None, Set[str]]:"
  },
  {
    "id": "310",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport fnmatch\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Set, Type, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom iopath.common.file_io import g_pathmgr\nfrom omegaconf import OmegaConf\n\nfrom .model_wrappers import MIMOHeadWrapper\n\n\ndef _unix_pattern_to_parameter_names(\n    constraints: List[str], all_parameter_names: Set[str]\n) -> Union[None, Set[str]]:\n\n    parameter_names = []\n    for param_name in constraints:\n        matching_parameters = set(fnmatch.filter(all_parameter_names, param_name))\n        assert (\n            len(matching_parameters) > 0\n        ), f\"param_names {param_name} don't match any param in the given names.\"\n        parameter_names.append(matching_parameters)\n    return set.union(*parameter_names)\n\n\nclass CkptIncludeKernel:\n    \"\"\"\n    Includes only the keys from the given model state_dict that match the key_pattern.\n    Rest of the keys are removed from the given state_dict.\n\n    Args:\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, key_pattern: List[str]):\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\""
  },
  {
    "id": "311",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport fnmatch\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Set, Type, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom iopath.common.file_io import g_pathmgr\nfrom omegaconf import OmegaConf\n\nfrom .model_wrappers import MIMOHeadWrapper\n\n\ndef _unix_pattern_to_parameter_names(\n    constraints: List[str], all_parameter_names: Set[str]\n) -> Union[None, Set[str]]:\n\n    parameter_names = []\n    for param_name in constraints:\n        matching_parameters = set(fnmatch.filter(all_parameter_names, param_name))\n        assert (\n            len(matching_parameters) > 0\n        ), f\"param_names {param_name} don't match any param in the given names.\"\n        parameter_names.append(matching_parameters)\n    return set.union(*parameter_names)\n\n\nclass CkptIncludeKernel:\n    \"\"\"\n    Includes only the keys from the given model state_dict that match the key_pattern.\n    Rest of the keys are removed from the given state_dict.\n\n    Args:\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, key_pattern: List[str]):\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        include_keys = _unix_pattern_to_parameter_names(\n            self.key_pattern, state_dict.keys()\n        )\n\n        new_state_dict = {}\n        for key in include_keys:\n            new_state_dict[key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptExcludeKernel:\n    \"\"\"\n    Removes the keys from the given model state_dict that match the key_pattern.\n\n    Args:\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, key_pattern: List[str]):\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\""
  },
  {
    "id": "312",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport fnmatch\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Set, Type, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom iopath.common.file_io import g_pathmgr\nfrom omegaconf import OmegaConf\n\nfrom .model_wrappers import MIMOHeadWrapper\n\n\ndef _unix_pattern_to_parameter_names(\n    constraints: List[str], all_parameter_names: Set[str]\n) -> Union[None, Set[str]]:\n\n    parameter_names = []\n    for param_name in constraints:\n        matching_parameters = set(fnmatch.filter(all_parameter_names, param_name))\n        assert (\n            len(matching_parameters) > 0\n        ), f\"param_names {param_name} don't match any param in the given names.\"\n        parameter_names.append(matching_parameters)\n    return set.union(*parameter_names)\n\n\nclass CkptIncludeKernel:\n    \"\"\"\n    Includes only the keys from the given model state_dict that match the key_pattern.\n    Rest of the keys are removed from the given state_dict.\n\n    Args:\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, key_pattern: List[str]):\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        include_keys = _unix_pattern_to_parameter_names(\n            self.key_pattern, state_dict.keys()\n        )\n\n        new_state_dict = {}\n        for key in include_keys:\n            new_state_dict[key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptExcludeKernel:\n    \"\"\"\n    Removes the keys from the given model state_dict that match the key_pattern.\n\n    Args:\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, key_pattern: List[str]):\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        exclude_keys = _unix_pattern_to_parameter_names(\n            self.key_pattern, state_dict.keys()\n        )\n        include_keys = set(state_dict.keys()) - exclude_keys\n\n        new_state_dict = {}\n        for key in include_keys:\n            new_state_dict[key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptPrependKernel:\n    \"\"\"\n    Prepends the given pattern to all the keys in the checkpoint state dict after\n    selecting them with key_pattern.\n\n    For instance, if prepend_pattern  = \"some_prepend.\" and\n    key_pattern = [\"model.head\"], this kernel would prepend \"some_prepend.\" to\n    \"model.key\", thus renaming the key \"model.head\" to \"some_prepend.model.head\".\n\n    Args:\n        prepend_pattern: The pattern to prepend the keys in the state_dict with.\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, prepend_pattern: str, key_pattern: List[str]):\n        self.prepend_pattern = prepend_pattern\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        all_keys = set(state_dict.keys())\n\n        include_keys = set(state_dict.keys())\n        if self.key_pattern is not None:\n            include_keys = _unix_pattern_to_parameter_names(\n                self.key_pattern, state_dict.keys()\n            )\n\n        excluded_keys = all_keys - include_keys\n\n        # Add excluded keys from re-mapping\n        new_state_dict = {}\n        for k in excluded_keys:\n            new_state_dict[k] = state_dict[k]\n\n        # Add keys from remapping\n        for key in include_keys:\n            new_state_dict[self.prepend_pattern + key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptRenameWithCopyKernel:\n    \"\"\"\n    Renames and also optionally creates copyies of the key-value pairs in the checkpoint\n    state dict. Before doing so, selects the keys to which to apply this kernel by\n    using key_pattern.\n\n    For instance, if source_pattern  = \"model.head\" and\n    target_patterns = [\"model.head_1\", \"model.head_2\"], this kernel would\n    rename the key \"model.head\" to \"model.head_1\" and will also create a copy of the\n    \"model.head\" and assign it a new name \"model.head_2\".\n\n    Args:\n        source_pattern: The pattern that needs to be renamed in the current\n            checkpoint state_dict.\n        target_patterns: A list of patterns to which the source_pattern is to be\n            renamed to it. If the list has more than one element, it creates multiple\n            copies of the source_pattern value and assigns then the names given in\n            target_pattern.\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_pattern: str,\n        target_patterns: List[str],\n        key_pattern: Optional[List[str]] = None,\n    ):"
  },
  {
    "id": "313",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport fnmatch\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Set, Type, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom iopath.common.file_io import g_pathmgr\nfrom omegaconf import OmegaConf\n\nfrom .model_wrappers import MIMOHeadWrapper\n\n\ndef _unix_pattern_to_parameter_names(\n    constraints: List[str], all_parameter_names: Set[str]\n) -> Union[None, Set[str]]:\n\n    parameter_names = []\n    for param_name in constraints:\n        matching_parameters = set(fnmatch.filter(all_parameter_names, param_name))\n        assert (\n            len(matching_parameters) > 0\n        ), f\"param_names {param_name} don't match any param in the given names.\"\n        parameter_names.append(matching_parameters)\n    return set.union(*parameter_names)\n\n\nclass CkptIncludeKernel:\n    \"\"\"\n    Includes only the keys from the given model state_dict that match the key_pattern.\n    Rest of the keys are removed from the given state_dict.\n\n    Args:\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, key_pattern: List[str]):\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        include_keys = _unix_pattern_to_parameter_names(\n            self.key_pattern, state_dict.keys()\n        )\n\n        new_state_dict = {}\n        for key in include_keys:\n            new_state_dict[key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptExcludeKernel:\n    \"\"\"\n    Removes the keys from the given model state_dict that match the key_pattern.\n\n    Args:\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, key_pattern: List[str]):\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        exclude_keys = _unix_pattern_to_parameter_names(\n            self.key_pattern, state_dict.keys()\n        )\n        include_keys = set(state_dict.keys()) - exclude_keys\n\n        new_state_dict = {}\n        for key in include_keys:\n            new_state_dict[key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptPrependKernel:\n    \"\"\"\n    Prepends the given pattern to all the keys in the checkpoint state dict after\n    selecting them with key_pattern.\n\n    For instance, if prepend_pattern  = \"some_prepend.\" and\n    key_pattern = [\"model.head\"], this kernel would prepend \"some_prepend.\" to\n    \"model.key\", thus renaming the key \"model.head\" to \"some_prepend.model.head\".\n\n    Args:\n        prepend_pattern: The pattern to prepend the keys in the state_dict with.\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, prepend_pattern: str, key_pattern: List[str]):\n        self.prepend_pattern = prepend_pattern\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        all_keys = set(state_dict.keys())\n\n        include_keys = set(state_dict.keys())\n        if self.key_pattern is not None:\n            include_keys = _unix_pattern_to_parameter_names(\n                self.key_pattern, state_dict.keys()\n            )\n\n        excluded_keys = all_keys - include_keys\n\n        # Add excluded keys from re-mapping\n        new_state_dict = {}\n        for k in excluded_keys:\n            new_state_dict[k] = state_dict[k]\n\n        # Add keys from remapping\n        for key in include_keys:\n            new_state_dict[self.prepend_pattern + key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptRenameWithCopyKernel:\n    \"\"\"\n    Renames and also optionally creates copyies of the key-value pairs in the checkpoint\n    state dict. Before doing so, selects the keys to which to apply this kernel by\n    using key_pattern.\n\n    For instance, if source_pattern  = \"model.head\" and\n    target_patterns = [\"model.head_1\", \"model.head_2\"], this kernel would\n    rename the key \"model.head\" to \"model.head_1\" and will also create a copy of the\n    \"model.head\" and assign it a new name \"model.head_2\".\n\n    Args:\n        source_pattern: The pattern that needs to be renamed in the current\n            checkpoint state_dict.\n        target_patterns: A list of patterns to which the source_pattern is to be\n            renamed to it. If the list has more than one element, it creates multiple\n            copies of the source_pattern value and assigns then the names given in\n            target_pattern.\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_pattern: str,\n        target_patterns: List[str],\n        key_pattern: Optional[List[str]] = None,\n    ):\n        self.source_pattern = source_pattern\n        self.target_patterns = target_patterns\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        # Replaces only first occurences"
  },
  {
    "id": "314",
    "text": "            self.key_pattern, state_dict.keys()\n        )\n\n        new_state_dict = {}\n        for key in include_keys:\n            new_state_dict[key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptExcludeKernel:\n    \"\"\"\n    Removes the keys from the given model state_dict that match the key_pattern.\n\n    Args:\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, key_pattern: List[str]):\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        exclude_keys = _unix_pattern_to_parameter_names(\n            self.key_pattern, state_dict.keys()\n        )\n        include_keys = set(state_dict.keys()) - exclude_keys\n\n        new_state_dict = {}\n        for key in include_keys:\n            new_state_dict[key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptPrependKernel:\n    \"\"\"\n    Prepends the given pattern to all the keys in the checkpoint state dict after\n    selecting them with key_pattern.\n\n    For instance, if prepend_pattern  = \"some_prepend.\" and\n    key_pattern = [\"model.head\"], this kernel would prepend \"some_prepend.\" to\n    \"model.key\", thus renaming the key \"model.head\" to \"some_prepend.model.head\".\n\n    Args:\n        prepend_pattern: The pattern to prepend the keys in the state_dict with.\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, prepend_pattern: str, key_pattern: List[str]):\n        self.prepend_pattern = prepend_pattern\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        all_keys = set(state_dict.keys())\n\n        include_keys = set(state_dict.keys())\n        if self.key_pattern is not None:\n            include_keys = _unix_pattern_to_parameter_names(\n                self.key_pattern, state_dict.keys()\n            )\n\n        excluded_keys = all_keys - include_keys\n\n        # Add excluded keys from re-mapping\n        new_state_dict = {}\n        for k in excluded_keys:\n            new_state_dict[k] = state_dict[k]\n\n        # Add keys from remapping\n        for key in include_keys:\n            new_state_dict[self.prepend_pattern + key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptRenameWithCopyKernel:\n    \"\"\"\n    Renames and also optionally creates copyies of the key-value pairs in the checkpoint\n    state dict. Before doing so, selects the keys to which to apply this kernel by\n    using key_pattern.\n\n    For instance, if source_pattern  = \"model.head\" and\n    target_patterns = [\"model.head_1\", \"model.head_2\"], this kernel would\n    rename the key \"model.head\" to \"model.head_1\" and will also create a copy of the\n    \"model.head\" and assign it a new name \"model.head_2\".\n\n    Args:\n        source_pattern: The pattern that needs to be renamed in the current\n            checkpoint state_dict.\n        target_patterns: A list of patterns to which the source_pattern is to be\n            renamed to it. If the list has more than one element, it creates multiple\n            copies of the source_pattern value and assigns then the names given in\n            target_pattern.\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_pattern: str,\n        target_patterns: List[str],\n        key_pattern: Optional[List[str]] = None,\n    ):\n        self.source_pattern = source_pattern\n        self.target_patterns = target_patterns\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        # Replaces only first occurences\n        all_keys = set(state_dict.keys())\n\n        include_keys = set(state_dict.keys())\n        if self.key_pattern is not None:\n            include_keys = _unix_pattern_to_parameter_names(\n                self.key_pattern, state_dict.keys()\n            )\n\n        excluded_keys = all_keys - include_keys\n\n        # Add excluded keys from re-mapping\n        new_state_dict = {}\n        for k in excluded_keys:\n            new_state_dict[k] = state_dict[k]\n\n        # Add keys from remapping\n        for key in include_keys:\n            if self.source_pattern in key:\n                for target_pattern in self.target_patterns:\n                    new_key = key.replace(self.source_pattern, target_pattern, 1)\n                    new_state_dict[new_key] = state_dict[key]\n            else:\n                new_state_dict[key] = state_dict[key]\n\n        return new_state_dict\n\n\ndef load_checkpoint(\n    path_list: List[str],\n    pick_recursive_keys: Optional[List[str]] = None,\n    map_location: str = \"cpu\",\n) -> Any:\n    \"\"\"\n    Loads a checkpoint from the specified path.\n\n    Args:\n        path_list: A list of paths which contain the checkpoint. Each element\n            is tried (in order) until a file that exists is found. That file is then\n            used to read the checkpoint.\n        pick_recursive_keys: Picks sub dicts from the loaded checkpoint if not None.\n            For pick_recursive_keys = [\"a\", \"b\"], will return checkpoint_dict[\"a\"][\"b\"]\n        map_location (str): a function, torch.device, string or a dict specifying how to\n            remap storage locations\n\n    Returns: Model with the matchin pre-trained weights loaded.\n    \"\"\"\n    path_exists = False\n    for path in path_list:\n        if g_pathmgr.exists(path):\n            path_exists = True\n            break\n\n    if not path_exists:\n        raise ValueError(f\"No path exists in {path_list}\")\n\n    with g_pathmgr.open(path, \"rb\") as f:\n        checkpoint = torch.load(f, map_location=map_location)\n\n    logging.info(f\"Loaded checkpoint from {path}\")\n    if pick_recursive_keys is not None:\n        for key in pick_recursive_keys:\n            checkpoint = checkpoint[key]\n    return checkpoint\n\n\ndef load_checkpoint_and_apply_kernels(\n    checkpoint_path: str,\n    checkpoint_kernels: List[Callable] = None,\n    ckpt_state_dict_key: str = \"state_dict\",\n    map_location: str = None,\n) -> nn.Module:\n    \"\"\"\n    Performs checkpoint loading with a variety of pre-processing kernel applied in\n    sequence.\n\n    Args:\n        checkpoint_path (str): Path to the checkpoint.\n        checkpoint_kernels List(Callable): A list of checkpoint processing kernels\n            to apply in the specified order. Supported kernels include `CkptIncludeKernel`,\n            `CkptExcludeKernel`, etc. These kernels are applied in the\n            given order.\n        ckpt_state_dict_key (str): Key containing the model state dict.\n        map_location (str): a function, torch.device, string or a dict specifying how to\n            remap storage locations\n\n    Returns: Model with the matchin pre-trained weights loaded.\n    \"\"\""
  },
  {
    "id": "315",
    "text": " \"model.key\", thus renaming the key \"model.head\" to \"some_prepend.model.head\".\n\n    Args:\n        prepend_pattern: The pattern to prepend the keys in the state_dict with.\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(self, prepend_pattern: str, key_pattern: List[str]):\n        self.prepend_pattern = prepend_pattern\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        all_keys = set(state_dict.keys())\n\n        include_keys = set(state_dict.keys())\n        if self.key_pattern is not None:\n            include_keys = _unix_pattern_to_parameter_names(\n                self.key_pattern, state_dict.keys()\n            )\n\n        excluded_keys = all_keys - include_keys\n\n        # Add excluded keys from re-mapping\n        new_state_dict = {}\n        for k in excluded_keys:\n            new_state_dict[k] = state_dict[k]\n\n        # Add keys from remapping\n        for key in include_keys:\n            new_state_dict[self.prepend_pattern + key] = state_dict[key]\n\n        return new_state_dict\n\n\nclass CkptRenameWithCopyKernel:\n    \"\"\"\n    Renames and also optionally creates copyies of the key-value pairs in the checkpoint\n    state dict. Before doing so, selects the keys to which to apply this kernel by\n    using key_pattern.\n\n    For instance, if source_pattern  = \"model.head\" and\n    target_patterns = [\"model.head_1\", \"model.head_2\"], this kernel would\n    rename the key \"model.head\" to \"model.head_1\" and will also create a copy of the\n    \"model.head\" and assign it a new name \"model.head_2\".\n\n    Args:\n        source_pattern: The pattern that needs to be renamed in the current\n            checkpoint state_dict.\n        target_patterns: A list of patterns to which the source_pattern is to be\n            renamed to it. If the list has more than one element, it creates multiple\n            copies of the source_pattern value and assigns then the names given in\n            target_pattern.\n        key_pattern: Patterns used to select the keys in the state_dict\n            that are eligible for this kernel.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_pattern: str,\n        target_patterns: List[str],\n        key_pattern: Optional[List[str]] = None,\n    ):\n        self.source_pattern = source_pattern\n        self.target_patterns = target_patterns\n        self.key_pattern = key_pattern\n\n    def __call__(self, state_dict: Dict):\n        \"\"\"\n        Args:\n            state_dict: A dictionary representing the given checkpoint's state dict.\n        \"\"\"\n\n        # Replaces only first occurences\n        all_keys = set(state_dict.keys())\n\n        include_keys = set(state_dict.keys())\n        if self.key_pattern is not None:\n            include_keys = _unix_pattern_to_parameter_names(\n                self.key_pattern, state_dict.keys()\n            )\n\n        excluded_keys = all_keys - include_keys\n\n        # Add excluded keys from re-mapping\n        new_state_dict = {}\n        for k in excluded_keys:\n            new_state_dict[k] = state_dict[k]\n\n        # Add keys from remapping\n        for key in include_keys:\n            if self.source_pattern in key:\n                for target_pattern in self.target_patterns:\n                    new_key = key.replace(self.source_pattern, target_pattern, 1)\n                    new_state_dict[new_key] = state_dict[key]\n            else:\n                new_state_dict[key] = state_dict[key]\n\n        return new_state_dict\n\n\ndef load_checkpoint(\n    path_list: List[str],\n    pick_recursive_keys: Optional[List[str]] = None,\n    map_location: str = \"cpu\",\n) -> Any:\n    \"\"\"\n    Loads a checkpoint from the specified path.\n\n    Args:\n        path_list: A list of paths which contain the checkpoint. Each element\n            is tried (in order) until a file that exists is found. That file is then\n            used to read the checkpoint.\n        pick_recursive_keys: Picks sub dicts from the loaded checkpoint if not None.\n            For pick_recursive_keys = [\"a\", \"b\"], will return checkpoint_dict[\"a\"][\"b\"]\n        map_location (str): a function, torch.device, string or a dict specifying how to\n            remap storage locations\n\n    Returns: Model with the matchin pre-trained weights loaded.\n    \"\"\"\n    path_exists = False\n    for path in path_list:\n        if g_pathmgr.exists(path):\n            path_exists = True\n            break\n\n    if not path_exists:\n        raise ValueError(f\"No path exists in {path_list}\")\n\n    with g_pathmgr.open(path, \"rb\") as f:\n        checkpoint = torch.load(f, map_location=map_location)\n\n    logging.info(f\"Loaded checkpoint from {path}\")\n    if pick_recursive_keys is not None:\n        for key in pick_recursive_keys:\n            checkpoint = checkpoint[key]\n    return checkpoint\n\n\ndef load_checkpoint_and_apply_kernels(\n    checkpoint_path: str,\n    checkpoint_kernels: List[Callable] = None,\n    ckpt_state_dict_key: str = \"state_dict\",\n    map_location: str = None,\n) -> nn.Module:\n    \"\"\"\n    Performs checkpoint loading with a variety of pre-processing kernel applied in\n    sequence.\n\n    Args:\n        checkpoint_path (str): Path to the checkpoint.\n        checkpoint_kernels List(Callable): A list of checkpoint processing kernels\n            to apply in the specified order. Supported kernels include `CkptIncludeKernel`,\n            `CkptExcludeKernel`, etc. These kernels are applied in the\n            given order.\n        ckpt_state_dict_key (str): Key containing the model state dict.\n        map_location (str): a function, torch.device, string or a dict specifying how to\n            remap storage locations\n\n    Returns: Model with the matchin pre-trained weights loaded.\n    \"\"\"\n    assert g_pathmgr.exists(checkpoint_path), \"Checkpoint '{}' not found\".format(\n        checkpoint_path\n    )\n\n    # Load the checkpoint on CPU to avoid GPU mem spike.\n    with g_pathmgr.open(checkpoint_path, \"rb\") as f:\n        checkpoint = torch.load(f, map_location=map_location)\n\n    pre_train_dict = (\n        checkpoint[ckpt_state_dict_key] if ckpt_state_dict_key else checkpoint\n    )\n\n    logging.info(\n        \"Loaded Checkpoint State Dict pre-kernel application: %s\"\n        % str(\", \".join(list(pre_train_dict.keys())))\n    )\n    # Apply kernels\n    if checkpoint_kernels is not None:\n        for f in checkpoint_kernels:\n            pre_train_dict = f(state_dict=pre_train_dict)\n\n    logging.info(\n        \"Loaded Checkpoint State Dict Post-kernel application %s\"\n        % str(\", \".join(list(pre_train_dict.keys())))\n    )\n\n    return pre_train_dict\n\n\ndef load_state_dict_into_model(state_dict: Dict, model: nn.Module, strict: bool = True):\n    \"\"\"\n    Loads a state dict into the given model.\n\n    Args:\n        state_dict: A dictionary containing the model's\n            state dict, or a subset if strict is False\n        model: Model to load the checkpoint weights into\n        strict: raise if the state_dict has missing state keys\n    \"\"\""
  },
  {
    "id": "316",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport copy\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Mapping, Optional, Sequence\n\nimport numpy as np\n\nimport torch\nimport torch.nn as nn\nfrom omnivision.data.api import VisionSample\n\n\nclass MIMOHeadWrapper(nn.Module):\n    \"\"\"Attaches multiple input multiple output heads to the trunk using forward hooks.\n\n    Args:\n        trunk: Any model to which you want to attach the heads to.\n        heads: A list of dicts with the following keys:\n            fork_module: The module which the head will be applied to. It can be an\n                empty string, in which case the head is attached to the trunk's output.\n            head: The head which is to be attached.\n            input_key: The head will only run on inputs with this key. If set to\n                `None` the head will be applied to all inputs.\n            output_key: The head will produce this output key. If set to `None`, the\n                output key will be the same as the input key.\n\n            An example heads value can look like -\n            ```\n            [\n                {\n                    \"fork_module\": \"layer_1.layer_a.layer_alpha\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_1\",\n                    \"output_key\": \"out_1\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_1\",\n                    \"output_key\": \"out_2\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_2\",\n                    \"output_key\": \"out_3\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Conv2d(in_feat, out_feat),\n                    \"input_key\": None,\n                    \"output_key\": None,\n                },\n            ]\n            ```\n        trunk_fields: A list of dicts with the following keys:\n            input_key: The input key this rule applies to. If `None`, applies to all\n                inputs.\n            args: These specific keys will be fetched from the sample and passed as\n                *args to the trunk for the specified `input_key`.\n            kwargs: These specific keys will be fetched from the sample and passed as\n                **kwargs to the trunk for the specified `input_key`.\n\n            Example -\n            ```\n            [\n                {\n                    \"input_key\": \"dataset_1\",\n                    \"args\": [\"vision\"]\n                },\n                {\n                    \"input_key\": \"dataset_2\",\n                    \"args\": [\"vision\"],\n                    \"kwargs\": {\"mask\": \"mask\"}\n                },\n            ]\n            ```\n\n        Note that two heads cannot produce the same output key in the same forward pass.\n\n    Returns:\n        A dict with keys corresponding to the output keys which match with the input key.\n    \"\"\"\n\n    @dataclass\n    class HeadArgs:\n        fork_module: str\n        head: nn.Module\n        input_key: Optional[str]\n        output_key: Optional[str]\n\n    @dataclass\n    class TrunkFieldArgs:\n        input_key: Optional[str]\n        args: List[str] = field(default_factory=list)\n        kwargs: Dict[str, str] = field(default_factory=dict)\n\n    def __init__(\n        self,\n        trunk: nn.Module,\n        heads: List[Dict],\n        trunk_fields: List[Dict],\n        handle_list_inputs=False,\n    ) -> None:\n        \"\"\"WARNING: handle_list_inputs is a hack which needs to be refactored away.\"\"\"\n        super().__init__()\n\n        self.trunk = trunk\n        self.handle_list_inputs = handle_list_inputs\n\n        # cast to HeadArgs for input validation\n        heads = [self.HeadArgs(**head_dict) for head_dict in heads]\n        # cast to TrunkFieldArgs for input validation\n        trunk_fields = [\n            self.TrunkFieldArgs(**trunk_fields_dict)\n            for trunk_fields_dict in trunk_fields\n        ]\n\n        self.head_name_to_fork_module = {}\n        self.heads = nn.ModuleList()\n        self.head_input_keys = []\n        self.head_output_keys = []\n        self.head_fork_modules = []\n\n        for head_args in heads:\n            self.heads.append(head_args.head)\n            self.head_input_keys.append(head_args.input_key)\n            self.head_output_keys.append(head_args.output_key)\n            self.head_fork_modules.append(head_args.fork_module)\n\n        self.trunk_field_args = {}\n        self.trunk_field_kwargs = {}\n        for trunk_fields_elem in trunk_fields:\n            input_key = trunk_fields_elem.input_key\n            if input_key in self.trunk_field_args:\n                raise KeyError(\n                    f\"Multiple trunk_fields specified for the same input_key: {input_key}\"\n                )\n            self.trunk_field_args[input_key] = trunk_fields_elem.args\n            self.trunk_field_kwargs[input_key] = trunk_fields_elem.kwargs\n\n        # outputs is used as a temporary storage of the head outputs\n        self.outputs = {}\n\n        # input_key is used to specify which key is currently being processed\n        self.input_key = None\n\n        # handles to the hooks which can be used for removing the hooks if needed\n        self.hook_handles = []\n        self._register_hooks()\n\n    def _register_hooks(self):\n        for i, head in enumerate(self.heads):\n            fork_module_name = self.head_fork_modules[i]\n\n            def hook_fn(\n                module,\n                module_in,\n                module_out,\n                # the following variables are passed as kwargs in the closure to avoid\n                # late binding in python\n                head_method=head,\n                in_key=self.head_input_keys[i],\n                out_key=self.head_output_keys[i],\n            ):"
  },
  {
    "id": "317",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport copy\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Mapping, Optional, Sequence\n\nimport numpy as np\n\nimport torch\nimport torch.nn as nn\nfrom omnivision.data.api import VisionSample\n\n\nclass MIMOHeadWrapper(nn.Module):\n    \"\"\"Attaches multiple input multiple output heads to the trunk using forward hooks.\n\n    Args:\n        trunk: Any model to which you want to attach the heads to.\n        heads: A list of dicts with the following keys:\n            fork_module: The module which the head will be applied to. It can be an\n                empty string, in which case the head is attached to the trunk's output.\n            head: The head which is to be attached.\n            input_key: The head will only run on inputs with this key. If set to\n                `None` the head will be applied to all inputs.\n            output_key: The head will produce this output key. If set to `None`, the\n                output key will be the same as the input key.\n\n            An example heads value can look like -\n            ```\n            [\n                {\n                    \"fork_module\": \"layer_1.layer_a.layer_alpha\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_1\",\n                    \"output_key\": \"out_1\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_1\",\n                    \"output_key\": \"out_2\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_2\",\n                    \"output_key\": \"out_3\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Conv2d(in_feat, out_feat),\n                    \"input_key\": None,\n                    \"output_key\": None,\n                },\n            ]\n            ```\n        trunk_fields: A list of dicts with the following keys:\n            input_key: The input key this rule applies to. If `None`, applies to all\n                inputs.\n            args: These specific keys will be fetched from the sample and passed as\n                *args to the trunk for the specified `input_key`.\n            kwargs: These specific keys will be fetched from the sample and passed as\n                **kwargs to the trunk for the specified `input_key`.\n\n            Example -\n            ```\n            [\n                {\n                    \"input_key\": \"dataset_1\",\n                    \"args\": [\"vision\"]\n                },\n                {\n                    \"input_key\": \"dataset_2\",\n                    \"args\": [\"vision\"],\n                    \"kwargs\": {\"mask\": \"mask\"}\n                },\n            ]\n            ```\n\n        Note that two heads cannot produce the same output key in the same forward pass.\n\n    Returns:\n        A dict with keys corresponding to the output keys which match with the input key.\n    \"\"\"\n\n    @dataclass\n    class HeadArgs:\n        fork_module: str\n        head: nn.Module\n        input_key: Optional[str]\n        output_key: Optional[str]\n\n    @dataclass\n    class TrunkFieldArgs:\n        input_key: Optional[str]\n        args: List[str] = field(default_factory=list)\n        kwargs: Dict[str, str] = field(default_factory=dict)\n\n    def __init__(\n        self,\n        trunk: nn.Module,\n        heads: List[Dict],\n        trunk_fields: List[Dict],\n        handle_list_inputs=False,\n    ) -> None:\n        \"\"\"WARNING: handle_list_inputs is a hack which needs to be refactored away.\"\"\"\n        super().__init__()\n\n        self.trunk = trunk\n        self.handle_list_inputs = handle_list_inputs\n\n        # cast to HeadArgs for input validation\n        heads = [self.HeadArgs(**head_dict) for head_dict in heads]\n        # cast to TrunkFieldArgs for input validation\n        trunk_fields = [\n            self.TrunkFieldArgs(**trunk_fields_dict)\n            for trunk_fields_dict in trunk_fields\n        ]\n\n        self.head_name_to_fork_module = {}\n        self.heads = nn.ModuleList()\n        self.head_input_keys = []\n        self.head_output_keys = []\n        self.head_fork_modules = []\n\n        for head_args in heads:\n            self.heads.append(head_args.head)\n            self.head_input_keys.append(head_args.input_key)\n            self.head_output_keys.append(head_args.output_key)\n            self.head_fork_modules.append(head_args.fork_module)\n\n        self.trunk_field_args = {}\n        self.trunk_field_kwargs = {}\n        for trunk_fields_elem in trunk_fields:\n            input_key = trunk_fields_elem.input_key\n            if input_key in self.trunk_field_args:\n                raise KeyError(\n                    f\"Multiple trunk_fields specified for the same input_key: {input_key}\"\n                )\n            self.trunk_field_args[input_key] = trunk_fields_elem.args\n            self.trunk_field_kwargs[input_key] = trunk_fields_elem.kwargs\n\n        # outputs is used as a temporary storage of the head outputs\n        self.outputs = {}\n\n        # input_key is used to specify which key is currently being processed\n        self.input_key = None\n\n        # handles to the hooks which can be used for removing the hooks if needed\n        self.hook_handles = []\n        self._register_hooks()\n\n    def _register_hooks(self):\n        for i, head in enumerate(self.heads):\n            fork_module_name = self.head_fork_modules[i]\n\n            def hook_fn(\n                module,\n                module_in,\n                module_out,\n                # the following variables are passed as kwargs in the closure to avoid\n                # late binding in python\n                head_method=head,\n                in_key=self.head_input_keys[i],\n                out_key=self.head_output_keys[i],\n            ):\n                if in_key is not None and self.input_key != in_key:\n                    return\n                if out_key is None:\n                    out_key = self.input_key\n                if out_key in self.outputs:\n                    # reset state before raising\n                    self.outputs = {}\n                    self.input_key = None\n                    raise ValueError(\n                        f\"Two heads produced the same output key `{out_key}` during forward\"\n                    )\n                self.outputs[out_key] = head_method(module_out)\n\n            fork_module = self.trunk.get_submodule(fork_module_name)\n            self.hook_handles.append(fork_module.register_forward_hook(hook_fn))\n\n    def _get_trunk_fields(self):"
  },
  {
    "id": "318",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport copy\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Mapping, Optional, Sequence\n\nimport numpy as np\n\nimport torch\nimport torch.nn as nn\nfrom omnivision.data.api import VisionSample\n\n\nclass MIMOHeadWrapper(nn.Module):\n    \"\"\"Attaches multiple input multiple output heads to the trunk using forward hooks.\n\n    Args:\n        trunk: Any model to which you want to attach the heads to.\n        heads: A list of dicts with the following keys:\n            fork_module: The module which the head will be applied to. It can be an\n                empty string, in which case the head is attached to the trunk's output.\n            head: The head which is to be attached.\n            input_key: The head will only run on inputs with this key. If set to\n                `None` the head will be applied to all inputs.\n            output_key: The head will produce this output key. If set to `None`, the\n                output key will be the same as the input key.\n\n            An example heads value can look like -\n            ```\n            [\n                {\n                    \"fork_module\": \"layer_1.layer_a.layer_alpha\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_1\",\n                    \"output_key\": \"out_1\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_1\",\n                    \"output_key\": \"out_2\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_2\",\n                    \"output_key\": \"out_3\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Conv2d(in_feat, out_feat),\n                    \"input_key\": None,\n                    \"output_key\": None,\n                },\n            ]\n            ```\n        trunk_fields: A list of dicts with the following keys:\n            input_key: The input key this rule applies to. If `None`, applies to all\n                inputs.\n            args: These specific keys will be fetched from the sample and passed as\n                *args to the trunk for the specified `input_key`.\n            kwargs: These specific keys will be fetched from the sample and passed as\n                **kwargs to the trunk for the specified `input_key`.\n\n            Example -\n            ```\n            [\n                {\n                    \"input_key\": \"dataset_1\",\n                    \"args\": [\"vision\"]\n                },\n                {\n                    \"input_key\": \"dataset_2\",\n                    \"args\": [\"vision\"],\n                    \"kwargs\": {\"mask\": \"mask\"}\n                },\n            ]\n            ```\n\n        Note that two heads cannot produce the same output key in the same forward pass.\n\n    Returns:\n        A dict with keys corresponding to the output keys which match with the input key.\n    \"\"\"\n\n    @dataclass\n    class HeadArgs:\n        fork_module: str\n        head: nn.Module\n        input_key: Optional[str]\n        output_key: Optional[str]\n\n    @dataclass\n    class TrunkFieldArgs:\n        input_key: Optional[str]\n        args: List[str] = field(default_factory=list)\n        kwargs: Dict[str, str] = field(default_factory=dict)\n\n    def __init__(\n        self,\n        trunk: nn.Module,\n        heads: List[Dict],\n        trunk_fields: List[Dict],\n        handle_list_inputs=False,\n    ) -> None:\n        \"\"\"WARNING: handle_list_inputs is a hack which needs to be refactored away.\"\"\"\n        super().__init__()\n\n        self.trunk = trunk\n        self.handle_list_inputs = handle_list_inputs\n\n        # cast to HeadArgs for input validation\n        heads = [self.HeadArgs(**head_dict) for head_dict in heads]\n        # cast to TrunkFieldArgs for input validation\n        trunk_fields = [\n            self.TrunkFieldArgs(**trunk_fields_dict)\n            for trunk_fields_dict in trunk_fields\n        ]\n\n        self.head_name_to_fork_module = {}\n        self.heads = nn.ModuleList()\n        self.head_input_keys = []\n        self.head_output_keys = []\n        self.head_fork_modules = []\n\n        for head_args in heads:\n            self.heads.append(head_args.head)\n            self.head_input_keys.append(head_args.input_key)\n            self.head_output_keys.append(head_args.output_key)\n            self.head_fork_modules.append(head_args.fork_module)\n\n        self.trunk_field_args = {}\n        self.trunk_field_kwargs = {}\n        for trunk_fields_elem in trunk_fields:\n            input_key = trunk_fields_elem.input_key\n            if input_key in self.trunk_field_args:\n                raise KeyError(\n                    f\"Multiple trunk_fields specified for the same input_key: {input_key}\"\n                )\n            self.trunk_field_args[input_key] = trunk_fields_elem.args\n            self.trunk_field_kwargs[input_key] = trunk_fields_elem.kwargs\n\n        # outputs is used as a temporary storage of the head outputs\n        self.outputs = {}\n\n        # input_key is used to specify which key is currently being processed\n        self.input_key = None\n\n        # handles to the hooks which can be used for removing the hooks if needed\n        self.hook_handles = []\n        self._register_hooks()\n\n    def _register_hooks(self):\n        for i, head in enumerate(self.heads):\n            fork_module_name = self.head_fork_modules[i]\n\n            def hook_fn(\n                module,\n                module_in,\n                module_out,\n                # the following variables are passed as kwargs in the closure to avoid\n                # late binding in python\n                head_method=head,\n                in_key=self.head_input_keys[i],\n                out_key=self.head_output_keys[i],\n            ):\n                if in_key is not None and self.input_key != in_key:\n                    return\n                if out_key is None:\n                    out_key = self.input_key\n                if out_key in self.outputs:\n                    # reset state before raising\n                    self.outputs = {}\n                    self.input_key = None\n                    raise ValueError(\n                        f\"Two heads produced the same output key `{out_key}` during forward\"\n                    )\n                self.outputs[out_key] = head_method(module_out)\n\n            fork_module = self.trunk.get_submodule(fork_module_name)\n            self.hook_handles.append(fork_module.register_forward_hook(hook_fn))\n\n    def _get_trunk_fields(self):\n        fields_args = self.trunk_field_args.get(self.input_key)\n        fields_kwargs = self.trunk_field_kwargs.get(self.input_key)\n        if fields_args is None:\n            assert fields_kwargs is None\n            fields_args = self.trunk_field_args.get(None)\n            fields_kwargs = self.trunk_field_kwargs.get(None)\n            if fields_args is None:\n                assert fields_kwargs is None\n                raise ValueError(\n                    f\"No trunk fields specified for input key: {self.input_key}\"\n                )\n        return fields_args, fields_kwargs\n\n    def forward_sub_batch(self, sub_batch, *args, **kwargs):"
  },
  {
    "id": "319",
    "text": "\n\n    Args:\n        trunk: Any model to which you want to attach the heads to.\n        heads: A list of dicts with the following keys:\n            fork_module: The module which the head will be applied to. It can be an\n                empty string, in which case the head is attached to the trunk's output.\n            head: The head which is to be attached.\n            input_key: The head will only run on inputs with this key. If set to\n                `None` the head will be applied to all inputs.\n            output_key: The head will produce this output key. If set to `None`, the\n                output key will be the same as the input key.\n\n            An example heads value can look like -\n            ```\n            [\n                {\n                    \"fork_module\": \"layer_1.layer_a.layer_alpha\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_1\",\n                    \"output_key\": \"out_1\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_1\",\n                    \"output_key\": \"out_2\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Linear(in_feat, out_feat),\n                    \"input_key\": \"dataset_2\",\n                    \"output_key\": \"out_3\",\n                },\n                {\n                    \"fork_module\": \"\",\n                    \"head\": nn.Conv2d(in_feat, out_feat),\n                    \"input_key\": None,\n                    \"output_key\": None,\n                },\n            ]\n            ```\n        trunk_fields: A list of dicts with the following keys:\n            input_key: The input key this rule applies to. If `None`, applies to all\n                inputs.\n            args: These specific keys will be fetched from the sample and passed as\n                *args to the trunk for the specified `input_key`.\n            kwargs: These specific keys will be fetched from the sample and passed as\n                **kwargs to the trunk for the specified `input_key`.\n\n            Example -\n            ```\n            [\n                {\n                    \"input_key\": \"dataset_1\",\n                    \"args\": [\"vision\"]\n                },\n                {\n                    \"input_key\": \"dataset_2\",\n                    \"args\": [\"vision\"],\n                    \"kwargs\": {\"mask\": \"mask\"}\n                },\n            ]\n            ```\n\n        Note that two heads cannot produce the same output key in the same forward pass.\n\n    Returns:\n        A dict with keys corresponding to the output keys which match with the input key.\n    \"\"\"\n\n    @dataclass\n    class HeadArgs:\n        fork_module: str\n        head: nn.Module\n        input_key: Optional[str]\n        output_key: Optional[str]\n\n    @dataclass\n    class TrunkFieldArgs:\n        input_key: Optional[str]\n        args: List[str] = field(default_factory=list)\n        kwargs: Dict[str, str] = field(default_factory=dict)\n\n    def __init__(\n        self,\n        trunk: nn.Module,\n        heads: List[Dict],\n        trunk_fields: List[Dict],\n        handle_list_inputs=False,\n    ) -> None:\n        \"\"\"WARNING: handle_list_inputs is a hack which needs to be refactored away.\"\"\"\n        super().__init__()\n\n        self.trunk = trunk\n        self.handle_list_inputs = handle_list_inputs\n\n        # cast to HeadArgs for input validation\n        heads = [self.HeadArgs(**head_dict) for head_dict in heads]\n        # cast to TrunkFieldArgs for input validation\n        trunk_fields = [\n            self.TrunkFieldArgs(**trunk_fields_dict)\n            for trunk_fields_dict in trunk_fields\n        ]\n\n        self.head_name_to_fork_module = {}\n        self.heads = nn.ModuleList()\n        self.head_input_keys = []\n        self.head_output_keys = []\n        self.head_fork_modules = []\n\n        for head_args in heads:\n            self.heads.append(head_args.head)\n            self.head_input_keys.append(head_args.input_key)\n            self.head_output_keys.append(head_args.output_key)\n            self.head_fork_modules.append(head_args.fork_module)\n\n        self.trunk_field_args = {}\n        self.trunk_field_kwargs = {}\n        for trunk_fields_elem in trunk_fields:\n            input_key = trunk_fields_elem.input_key\n            if input_key in self.trunk_field_args:\n                raise KeyError(\n                    f\"Multiple trunk_fields specified for the same input_key: {input_key}\"\n                )\n            self.trunk_field_args[input_key] = trunk_fields_elem.args\n            self.trunk_field_kwargs[input_key] = trunk_fields_elem.kwargs\n\n        # outputs is used as a temporary storage of the head outputs\n        self.outputs = {}\n\n        # input_key is used to specify which key is currently being processed\n        self.input_key = None\n\n        # handles to the hooks which can be used for removing the hooks if needed\n        self.hook_handles = []\n        self._register_hooks()\n\n    def _register_hooks(self):\n        for i, head in enumerate(self.heads):\n            fork_module_name = self.head_fork_modules[i]\n\n            def hook_fn(\n                module,\n                module_in,\n                module_out,\n                # the following variables are passed as kwargs in the closure to avoid\n                # late binding in python\n                head_method=head,\n                in_key=self.head_input_keys[i],\n                out_key=self.head_output_keys[i],\n            ):\n                if in_key is not None and self.input_key != in_key:\n                    return\n                if out_key is None:\n                    out_key = self.input_key\n                if out_key in self.outputs:\n                    # reset state before raising\n                    self.outputs = {}\n                    self.input_key = None\n                    raise ValueError(\n                        f\"Two heads produced the same output key `{out_key}` during forward\"\n                    )\n                self.outputs[out_key] = head_method(module_out)\n\n            fork_module = self.trunk.get_submodule(fork_module_name)\n            self.hook_handles.append(fork_module.register_forward_hook(hook_fn))\n\n    def _get_trunk_fields(self):\n        fields_args = self.trunk_field_args.get(self.input_key)\n        fields_kwargs = self.trunk_field_kwargs.get(self.input_key)\n        if fields_args is None:\n            assert fields_kwargs is None\n            fields_args = self.trunk_field_args.get(None)\n            fields_kwargs = self.trunk_field_kwargs.get(None)\n            if fields_args is None:\n                assert fields_kwargs is None\n                raise ValueError(\n                    f\"No trunk fields specified for input key: {self.input_key}\"\n                )\n        return fields_args, fields_kwargs\n\n    def forward_sub_batch(self, sub_batch, *args, **kwargs):\n        assert isinstance(sub_batch, VisionSample), f\"Received {type(sub_batch)}\"\n        fields_args, fields_kwargs = self._get_trunk_fields()\n        sample_args = [getattr(sub_batch, arg) for arg in fields_args]\n        sample_kwargs = {\n            key: getattr(sub_batch, field) for key, field in fields_kwargs.items()\n        }\n        self.trunk(*sample_args, *args, **sample_kwargs, **kwargs)\n\n    def forward(self, batch, *args, **kwargs) -> Dict:"
  },
  {
    "id": "320",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom dataclasses import dataclass, field, fields, is_dataclass, make_dataclass\nfrom typing import Any, Callable, Dict\n\nfrom torch.utils.data.dataloader import default_collate\n\n\n@dataclass\nclass Batch:\n    # the following are per batch args which are passed to the trainer\n    # and are set to reasonable defaults\n    model_fwd_kwargs: Dict = field(default_factory=dict)\n    accum_steps: int = 1\n\n\ndef create_batch_sample_cls(cls):\n    \"\"\"Dynamically creates a dataclass which is a `Batch` and a `Sample`.\n\n    This function also registers the class in globals() to make the class picklable.\n    \"\"\""
  },
  {
    "id": "321",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport contextlib\nimport json\nimport logging\nimport math\nimport os\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, List, Mapping, Optional, Sequence\n\nimport torch\nimport torch.distributed as dist\nimport torch.nn as nn\nfrom hydra.utils import instantiate\nfrom iopath.common.file_io import g_pathmgr\nfrom omnivision.data.api import Sample\nfrom omnivision.data.concat_dataset import ConcatDataset\nfrom omnivision.data.torch_dataset import TorchDataset\nfrom omnivision.losses import wrap_base_loss\nfrom omnivision.optim import construct_optimizer\nfrom omnivision.utils.train import (\n    AverageMeter,\n    copy_data_to_device,\n    get_amp_type,\n    get_machine_local_and_dist_rank,\n    get_resume_checkpoint,\n    is_dist_avail_and_initialized,\n    makedir,\n    ProgressMeter,\n    set_seeds,\n    setup_distributed_backend,\n    setup_logging,\n)\n\n\ndef chunk_batch_for_accum_steps(batch, accum_steps):\n    return [get_chunk_from_data(batch, i, accum_steps) for i in range(accum_steps)]\n\n\ndef get_chunk_from_data(data, chunk_id, num_chunks):\n    \"\"\"\n    Recursively splits all the tensors inside the passed data object into num_chunks.\n    \"\"\"\n    if isinstance(data, torch.Tensor):\n        assert len(data) % num_chunks == 0\n        start = (len(data) // num_chunks) * chunk_id\n        end = (len(data) // num_chunks) * (chunk_id + 1)\n        return data[start:end]\n    elif isinstance(data, Mapping):\n        return {\n            key: get_chunk_from_data(value, chunk_id, num_chunks)\n            for key, value in data.items()\n        }\n    elif isinstance(data, Sequence):\n        return [get_chunk_from_data(value, chunk_id, num_chunks) for value in data]\n    elif isinstance(data, Sample):\n        data_cls = type(data)\n        data = data.__dict__\n        return data_cls(**get_chunk_from_data(data, chunk_id, num_chunks))\n    else:\n        return data\n\n\n@dataclass\nclass OmnivisionOptimAMPConf:\n    enabled: bool = False\n    amp_dtype: str = \"float16\"\n\n\n@dataclass\nclass OmnivisionOptimConf:\n    optimizer: torch.optim.Optimizer = None\n    options: Optional[Dict[str, Any]] = None\n    param_group_modifiers: Optional[List] = None\n    amp: Optional[Dict[str, Any]] = None\n    gradient_clip: Any = None\n\n    def __post_init__(self):\n        # amp"
  },
  {
    "id": "322",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n# pyre-ignore-all-errors\n\nimport fnmatch\nimport itertools\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Iterable, List, Optional, Set, Tuple, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom omegaconf import DictConfig, MISSING\n\nfrom . import LARS, OmniOptimizer\n\n\ndef create_lars_optimizer(params, opt, **lars_params):\n    optim = hydra.utils.instantiate(opt, params=params)\n    return LARS(optim, **lars_params)\n\n\ndef validate_param_group_params(param_groups, model):"
  },
  {
    "id": "323",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n# pyre-ignore-all-errors\n\nimport fnmatch\nimport itertools\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Iterable, List, Optional, Set, Tuple, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom omegaconf import DictConfig, MISSING\n\nfrom . import LARS, OmniOptimizer\n\n\ndef create_lars_optimizer(params, opt, **lars_params):\n    optim = hydra.utils.instantiate(opt, params=params)\n    return LARS(optim, **lars_params)\n\n\ndef validate_param_group_params(param_groups, model):\n    parameters = [set(param_group[\"params\"]) for param_group in param_groups]\n    model_parameters = {parameter for _, parameter in model.named_parameters()}\n    for p1, p2 in itertools.permutations(parameters, 2):\n        assert p1.isdisjoint(p2), \"Scheduler generated param_groups should be disjoint\"\n    assert (\n        set.union(*parameters) == model_parameters\n    ), \"Scheduler generated param_groups include all parameters of the model\"\n\n\ndef unix_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig, model: nn.Module\n) -> Union[None, Set[str]]:"
  },
  {
    "id": "324",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n# pyre-ignore-all-errors\n\nimport fnmatch\nimport itertools\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Iterable, List, Optional, Set, Tuple, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom omegaconf import DictConfig, MISSING\n\nfrom . import LARS, OmniOptimizer\n\n\ndef create_lars_optimizer(params, opt, **lars_params):\n    optim = hydra.utils.instantiate(opt, params=params)\n    return LARS(optim, **lars_params)\n\n\ndef validate_param_group_params(param_groups, model):\n    parameters = [set(param_group[\"params\"]) for param_group in param_groups]\n    model_parameters = {parameter for _, parameter in model.named_parameters()}\n    for p1, p2 in itertools.permutations(parameters, 2):\n        assert p1.isdisjoint(p2), \"Scheduler generated param_groups should be disjoint\"\n    assert (\n        set.union(*parameters) == model_parameters\n    ), \"Scheduler generated param_groups include all parameters of the model\"\n\n\ndef unix_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig, model: nn.Module\n) -> Union[None, Set[str]]:\n    if \"param_names\" not in scheduler_cfg and \"module_cls_names\" not in scheduler_cfg:\n        return None\n    return unix_param_pattern_to_parameter_names(scheduler_cfg, model).union(\n        unix_module_cls_pattern_to_parameter_names(scheduler_cfg, model)\n    )\n\n\ndef get_full_parameter_name(module_name, param_name):"
  },
  {
    "id": "325",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n# pyre-ignore-all-errors\n\nimport fnmatch\nimport itertools\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Iterable, List, Optional, Set, Tuple, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom omegaconf import DictConfig, MISSING\n\nfrom . import LARS, OmniOptimizer\n\n\ndef create_lars_optimizer(params, opt, **lars_params):\n    optim = hydra.utils.instantiate(opt, params=params)\n    return LARS(optim, **lars_params)\n\n\ndef validate_param_group_params(param_groups, model):\n    parameters = [set(param_group[\"params\"]) for param_group in param_groups]\n    model_parameters = {parameter for _, parameter in model.named_parameters()}\n    for p1, p2 in itertools.permutations(parameters, 2):\n        assert p1.isdisjoint(p2), \"Scheduler generated param_groups should be disjoint\"\n    assert (\n        set.union(*parameters) == model_parameters\n    ), \"Scheduler generated param_groups include all parameters of the model\"\n\n\ndef unix_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig, model: nn.Module\n) -> Union[None, Set[str]]:\n    if \"param_names\" not in scheduler_cfg and \"module_cls_names\" not in scheduler_cfg:\n        return None\n    return unix_param_pattern_to_parameter_names(scheduler_cfg, model).union(\n        unix_module_cls_pattern_to_parameter_names(scheduler_cfg, model)\n    )\n\n\ndef get_full_parameter_name(module_name, param_name):\n    if module_name == \"\":\n        return param_name\n    return f\"{module_name}.{param_name}\"\n\n\ndef unix_module_cls_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig,\n    model: nn.Module,\n) -> Union[None, Set[str]]:\n    if \"module_cls_names\" not in scheduler_cfg:\n        return set()\n    module_cls_to_params = {}\n    for module_name, module in model.named_modules():\n        module_cls = type(module)\n        module_cls_to_params.setdefault(module_cls, set())\n        module_cls_to_params[module_cls] |= set(\n            get_full_parameter_name(module_name, param_name)\n            for param_name, _ in module.named_parameters()\n        )\n    parameter_names = []\n    for module_cls_name in scheduler_cfg.module_cls_names:\n        module_cls = hydra.utils.get_class(module_cls_name)\n        matching_parameters = module_cls_to_params.get(module_cls, set())\n        assert len(matching_parameters) > 0, (\n            f\"Optimizer option for {scheduler_cfg.option} module_cls_name\"\n            f\" {module_cls_name} does not match any classes in the model\"\n        )\n        logging.info(\n            f\"Matches for module_cls_name [{module_cls_name}]: {matching_parameters} \"\n        )\n        parameter_names.append(matching_parameters)\n    return set.union(*parameter_names)\n\n\ndef unix_param_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig,\n    model: nn.Module,\n) -> Union[None, Set[str]]:"
  },
  {
    "id": "326",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n# pyre-ignore-all-errors\n\nimport fnmatch\nimport itertools\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Iterable, List, Optional, Set, Tuple, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom omegaconf import DictConfig, MISSING\n\nfrom . import LARS, OmniOptimizer\n\n\ndef create_lars_optimizer(params, opt, **lars_params):\n    optim = hydra.utils.instantiate(opt, params=params)\n    return LARS(optim, **lars_params)\n\n\ndef validate_param_group_params(param_groups, model):\n    parameters = [set(param_group[\"params\"]) for param_group in param_groups]\n    model_parameters = {parameter for _, parameter in model.named_parameters()}\n    for p1, p2 in itertools.permutations(parameters, 2):\n        assert p1.isdisjoint(p2), \"Scheduler generated param_groups should be disjoint\"\n    assert (\n        set.union(*parameters) == model_parameters\n    ), \"Scheduler generated param_groups include all parameters of the model\"\n\n\ndef unix_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig, model: nn.Module\n) -> Union[None, Set[str]]:\n    if \"param_names\" not in scheduler_cfg and \"module_cls_names\" not in scheduler_cfg:\n        return None\n    return unix_param_pattern_to_parameter_names(scheduler_cfg, model).union(\n        unix_module_cls_pattern_to_parameter_names(scheduler_cfg, model)\n    )\n\n\ndef get_full_parameter_name(module_name, param_name):\n    if module_name == \"\":\n        return param_name\n    return f\"{module_name}.{param_name}\"\n\n\ndef unix_module_cls_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig,\n    model: nn.Module,\n) -> Union[None, Set[str]]:\n    if \"module_cls_names\" not in scheduler_cfg:\n        return set()\n    module_cls_to_params = {}\n    for module_name, module in model.named_modules():\n        module_cls = type(module)\n        module_cls_to_params.setdefault(module_cls, set())\n        module_cls_to_params[module_cls] |= set(\n            get_full_parameter_name(module_name, param_name)\n            for param_name, _ in module.named_parameters()\n        )\n    parameter_names = []\n    for module_cls_name in scheduler_cfg.module_cls_names:\n        module_cls = hydra.utils.get_class(module_cls_name)\n        matching_parameters = module_cls_to_params.get(module_cls, set())\n        assert len(matching_parameters) > 0, (\n            f\"Optimizer option for {scheduler_cfg.option} module_cls_name\"\n            f\" {module_cls_name} does not match any classes in the model\"\n        )\n        logging.info(\n            f\"Matches for module_cls_name [{module_cls_name}]: {matching_parameters} \"\n        )\n        parameter_names.append(matching_parameters)\n    return set.union(*parameter_names)\n\n\ndef unix_param_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig,\n    model: nn.Module,\n) -> Union[None, Set[str]]:\n    if \"param_names\" not in scheduler_cfg:\n        return set()\n    all_parameter_names = {name for name, _ in model.named_parameters()}\n    parameter_names = []\n    for param_name in scheduler_cfg.param_names:\n        matching_parameters = set(fnmatch.filter(all_parameter_names, param_name))\n        assert len(matching_parameters) >= 1, (\n            f\"Optimizer option for {scheduler_cfg.option} param_names {param_name} \"\n            \"does not match any parameters in the model\"\n        )\n        logging.info(f\"Matches for param_name [{param_name}]: {matching_parameters}\")\n        parameter_names.append(matching_parameters)\n    return set.union(*parameter_names)\n\n\ndef set_default_parameters(\n    scheduler_cfgs: List[DictConfig], all_parameter_names: Set[str]\n) -> None:"
  },
  {
    "id": "327",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n# pyre-ignore-all-errors\n\nimport fnmatch\nimport itertools\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Iterable, List, Optional, Set, Tuple, Union\n\nimport hydra\nimport torch\nimport torch.nn as nn\nfrom omegaconf import DictConfig, MISSING\n\nfrom . import LARS, OmniOptimizer\n\n\ndef create_lars_optimizer(params, opt, **lars_params):\n    optim = hydra.utils.instantiate(opt, params=params)\n    return LARS(optim, **lars_params)\n\n\ndef validate_param_group_params(param_groups, model):\n    parameters = [set(param_group[\"params\"]) for param_group in param_groups]\n    model_parameters = {parameter for _, parameter in model.named_parameters()}\n    for p1, p2 in itertools.permutations(parameters, 2):\n        assert p1.isdisjoint(p2), \"Scheduler generated param_groups should be disjoint\"\n    assert (\n        set.union(*parameters) == model_parameters\n    ), \"Scheduler generated param_groups include all parameters of the model\"\n\n\ndef unix_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig, model: nn.Module\n) -> Union[None, Set[str]]:\n    if \"param_names\" not in scheduler_cfg and \"module_cls_names\" not in scheduler_cfg:\n        return None\n    return unix_param_pattern_to_parameter_names(scheduler_cfg, model).union(\n        unix_module_cls_pattern_to_parameter_names(scheduler_cfg, model)\n    )\n\n\ndef get_full_parameter_name(module_name, param_name):\n    if module_name == \"\":\n        return param_name\n    return f\"{module_name}.{param_name}\"\n\n\ndef unix_module_cls_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig,\n    model: nn.Module,\n) -> Union[None, Set[str]]:\n    if \"module_cls_names\" not in scheduler_cfg:\n        return set()\n    module_cls_to_params = {}\n    for module_name, module in model.named_modules():\n        module_cls = type(module)\n        module_cls_to_params.setdefault(module_cls, set())\n        module_cls_to_params[module_cls] |= set(\n            get_full_parameter_name(module_name, param_name)\n            for param_name, _ in module.named_parameters()\n        )\n    parameter_names = []\n    for module_cls_name in scheduler_cfg.module_cls_names:\n        module_cls = hydra.utils.get_class(module_cls_name)\n        matching_parameters = module_cls_to_params.get(module_cls, set())\n        assert len(matching_parameters) > 0, (\n            f\"Optimizer option for {scheduler_cfg.option} module_cls_name\"\n            f\" {module_cls_name} does not match any classes in the model\"\n        )\n        logging.info(\n            f\"Matches for module_cls_name [{module_cls_name}]: {matching_parameters} \"\n        )\n        parameter_names.append(matching_parameters)\n    return set.union(*parameter_names)\n\n\ndef unix_param_pattern_to_parameter_names(\n    scheduler_cfg: DictConfig,\n    model: nn.Module,\n) -> Union[None, Set[str]]:\n    if \"param_names\" not in scheduler_cfg:\n        return set()\n    all_parameter_names = {name for name, _ in model.named_parameters()}\n    parameter_names = []\n    for param_name in scheduler_cfg.param_names:\n        matching_parameters = set(fnmatch.filter(all_parameter_names, param_name))\n        assert len(matching_parameters) >= 1, (\n            f\"Optimizer option for {scheduler_cfg.option} param_names {param_name} \"\n            \"does not match any parameters in the model\"\n        )\n        logging.info(f\"Matches for param_name [{param_name}]: {matching_parameters}\")\n        parameter_names.append(matching_parameters)\n    return set.union(*parameter_names)\n\n\ndef set_default_parameters(\n    scheduler_cfgs: List[DictConfig], all_parameter_names: Set[str]\n) -> None:\n    constraints = [\n        scheduler_cfg.parameter_names\n        for scheduler_cfg in scheduler_cfgs\n        if scheduler_cfg.parameter_names is not None\n    ]\n    if len(constraints) == 0:\n        default_params = set(all_parameter_names)\n    else:\n\n        default_params = all_parameter_names - set.union(*constraints)\n    default_count = 0\n    for scheduler_cfg in scheduler_cfgs:\n        if scheduler_cfg.parameter_names is None:\n            scheduler_cfg.parameter_names = default_params\n            default_count += 1\n    assert default_count <= 1, \"Only one scheduler per option can be default\"\n    if default_count == 0:  # Add defaults without options\n        scheduler_cfgs.append({\"parameter_names\": default_params})\n\n\ndef name_constraints_to_parameters(\n    param_constraints: List[Set[str]], model: torch.nn.Module\n) -> List[torch.nn.Parameter]:\n    matching_names = set.intersection(*param_constraints)\n    return [value for name, value in model.named_parameters() if name in matching_names]\n\n\ndef map_scheduler_cfgs_to_param_groups(\n    scheduler_cfgs_per_param_group: Iterable[List[Dict]], model: torch.nn.Module\n) -> Tuple[List[Dict[Any, Any]], List[Dict[str, List[torch.nn.Parameter]]]]:"
  },
  {
    "id": "328",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nclass OmniOptimizer(object):\n    def __init__(self, optimizer, schedulers=None) -> None:"
  },
  {
    "id": "329",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nclass OmniOptimizer(object):\n    def __init__(self, optimizer, schedulers=None) -> None:\n        self.optimizer = optimizer\n        self.schedulers = schedulers\n        self._validate_optimizer_schedulers()\n        self.step_schedulers(0.0)\n\n    def _validate_optimizer_schedulers(self):"
  },
  {
    "id": "330",
    "text": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nclass OmniOptimizer(object):\n    def __init__(self, optimizer, schedulers=None) -> None:\n        self.optimizer = optimizer\n        self.schedulers = schedulers\n        self._validate_optimizer_schedulers()\n        self.step_schedulers(0.0)\n\n    def _validate_optimizer_schedulers(self):\n        if self.schedulers is None:\n            return\n        for _, set_of_schedulers in enumerate(self.schedulers):\n            for option, _ in set_of_schedulers.items():\n                assert option in self.optimizer.defaults, (\n                    \"Optimizer option \"\n                    f\"{option} not found in {self.optimizer}. Valid options are \"\n                    f\"{self.optimizer.defaults.keys()}\"\n                )\n\n    def step_schedulers(self, where: float) -> None:"
  },
  {
    "id": "331",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, Func, PandasDataFrame\n\n\ndef mutate(df: PandasDataFrame, over: dict[Column, Func]) -> PandasDataFrame:"
  },
  {
    "id": "332",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef drop(df: PandasDataFrame, columns: LazyColumns) -> PandasDataFrame:"
  },
  {
    "id": "333",
    "text": "from ..checks import _check_type, _check_values\nfrom ..types import NewColumn, OldColumn, PandasDataFrame\n\n\ndef rename(df: PandasDataFrame, columns: dict[OldColumn, NewColumn]) -> PandasDataFrame:"
  },
  {
    "id": "334",
    "text": "import uuid\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef split(\n    df: PandasDataFrame, column: Column, into: Columns, sep: str, drop: bool = True\n) -> PandasDataFrame:"
  },
  {
    "id": "335",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_keys, _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef sort(\n    df: PandasDataFrame, columns: LazyColumns, descending: bool = False\n) -> PandasDataFrame:"
  },
  {
    "id": "336",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef pack(\n    df: PandasDataFrame | PandasGroupedFrame, column: Column, sep: str\n) -> PandasDataFrame:"
  },
  {
    "id": "337",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, Func, PandasDataFrame, PandasGroupedFrame\n\n\ndef rollup(\n    df: PandasDataFrame | PandasGroupedFrame,\n    over: dict[Column, tuple[Column, Func]],\n) -> PandasDataFrame:"
  },
  {
    "id": "338",
    "text": "import pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..types import PandasDataFrame\n\n\ndef append(top: PandasDataFrame, bottom: PandasDataFrame) -> PandasDataFrame:"
  },
  {
    "id": "339",
    "text": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, PandasDataFrame\n\n\ndef combine(\n    df: PandasDataFrame, columns: Columns, into: Column, sep: str, drop: bool = True\n) -> PandasDataFrame:"
  },
  {
    "id": "340",
    "text": "from ..checks import _check_type\nfrom ..types import Column, NewValue, OldValue, PandasDataFrame\n\n\ndef replace(\n    df: PandasDataFrame, over: dict[Column, dict[OldValue, NewValue]]\n) -> PandasDataFrame:"
  },
  {
    "id": "341",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef denix(df: PandasDataFrame, columns: LazyColumns | None = None) -> PandasDataFrame:"
  },
  {
    "id": "342",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_keys, _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef dedupe(df: PandasDataFrame, columns: LazyColumns | None = None) -> PandasDataFrame:"
  },
  {
    "id": "343",
    "text": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef accumulate(\n    df: PandasDataFrame | PandasGroupedFrame, column: Column, into: Column\n) -> PandasDataFrame:"
  },
  {
    "id": "344",
    "text": "from __future__ import annotations\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame\n\n\ndef cross(\n    lhs: PandasDataFrame,\n    rhs: PandasDataFrame,\n    postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n) -> PandasDataFrame:"
  },
  {
    "id": "345",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame\n\n\ndef sample(\n    df: PandasDataFrame, rows: int | float, seed: int | None = None\n) -> PandasDataFrame:"
  },
  {
    "id": "346",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame\n\n\ndef shuffle(df: PandasDataFrame, seed: int | None = None) -> PandasDataFrame:"
  },
  {
    "id": "347",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame\n\n\ndef unpack(df: PandasDataFrame, column: Column, sep: str) -> PandasDataFrame:"
  },
  {
    "id": "348",
    "text": "from __future__ import annotations\n\nimport warnings\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame, PandasGroupedFrame\n\n\ndef rank(\n    df: PandasDataFrame | PandasGroupedFrame,\n    column: Column,\n    into: Column,\n    descending: bool = False,\n) -> PandasDataFrame:"
  },
  {
    "id": "349",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import Direction, LazyColumns, PandasDataFrame, Value\n\n\ndef fill(\n    df: PandasDataFrame,\n    columns: LazyColumns | None = None,\n    direction: Direction | None = None,\n    constant: Value | None = None,\n) -> PandasDataFrame:"
  },
  {
    "id": "350",
    "text": "import uuid\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, PandasDataFrame\n\n\ndef spread(df: PandasDataFrame, column: Column, using: Column) -> PandasDataFrame:"
  },
  {
    "id": "351",
    "text": "from __future__ import annotations\n\nimport warnings\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:"
  },
  {
    "id": "352",
    "text": "from __future__ import annotations\n\nimport warnings\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Column, Columns, LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef _melt(\n    df: PandasDataFrame,\n    cols_to_keep: list[str],\n    cols_to_gather: list[str],\n    into: tuple[str, str],\n) -> PandasDataFrame:\n    df = pd.melt(\n        df,\n        id_vars=cols_to_keep,\n        value_vars=cols_to_gather,\n        var_name=into[0],\n        value_name=into[1],\n    )\n    df = df.dropna(subset=into[1])  # type: ignore\n    df = df.reset_index(drop=True)\n    return df\n\n\ndef _grouped_melt(df: PandasGroupedFrame, into: tuple[str, str]) -> PandasDataFrame:"
  },
  {
    "id": "353",
    "text": "from __future__ import annotations\n\nimport pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import Join, LazyColumns, PandasDataFrame\n\n\ndef join(\n    lhs: PandasDataFrame,\n    rhs: PandasDataFrame,\n    on: LazyColumns,\n    how: Join = \"left\",\n    postfix: tuple[str, str] = (\"_lhs\", \"_rhs\"),\n) -> PandasDataFrame:"
  },
  {
    "id": "354",
    "text": "from ..types import Func, PandasDataFrame\n\n\ndef filter(df: PandasDataFrame, func: Func) -> PandasDataFrame:"
  },
  {
    "id": "355",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import PandasDataFrame, PandasGroupedFrame\n\n\ndef take(\n    df: PandasDataFrame | PandasGroupedFrame, rows: int = 1, **kwargs\n) -> PandasDataFrame:"
  },
  {
    "id": "356",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame, PandasGroupedFrame\n\n\ndef group(df: PandasDataFrame, by: LazyColumns) -> PandasGroupedFrame:"
  },
  {
    "id": "357",
    "text": "import pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom ..checks import _check_type\nfrom ..types import LazyColumns, PandasDataFrame\n\n\ndef select(df: PandasDataFrame, columns: LazyColumns) -> PandasDataFrame:"
  },
  {
    "id": "358",
    "text": "from ..checks import _check_file, _check_type\nfrom ..core import DataFrame\n\n\ndef save(df: DataFrame, path: str, **kwargs) -> None:\n    \"\"\"Save a rf.DataFrame to a csv file (opposite of `load`)\n\n    Example:\n\n    ```python\n    rf.save(df, \"example.csv\")\n    ```\n    \"\"\""
  },
  {
    "id": "359",
    "text": "import pandas as pd  # pyright: ignore[reportMissingImports]\n\nfrom redframes.types import PandasDataFrame\n\nfrom ..checks import _check_columns, _check_file, _check_index, _check_type\nfrom ..core import DataFrame, _wrap\n\n\ndef load(path: str, **kwargs) -> DataFrame:\n    \"\"\"Load a csv file into a rf.DataFrame (opposite of `save`)\n\n    Example:\n\n    ```python\n    df = rf.load(\"example.csv\")\n    ```\n    \"\"\""
  },
  {
    "id": "360",
    "text": "from __future__ import annotations\n\nfrom ..checks import _check_columns, _check_index, _check_type\nfrom ..core import DataFrame\nfrom ..types import PandasDataFrame\n\n\ndef unwrap(rdf: DataFrame) -> PandasDataFrame:\n    \"\"\"Convert a rf.DataFrame into a pd.DataFrame (opposite of `wrap`)\n\n    Example:\n\n    ```python\n    rdf = rf.DataFrame({\"foo\": range(10)})\n    pdf = rf.unwrap(rdf)\n    ```\n    \"\"\"\n    _check_type(rdf, DataFrame)\n    return rdf._data.copy()\n\n\ndef wrap(pdf: PandasDataFrame) -> DataFrame:\n    \"\"\"Convert a pd.DataFrame into a rf.DataFrame (opposite of `unwrap`)\n\n    Example:\n\n    ```python\n    pdf = pd.DataFrame({\"foo\": range(10)})\n    rdf = rf.wrap(pdf)\n    ```\n    \"\"\""
  },
  {
    "id": "361",
    "text": "from __future__ import annotations\n\nimport pprint\nimport warnings\n\nfrom .checks import _check_type\nfrom .types import (\n    Any,\n    Column,\n    Columns,\n    DateTime,\n    Direction,\n    Func,\n    Join,\n    LazyColumns,\n    NewColumn,\n    NewValue,\n    NumpyArray,\n    NumpyType,\n    OldColumn,\n    OldValue,\n    PandasDataFrame,\n    PandasGroupedFrame,\n    Value,\n    Values,\n)\nfrom .verbs import (\n    accumulate,\n    append,\n    combine,\n    cross,\n    dedupe,\n    denix,\n    drop,\n    fill,\n    filter,\n    gather,\n    group,\n    join,\n    mutate,\n    pack,\n    rank,\n    rename,\n    replace,\n    rollup,\n    sample,\n    select,\n    shuffle,\n    sort,\n    split,\n    spread,\n    take,\n    unpack,\n)\n\n\ndef _wrap(data: PandasDataFrame) -> DataFrame:\n    \"\"\"Unsafe version of redframes.io.wrap()\"\"\""
  },
  {
    "id": "362",
    "text": "        |     1 |\n        |     2 |\n        |     3 |\n        |     4 |\n\n        ```python\n        df.accumulate(\"foo\", into=\"cumsum\")\n        ```\n        |   foo |   cumsum |\n        |------:|---------:|\n        |     1 |        1 |\n        |     2 |        3 |\n        |     3 |        6 |\n        |     4 |       10 |\n        \"\"\"\n        return _wrap(accumulate(self._data, column, into))\n\n    def gather(\n        self,\n        columns: Columns | None = None,\n        beside: LazyColumns | None = None,\n        into: tuple[Column, Column] = (\"variable\", \"value\"),\n    ):\n        \"\"\"Gather columns into rows (opposite of spread)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [1, 2, 1, 2],\n            \"bar\": [\"A\", \"B\", \"C\", \"D\"],\n            \"baz\": [\"!\", \"@\", \"#\", \"$\"],\n            \"jaz\": range(4)\n        })\n        ```\n        |   foo | bar   | baz   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:"
  },
  {
    "id": "363",
    "text": "az   |   jaz |\n        |------:|:------|:------|------:|\n        |     1 | A     | !     |     0 |\n        |     2 | B     | @     |     1 |\n        |     1 | C     | #     |     2 |\n        |     2 | D     | $     |     3 |\n\n        All columns:\n\n        ```python\n        df.gather()\n        ```\n        | variable   | value   |\n        |:-----------|:--------|\n        | foo        | 1       |\n        | foo        | 2       |\n        | foo        | 1       |\n        | foo        | 2       |\n        | bar        | A       |\n        | bar        | B       |\n        | bar        | C       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\""
  },
  {
    "id": "364",
    "text": "       |\n        | bar        | D       |\n        | baz        | !       |\n        | baz        | @       |\n        | baz        | #       |\n        | baz        | $       |\n        | jaz        | 0       |\n        | jaz        | 1       |\n        | jaz        | 2       |\n        | jaz        | 3       |\n\n        Multiple columns:\n\n        ```python\n        df.gather([\"foo\", \"bar\"], into=(\"var\", \"val\"))\n        ```\n        | baz   |   jaz | var   | val   |\n        |:------|------:|:------|:------|\n        | !     |     0 | foo   | 1     |\n        | @     |     1 | foo   | 2     |\n        | #     |     2 | foo   | 1     |\n        | $     |     3 | foo   | 2     |\n        | !     |     0 | bar   | A     |\n        | @     |     1 | bar   | B     |\n        | #     |     2 | bar   | C     |\n        | $     |     3 | bar   | D     |\n\n        All columns beside:\n\n        ```python\n        df.group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\""
  },
  {
    "id": "365",
    "text": "group([\"foo\", \"bar\"]).gather(into=(\"variable\", \"value\"))\n        ```\n        |   foo | bar   | variable   | value   |\n        |------:|:------|:-----------|:--------|\n        |     1 | A     | baz        | !       |\n        |     2 | B     | baz        | @       |\n        |     1 | C     | baz        | #       |\n        |     2 | D     | baz        | $       |\n        |     1 | A     | jaz        | 0       |\n        |     2 | B     | jaz        | 1       |\n        |     1 | C     | jaz        | 2       |\n        |     2 | D     | jaz        | 3       |\n        \"\"\"\n        return _wrap(gather(self._data, columns, beside, into))\n\n    def pack(self, column: Column, sep: str) -> DataFrame:\n        \"\"\"Collate and concatenate row values for a target column (opposite of unpack)\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\n            \"foo\": [\"A\", \"A\", \"B\", \"A\", \"B\", \"C\"],\n            \"bar\": [1, 2, 3, 4, 5, 6]\n        })\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | A     |     1 |\n        | A     |     2 |\n        | B     |     3 |\n        | A     |     4 |\n        | B     |     5 |\n        | C     |     6 |\n\n        Pack all rows:\n\n        ```python\n        df.pack(\"foo\", sep=\"+\")\n        ```\n        | foo         |\n        |:------------|\n        | A+A+B+A+B+C |\n\n        Pack rows by Group:\n\n        ```python\n        df.group(\"foo\").pack(\"bar\", sep=\"|\")\n        ```\n        | foo   | bar   |\n        |:------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\""
  },
  {
    "id": "366",
    "text": ":------|:------|\n        | A     | 1|2|4 |\n        | B     | 3|5   |\n        | C     | 6     |\n        \"\"\"\n        return _wrap(pack(self._data, column, sep))\n\n    def rank(\n        self,\n        column: Column,\n        into: Column,\n        descending: bool = False,\n    ) -> DataFrame:\n        \"\"\"Rank order values in a column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [2, 3, 3, 99, 1000, 1, -6, 4]})\n        ```\n        |   foo |\n        |------:|\n        |     2 |\n        |     3 |\n        |     3 |\n        |    99 |\n        |  1000 |\n        |     1 |\n        |    -6 |\n        |     4 |\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\""
  },
  {
    "id": "367",
    "text": "\n\n        ```python\n        df.rank(\"foo\", into=\"rank\", descending=True)\n        ```\n        |   foo |   rank |\n        |------:|-------:|\n        |     2 |      5 |\n        |     3 |      4 |\n        |     3 |      4 |\n        |    99 |      2 |\n        |  1000 |      1 |\n        |     1 |      6 |\n        |    -6 |      7 |\n        |     4 |      3 |\n        \"\"\"\n        return _wrap(rank(self._data, column, into, descending))\n\n    def rollup(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        \"\"\"Apply summary functions and/or statistics to target columns\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3, 4, 5], \"bar\": [99, 100, 1, -5, 2]})\n        ```\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |    99 |\n        |     2 |   100 |\n        |     3 |     1 |\n        |     4 |    -5 |\n        |     5 |     2 |\n\n        ```python\n        df.rollup({\n            \"fcount\": (\"foo\", rf.stat.count),\n            \"fmean\": (\"foo\", rf.stat.mean),\n            \"fsum\": (\"foo\", rf.stat.sum),\n            \"fmax\": (\"foo\", rf.stat.max),\n            \"bmedian\": (\"bar\", rf.stat.median),\n            \"bmin\": (\"bar\", rf.stat.min),\n            \"bstd\": (\"bar\", rf.stat.std)\n        })\n        ```\n        |   fcount |   fmean |   fsum |   fmax |   bmedian |   bmin |   bstd |\n        |---------:|--------:|-------:|-------:|----------:|-------:|-------:|\n        |        5 |       3 |     15 |      5 |         2 |     -5 |  54.93 |\n        \"\"\"\n        return _wrap(rollup(self._data, over))\n\n    def summarize(self, over: dict[Column, tuple[Column, Func]]) -> DataFrame:\n        message = \"Marked for removal, please use `rollup` instead\"\n        warnings.warn(message, FutureWarning)\n        return self.rollup(over)\n\n\nclass GroupedFrame(_CommonMixin):\n    \"\"\"GroupedFrame compatible with: `accumulate`, `gather`, `pack`, `rank`, `rollup`, `take`\"\"\"\n\n    def __repr__(self) -> str:\n        return self._data.obj.__repr__()  # type: ignore\n\n    def _repr_html_(self) -> str:\n        return self._data.obj.to_html(index=True)  # type: ignore\n\n\nclass DataFrame(_CommonMixin, _InterchangeMixin):\n    def __init__(self, data: dict[Column, Values] | None = None) -> None:\n        \"\"\"Initialize a DataFrame with a standard dictionary\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n        \"\"\"\n        _check_type(data, {dict, None})\n        if not data:\n            self._data = PandasDataFrame()\n        if isinstance(data, dict):\n            self._data = PandasDataFrame(data)\n\n    def __eq__(self, rhs: Any) -> bool:\n        \"\"\"Check if two DataFrames are equal to each other\n\n        Example:\n\n        ```python\n        adf = rf.DataFrame({\"foo\": [1]})\n        bdf = rf.DataFrame({\"bar\": [1]})\n        cdf = rf.DataFrame({\"foo\": [1]})\n        print(adf == bdf)\n        print(adf == cdf)\n        # False\n        # True\n        ```\n        \"\"\"\n        if not isinstance(rhs, DataFrame):\n            return False\n        return self._data.equals(rhs._data)\n\n    def __getitem__(self, key: Column) -> Values:\n        \"\"\"Retrive values (as a python list) from a specified column\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        df[\"foo\"]\n        # [1, 2]\n        ```\n        \"\"\"\n        return list(self._data[key])\n\n    def __repr__(self) -> str:\n        return self._data.__repr__()\n\n    def _repr_html_(self) -> str:\n        return self._data.to_html(index=True)\n\n    def __str__(self) -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\""
  },
  {
    "id": "368",
    "text": " -> str:\n        \"\"\"Return string constructor (for copy-and-pasting)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        str(df)\n        # \"rf.DataFrame({'foo': [1, 2], 'bar': ['A', 'B']})\"\n        ```\n        \"\"\"\n        data = self._data.to_dict(orient=\"list\")\n        string = pprint.pformat(data, indent=4, sort_dicts=False, compact=True)\n        if \"\\n\" in string:\n            string = \" \" + string[1:-1]\n            string = f\"rf.DataFrame({{\\n{string}\\n}})\"\n        else:\n            string = f\"rf.DataFrame({string})\"\n        return string\n\n    @property\n    def columns(self) -> Columns:\n        \"\"\"Inspect column keys (names)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.columns\n        # ['foo', 'bar', 'baz']\n        ```\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def dimensions(self) -> dict[str, int]:\n        \"\"\"Inspect DataFrame shape\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": range(10), \"bar\": range(10, 20)})\n        df.dimensions\n        # {'rows': 10, 'columns': 2}\n        ```\n        \"\"\"\n        return dict(zip([\"rows\", \"columns\"], self._data.shape))\n\n    @property\n    def empty(self) -> bool:\n        \"\"\"Inspect if DataFrame is \"empty\"\n\n        Example:\n\n        ```python\n        df = rf.DataFrame()\n        df.empty\n        # True\n        ```\n        \"\"\"\n        return self._data.empty\n\n    @property\n    def memory(self) -> str:\n        \"\"\"Interrogate DataFrame (deep) memory usage\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2, 3], \"bar\": [\"A\", \"B\", \"C\"]})\n        df.memory\n        # '326B'\n        ```\n        \"\"\"\n        size = self._data.memory_usage(deep=True).sum()\n        power_labels = {40: \"TB\", 30: \"GB\", 20: \"MB\", 10: \"KB\"}\n        for power, label in power_labels.items():\n            if size >= (2**power):\n                approx_size = size // 2**power\n                return f\"{approx_size} {label}\"\n        return f\"{size} B\"\n\n    @property\n    def types(self) -> dict[Column, type]:\n        \"\"\"Inspect column types\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"], \"baz\": [True, False]})\n        df.types\n        # {'foo': int, 'bar': object, 'baz': bool}\n        ```\n        \"\"\"\n        numpy_types = {\n            NumpyType(\"O\"): object,\n            NumpyType(\"int64\"): int,\n            NumpyType(\"float64\"): float,\n            NumpyType(\"bool\"): bool,\n            NumpyType(\"datetime64\"): DateTime,\n        }\n        raw_types = dict(self._data.dtypes)\n        clean_types = {}\n        for column in self.columns:\n            current = raw_types[column]\n            clean = numpy_types.get(current, current)  # type: ignore\n            clean_types[column] = clean\n        return clean_types\n\n    def append(self, other: DataFrame) -> DataFrame:\n        \"\"\"Append rows from another DataFrame\n\n        Example:\n\n        ```python\n        df1 = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df2 = rf.DataFrame({\"bar\": [\"C\", \"D\"], \"foo\": [3, 4], \"baz\": [\"$\", \"@\"]})\n        ```\n        | bar   |   foo | baz   |\n        |:------|------:|:------|\n        | C     |     3 | $     |\n        | D     |     4 | @     |\n\n        ```python\n        df1.append(df2)\n        ```\n        |   foo | bar   | baz   |\n        |------:|:------|:------|\n        |     1 | A     | nan   |\n        |     2 | B     | nan   |\n        |     3 | C     | $     |\n        |     4 | D     | @     |\n        \"\"\"\n        _check_type(other, DataFrame)\n        return _wrap(append(self._data, other._data))\n\n    def combine(\n        self, columns: Columns, into: Column, sep: str, drop: bool = True\n    ) -> DataFrame:\n        \"\"\"Combine multiple columns into a single column (opposite of `split`)\n\n        Example:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [1, 2], \"bar\": [\"A\", \"B\"]})\n        ```\n        |   foo | bar   |\n        |------:|:------|\n        |     1 | A     |\n        |     2 | B     |\n\n        ```python\n        df.combine([\"bar\", \"foo\"], into=\"baz\", sep=\"::\", drop=True)\n        ```\n        | baz   |\n        |:------|\n        | A::1  |\n        | B::2  |\n        \"\"\"\n        return _wrap(combine(self._data, columns, into, sep, drop))\n\n    def cross(\n        self, rhs: DataFrame | None = None, postfix: tuple[str, str] = (\"_lhs\", \"_rhs\")\n    ) -> DataFrame:\n        \"\"\"Cross join columns from another DataFrame\n\n        Examples:\n\n        ```python\n        df = rf.DataFrame({\"foo\": [\"a\", \"b\", \"c\"], \"bar\": [1, 2, 3]})\n        ```\n        | foo   |   bar |\n        |:------|------:|\n        | a     |     1 |\n        | b     |     2 |\n        | c     |     3 |\n\n        Self:\n\n        ```python\n        df.cross()\n        ```\n\n        | foo_lhs   |   bar_lhs | foo_rhs   |   bar_rhs |\n        |:----------|----------:|:----------|----------:|\n        | a         |         1 | a         |         1 |\n        | a         |         1 | b         |         2 |\n        | a         |         1 | c         |         3 |\n        | b         |         2 | a         |         1 |\n        | b         |         2 | b         |         2 |\n        | b         |         2 | c         |         3 |\n        | c         |         3 | a         |         1 |\n        | c         |         3 | b         |         2 |\n        | c         |         3 | c         |         3 |\n\n        Two DataFrames:\n\n        ```python\n        dfa = rf.DataFrame({\"foo\": [1, 2, 3]})\n        dfb = rf.DataFrame({\"bar\": [1, 2, 3]})\n        dfa.cross(dfb, postfix=(\"_a\", \"_b\"))\n        ```\n\n        |   foo |   bar |\n        |------:|------:|\n        |     1 |     1 |\n        |     1 |     2 |\n        |     1 |     3 |\n        |     2 |     1 |\n        |     2 |     2 |\n        |     2 |     3 |\n        |     3 |     1 |\n        |     3 |     2 |\n        |     3 |     3 |\n        \"\"\""
  },
  {
    "id": "369",
    "text": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:"
  },
  {
    "id": "370",
    "text": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:"
  },
  {
    "id": "371",
    "text": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:"
  },
  {
    "id": "372",
    "text": "from __future__ import annotations\n\nfrom .types import (\n    Any,\n    Columns,\n    LazyColumns,\n    PandasDataFrame,\n    PandasIndex,\n    PandasRangeIndex,\n)\n\n\ndef _check_type(argument: Any, against: type | set[type | None]) -> None:\n    if isinstance(against, set):\n        if len(against) == 0:\n            against = {against}  # type: ignore\n    if not isinstance(against, set):\n        against = {against}\n    optional = None in against\n    just_types = against.difference({None})\n    checks = [isinstance(argument, t) for t in just_types]  # type: ignore\n    if optional:\n        checks += [argument == None]\n    if not any(checks):\n        str_types = \" | \".join([t.__name__ for t in just_types])  # type: ignore\n        if optional:\n            str_types += \" | None\"\n        raise TypeError(f\"must be {str_types}\")\n\n\ndef _check_values(values: Any, type: type) -> None:\n    if not all(isinstance(value, type) for value in values):\n        raise TypeError(f\"must be {type.__name__}\")\n\n\ndef _check_keys(columns: LazyColumns | None, against: Columns | PandasIndex) -> None:\n    if isinstance(columns, str):\n        columns = [columns]\n    columns = [] if (columns == None) else columns\n    bad_keys = set(columns).difference(against)  # type: ignore\n    if bad_keys:\n        if len(bad_keys) == 1:\n            raise KeyError(f\"invalid key {bad_keys}\")\n        else:\n            raise KeyError(f\"invalid keys {bad_keys}\")\n\n\ndef _check_index(df: PandasDataFrame) -> None:\n    if not (df.index.name == None):\n        raise IndexError(\"must be unnamed\")\n    if not isinstance(df.index, PandasRangeIndex):\n        raise IndexError(\"must be range\")\n    if not (df.index.start == 0):\n        raise IndexError(\"must start at 0\")\n    if not (df.index.step == 1):\n        raise IndexError(\"must step by 1\")\n\n\ndef _check_columns(df: PandasDataFrame) -> None:"
  },
  {
    "id": "finetune_evaluator.py",
    "text": "import numpy as np\nimport torch\nfrom sklearn.metrics import balanced_accuracy_score, f1_score, confusion_matrix, cohen_kappa_score, roc_auc_score, \\\n    precision_recall_curve, auc, r2_score, mean_squared_error\nfrom tqdm import tqdm\n\n\nclass Evaluator:\n    def __init__(self, params, data_loader):\n        self.params = params\n        self.data_loader = data_loader\n\n    def get_metrics_for_multiclass(self, model):\n        model.eval()\n\n        truths = []\n        preds = []\n        for x, y in tqdm(self.data_loader, mininterval=1):\n            x = x.cuda()\n            y = y.cuda()\n\n            pred = model(x)\n            pred_y = torch.max(pred, dim=-1)[1]\n\n            truths += y.cpu().squeeze().numpy().tolist()\n            preds += pred_y.cpu().squeeze().numpy().tolist()\n\n        truths = np.array(truths)\n        preds = np.array(preds)\n        acc = balanced_accuracy_score(truths, preds)\n        f1 = f1_score(truths, preds, average='weighted')\n        kappa = cohen_kappa_score(truths, preds)\n        cm = confusion_matrix(truths, preds)\n        return acc, kappa, f1, cm\n\n    def get_metrics_for_binaryclass(self, model):\n        model.eval()\n\n        truths = []\n        preds = []\n        scores = []\n        for x, y in tqdm(self.data_loader, mininterval=1):\n            x = x.cuda()\n            y = y.cuda()\n            pred = model(x)\n            score_y = torch.sigmoid(pred)\n            pred_y = torch.gt(score_y, 0.5).long()\n            truths += y.long().cpu().squeeze().numpy().tolist()\n            preds += pred_y.cpu().squeeze().numpy().tolist()\n            scores += score_y.cpu().numpy().tolist()\n\n        truths = np.array(truths)\n        preds = np.array(preds)\n        scores = np.array(scores)\n        acc = balanced_accuracy_score(truths, preds)\n        roc_auc = roc_auc_score(truths, scores)\n        precision, recall, thresholds = precision_recall_curve(truths, scores, pos_label=1)\n        pr_auc = auc(recall, precision)\n        cm = confusion_matrix(truths, preds)\n        return acc, pr_auc, roc_auc, cm\n\n    def get_metrics_for_regression(self, model):\n        model.eval()\n\n        truths = []\n        preds = []\n        for x, y in tqdm(self.data_loader, mininterval=1):\n            x = x.cuda()\n            y = y.cuda()\n            pred = model(x)\n            truths += y.cpu().squeeze().numpy().tolist()\n            preds += pred.cpu().squeeze().numpy().tolist()\n\n        truths = np.array(truths)\n        preds = np.array(preds)\n        corrcoef = np.corrcoef(truths, preds)[0, 1]\n        r2 = r2_score(truths, preds)\n        rmse = mean_squared_error(truths, preds) ** 0.5\n        return corrcoef, r2, rmse"
  },
  {
    "id": "finetune_main.py",
    "text": "import argparse\nimport random\n\nimport numpy as np\nimport torch\n\nfrom datasets import faced_dataset, seedv_dataset, physio_dataset, shu_dataset, isruc_dataset, chb_dataset, \\\n    speech_dataset, mumtaz_dataset, seedvig_dataset, stress_dataset, tuev_dataset, tuab_dataset, bciciv2a_dataset\nfrom finetune_trainer import Trainer\nfrom models import model_for_faced, model_for_seedv, model_for_physio, model_for_shu, model_for_isruc, model_for_chb, \\\n    model_for_speech, model_for_mumtaz, model_for_seedvig, model_for_stress, model_for_tuev, model_for_tuab, \\\n    model_for_bciciv2a\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Big model downstream')\n    parser.add_argument('--seed', type=int, default=3407, help='random seed (default: 0)')\n    parser.add_argument('--cuda', type=int, default=0, help='cuda number (default: 1)')\n    parser.add_argument('--epochs', type=int, default=50, help='number of epochs (default: 5)')\n    parser.add_argument('--batch_size', type=int, default=64, help='batch size for training (default: 32)')\n    parser.add_argument('--lr', type=float, default=1e-4, help='learning rate (default: 1e-3)')\n    parser.add_argument('--weight_decay', type=float, default=5e-2, help='weight decay (default: 1e-2)')\n    parser.add_argument('--optimizer', type=str, default='AdamW', help='optimizer (AdamW, SGD)')\n    parser.add_argument('--clip_value', type=float, default=1, help='clip_value')\n    parser.add_argument('--dropout', type=float, default=0.1, help='dropout')\n    parser.add_argument('--classifier', type=str, default='avgpooling_patch_reps',\n                        help='[all_patch_reps, avgpooling_patch_reps]')\n    # avgpooling_patch_reps: use average pooling for patch features; all_patch_reps: use all patch features\n\n    \"\"\"############ Downstream dataset settings ############\"\"\"\n    parser.add_argument('--downstream_dataset', type=str, default='FACED',\n                        help='[FACED, SEED-V, PhysioNet-MI, SHU-MI, ISRUC, CHB-MIT, BCIC2020-3, Mumtaz2016, SEED-VIG, MentalArithmetic, TUEV, TUAB, BCIC-IV-2a]')\n    parser.add_argument('--datasets_dir', type=str,\n                        default='/data/datasets/BigDownstream/Faced/processed',\n                        help='datasets_dir')\n    parser.add_argument('--num_of_classes', type=int, default=9, help='number of classes')\n    parser.add_argument('--model_dir', type=str, default='/data/wjq/models_weights/Big/BigFaced', help='model_dir')\n    \"\"\"############ Downstream dataset settings ############\"\"\"\n\n    parser.add_argument('--num_workers', type=int, default=16, help='num_workers')\n    parser.add_argument('--label_smoothing', type=float, default=0.1, help='label_smoothing')\n    parser.add_argument('--multi_lr', type=bool, default=True,\n                        help='multi_lr')  # set different learning rates for different modules\n    parser.add_argument('--frozen', type=bool,\n                        default=False, help='frozen')\n    parser.add_argument('--use_pretrained_weights', type=bool,\n                        default=True, help='use_pretrained_weights')\n    parser.add_argument('--foundation_dir', type=str,\n                        default='pretrained_weights/pretrained_weights.pth',\n                        help='foundation_dir')\n\n    params = parser.parse_args()\n    print(params)\n\n    setup_seed(params.seed)\n    torch.cuda.set_device(params.cuda)\n    print('The downstream dataset is {}'.format(params.downstream_dataset))\n    if params.downstream_dataset == 'FACED':\n        load_dataset = faced_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_faced.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_multiclass()\n    elif params.downstream_dataset == 'SEED-V':\n        load_dataset = seedv_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_seedv.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_multiclass()\n    elif params.downstream_dataset == 'PhysioNet-MI':\n        load_dataset = physio_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_physio.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_multiclass()\n    elif params.downstream_dataset == 'SHU-MI':\n        load_dataset = shu_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_shu.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_binaryclass()\n    elif params.downstream_dataset == 'ISRUC':\n        load_dataset = isruc_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_isruc.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_multiclass()\n    elif params.downstream_dataset == 'CHB-MIT':\n        load_dataset = chb_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_chb.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_binaryclass()\n    elif params.downstream_dataset == 'BCIC2020-3':\n        load_dataset = speech_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_speech.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_multiclass()\n    elif params.downstream_dataset == 'Mumtaz2016':\n        load_dataset = mumtaz_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_mumtaz.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_binaryclass()\n    elif params.downstream_dataset == 'SEED-VIG':\n        load_dataset = seedvig_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_seedvig.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_regression()\n    elif params.downstream_dataset == 'MentalArithmetic':\n        load_dataset = stress_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_stress.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_binaryclass()\n    elif params.downstream_dataset == 'TUEV':\n        load_dataset = tuev_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_tuev.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_multiclass()\n    elif params.downstream_dataset == 'TUAB':\n        load_dataset = tuab_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_tuab.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_binaryclass()\n    elif params.downstream_dataset == 'BCIC-IV-2a':\n        load_dataset = bciciv2a_dataset.LoadDataset(params)\n        data_loader = load_dataset.get_data_loader()\n        model = model_for_bciciv2a.Model(params)\n        t = Trainer(params, data_loader, model)\n        t.train_for_multiclass()\n    print('Done!!!!!')\n\n\ndef setup_seed(seed):\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    np.random.seed(seed)\n    random.seed(seed)\n    torch.backends.cudnn.deterministic = True\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "id": "pretrain_trainer.py",
    "text": "import numpy as np\nimport torch\nfrom ptflops import get_model_complexity_info\nfrom torch.nn import MSELoss\nfrom torchinfo import summary\nfrom tqdm import tqdm\n\nfrom utils.util import generate_mask\n\n\nclass Trainer(object):\n    def __init__(self, params, data_loader, model):\n        self.params = params\n        self.device = torch.device(f\"cuda:{self.params.cuda}\" if torch.cuda.is_available() else \"cpu\")\n        self.data_loader = data_loader\n        self.model = model.to(self.device)\n        self.criterion = MSELoss(reduction='mean').to(self.device)\n\n        if self.params.parallel:\n            device_ids = [0, 1, 2, 3, 4, 5, 6, 7]\n            self.model = torch.nn.DataParallel(self.model, device_ids=device_ids)\n\n        self.data_length = len(self.data_loader)\n\n        summary(self.model, input_size=(1, 19, 30, 200))\n\n        macs, params = get_model_complexity_info(self.model, (19, 30, 200), as_strings=True,\n                                                 print_per_layer_stat=True, verbose=True)\n        print('{:<30}  {:<8}'.format('Computational complexity: ', macs))\n        print('{:<30}  {:<8}'.format('Number of parameters: ', params))\n\n        self.optimizer = torch.optim.AdamW(self.model.parameters(), lr=self.params.lr,\n                                           weight_decay=self.params.weight_decay)\n\n        if self.params.lr_scheduler=='CosineAnnealingLR':\n            self.optimizer_scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(\n                self.optimizer, T_max=40*self.data_length, eta_min=1e-5\n            )\n        elif self.params.lr_scheduler=='ExponentialLR':\n            self.optimizer_scheduler = torch.optim.lr_scheduler.ExponentialLR(\n                self.optimizer, gamma=0.999999999\n            )\n        elif self.params.lr_scheduler=='StepLR':\n            self.optimizer_scheduler = torch.optim.lr_scheduler.StepLR(\n                self.optimizer, step_size=5*self.data_length, gamma=0.5\n            )\n        elif self.params.lr_scheduler=='MultiStepLR':\n            self.optimizer_scheduler = torch.optim.lr_scheduler.MultiStepLR(\n                self.optimizer, milestones=[10*self.data_length, 20*self.data_length, 30*self.data_length], gamma=0.1\n            )\n        elif self.params.lr_scheduler=='CyclicLR':\n            self.optimizer_scheduler = torch.optim.lr_scheduler.CyclicLR(\n                self.optimizer, base_lr=1e-6, max_lr=0.001, step_size_up=self.data_length*5,\n                step_size_down=self.data_length*2, mode='exp_range', gamma=0.9, cycle_momentum=False\n            )\n\n\n    def train(self):\n        best_loss = 10000\n        for epoch in range(self.params.epochs):\n            losses = []\n            for x in tqdm(self.data_loader, mininterval=10):\n                self.optimizer.zero_grad()\n                x = x.to(self.device)/100\n                if self.params.need_mask:\n                    bz, ch_num, patch_num, patch_size = x.shape\n                    mask = generate_mask(\n                        bz, ch_num, patch_num, mask_ratio=self.params.mask_ratio, device=self.device,\n                    )\n                    y = self.model(x, mask=mask)\n                    masked_x = x[mask == 1]\n                    masked_y = y[mask == 1]\n                    loss = self.criterion(masked_y, masked_x)\n\n                    # non_masked_x = x[mask == 0]\n                    # non_masked_y = y[mask == 0]\n                    # non_masked_loss = self.criterion(non_masked_y, non_masked_x)\n                    # loss = 0.8 * masked_loss + 0.2 * non_masked_loss\n                else:\n                    y = self.model(x)\n                    loss = self.criterion(y, x)\n                loss.backward()\n                if self.params.clip_value > 0:\n                    torch.nn.utils.clip_grad_norm_(self.model.parameters(), self.params.clip_value)\n                self.optimizer.step()\n                self.optimizer_scheduler.step()\n                losses.append(loss.data.cpu().numpy())\n            mean_loss = np.mean(losses)\n            learning_rate = self.optimizer.state_dict()['param_groups'][0]['lr']\n            print(f'Epoch {epoch+1}: Training Loss: {mean_loss:.6f}, Learning Rate: {learning_rate:.6f}')\n            if  mean_loss < best_loss:\n                model_path = rf'{self.params.model_dir}/epoch{epoch+1}_loss{mean_loss}.pth'\n                torch.save(self.model.state_dict(), model_path)\n                print(\"model save in \" + model_path)\n                best_loss = mean_loss"
  },
  {
    "id": "pretrain_main.py",
    "text": "import argparse\nimport random\nimport numpy as np\nimport torch\nfrom torch.utils.data import DataLoader\n\nfrom datasets.pretraining_dataset import PretrainingDataset\nfrom models.cbramod import CBraMod\nfrom pretrain_trainer import Trainer\n\n\ndef setup_seed(seed):\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    np.random.seed(seed)\n    random.seed(seed)\n    torch.backends.cudnn.deterministic = True\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='EEG Foundation Model')\n    parser.add_argument('--seed', type=int, default=42, help='random seed (default: 0)')\n    parser.add_argument('--cuda', type=int, default=3, help='cuda number (default: 1)')\n    parser.add_argument('--parallel', type=bool, default=False, help='parallel')\n    parser.add_argument('--epochs', type=int, default=40, help='number of epochs (default: 5)')\n    parser.add_argument('--batch_size', type=int, default=128, help='batch size for training (default: 32)')\n    parser.add_argument('--lr', type=float, default=5e-4, help='learning rate (default: 1e-3)')\n    parser.add_argument('--weight_decay', type=float, default=5e-2, help='weight_decay')\n    parser.add_argument('--clip_value', type=float, default=1, help='clip_value')\n    parser.add_argument('--lr_scheduler', type=str, default='CosineAnnealingLR',\n                        help='lr_scheduler: CosineAnnealingLR, ExponentialLR, StepLR, MultiStepLR, CyclicLR')\n\n    # parser.add_argument('--project_mode', type=str, default='cnn', help='project_mode')\n    parser.add_argument('--dropout', type=float, default=0.1, help='dropout')\n    parser.add_argument('--in_dim', type=int, default=200, help='in_dim')\n    parser.add_argument('--out_dim', type=int, default=200, help='out_dim')\n    parser.add_argument('--d_model', type=int, default=200, help='d_model')\n    parser.add_argument('--dim_feedforward', type=int, default=800, help='dim_feedforward')\n    parser.add_argument('--seq_len', type=int, default=30, help='seq_len')\n    parser.add_argument('--n_layer', type=int, default=12, help='n_layer')\n    parser.add_argument('--nhead', type=int, default=8, help='nhead')\n    parser.add_argument('--need_mask', type=bool, default=True, help='need_mask')\n    parser.add_argument('--mask_ratio', type=float, default=0.5, help='mask_ratio')\n\n    parser.add_argument('--dataset_dir', type=str, default='dataset_dir',\n                        help='dataset_dir')\n    parser.add_argument('--model_dir',   type=str,   default='model_dir', help='model_dir')\n    params = parser.parse_args()\n    print(params)\n    setup_seed(params.seed)\n    pretrained_dataset = PretrainingDataset(dataset_dir=params.dataset_dir)\n    print(len(pretrained_dataset))\n    data_loader = DataLoader(\n        pretrained_dataset,\n        batch_size=params.batch_size,\n        num_workers=8,\n        shuffle=True,\n    )\n    model = CBraMod(\n        params.in_dim, params.out_dim, params.d_model, params.dim_feedforward, params.seq_len, params.n_layer,\n        params.nhead\n    )\n    trainer = Trainer(params, data_loader, model)\n    trainer.train()\n    pretrained_dataset.db.close()\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "id": "quick_example.py",
    "text": "import torch\nimport torch.nn as nn\nfrom models.cbramod import CBraMod\nfrom einops.layers.torch import Rearrange\n\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nmodel = CBraMod().to(device)\nmodel.load_state_dict(torch.load('pretrained_weights/pretrained_weights.pth', map_location=device))\nmodel.proj_out = nn.Identity()\nclassifier = nn.Sequential(\n  Rearrange('b c s p -> b (c s p)'),\n  nn.Linear(22*4*200, 4*200),\n  nn.ELU(),\n  nn.Dropout(0.1),\n  nn.Linear(4 * 200, 200),\n  nn.ELU(),\n  nn.Dropout(0.1),\n  nn.Linear(200, 4),\n).to(device)\n\n# mock_eeg.shape = (batch_size, num_of_channels, time_segments, points_per_patch)\nmock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n# logits.shape = (batch_size, num_of_classes)\nlogits = classifier(model(mock_eeg))\n\nprint(logits.shape)"
  },
  {
    "id": "finetune_trainer.py",
    "text": "import torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader\n# from models.model_for_faced import Model\nfrom tqdm import tqdm\nimport torch\nfrom finetune_evaluator import Evaluator\nfrom torch.nn import CrossEntropyLoss, BCEWithLogitsLoss, MSELoss\nfrom timeit import default_timer as timer\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.manifold import TSNE\nimport matplotlib as mpl\nimport umap\nfrom sklearn.decomposition import PCA\nimport copy\nimport os\n\n\nclass Trainer(object):\n    def __init__(self, params, data_loader, model):\n        self.params = params\n        self.data_loader = data_loader\n\n        self.val_eval = Evaluator(params, self.data_loader['val'])\n        self.test_eval = Evaluator(params, self.data_loader['test'])\n\n        self.model = model.cuda()\n        if self.params.downstream_dataset in ['FACED', 'SEED-V', 'PhysioNet-MI', 'ISRUC', 'BCIC2020-3', 'TUEV', 'BCIC-IV-2a']:\n            self.criterion = CrossEntropyLoss(label_smoothing=self.params.label_smoothing).cuda()\n        elif self.params.downstream_dataset in ['SHU-MI', 'CHB-MIT', 'Mumtaz2016', 'MentalArithmetic', 'TUAB']:\n            self.criterion = BCEWithLogitsLoss().cuda()\n        elif self.params.downstream_dataset == 'SEED-VIG':\n            self.criterion = MSELoss().cuda()\n\n        self.best_model_states = None\n\n        backbone_params = []\n        other_params = []\n        for name, param in self.model.named_parameters():\n            if \"backbone\" in name:\n                backbone_params.append(param)\n\n                if params.frozen:\n                    param.requires_grad = False\n                else:\n                    param.requires_grad = True\n            else:\n                other_params.append(param)\n\n        if self.params.optimizer == 'AdamW':\n            if self.params.multi_lr: # set different learning rates for different modules\n                self.optimizer = torch.optim.AdamW([\n                    {'params': backbone_params, 'lr': self.params.lr},\n                    {'params': other_params, 'lr': self.params.lr * 5}\n                ], weight_decay=self.params.weight_decay)\n            else:\n                self.optimizer = torch.optim.AdamW(self.model.parameters(), lr=self.params.lr,\n                                                   weight_decay=self.params.weight_decay)\n        else:\n            if self.params.multi_lr:\n                self.optimizer = torch.optim.SGD([\n                    {'params': backbone_params, 'lr': self.params.lr},\n                    {'params': other_params, 'lr': self.params.lr * 5}\n                ],  momentum=0.9, weight_decay=self.params.weight_decay)\n            else:\n                self.optimizer = torch.optim.SGD(self.model.parameters(), lr=self.params.lr, momentum=0.9,\n                                                 weight_decay=self.params.weight_decay)\n\n        self.data_length = len(self.data_loader['train'])\n        self.optimizer_scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(\n            self.optimizer, T_max=self.params.epochs * self.data_length, eta_min=1e-6\n        )\n        print(self.model)\n\n    def train_for_multiclass(self):\n        f1_best = 0\n        kappa_best = 0\n        acc_best = 0\n        cm_best = None\n        for epoch in range(self.params.epochs):\n            self.model.train()\n            start_time = timer()\n            losses = []\n            for x, y in tqdm(self.data_loader['train'], mininterval=10):\n                self.optimizer.zero_grad()\n                x = x.cuda()\n                y = y.cuda()\n                pred = self.model(x)\n                if self.params.downstream_dataset == 'ISRUC':\n                    loss = self.criterion(pred.transpose(1, 2), y)\n                else:\n                    loss = self.criterion(pred, y)\n\n                loss.backward()\n                losses.append(loss.data.cpu().numpy())\n                if self.params.clip_value > 0:\n                    torch.nn.utils.clip_grad_norm_(self.model.parameters(), self.params.clip_value)\n                    # torch.nn.utils.clip_grad_value_(self.model.parameters(), self.params.clip_value)\n                self.optimizer.step()\n                self.optimizer_scheduler.step()\n\n            optim_state = self.optimizer.state_dict()\n\n            with torch.no_grad():\n                acc, kappa, f1, cm = self.val_eval.get_metrics_for_multiclass(self.model)\n                print(\n                    \"Epoch {} : Training Loss: {:.5f}, acc: {:.5f}, kappa: {:.5f}, f1: {:.5f}, LR: {:.5f}, Time elapsed {:.2f} mins\".format(\n                        epoch + 1,\n                        np.mean(losses),\n                        acc,\n                        kappa,\n                        f1,\n                        optim_state['param_groups'][0]['lr'],\n                        (timer() - start_time) / 60\n                    )\n                )\n                print(cm)\n                if kappa > kappa_best:\n                    print(\"kappa increasing....saving weights !! \")\n                    print(\"Val Evaluation: acc: {:.5f}, kappa: {:.5f}, f1: {:.5f}\".format(\n                        acc,\n                        kappa,\n                        f1,\n                    ))\n                    best_f1_epoch = epoch + 1\n                    acc_best = acc\n                    kappa_best = kappa\n                    f1_best = f1\n                    cm_best = cm\n                    self.best_model_states = copy.deepcopy(self.model.state_dict())\n        self.model.load_state_dict(self.best_model_states)\n        with torch.no_grad():\n            print(\"***************************Test************************\")\n            acc, kappa, f1, cm = self.test_eval.get_metrics_for_multiclass(self.model)\n            print(\"***************************Test results************************\")\n            print(\n                \"Test Evaluation: acc: {:.5f}, kappa: {:.5f}, f1: {:.5f}\".format(\n                    acc,\n                    kappa,\n                    f1,\n                )\n            )\n            print(cm)\n            if not os.path.isdir(self.params.model_dir):\n                os.makedirs(self.params.model_dir)\n            model_path = self.params.model_dir + \"/epoch{}_acc_{:.5f}_kappa_{:.5f}_f1_{:.5f}.pth\".format(best_f1_epoch, acc, kappa, f1)\n            torch.save(self.model.state_dict(), model_path)\n            print(\"model save in \" + model_path)\n\n    def train_for_binaryclass(self):\n        acc_best = 0\n        roc_auc_best = 0\n        pr_auc_best = 0\n        cm_best = None\n        for epoch in range(self.params.epochs):\n            self.model.train()\n            start_time = timer()\n            losses = []\n            for x, y in tqdm(self.data_loader['train'], mininterval=10):\n                self.optimizer.zero_grad()\n                x = x.cuda()\n                y = y.cuda()\n                pred = self.model(x)\n\n                loss = self.criterion(pred, y)\n\n                loss.backward()\n                losses.append(loss.data.cpu().numpy())\n                if self.params.clip_value > 0:\n                    torch.nn.utils.clip_grad_norm_(self.model.parameters(), self.params.clip_value)\n                    # torch.nn.utils.clip_grad_value_(self.model.parameters(), self.params.clip_value)\n                self.optimizer.step()\n                self.optimizer_scheduler.step()\n\n            optim_state = self.optimizer.state_dict()\n\n            with torch.no_grad():\n                acc, pr_auc, roc_auc, cm = self.val_eval.get_metrics_for_binaryclass(self.model)\n                print(\n                    \"Epoch {} : Training Loss: {:.5f}, acc: {:.5f}, pr_auc: {:.5f}, roc_auc: {:.5f}, LR: {:.5f}, Time elapsed {:.2f} mins\".format(\n                        epoch + 1,\n                        np.mean(losses),\n                        acc,\n                        pr_auc,\n                        roc_auc,\n                        optim_state['param_groups'][0]['lr'],\n                        (timer() - start_time) / 60\n                    )\n                )\n                print(cm)\n                if roc_auc > roc_auc_best:\n                    print(\"kappa increasing....saving weights !! \")\n                    print(\"Val Evaluation: acc: {:.5f}, pr_auc: {:.5f}, roc_auc: {:.5f}\".format(\n                        acc,\n                        pr_auc,\n                        roc_auc,\n                    ))\n                    best_f1_epoch = epoch + 1\n                    acc_best = acc\n                    pr_auc_best = pr_auc\n                    roc_auc_best = roc_auc\n                    cm_best = cm\n                    self.best_model_states = copy.deepcopy(self.model.state_dict())\n        self.model.load_state_dict(self.best_model_states)\n        with torch.no_grad():\n            print(\"***************************Test************************\")\n            acc, pr_auc, roc_auc, cm = self.test_eval.get_metrics_for_binaryclass(self.model)\n            print(\"***************************Test results************************\")\n            print(\n                \"Test Evaluation: acc: {:.5f}, pr_auc: {:.5f}, roc_auc: {:.5f}\".format(\n                    acc,\n                    pr_auc,\n                    roc_auc,\n                )\n            )\n            print(cm)\n            if not os.path.isdir(self.params.model_dir):\n                os.makedirs(self.params.model_dir)\n            model_path = self.params.model_dir + \"/epoch{}_acc_{:.5f}_pr_{:.5f}_roc_{:.5f}.pth\".format(best_f1_epoch, acc, pr_auc, roc_auc)\n            torch.save(self.model.state_dict(), model_path)\n            print(\"model save in \" + model_path)\n\n    def train_for_regression(self):\n        corrcoef_best = 0\n        r2_best = 0\n        rmse_best = 0\n        for epoch in range(self.params.epochs):\n            self.model.train()\n            start_time = timer()\n            losses = []\n            for x, y in tqdm(self.data_loader['train'], mininterval=10):\n                self.optimizer.zero_grad()\n                x = x.cuda()\n                y = y.cuda()\n                pred = self.model(x)\n                loss = self.criterion(pred, y)\n\n                loss.backward()\n                losses.append(loss.data.cpu().numpy())\n                if self.params.clip_value > 0:\n                    torch.nn.utils.clip_grad_norm_(self.model.parameters(), self.params.clip_value)\n                    # torch.nn.utils.clip_grad_value_(self.model.parameters(), self.params.clip_value)\n                self.optimizer.step()\n                self.optimizer_scheduler.step()\n\n            optim_state = self.optimizer.state_dict()\n\n            with torch.no_grad():\n                corrcoef, r2, rmse = self.val_eval.get_metrics_for_regression(self.model)\n                print(\n                    \"Epoch {} : Training Loss: {:.5f}, corrcoef: {:.5f}, r2: {:.5f}, rmse: {:.5f}, LR: {:.5f}, Time elapsed {:.2f} mins\".format(\n                        epoch + 1,\n                        np.mean(losses),\n                        corrcoef,\n                        r2,\n                        rmse,\n                        optim_state['param_groups'][0]['lr'],\n                        (timer() - start_time) / 60\n                    )\n                )\n                if r2 > r2_best:\n                    print(\"kappa increasing....saving weights !! \")\n                    print(\"Val Evaluation: corrcoef: {:.5f}, r2: {:.5f}, rmse: {:.5f}\".format(\n                        corrcoef,\n                        r2,\n                        rmse,\n                    ))\n                    best_r2_epoch = epoch + 1\n                    corrcoef_best = corrcoef\n                    r2_best = r2\n                    rmse_best = rmse\n                    self.best_model_states = copy.deepcopy(self.model.state_dict())\n\n        self.model.load_state_dict(self.best_model_states)\n        with torch.no_grad():\n            print(\"***************************Test************************\")\n            corrcoef, r2, rmse = self.test_eval.get_metrics_for_regression(self.model)\n            print(\"***************************Test results************************\")\n            print(\n                \"Test Evaluation: corrcoef: {:.5f}, r2: {:.5f}, rmse: {:.5f}\".format(\n                    corrcoef,\n                    r2,\n                    rmse,\n                )\n            )\n\n            if not os.path.isdir(self.params.model_dir):\n                os.makedirs(self.params.model_dir)\n            model_path = self.params.model_dir + \"/epoch{}_corrcoef_{:.5f}_r2_{:.5f}_rmse_{:.5f}.pth\".format(best_r2_epoch, corrcoef, r2, rmse)\n            torch.save(self.model.state_dict(), model_path)\n            print(\"model save in \" + model_path)"
  },
  {
    "id": "models/model_for_mumtaz.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(19 * 5 * 200, 5 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(5 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n"
  },
  {
    "id": "models/model_for_seedv.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, param.num_of_classes),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(62 * 1 * 200, 4 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(4 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, param.num_of_classes),\n            )\n\n    def forward(self, x):\n        # x = x / 100\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        feats = feats.contiguous().view(bz, ch_num*seq_len*200)\n        out = self.classifier(feats)\n        return out\n"
  },
  {
    "id": "models/model_for_faced.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, param.num_of_classes),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(32 * 10 * 200, 10 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(10 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, param.num_of_classes),\n            )\n\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n\n\n\n"
  },
  {
    "id": "models/criss_cross_transformer.py",
    "text": "import copy\nfrom typing import Optional, Any, Union, Callable\n\nimport torch\nimport torch.nn as nn\n# import torch.nn.functional as F\nimport warnings\nfrom torch import Tensor\nfrom torch.nn import functional as F\n\n\nclass TransformerEncoder(nn.Module):\n    def __init__(self, encoder_layer, num_layers, norm=None, enable_nested_tensor=True, mask_check=True):\n        super().__init__()\n        torch._C._log_api_usage_once(f\"torch.nn.modules.{self.__class__.__name__}\")\n        self.layers = _get_clones(encoder_layer, num_layers)\n        self.num_layers = num_layers\n        self.norm = norm\n\n    def forward(\n            self,\n            src: Tensor,\n            mask: Optional[Tensor] = None,\n            src_key_padding_mask: Optional[Tensor] = None,\n            is_causal: Optional[bool] = None) -> Tensor:\n\n        output = src\n        for mod in self.layers:\n            output = mod(output, src_mask=mask)\n        if self.norm is not None:\n            output = self.norm(output)\n        return output\n\n\nclass TransformerEncoderLayer(nn.Module):\n    __constants__ = ['norm_first']\n\n    def __init__(self, d_model: int, nhead: int, dim_feedforward: int = 2048, dropout: float = 0.1,\n                 activation: Union[str, Callable[[Tensor], Tensor]] = F.relu,\n                 layer_norm_eps: float = 1e-5, batch_first: bool = False, norm_first: bool = False,\n                 bias: bool = True, device=None, dtype=None) -> None:\n        factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__()\n        self.self_attn_s = nn.MultiheadAttention(d_model//2, nhead // 2, dropout=dropout,\n                                                 bias=bias, batch_first=batch_first,\n                                                 **factory_kwargs)\n        self.self_attn_t = nn.MultiheadAttention(d_model//2, nhead // 2, dropout=dropout,\n                                                 bias=bias, batch_first=batch_first,\n                                                 **factory_kwargs)\n\n        # Implementation of Feedforward model\n        self.linear1 = nn.Linear(d_model, dim_feedforward, bias=bias, **factory_kwargs)\n        self.dropout = nn.Dropout(dropout)\n        self.linear2 = nn.Linear(dim_feedforward, d_model, bias=bias, **factory_kwargs)\n\n        self.norm_first = norm_first\n        self.norm1 = nn.LayerNorm(d_model, eps=layer_norm_eps, **factory_kwargs)\n        self.norm2 = nn.LayerNorm(d_model, eps=layer_norm_eps, **factory_kwargs)\n        self.dropout1 = nn.Dropout(dropout)\n        self.dropout2 = nn.Dropout(dropout)\n\n        # Legacy string support for activation function.\n        if isinstance(activation, str):\n            activation = _get_activation_fn(activation)\n\n        # We can't test self.activation in forward() in TorchScript,\n        # so stash some information about it instead.\n        if activation is F.relu or isinstance(activation, torch.nn.ReLU):\n            self.activation_relu_or_gelu = 1\n        elif activation is F.gelu or isinstance(activation, torch.nn.GELU):\n            self.activation_relu_or_gelu = 2\n        else:\n            self.activation_relu_or_gelu = 0\n        self.activation = activation\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        if not hasattr(self, 'activation'):\n            self.activation = F.relu\n\n\n    def forward(\n            self,\n            src: Tensor,\n            src_mask: Optional[Tensor] = None,\n            src_key_padding_mask: Optional[Tensor] = None,\n            is_causal: bool = False) -> Tensor:\n\n        x = src\n        x = x + self._sa_block(self.norm1(x), src_mask, src_key_padding_mask, is_causal=is_causal)\n        x = x + self._ff_block(self.norm2(x))\n        return x\n\n    # self-attention block\n    def _sa_block(self, x: Tensor,\n                  attn_mask: Optional[Tensor], key_padding_mask: Optional[Tensor], is_causal: bool = False) -> Tensor:\n        bz, ch_num, patch_num, patch_size = x.shape\n        xs = x[:, :, :, :patch_size // 2]\n        xt = x[:, :, :, patch_size // 2:]\n        xs = xs.transpose(1, 2).contiguous().view(bz*patch_num, ch_num, patch_size // 2)\n        xt = xt.contiguous().view(bz*ch_num, patch_num, patch_size // 2)\n        xs = self.self_attn_s(xs, xs, xs,\n                             attn_mask=attn_mask,\n                             key_padding_mask=key_padding_mask,\n                             need_weights=False)[0]\n        xs = xs.contiguous().view(bz, patch_num, ch_num, patch_size//2).transpose(1, 2)\n        xt = self.self_attn_t(xt, xt, xt,\n                              attn_mask=attn_mask,\n                              key_padding_mask=key_padding_mask,\n                              need_weights=False)[0]\n        xt = xt.contiguous().view(bz, ch_num, patch_num, patch_size//2)\n        x = torch.concat((xs, xt), dim=3)\n        return self.dropout1(x)\n\n    # feed forward block\n    def _ff_block(self, x: Tensor) -> Tensor:\n        x = self.linear2(self.dropout(self.activation(self.linear1(x))))\n        return self.dropout2(x)\n\n\n\ndef _get_activation_fn(activation: str) -> Callable[[Tensor], Tensor]:\n    if activation == \"relu\":\n        return F.relu\n    elif activation == \"gelu\":\n        return F.gelu\n\n    raise RuntimeError(f\"activation should be relu/gelu, not {activation}\")\n\ndef _get_clones(module, N):\n    # FIXME: copy.deepcopy() is not defined on nn.module\n    return nn.ModuleList([copy.deepcopy(module) for i in range(N)])\n\n\ndef _get_seq_len(\n        src: Tensor,\n        batch_first: bool\n) -> Optional[int]:\n\n    if src.is_nested:\n        return None\n    else:\n        src_size = src.size()\n        if len(src_size) == 2:\n            # unbatched: S, E\n            return src_size[0]\n        else:\n            # batched: B, S, E if batch_first else S, B, E\n            seq_len_pos = 1 if batch_first else 0\n            return src_size[seq_len_pos]\n\n\ndef _detect_is_causal_mask(\n        mask: Optional[Tensor],\n        is_causal: Optional[bool] = None,\n        size: Optional[int] = None,\n) -> bool:\n    \"\"\"Return whether the given attention mask is causal.\n\n    Warning:\n    If ``is_causal`` is not ``None``, its value will be returned as is.  If a\n    user supplies an incorrect ``is_causal`` hint,\n\n    ``is_causal=False`` when the mask is in fact a causal attention.mask\n       may lead to reduced performance relative to what would be achievable\n       with ``is_causal=True``;\n    ``is_causal=True`` when the mask is in fact not a causal attention.mask\n       may lead to incorrect and unpredictable execution - in some scenarios,\n       a causal mask may be applied based on the hint, in other execution\n       scenarios the specified mask may be used.  The choice may not appear\n       to be deterministic, in that a number of factors like alignment,\n       hardware SKU, etc influence the decision whether to use a mask or\n       rely on the hint.\n    ``size`` if not None, check whether the mask is a causal mask of the provided size\n       Otherwise, checks for any causal mask.\n    \"\"\"\n    # Prevent type refinement\n    make_causal = (is_causal is True)\n\n    if is_causal is None and mask is not None:\n        sz = size if size is not None else mask.size(-2)\n        causal_comparison = _generate_square_subsequent_mask(\n            sz, device=mask.device, dtype=mask.dtype)\n\n        # Do not use `torch.equal` so we handle batched masks by\n        # broadcasting the comparison.\n        if mask.size() == causal_comparison.size():\n            make_causal = bool((mask == causal_comparison).all())\n        else:\n            make_causal = False\n\n    return make_causal\n\n\ndef _generate_square_subsequent_mask(\n        sz: int,\n        device: torch.device = torch.device(torch._C._get_default_device()),  # torch.device('cpu'),\n        dtype: torch.dtype = torch.get_default_dtype(),\n) -> Tensor:\n    r\"\"\"Generate a square causal mask for the sequence. The masked positions are filled with float('-inf').\n        Unmasked positions are filled with float(0.0).\n    \"\"\"\n    return torch.triu(\n        torch.full((sz, sz), float('-inf'), dtype=dtype, device=device),\n        diagonal=1,\n    )\n\n\nif __name__ == '__main__':\n    encoder_layer = TransformerEncoderLayer(\n        d_model=256, nhead=4, dim_feedforward=1024, batch_first=True, norm_first=True,\n        activation=F.gelu\n    )\n    encoder = TransformerEncoder(encoder_layer, num_layers=2, enable_nested_tensor=False)\n    encoder = encoder.cuda()\n\n    a = torch.randn((4, 19, 30, 256)).cuda()\n    b = encoder(a)\n    print(a.shape, b.shape)"
  },
  {
    "id": "models/model_for_tuev.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, param.num_of_classes),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(16 * 5 * 200, 5 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(5 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, param.num_of_classes),\n            )\n\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n\n"
  },
  {
    "id": "models/model_for_isruc.py",
    "text": "import torch\nimport torch.nn as nn\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super().__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n\n        self.head = nn.Sequential(\n            nn.Linear(6*30*200, 512),\n            nn.GELU(),\n        )\n\n        encoder_layer = nn.TransformerEncoderLayer(\n            d_model=512, nhead=4, dim_feedforward=2048, batch_first=True, activation=F.gelu, norm_first=True\n        )\n        self.sequence_encoder = nn.TransformerEncoder(encoder_layer, num_layers=1, enable_nested_tensor=False)\n        self.classifier = nn.Linear(512, param.num_of_classes)\n\n        # self.apply(_weights_init)\n\n    def forward(self, x):\n        bz, seq_len, ch_num, epoch_size = x.shape\n\n        x = x.contiguous().view(bz * seq_len, ch_num, 30, 200)\n        epoch_features = self.backbone(x)\n        epoch_features = epoch_features.contiguous().view(bz, seq_len, ch_num*30*200)\n        epoch_features = self.head(epoch_features)\n        seq_features = self.sequence_encoder(epoch_features)\n        out = self.classifier(seq_features)\n        return out\n"
  },
  {
    "id": "models/model_for_speech.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, param.num_of_classes)\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(64*3*200, 3*200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(3*200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, param.num_of_classes),\n            )\n\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n\n"
  },
  {
    "id": "models/model_for_chb.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(16*10*200, 10*200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(10*200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out"
  },
  {
    "id": "models/model_for_bciciv2a.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, param.num_of_classes),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(22 * 4 * 200, 4 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(4 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, param.num_of_classes),\n            )\n\n    def forward(self, x):\n        # x = x / 100\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n"
  },
  {
    "id": "models/model_for_stress.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(20 * 5 * 200, 5 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(5 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n\n"
  },
  {
    "id": "models/cbramod.py",
    "text": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom models.criss_cross_transformer import TransformerEncoderLayer, TransformerEncoder\n\n\nclass CBraMod(nn.Module):\n    def __init__(self, in_dim=200, out_dim=200, d_model=200, dim_feedforward=800, seq_len=30, n_layer=12,\n                    nhead=8):\n        super().__init__()\n        self.patch_embedding = PatchEmbedding(in_dim, out_dim, d_model, seq_len)\n        encoder_layer = TransformerEncoderLayer(\n            d_model=d_model, nhead=nhead, dim_feedforward=dim_feedforward, batch_first=True, norm_first=True,\n            activation=F.gelu\n        )\n        self.encoder = TransformerEncoder(encoder_layer, num_layers=n_layer, enable_nested_tensor=False)\n        self.proj_out = nn.Sequential(\n            # nn.Linear(d_model, d_model*2),\n            # nn.GELU(),\n            # nn.Linear(d_model*2, d_model),\n            # nn.GELU(),\n            nn.Linear(d_model, out_dim),\n        )\n        self.apply(_weights_init)\n\n    def forward(self, x, mask=None):\n        patch_emb = self.patch_embedding(x, mask)\n        feats = self.encoder(patch_emb)\n\n        out = self.proj_out(feats)\n\n        return out\n\nclass PatchEmbedding(nn.Module):\n    def __init__(self, in_dim, out_dim, d_model, seq_len):\n        super().__init__()\n        self.d_model = d_model\n        self.positional_encoding = nn.Sequential(\n            nn.Conv2d(in_channels=d_model, out_channels=d_model, kernel_size=(19, 7), stride=(1, 1), padding=(9, 3),\n                      groups=d_model),\n        )\n        self.mask_encoding = nn.Parameter(torch.zeros(in_dim), requires_grad=False)\n        # self.mask_encoding = nn.Parameter(torch.randn(in_dim), requires_grad=True)\n\n        self.proj_in = nn.Sequential(\n            nn.Conv2d(in_channels=1, out_channels=25, kernel_size=(1, 49), stride=(1, 25), padding=(0, 24)),\n            nn.GroupNorm(5, 25),\n            nn.GELU(),\n\n            nn.Conv2d(in_channels=25, out_channels=25, kernel_size=(1, 3), stride=(1, 1), padding=(0, 1)),\n            nn.GroupNorm(5, 25),\n            nn.GELU(),\n\n            nn.Conv2d(in_channels=25, out_channels=25, kernel_size=(1, 3), stride=(1, 1), padding=(0, 1)),\n            nn.GroupNorm(5, 25),\n            nn.GELU(),\n        )\n        self.spectral_proj = nn.Sequential(\n            nn.Linear(101, d_model),\n            nn.Dropout(0.1),\n            # nn.LayerNorm(d_model, eps=1e-5),\n        )\n        # self.norm1 = nn.LayerNorm(d_model, eps=1e-5)\n        # self.norm2 = nn.LayerNorm(d_model, eps=1e-5)\n        # self.proj_in = nn.Sequential(\n        #     nn.Linear(in_dim, d_model, bias=False),\n        # )\n\n\n    def forward(self, x, mask=None):\n        bz, ch_num, patch_num, patch_size = x.shape\n        if mask == None:\n            mask_x = x\n        else:\n            mask_x = x.clone()\n            mask_x[mask == 1] = self.mask_encoding\n\n        mask_x = mask_x.contiguous().view(bz, 1, ch_num * patch_num, patch_size)\n        patch_emb = self.proj_in(mask_x)\n        patch_emb = patch_emb.permute(0, 2, 1, 3).contiguous().view(bz, ch_num, patch_num, self.d_model)\n\n        mask_x = mask_x.contiguous().view(bz*ch_num*patch_num, patch_size)\n        spectral = torch.fft.rfft(mask_x, dim=-1, norm='forward')\n        spectral = torch.abs(spectral).contiguous().view(bz, ch_num, patch_num, 101)\n        spectral_emb = self.spectral_proj(spectral)\n        # print(patch_emb[5, 5, 5, :])\n        # print(spectral_emb[5, 5, 5, :])\n        patch_emb = patch_emb + spectral_emb\n\n        positional_embedding = self.positional_encoding(patch_emb.permute(0, 3, 1, 2))\n        positional_embedding = positional_embedding.permute(0, 2, 3, 1)\n\n        patch_emb = patch_emb + positional_embedding\n\n        return patch_emb\n\n\ndef _weights_init(m):\n    if isinstance(m, nn.Linear):\n        nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n    if isinstance(m, nn.Conv1d):\n        nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n    elif isinstance(m, nn.BatchNorm1d):\n        nn.init.constant_(m.weight, 1)\n        nn.init.constant_(m.bias, 0)\n\n\n\nif __name__ == '__main__':\n\n    device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n    model = CBraMod(in_dim=200, out_dim=200, d_model=200, dim_feedforward=800, seq_len=30, n_layer=12,\n                    nhead=8).to(device)\n    model.load_state_dict(torch.load('pretrained_weights/pretrained_weights.pth',\n                                     map_location=device))\n    a = torch.randn((8, 16, 10, 200)).cuda()\n    b = model(a)\n    print(a.shape, b.shape)\n"
  },
  {
    "id": "models/model_for_seedvig.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(17 * 8 * 200, 8 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(8 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n\n"
  },
  {
    "id": "models/model_for_physio.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, param.num_of_classes),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(64 * 4 * 200, 4 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(4 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, param.num_of_classes),\n            )\n\n\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n"
  },
  {
    "id": "models/model_for_shu.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(32 * 4 * 200, 4 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(4 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n\n\n"
  },
  {
    "id": "models/model_for_tuab.py",
    "text": "import torch\nimport torch.nn as nn\nfrom einops.layers.torch import Rearrange\n\nfrom .cbramod import CBraMod\n\n\nclass Model(nn.Module):\n    def __init__(self, param):\n        super(Model, self).__init__()\n        self.backbone = CBraMod(\n            in_dim=200, out_dim=200, d_model=200,\n            dim_feedforward=800, seq_len=30,\n            n_layer=12, nhead=8\n        )\n        if param.use_pretrained_weights:\n            map_location = torch.device(f'cuda:{param.cuda}')\n            self.backbone.load_state_dict(torch.load(param.foundation_dir, map_location=map_location))\n        self.backbone.proj_out = nn.Identity()\n        if param.classifier == 'avgpooling_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b d c s'),\n                nn.AdaptiveAvgPool2d((1, 1)),\n                nn.Flatten(),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n        elif param.classifier == 'all_patch_reps':\n            self.classifier = nn.Sequential(\n                Rearrange('b c s d -> b (c s d)'),\n                nn.Linear(16 * 10 * 200, 10 * 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(10 * 200, 200),\n                nn.ELU(),\n                nn.Dropout(param.dropout),\n                nn.Linear(200, 1),\n                Rearrange('b 1 -> (b 1)'),\n            )\n\n    def forward(self, x):\n        bz, ch_num, seq_len, patch_size = x.shape\n        feats = self.backbone(x)\n        out = self.classifier(feats)\n        return out\n"
  },
  {
    "id": "models/__init__.py",
    "text": ""
  },
  {
    "id": "datasets/seedvig_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.db = lmdb.open(data_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))[mode]\n\n    def __len__(self):\n        return len((self.keys))\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n        with self.db.begin(write=False) as txn:\n            pair = pickle.loads(txn.get(key.encode()))\n        data = pair['sample']\n        label = pair['label']\n        # print(key)\n        # print(data.shape)\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label)\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/seedv_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\n\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.db = lmdb.open(data_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))[mode]\n\n    def __len__(self):\n        return len((self.keys))\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n        with self.db.begin(write=False) as txn:\n            pair = pickle.loads(txn.get(key.encode()))\n        data = pair['sample']\n        label = pair['label']\n        # print(key)\n        # print(data)\n        # print(label)\n        return data / 100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label).long()\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set) + len(val_set) + len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/tuev_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\nfrom scipy import signal\n\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            files,\n    ):\n        super(CustomDataset, self).__init__()\n        self.data_dir = data_dir\n        self.files = files\n\n    def __len__(self):\n        return len((self.files))\n\n    def __getitem__(self, idx):\n        file = self.files[idx]\n        data_dict = pickle.load(open(os.path.join(self.data_dir, file), \"rb\"))\n        data = data_dict['signal']\n        label = int(data_dict['label'][0]-1)\n        # data = signal.resample(data, 1000, axis=-1)\n        data = data.reshape(16, 5, 200)\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label).long()\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_files = os.listdir(os.path.join(self.datasets_dir, \"processed_train\"))\n        val_files = os.listdir(os.path.join(self.datasets_dir, \"processed_eval\"))\n        test_files = os.listdir(os.path.join(self.datasets_dir, \"processed_test\"))\n\n        train_set = CustomDataset(os.path.join(self.datasets_dir, \"processed_train\"), train_files)\n        val_set = CustomDataset(os.path.join(self.datasets_dir, \"processed_eval\"), val_files)\n        test_set = CustomDataset(os.path.join(self.datasets_dir, \"processed_test\"), test_files)\n\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set)+len(val_set)+len(test_set))\n\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/isruc_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\n\n\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            seqs_labels_path_pair\n    ):\n        super(CustomDataset, self).__init__()\n        self.seqs_labels_path_pair = seqs_labels_path_pair\n\n    def __len__(self):\n        return len((self.seqs_labels_path_pair))\n\n    def __getitem__(self, idx):\n        seq_path = self.seqs_labels_path_pair[idx][0]\n        label_path = self.seqs_labels_path_pair[idx][1]\n        # print(seq_path)\n        # print(label_path)\n        seq = np.load(seq_path)\n        label = np.load(label_path)\n        return seq, label\n\n    def collate(self, batch):\n        x_seq = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_seq), to_tensor(y_label).long()\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.seqs_dir = os.path.join(params.datasets_dir, 'seq')\n        self.labels_dir = os.path.join(params.datasets_dir, 'labels')\n        self.seqs_labels_path_pair = self.load_path()\n\n    def get_data_loader(self):\n        train_pairs, val_pairs, test_pairs = self.split_dataset(self.seqs_labels_path_pair)\n        train_set = CustomDataset(train_pairs)\n        val_set = CustomDataset(val_pairs)\n        test_set = CustomDataset(test_pairs)\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set) + len(val_set) + len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=1,\n                collate_fn=val_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=1,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n\n    def load_path(self):\n        seqs_labels_path_pair = []\n        # subject_nums = os.listdir(self.seqs_dir)\n        # print(subject_nums)\n        subject_dirs_seq = []\n        subject_dirs_labels = []\n        for subject_num in range(1, 101):\n            subject_dirs_seq.append(os.path.join(self.seqs_dir, f'ISRUC-group1-{subject_num}'))\n            subject_dirs_labels.append(os.path.join(self.labels_dir, f'ISRUC-group1-{subject_num}'))\n\n        for subject_seq, subject_label in zip(subject_dirs_seq, subject_dirs_labels):\n            # print(subject_seq, subject_label)\n            subject_pairs = []\n            seq_fnames = os.listdir(subject_seq)\n            label_fnames = os.listdir(subject_label)\n            # print(seq_fnames)\n            for seq_fname, label_fname in zip(seq_fnames, label_fnames):\n                subject_pairs.append((os.path.join(subject_seq, seq_fname), os.path.join(subject_label, label_fname)))\n            seqs_labels_path_pair.append(subject_pairs)\n        # print(seqs_labels_path_pair)\n        return seqs_labels_path_pair\n\n    def split_dataset(self, seqs_labels_path_pair):\n        train_pairs = []\n        val_pairs = []\n        test_pairs = []\n\n        for i in range(100):\n            if i < 80:\n                train_pairs.extend(seqs_labels_path_pair[i])\n            elif i < 90:\n                val_pairs.extend(seqs_labels_path_pair[i])\n            else:\n                test_pairs.extend(seqs_labels_path_pair[i])\n        # print(train_pairs, val_pairs, test_pairs)\n        return train_pairs, val_pairs, test_pairs\n"
  },
  {
    "id": "datasets/speech_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.db = lmdb.open(data_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))[mode]\n\n    def __len__(self):\n        return len((self.keys))\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n        with self.db.begin(write=False) as txn:\n            pair = pickle.loads(txn.get(key.encode()))\n        data = pair['sample']\n        label = pair['label']\n        # print(key)\n        # print(data.shape)\n        # print(label)\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label).long()\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/chb_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\nfrom scipy import signal\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.files = [os.path.join(data_dir, mode, file) for file in os.listdir(os.path.join(data_dir, mode))]\n\n\n    def __len__(self):\n        return len((self.files))\n\n    def __getitem__(self, idx):\n        file = self.files[idx]\n        data_dict = pickle.load(open(file, 'rb'))\n        data = data_dict['X']\n        label = data_dict['y']\n        data = signal.resample(data, 2000, axis=1)\n        data = data.reshape(16, 10, 200)\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label)\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set) + len(val_set) + len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/shu_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.db = lmdb.open(data_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))[mode]\n        if mode == 'train':\n            random.shuffle(self.keys)\n            length = len(self.keys)\n            self.keys = self.keys[:int(length * 0.3)]\n\n    def __len__(self):\n        return len((self.keys))\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n        with self.db.begin(write=False) as txn:\n            pair = pickle.loads(txn.get(key.encode()))\n        data = pair['sample']\n        label = pair['label']\n        # print(label)\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label)\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set)+len(val_set)+len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=True,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=True,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/tuab_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\nfrom scipy import signal\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.files = [os.path.join(data_dir, mode, file) for file in os.listdir(os.path.join(data_dir, mode))]\n\n\n    def __len__(self):\n        return len((self.files))\n\n    def __getitem__(self, idx):\n        file = self.files[idx]\n        data_dict = pickle.load(open(file, 'rb'))\n        data = data_dict['X']\n        label = data_dict['y']\n        # data = signal.resample(data, 2000, axis=-1)\n        data = data.reshape(16, 10, 200)\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label)\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set) + len(val_set) + len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/physio_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.db = lmdb.open(data_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))[mode]\n\n    def __len__(self):\n        return len((self.keys))\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n        with self.db.begin(write=False) as txn:\n            pair = pickle.loads(txn.get(key.encode()))\n        data = pair['sample']\n        label = pair['label']\n        # print(key)\n        # print(data)\n        # print(label)\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label).long()\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set)+len(val_set)+len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/mumtaz_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.db = lmdb.open(data_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))[mode]\n\n    def __len__(self):\n        return len((self.keys))\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n        with self.db.begin(write=False) as txn:\n            pair = pickle.loads(txn.get(key.encode()))\n        data = pair['sample']\n        label = pair['label']\n        # print(label)\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label)\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set) + len(val_set) + len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=True,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=True,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/faced_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.db = lmdb.open(data_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))[mode]\n\n    def __len__(self):\n        return len((self.keys))\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n        with self.db.begin(write=False) as txn:\n            pair = pickle.loads(txn.get(key.encode()))\n        data = pair['sample']\n        label = pair['label']\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label).long()\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set)+len(val_set)+len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/pretraining_dataset.py",
    "text": "import pickle\n\nimport lmdb\nfrom torch.utils.data import Dataset\n\nfrom utils.util import to_tensor\n\n\nclass PretrainingDataset(Dataset):\n    def __init__(\n            self,\n            dataset_dir\n    ):\n        super(PretrainingDataset, self).__init__()\n        self.db = lmdb.open(dataset_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))\n        # self.keys = self.keys[:100000]\n\n    def __len__(self):\n        return len(self.keys)\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n\n        with self.db.begin(write=False) as txn:\n            patch = pickle.loads(txn.get(key.encode()))\n\n        patch = to_tensor(patch)\n        # print(patch.shape)\n        return patch\n\n\n\n"
  },
  {
    "id": "datasets/bciciv2a_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.db = lmdb.open(data_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))[mode]\n\n    def __len__(self):\n        return len((self.keys))\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n        with self.db.begin(write=False) as txn:\n            pair = pickle.loads(txn.get(key.encode()))\n        data = pair['sample']\n        label = pair['label']\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label).long()\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set)+len(val_set)+len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=False,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "datasets/__init__.py",
    "text": ""
  },
  {
    "id": "datasets/stress_dataset.py",
    "text": "import torch\nfrom torch.utils.data import Dataset, DataLoader\nimport numpy as np\nfrom utils.util import to_tensor\nimport os\nimport random\nimport lmdb\nimport pickle\n\nclass CustomDataset(Dataset):\n    def __init__(\n            self,\n            data_dir,\n            mode='train',\n    ):\n        super(CustomDataset, self).__init__()\n        self.db = lmdb.open(data_dir, readonly=True, lock=False, readahead=True, meminit=False)\n        with self.db.begin(write=False) as txn:\n            self.keys = pickle.loads(txn.get('__keys__'.encode()))[mode]\n\n    def __len__(self):\n        return len((self.keys))\n\n    def __getitem__(self, idx):\n        key = self.keys[idx]\n        with self.db.begin(write=False) as txn:\n            pair = pickle.loads(txn.get(key.encode()))\n        data = pair['sample']\n        label = pair['label']\n        # print(label)\n        return data/100, label\n\n    def collate(self, batch):\n        x_data = np.array([x[0] for x in batch])\n        y_label = np.array([x[1] for x in batch])\n        return to_tensor(x_data), to_tensor(y_label)\n\n\nclass LoadDataset(object):\n    def __init__(self, params):\n        self.params = params\n        self.datasets_dir = params.datasets_dir\n\n    def get_data_loader(self):\n        train_set = CustomDataset(self.datasets_dir, mode='train')\n        val_set = CustomDataset(self.datasets_dir, mode='val')\n        test_set = CustomDataset(self.datasets_dir, mode='test')\n        print(len(train_set), len(val_set), len(test_set))\n        print(len(train_set)+len(val_set)+len(test_set))\n        data_loader = {\n            'train': DataLoader(\n                train_set,\n                batch_size=self.params.batch_size,\n                collate_fn=train_set.collate,\n                shuffle=True,\n            ),\n            'val': DataLoader(\n                val_set,\n                batch_size=self.params.batch_size,\n                collate_fn=val_set.collate,\n                shuffle=True,\n            ),\n            'test': DataLoader(\n                test_set,\n                batch_size=self.params.batch_size,\n                collate_fn=test_set.collate,\n                shuffle=True,\n            ),\n        }\n        return data_loader\n"
  },
  {
    "id": "preprocessing/preprocessing_speech.py",
    "text": "import h5py\nimport scipy\nfrom scipy import signal\nimport os\nimport lmdb\nimport pickle\nimport numpy as np\nimport pandas as pd\n\n\ntrain_dir = '/data/datasets/BigDownstream/Imagined speech/mat/Training set'\nval_dir = '/data/datasets/BigDownstream/Imagined speech/mat/Validation set'\ntest_dir = '/data/datasets/BigDownstream/Imagined speech/mat/Test set'\n\n\n\nfiles_dict = {\n    'train':sorted([file for file in os.listdir(train_dir)]),\n    'val':sorted([file for file in os.listdir(val_dir)]),\n    'test':sorted([file for file in os.listdir(test_dir)]),\n}\n\nprint(files_dict)\n\ndataset = {\n    'train': list(),\n    'val': list(),\n    'test': list(),\n}\n\ndb = lmdb.open('/data/datasets/BigDownstream/Imagined speech/processed', map_size=3000000000)\n\nfor file in files_dict['train']:\n    data = scipy.io.loadmat(os.path.join(train_dir, file))\n    print(data['epo_train'][0][0][0])\n    eeg = data['epo_train'][0][0][4].transpose(2, 1, 0)\n    labels = data['epo_train'][0][0][5].transpose(1, 0)\n    eeg = eeg[:, :, -768:]\n    labels = np.argmax(labels, axis=1)\n    eeg = signal.resample(eeg, 600, axis=2).reshape(300, 64, 3, 200)\n    print(eeg.shape, labels.shape)\n    for i, (sample, label) in enumerate(zip(eeg, labels)):\n        sample_key = f'train-{file[:-4]}-{i}'\n        data_dict = {\n            'sample': sample, 'label': label,\n        }\n        txn = db.begin(write=True)\n        txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n        txn.commit()\n        print(sample_key)\n        dataset['train'].append(sample_key)\n\n\nfor file in files_dict['val']:\n    data = scipy.io.loadmat(os.path.join(val_dir, file))\n    eeg = data['epo_validation'][0][0][4].transpose(2, 1, 0)\n    labels = data['epo_validation'][0][0][5].transpose(1, 0)\n    eeg = eeg[:, :, -768:]\n    labels = np.argmax(labels, axis=1)\n    eeg = signal.resample(eeg, 600, axis=2).reshape(50, 64, 3, 200)\n    print(eeg.shape, labels.shape)\n    for i, (sample, label) in enumerate(zip(eeg, labels)):\n        sample_key = f'val-{file[:-4]}-{i}'\n        data_dict = {\n            'sample': sample, 'label': label,\n        }\n        txn = db.begin(write=True)\n        txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n        txn.commit()\n        print(sample_key)\n        dataset['val'].append(sample_key)\n\n\ndf = pd.read_excel(\"/data/datasets/BigDownstream/Imagined speech/mat/Track3_Answer Sheet_Test.xlsx\")\ndf_=df.head(53)\nall_labels=df_.values\nprint(all_labels.shape)\nall_labels = all_labels[2:, 1:][:, 1:30:2].transpose(1, 0)\nprint(all_labels.shape)\nprint(all_labels)\n\nfor j, file in enumerate(files_dict['test']):\n    data = h5py.File(os.path.join(test_dir, file))\n    eeg = data['epo_test']['x'][:]\n    labels = all_labels[j]\n    eeg = eeg[:, :, -768:]\n    eeg = signal.resample(eeg, 600, axis=2).reshape(50, 64, 3, 200)\n    print(eeg.shape, labels.shape)\n    for i, (sample, label) in enumerate(zip(eeg, labels)):\n        sample_key = f'test-{file[:-4]}-{i}'\n        data_dict = {\n            'sample': sample, 'label': label-1,\n        }\n        txn = db.begin(write=True)\n        txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n        txn.commit()\n        print(sample_key)\n        dataset['test'].append(sample_key)\n\n\ntxn = db.begin(write=True)\ntxn.put(key='__keys__'.encode(), value=pickle.dumps(dataset))\ntxn.commit()\ndb.close()"
  },
  {
    "id": "preprocessing/preprocessing_bciciv2a.py",
    "text": "import numpy as np\nimport scipy\nfrom scipy import signal\nimport os\nimport lmdb\nimport pickle\nfrom scipy.signal import butter, lfilter, resample, filtfilt\n\ndef butter_bandpass(low_cut, high_cut, fs, order=5):\n    nyq = 0.5 * fs\n    low = low_cut / nyq\n    high = high_cut / nyq\n    b, a = butter(order, [low, high], btype='band')\n    return b, a\n\nroot_dir = '/data/datasets/BCICIV2a/data_mat'\nfiles = [file for file in os.listdir(root_dir)]\nfiles = sorted(files)\n\n# files.remove('A04E.mat')\n# files.remove('A04T.mat')\n# files.remove('A06E.mat')\n# files.remove('A06T.mat')\nprint(files)\n\nfiles_dict = {\n    'train': ['A01E.mat', 'A01T.mat', 'A02E.mat', 'A02T.mat', 'A03E.mat', 'A03T.mat',\n              'A04E.mat', 'A04T.mat',\n              'A05E.mat', 'A05T.mat'],\n    'val': [\n        'A06E.mat', 'A06T.mat',\n        'A07E.mat', 'A07T.mat'\n    ],\n    'test': ['A08E.mat', 'A08T.mat', 'A09E.mat', 'A09T.mat'],\n}\n\n\n\ndataset = {\n    'train': list(),\n    'val': list(),\n    'test': list(),\n}\n\n# for file in files:\n#     if 'E' in file:\n#         files_dict['train'].append(file)\n#     else:\n#         files_dict['test'].append(file)\n#\n# print(files_dict)\n\n\ndb = lmdb.open('/data/datasets/BCICIV2a/processed_inde_avg_03_50', map_size=1610612736)\nfor files_key in files_dict.keys():\n    for file in files_dict[files_key]:\n        print(file)\n        data = scipy.io.loadmat(os.path.join(root_dir, file))\n        num = len(data['data'][0])\n        # print(num)\n        # print(data['data'][0, 8][0, 0][0].shape)\n        # print(data['data'][0, 8][0, 0][1].shape)\n        # print(data['data'][0, 8][0, 0][2].shape)\n        for j in range(3, num):\n            raw_data = data['data'][0, j][0, 0][0][:, :22]\n            events = data['data'][0, j][0, 0][1][:, 0]\n            labels = data['data'][0, j][0, 0][2][:, 0]\n            length = raw_data.shape[0]\n            events = events.tolist()\n            events.append(length)\n            # print(events)\n            annos = []\n            for i in range(len(events) - 1):\n                annos.append((events[i], events[i + 1]))\n            for i, (anno, label) in enumerate(zip(annos, labels)):\n                sample = raw_data[anno[0]:anno[1]].transpose(1, 0)\n                sample  = sample - np.mean(sample, axis=0, keepdims=True)\n                # print(samples.shape)\n                b, a = butter_bandpass(0.3, 50, 250)\n                sample = lfilter(b, a, sample, -1)\n                # print(sample.shape)\n                sample = sample[:, 2 * 250:6 * 250]\n                sample = resample(sample, 800, axis=-1)\n                # print(sample.shape)\n                # print(i, sample.shape, label)\n                sample = sample.reshape(22, 4, 200)\n                sample_key = f'{file[:-4]}-{j}-{i}'\n                print(sample_key, label-1)\n                data_dict = {\n                    'sample': sample, 'label': label - 1\n                }\n                # print(label-1)\n                txn = db.begin(write=True)\n                txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n                txn.commit()\n                dataset[files_key].append(sample_key)\n\n\ntxn = db.begin(write=True)\ntxn.put(key='__keys__'.encode(), value=pickle.dumps(dataset))\ntxn.commit()\ndb.close()\n"
  },
  {
    "id": "preprocessing/preprocessing_tuev.py",
    "text": "import mne\nimport numpy as np\nimport os\nimport pickle\nfrom tqdm import tqdm\n\n\"\"\"\nhttps://github.com/Abhishaike/EEG_Event_Classification\n\"\"\"\n\n\ndef BuildEvents(signals, times, EventData):\n    [numEvents, z] = EventData.shape  # numEvents is equal to # of rows of the .rec file\n    fs = 200.0\n    [numChan, numPoints] = signals.shape\n    # for i in range(numChan):  # standardize each channel\n    #     if np.std(signals[i, :]) > 0:\n    #         signals[i, :] = (signals[i, :] - np.mean(signals[i, :])) / np.std(signals[i, :])\n    features = np.zeros([numEvents, numChan, int(fs) * 5])\n    offending_channel = np.zeros([numEvents, 1])  # channel that had the detected thing\n    labels = np.zeros([numEvents, 1])\n    offset = signals.shape[1]\n    signals = np.concatenate([signals, signals, signals], axis=1)\n    for i in range(numEvents):  # for each event\n        chan = int(EventData[i, 0])  # chan is channel\n        start = np.where((times) >= EventData[i, 1])[0][0]\n        end = np.where((times) >= EventData[i, 2])[0][0]\n        # print (offset + start - 2 * int(fs), offset + end + 2 * int(fs), signals.shape)\n        features[i, :] = signals[\n            :, offset + start - 2 * int(fs) : offset + end + 2 * int(fs)\n        ]\n        offending_channel[i, :] = int(chan)\n        labels[i, :] = int(EventData[i, 3])\n    return [features, offending_channel, labels]\n\n\ndef convert_signals(signals, Rawdata):\n    signal_names = {\n        k: v\n        for (k, v) in zip(\n            Rawdata.info[\"ch_names\"], list(range(len(Rawdata.info[\"ch_names\"])))\n        )\n    }\n    new_signals = np.vstack(\n        (\n            signals[signal_names[\"EEG FP1-REF\"]]\n            - signals[signal_names[\"EEG F7-REF\"]],  # 0\n            (\n                signals[signal_names[\"EEG F7-REF\"]]\n                - signals[signal_names[\"EEG T3-REF\"]]\n            ),  # 1\n            (\n                signals[signal_names[\"EEG T3-REF\"]]\n                - signals[signal_names[\"EEG T5-REF\"]]\n            ),  # 2\n            (\n                signals[signal_names[\"EEG T5-REF\"]]\n                - signals[signal_names[\"EEG O1-REF\"]]\n            ),  # 3\n            (\n                signals[signal_names[\"EEG FP2-REF\"]]\n                - signals[signal_names[\"EEG F8-REF\"]]\n            ),  # 4\n            (\n                signals[signal_names[\"EEG F8-REF\"]]\n                - signals[signal_names[\"EEG T4-REF\"]]\n            ),  # 5\n            (\n                signals[signal_names[\"EEG T4-REF\"]]\n                - signals[signal_names[\"EEG T6-REF\"]]\n            ),  # 6\n            (\n                signals[signal_names[\"EEG T6-REF\"]]\n                - signals[signal_names[\"EEG O2-REF\"]]\n            ),  # 7\n            (\n                signals[signal_names[\"EEG FP1-REF\"]]\n                - signals[signal_names[\"EEG F3-REF\"]]\n            ),  # 14\n            (\n                signals[signal_names[\"EEG F3-REF\"]]\n                - signals[signal_names[\"EEG C3-REF\"]]\n            ),  # 15\n            (\n                signals[signal_names[\"EEG C3-REF\"]]\n                - signals[signal_names[\"EEG P3-REF\"]]\n            ),  # 16\n            (\n                signals[signal_names[\"EEG P3-REF\"]]\n                - signals[signal_names[\"EEG O1-REF\"]]\n            ),  # 17\n            (\n                signals[signal_names[\"EEG FP2-REF\"]]\n                - signals[signal_names[\"EEG F4-REF\"]]\n            ),  # 18\n            (\n                signals[signal_names[\"EEG F4-REF\"]]\n                - signals[signal_names[\"EEG C4-REF\"]]\n            ),  # 19\n            (\n                signals[signal_names[\"EEG C4-REF\"]]\n                - signals[signal_names[\"EEG P4-REF\"]]\n            ),  # 20\n            (signals[signal_names[\"EEG P4-REF\"]] - signals[signal_names[\"EEG O2-REF\"]]),\n        )\n    )  # 21\n    return new_signals\n\n\ndef readEDF(fileName):\n    Rawdata = mne.io.read_raw_edf(fileName, preload=True)\n    Rawdata.resample(200)\n    Rawdata.filter(l_freq=0.3, h_freq=75)\n    Rawdata.notch_filter((60))\n\n    _, times = Rawdata[:]\n    signals = Rawdata.get_data(units='uV')\n    RecFile = fileName[0:-3] + \"rec\"\n    eventData = np.genfromtxt(RecFile, delimiter=\",\")\n    Rawdata.close()\n    return [signals, times, eventData, Rawdata]\n\n\ndef load_up_objects(BaseDir, Features, OffendingChannels, Labels, OutDir):\n    for dirName, subdirList, fileList in tqdm(os.walk(BaseDir)):\n        print(\"Found directory: %s\" % dirName)\n        for fname in fileList:\n            if fname[-4:] == \".edf\":\n                print(\"\\t%s\" % fname)\n                try:\n                    [signals, times, event, Rawdata] = readEDF(\n                        dirName + \"/\" + fname\n                    )  # event is the .rec file in the form of an array\n                    signals = convert_signals(signals, Rawdata)\n                except (ValueError, KeyError):\n                    print(\"something funky happened in \" + dirName + \"/\" + fname)\n                    continue\n                signals, offending_channels, labels = BuildEvents(signals, times, event)\n\n                for idx, (signal, offending_channel, label) in enumerate(\n                    zip(signals, offending_channels, labels)\n                ):\n                    sample = {\n                        \"signal\": signal,\n                        \"offending_channel\": offending_channel,\n                        \"label\": label,\n                    }\n                    save_pickle(\n                        sample,\n                        os.path.join(\n                            OutDir, fname.split(\".\")[0] + \"-\" + str(idx) + \".pkl\"\n                        ),\n                    )\n\n    return Features, Labels, OffendingChannels\n\n\ndef save_pickle(object, filename):\n    with open(filename, \"wb\") as f:\n        pickle.dump(object, f)\n\n\n\"\"\"\nTUEV dataset is downloaded from https://isip.piconepress.com/projects/tuh_eeg/html/downloads.shtml\n\"\"\"\n\nroot = \"/data/zcb/data/TUEV/edf\"\ntarget = \"/data/datasets/BigDownstream/TUEV_refine\"\n\ntrain_out_dir = os.path.join(target, \"processed_train\")\neval_out_dir = os.path.join(target, \"processed_eval\")\n\nif not os.path.exists(train_out_dir):\n    os.makedirs(train_out_dir)\nif not os.path.exists(eval_out_dir):\n    os.makedirs(eval_out_dir)\n\nBaseDirTrain = os.path.join(root, \"train\")\nfs = 200\nTrainFeatures = np.empty(\n    (0, 16, fs)\n)  # 0 for lack of intialization, 22 for channels, fs for num of points\nTrainLabels = np.empty([0, 1])\nTrainOffendingChannel = np.empty([0, 1])\nload_up_objects(\n    BaseDirTrain, TrainFeatures, TrainLabels, TrainOffendingChannel, train_out_dir\n)\n\nBaseDirEval = os.path.join(root, \"eval\")\nfs = 200\nEvalFeatures = np.empty(\n    (0, 16, fs)\n)  # 0 for lack of intialization, 22 for channels, fs for num of points\nEvalLabels = np.empty([0, 1])\nEvalOffendingChannel = np.empty([0, 1])\nload_up_objects(\n    BaseDirEval, EvalFeatures, EvalLabels, EvalOffendingChannel, eval_out_dir\n)\n\n\n#transfer to train, eval, and test\nroot = \"/data/datasets/BigDownstream/TUEV_refine\"\n# seed = 4523\n# np.random.seed(seed)\n\ntrain_files = os.listdir(os.path.join(root, \"processed_train\"))\ntrain_val_sub = list(set([f.split(\"_\")[0] for f in train_files]))\nprint(\"train val sub:\", train_val_sub)\ntest_files = os.listdir(os.path.join(root, \"processed_eval\"))\n\ntrain_val_sub.sort(key=lambda x: x)\n\ntrain_sub = train_val_sub[: int(len(train_val_sub) * 0.8)]\nval_sub = train_val_sub[int(len(train_val_sub) * 0.8) :]\nprint(\"train sub:\", train_sub)\nprint(\"val sub:\", val_sub)\n\nval_files = [f for f in train_files if f.split(\"_\")[0] in val_sub]\ntrain_files = [f for f in train_files if f.split(\"_\")[0] in train_sub]\n\n\nif not os.path.exists(os.path.join(root, 'processed', 'processed_train')):\n    os.makedirs(os.path.join(root, 'processed', 'processed_train'))\nif not os.path.exists(os.path.join(root, 'processed', 'processed_eval')):\n    os.makedirs(os.path.join(root, 'processed', 'processed_eval'))\nif not os.path.exists(os.path.join(root, 'processed', 'processed_test')):\n    os.makedirs(os.path.join(root, 'processed', 'processed_test'))\n\nfor file in tqdm(train_files):\n    os.system(f\"cp {os.path.join(root, 'processed_train', file)} {os.path.join(root, 'processed', 'processed_train')}\")\nfor file in tqdm(val_files):\n    os.system(f\"cp {os.path.join(root, 'processed_train', file)} {os.path.join(root, 'processed', 'processed_eval')}\")\nfor file in tqdm(test_files):\n    os.system(f\"cp {os.path.join(root, 'processed_eval', file)} {os.path.join(root, 'processed', 'processed_test')}\")\n\nprint('Done!')\n"
  },
  {
    "id": "preprocessing/preprocessing_physio.py",
    "text": "import scipy\nfrom scipy import signal\nimport os\nimport lmdb\nimport pickle\nimport numpy as np\nimport mne\n\ntasks = ['04', '06', '08', '10', '12', '14'] # select the data for motor imagery\n\nroot_dir = '/data/datasets/eeg-motor-movementimagery-dataset-1.0.0/files'\nfiles = [file for file in os.listdir(root_dir)]\nfiles = sorted(files)\n\nfiles_dict = {\n    'train': files[:70],\n    'val': files[70:89],\n    'test': files[89:109],\n}\n\nprint(files_dict)\n\ndataset = {\n    'train': list(),\n    'val': list(),\n    'test': list(),\n}\n\n\n\nselected_channels = ['Fc5.', 'Fc3.', 'Fc1.', 'Fcz.', 'Fc2.', 'Fc4.', 'Fc6.', 'C5..', 'C3..', 'C1..', 'Cz..', 'C2..',\n                     'C4..', 'C6..', 'Cp5.', 'Cp3.', 'Cp1.', 'Cpz.', 'Cp2.', 'Cp4.', 'Cp6.', 'Fp1.', 'Fpz.', 'Fp2.',\n                     'Af7.', 'Af3.', 'Afz.', 'Af4.', 'Af8.', 'F7..', 'F5..', 'F3..', 'F1..', 'Fz..', 'F2..', 'F4..',\n                     'F6..', 'F8..', 'Ft7.', 'Ft8.', 'T7..', 'T8..', 'T9..', 'T10.', 'Tp7.', 'Tp8.', 'P7..', 'P5..',\n                     'P3..', 'P1..', 'Pz..', 'P2..', 'P4..', 'P6..', 'P8..', 'Po7.', 'Po3.', 'Poz.', 'Po4.', 'Po8.',\n                     'O1..', 'Oz..', 'O2..', 'Iz..']\n\ndb = lmdb.open('/data/datasets/eeg-motor-movementimagery-dataset-1.0.0/processed_average', map_size=4614542346)\n\nfor files_key in files_dict.keys():\n    for file in files_dict[files_key]:\n        for task in tasks:\n            raw = mne.io.read_raw_edf(os.path.join(root_dir, file, f'{file}R{task}.edf'), preload=True)\n            raw.pick_channels(selected_channels, ordered=True)\n            if len(raw.info['bads']) > 0:\n                print('interpolate_bads')\n                raw.interpolate_bads()\n            raw.set_eeg_reference(ref_channels='average')\n            raw.filter(l_freq=0.3, h_freq=None)\n            raw.notch_filter((60))\n            raw.resample(200)\n            events_from_annot, event_dict = mne.events_from_annotations(raw)\n            epochs = mne.Epochs(raw,\n                                events_from_annot,\n                                event_dict,\n                                tmin=0,\n                                tmax=4. - 1.0 / raw.info['sfreq'],\n                                baseline=None,\n                                preload=True)\n            data = epochs.get_data(units='uV')\n            events = epochs.events[:, 2]\n            print(data.shape, events)\n            data = data[:, :, -800:]\n            bz, ch_nums, _ = data.shape\n            data = data.reshape(bz, ch_nums, 4, 200)\n            print(data.shape)\n            for i, (sample, event) in enumerate(zip(data, events)):\n                if event != 1:\n                    sample_key = f'{file}R{task}-{i}'\n                    data_dict = {\n                        'sample': sample, 'label': event - 2 if task in ['04', '08', '12'] else event\n                    }\n                    txn = db.begin(write=True)\n                    txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n                    txn.commit()\n                    dataset[files_key].append(sample_key)\n\ntxn = db.begin(write=True)\ntxn.put(key='__keys__'.encode(), value=pickle.dumps(dataset))\ntxn.commit()\ndb.close()\n"
  },
  {
    "id": "preprocessing/preprocessing_faced.py",
    "text": "import scipy\nfrom scipy import signal\nimport os\nimport lmdb\nimport pickle\nimport numpy as np\n\n\nlabels = np.array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8])\nroot_dir = '/data/cyn/FACED/Processed_data'\nfiles = [file for file in os.listdir(root_dir)]\nfiles = sorted(files)\n\nfiles_dict = {\n    'train':files[:80],\n    'val':files[80:100],\n    'test':files[100:],\n}\n\ndataset = {\n    'train': list(),\n    'val': list(),\n    'test': list(),\n}\n\ndb = lmdb.open('/data/datasets/BigDownstream/Faced/processed', map_size=6612500172)\n\nfor files_key in files_dict.keys():\n    for file in files_dict[files_key]:\n        f = open(os.path.join(root_dir, file), 'rb')\n        array = pickle.load(f)\n        eeg = signal.resample(array, 6000, axis=2)\n        eeg_ = eeg.reshape(28, 32, 30, 200)\n        for i, (samples, label) in enumerate(zip(eeg_, labels)):\n            for j in range(3):\n                sample = samples[:, 10*j:10*(j+1), :]\n                sample_key = f'{file}-{i}-{j}'\n                print(sample_key)\n                data_dict = {\n                    'sample': sample, 'label': label\n                }\n                txn = db.begin(write=True)\n                txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n                txn.commit()\n                dataset[files_key].append(sample_key)\n\n\ntxn = db.begin(write=True)\ntxn.put(key='__keys__'.encode(), value=pickle.dumps(dataset))\ntxn.commit()\ndb.close()"
  },
  {
    "id": "preprocessing/preprocessing_mumtaz.py",
    "text": "import os\nimport mne\nimport numpy as np\nimport lmdb\nimport pickle\n\n#\ndef iter_files(rootDir):\n    #\n    files_H, files_MDD = [], []\n    for file in os.listdir(rootDir):\n        if 'TASK' not in file:\n            if 'MDD' in file:\n                files_MDD.append(file)\n            else:\n                files_H.append(file)\n    return files_H, files_MDD\n\n\nselected_channels = ['EEG Fp1-LE', 'EEG Fp2-LE', 'EEG F3-LE', 'EEG F4-LE', 'EEG C3-LE', 'EEG C4-LE', 'EEG P3-LE',\n                     'EEG P4-LE', 'EEG O1-LE', 'EEG O2-LE', 'EEG F7-LE', 'EEG F8-LE', 'EEG T3-LE', 'EEG T4-LE',\n                     'EEG T5-LE', 'EEG T6-LE', 'EEG Fz-LE', 'EEG Cz-LE', 'EEG Pz-LE']\nrootDir = '/data/datasets/MDDPHCED/files'\nfiles_H, files_MDD = iter_files(rootDir)\nfiles_H = sorted(files_H)\nfiles_MDD = sorted(files_MDD)\nprint(files_H)\nprint(files_MDD)\nprint(len(files_H), len(files_MDD))\n\n\nfiles_dict = {\n    'train':[],\n    'val':[],\n    'test':[],\n}\n\ndataset = {\n    'train': list(),\n    'val': list(),\n    'test': list(),\n}\n\nfiles_dict['train'].extend(files_H[:40])\nfiles_dict['train'].extend(files_MDD[:42])\nfiles_dict['val'].extend(files_H[40:48])\nfiles_dict['val'].extend(files_MDD[42:52])\nfiles_dict['test'].extend(files_H[48:])\nfiles_dict['test'].extend(files_MDD[52:])\n\nprint(files_dict['train'])\nprint(files_dict['val'])\nprint(files_dict['test'])\n\n\ndb = lmdb.open('/data/datasets/MDDPHCED/processed_lmdb_75hz', map_size=1273741824)\n\nfor files_key in files_dict.keys():\n    for file in files_dict[files_key]:\n        raw = mne.io.read_raw_edf(os.path.join(rootDir, file), preload=True)\n        print(raw.info['ch_names'])\n        raw.pick_channels(selected_channels, ordered=True)\n        print(raw.info['ch_names'])\n        raw.resample(200)\n        raw.filter(l_freq=0.3, h_freq=75)\n        raw.notch_filter((50))\n        # raw.plot_psd(average=True)\n        eeg_array = raw.to_data_frame().values\n        # print(raw.info)\n        eeg_array = eeg_array[:, 1:]\n        points, chs = eeg_array.shape\n        print(eeg_array.shape)\n        a = points % (5 * 200)\n        print(a)\n        if a != 0:\n            eeg_array = eeg_array[:-a, :]\n        eeg_array = eeg_array.reshape(-1, 5, 200, chs)\n        eeg_array = eeg_array.transpose(0, 3, 1, 2)\n        print(eeg_array.shape)\n        label = 1 if 'MDD' in file else 0\n        for i, sample in enumerate(eeg_array):\n            sample_key = f'{file[:-4]}_{i}'\n            data_dict = {\n                'sample': sample, 'label': label\n            }\n            txn = db.begin(write=True)\n            txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n            txn.commit()\n            dataset[files_key].append(sample_key)\n\n\ntxn = db.begin(write=True)\ntxn.put(key='__keys__'.encode(), value=pickle.dumps(dataset))\ntxn.commit()\ndb.close()"
  },
  {
    "id": "preprocessing/preprocessing_tueg_for_pretraining.py",
    "text": "import os\nimport random\n\nimport mne\nimport numpy as np\nfrom tqdm import tqdm\nimport pickle\nimport lmdb\n\n\nselected_channels = {\n    '01_tcp_ar': [\n            'EEG FP1-REF', 'EEG FP2-REF', 'EEG F3-REF', 'EEG F4-REF', 'EEG C3-REF', 'EEG C4-REF', 'EEG P3-REF',\n            'EEG P4-REF', 'EEG O1-REF', 'EEG O2-REF', 'EEG F7-REF', 'EEG F8-REF', 'EEG T3-REF', 'EEG T4-REF',\n            'EEG T5-REF', 'EEG T6-REF', 'EEG FZ-REF', 'EEG CZ-REF', 'EEG PZ-REF'\n    ],\n    '02_tcp_le': [\n            'EEG FP1-LE', 'EEG FP2-LE', 'EEG F3-LE', 'EEG F4-LE', 'EEG C3-LE', 'EEG C4-LE', 'EEG P3-LE',\n            'EEG P4-LE', 'EEG O1-LE', 'EEG O2-LE', 'EEG F7-LE', 'EEG F8-LE', 'EEG T3-LE', 'EEG T4-LE',\n            'EEG T5-LE', 'EEG T6-LE', 'EEG FZ-LE', 'EEG CZ-LE', 'EEG PZ-LE'\n    ],\n    '03_tcp_ar_a': [\n            'EEG FP1-REF', 'EEG FP2-REF', 'EEG F3-REF', 'EEG F4-REF', 'EEG C3-REF', 'EEG C4-REF', 'EEG P3-REF',\n            'EEG P4-REF', 'EEG O1-REF', 'EEG O2-REF', 'EEG F7-REF', 'EEG F8-REF', 'EEG T3-REF', 'EEG T4-REF',\n            'EEG T5-REF', 'EEG T6-REF', 'EEG FZ-REF', 'EEG CZ-REF', 'EEG PZ-REF'\n    ]\n}\n\ndef setup_seed(seed):\n    np.random.seed(seed)\n    random.seed(seed)\n\n\n#\ndef iter_files(rootDir):\n    #\n    file_path_list = []\n    for root,dirs,files in os.walk(rootDir):\n        for file in files:\n            file_name = os.path.join(root,file)\n            # print(file_name)\n            file_path_list.append(file_name)\n    return file_path_list\n\ndef preprocessing_recording(file_path, file_key_list: list, db: lmdb.open):\n    raw = mne.io.read_raw_edf(file_path, preload=True)\n    if '02_tcp_le' in file_path:\n        for ch in selected_channels['02_tcp_le']:\n            if ch not in raw.info['ch_names']:\n                return\n        raw.pick_channels(selected_channels['02_tcp_le'], ordered=True)\n    elif '01_tcp_ar' in file_path:\n        for ch in selected_channels['01_tcp_ar']:\n            if ch not in raw.info['ch_names']:\n                return\n        raw.pick_channels(selected_channels['01_tcp_ar'], ordered=True)\n    elif '03_tcp_ar_a' in file_path:\n        for ch in selected_channels['03_tcp_ar_a']:\n            if ch not in raw.info['ch_names']:\n                return\n        raw.pick_channels(selected_channels['03_tcp_ar_a'], ordered=True)\n    else:\n        return\n    # print(raw.info)\n    raw.resample(200)\n    raw.filter(l_freq=0.3, h_freq=75)\n    raw.notch_filter((60))\n    eeg_array = raw.to_data_frame().values\n    # print(raw.info)\n    eeg_array = eeg_array[:, 1:]\n    points, chs = eeg_array.shape\n    if points < 300 * 200:\n        return\n    a = points % (30 * 200)\n    eeg_array = eeg_array[60 * 200:-(a+60 * 200), :]\n    # print(eeg_array.shape)\n    eeg_array = eeg_array.reshape(-1, 30, 200, chs)\n    eeg_array = eeg_array.transpose(0, 3, 1, 2)\n    print(eeg_array.shape)\n    file_name = file_path.split('/')[-1][:-4]\n\n    for i, sample in enumerate(eeg_array):\n        # print(i, sample.shape)\n        if np.max(np.abs(sample)) < 100:\n            sample_key = f'{file_name}_{i}'\n            print(sample_key)\n            file_key_list.append(sample_key)\n            txn = db.begin(write=True)\n            txn.put(key=sample_key.encode(), value=pickle.dumps(sample))\n            txn.commit()\n\nif __name__ == '__main__':\n    setup_seed(1)\n    file_path_list = iter_files('path...')\n\n    file_path_list = sorted(file_path_list)\n    random.shuffle(file_path_list)\n    # print(file_path_list)\n    db = lmdb.open(r'path...', map_size=1649267441664)\n    file_key_list = []\n    for file_path in tqdm(file_path_list):\n        preprocessing_recording(file_path, file_key_list, db)\n\n    txn = db.begin(write=True)\n    txn.put(key='__keys__'.encode(), value=pickle.dumps(file_key_list))\n    txn.commit()\n    db.close()\n"
  },
  {
    "id": "preprocessing/preprocessing_seedvig.py",
    "text": "import h5py\nimport scipy\nfrom scipy import signal\nimport os\nimport lmdb\nimport pickle\nimport numpy as np\nimport pandas as pd\n\n\ndata_dir = '/data/datasets/BigDownstream/SEED-VIG/mat/Raw_Data'\nlabels_dir = '/data/datasets/BigDownstream/SEED-VIG/mat/perclos_labels'\n\nfiles = [file for file in os.listdir(data_dir)]\nfiles = sorted(files)\n\nfiles_dict = {\n    'train': files[:15],\n    'val': files[15:19],\n    'test': files[19:23],\n}\n\nprint(files_dict)\n\ndataset = {\n    'train': list(),\n    'val': list(),\n    'test': list(),\n}\n\ndb = lmdb.open('/data/datasets/BigDownstream/SEED-VIG/processed', map_size=6000000000)\n\nfor files_key in files_dict.keys():\n    for file in files_dict[files_key]:\n        eeg = scipy.io.loadmat(os.path.join(data_dir, file))['EEG'][0][0][0]\n        labels = scipy.io.loadmat(os.path.join(labels_dir, file))['perclos']\n        print(eeg.shape, labels.shape)\n        eeg = eeg.reshape(885, 8, 200, 17)\n        eeg = eeg.transpose(0, 3, 1, 2)\n        labels = labels[:, 0]\n        print(eeg.shape, labels.shape)\n        for i, (sample, label) in enumerate(zip(eeg, labels)):\n            sample_key = f'{file[:-4]}-{i}'\n            print(sample_key)\n            data_dict = {\n                'sample': sample, 'label': label\n            }\n            txn = db.begin(write=True)\n            txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n            txn.commit()\n            dataset[files_key].append(sample_key)\n\ntxn = db.begin(write=True)\ntxn.put(key='__keys__'.encode(), value=pickle.dumps(dataset))\ntxn.commit()\ndb.close()"
  },
  {
    "id": "preprocessing/preprocessing_SEEDV.py",
    "text": "import scipy\nfrom scipy import signal\nimport os\nimport lmdb\nimport pickle\nimport numpy as np\nimport mne\n\nuseless_ch = ['M1', 'M2', 'VEO', 'HEO']\ntrials_of_sessions = {\n    '1': {'start': [30, 132, 287, 555, 773, 982, 1271, 1628, 1730, 2025, 2227, 2435, 2667, 2932, 3204],\n          'end': [102, 228, 524, 742, 920, 1240, 1568, 1697, 1994, 2166, 2401, 2607, 2901, 3172, 3359]},\n\n    '2': {'start': [30, 299, 548, 646, 836, 1000, 1091, 1392, 1657, 1809, 1966, 2186, 2333, 2490, 2741],\n          'end': [267, 488, 614, 773, 967, 1059, 1331, 1622, 1777, 1908, 2153, 2302, 2428, 2709, 2817]},\n\n    '3': {'start': [30, 353, 478, 674, 825, 908, 1200, 1346, 1451, 1711, 2055, 2307, 2457, 2726, 2888],\n          'end': [321, 418, 643, 764, 877, 1147, 1284, 1418, 1679, 1996, 2275, 2425, 2664, 2857, 3066]},\n}\nlabels_of_sessions = {\n    '1': [4, 1, 3, 2, 0, 4, 1, 3, 2, 0, 4, 1, 3, 2, 0, ],\n    '2': [2, 1, 3, 0, 4, 4, 0, 3, 2, 1, 3, 4, 1, 2, 0, ],\n    '3': [2, 1, 3, 0, 4, 4, 0, 3, 2, 1, 3, 4, 1, 2, 0, ],\n}\n\nroot_dir = '/data/datasets/BigDownstream/SEED-V/files'\nfiles = [file for file in os.listdir(root_dir)]\nfiles = sorted(files)\nprint(files)\n\ntrials_split = {\n    'train': range(5),\n    'val': range(5, 10),\n    'test': range(10, 15),\n}\n\ndataset = {\n    'train': list(),\n    'val': list(),\n    'test': list(),\n}\n\ndb = lmdb.open('/data/datasets/BigDownstream/SEED-V/processed', map_size=15614542346)\n\nfor file in files:\n    raw = mne.io.read_raw_cnt(os.path.join(root_dir, file), preload=True)\n    raw.drop_channels(useless_ch)\n    # raw.set_eeg_reference(ref_channels='average')\n    raw.resample(200)\n    raw.filter(l_freq=0.3, h_freq=75)\n    data_matrix = raw.get_data(units='uV')\n    session_index = file.split('_')[1]\n    data_trials = [\n        data_matrix[:,\n        trials_of_sessions[session_index]['start'][j] * 200:trials_of_sessions[session_index]['end'][j] * 200]\n        for j in range(15)]\n    labels = labels_of_sessions[session_index]\n    for mode in trials_split.keys():\n        for index in trials_split[mode]:\n            data = data_trials[index]\n            label = labels[index]\n            print(data.shape)\n            data = data.reshape(62, -1, 1, 200)\n            data = data.transpose(1, 0, 2, 3)\n            print(data.shape)\n            for i, sample in enumerate(data):\n                sample_key = f'{file}-{index}-{i}'\n                data_dict = {\n                    'sample': sample, 'label': label\n                }\n                txn = db.begin(write=True)\n                txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n                txn.commit()\n                dataset[mode].append(sample_key)\n\ntxn = db.begin(write=True)\ntxn.put(key='__keys__'.encode(), value=pickle.dumps(dataset))\ntxn.commit()\ndb.close()\n"
  },
  {
    "id": "preprocessing/preprocessing_stress.py",
    "text": "import scipy\nfrom scipy import signal\nimport os\nimport lmdb\nimport pickle\nimport mne\n\nroot_dir = '/data/datasets/BigDownstream/mental-arithmetic/edf'\nfiles = [file for file in os.listdir(root_dir)]\nfiles = sorted(files)\nprint(files)\n\nfiles_dict = {\n    'train':files[:56],\n    'val':files[56:64],\n    'test':files[64:],\n}\nprint(files_dict)\ndataset = {\n    'train': list(),\n    'val': list(),\n    'test': list(),\n}\n\n\nselected_channels = ['EEG Fp1', 'EEG Fp2', 'EEG F3', 'EEG F4', 'EEG F7', 'EEG F8', 'EEG T3', 'EEG T4',\n                     'EEG C3', 'EEG C4', 'EEG T5', 'EEG T6', 'EEG P3', 'EEG P4', 'EEG O1', 'EEG O2',\n                     'EEG Fz', 'EEG Cz', 'EEG Pz', 'EEG A2-A1']\n\n\n\ndb = lmdb.open('/data/datasets/BigDownstream/mental-arithmetic/processed', map_size=1000000000)\nfor files_key in files_dict.keys():\n    for file in files_dict[files_key]:\n        raw = mne.io.read_raw_edf(os.path.join(root_dir, file), preload=True)\n        raw.pick(selected_channels)\n        raw.reorder_channels(selected_channels)\n        raw.resample(200)\n\n        eeg = raw.get_data(units='uV')\n        chs, points = eeg.shape\n        a = points % (5 * 200)\n        if a != 0:\n            eeg = eeg[:, :-a]\n        eeg = eeg.reshape(20, -1, 5, 200).transpose(1, 0, 2, 3)\n        label = int(file[-5])\n\n        for i, sample in enumerate(eeg):\n            sample_key = f'{file[:-4]}-{i}'\n            # print(sample_key)\n            data_dict = {\n                'sample':sample, 'label':label-1\n            }\n            txn = db.begin(write=True)\n            txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n            txn.commit()\n            dataset[files_key].append(sample_key)\n\ntxn = db.begin(write=True)\ntxn.put(key='__keys__'.encode(), value=pickle.dumps(dataset))\ntxn.commit()\ndb.close()"
  },
  {
    "id": "preprocessing/preprocessing_tuab.py",
    "text": "import os\nimport pickle\n\nfrom multiprocessing import Pool\nimport numpy as np\nimport mne\n\n# we need these channels\n# (signals[signal_names['EEG FP1-REF']] - signals[signal_names['EEG F7-REF']],  # 0\n# (signals[signal_names['EEG F7-REF']] - signals[signal_names['EEG T3-REF']]),  # 1\n# (signals[signal_names['EEG T3-REF']] - signals[signal_names['EEG T5-REF']]),  # 2\n# (signals[signal_names['EEG T5-REF']] - signals[signal_names['EEG O1-REF']]),  # 3\n# (signals[signal_names['EEG FP2-REF']] - signals[signal_names['EEG F8-REF']]),  # 4\n# (signals[signal_names['EEG F8-REF']] - signals[signal_names['EEG T4-REF']]),  # 5\n# (signals[signal_names['EEG T4-REF']] - signals[signal_names['EEG T6-REF']]),  # 6\n# (signals[signal_names['EEG T6-REF']] - signals[signal_names['EEG O2-REF']]),  # 7\n# (signals[signal_names['EEG FP1-REF']] - signals[signal_names['EEG F3-REF']]),  # 14\n# (signals[signal_names['EEG F3-REF']] - signals[signal_names['EEG C3-REF']]),  # 15\n# (signals[signal_names['EEG C3-REF']] - signals[signal_names['EEG P3-REF']]),  # 16\n# (signals[signal_names['EEG P3-REF']] - signals[signal_names['EEG O1-REF']]),  # 17\n# (signals[signal_names['EEG FP2-REF']] - signals[signal_names['EEG F4-REF']]),  # 18\n# (signals[signal_names['EEG F4-REF']] - signals[signal_names['EEG C4-REF']]),  # 19\n# (signals[signal_names['EEG C4-REF']] - signals[signal_names['EEG P4-REF']]),  # 20\n# (signals[signal_names['EEG P4-REF']] - signals[signal_names['EEG O2-REF']]))) # 21\nstandard_channels = [\n    \"EEG FP1-REF\",\n    \"EEG F7-REF\",\n    \"EEG T3-REF\",\n    \"EEG T5-REF\",\n    \"EEG O1-REF\",\n    \"EEG FP2-REF\",\n    \"EEG F8-REF\",\n    \"EEG T4-REF\",\n    \"EEG T6-REF\",\n    \"EEG O2-REF\",\n    \"EEG FP1-REF\",\n    \"EEG F3-REF\",\n    \"EEG C3-REF\",\n    \"EEG P3-REF\",\n    \"EEG O1-REF\",\n    \"EEG FP2-REF\",\n    \"EEG F4-REF\",\n    \"EEG C4-REF\",\n    \"EEG P4-REF\",\n    \"EEG O2-REF\",\n]\n\n\ndef split_and_dump(params):\n    fetch_folder, sub, dump_folder, label = params\n    for file in os.listdir(fetch_folder):\n        if sub in file:\n            print(\"process\", file)\n            file_path = os.path.join(fetch_folder, file)\n            raw = mne.io.read_raw_edf(file_path, preload=True)\n            raw.resample(200)\n            raw.filter(l_freq=0.3, h_freq=75)\n            raw.notch_filter((60))\n            ch_name = raw.ch_names\n            raw_data = raw.get_data(units='uV')\n            channeled_data = raw_data.copy()[:16]\n            try:\n                channeled_data[0] = (\n                    raw_data[ch_name.index(\"EEG FP1-REF\")]\n                    - raw_data[ch_name.index(\"EEG F7-REF\")]\n                )\n                channeled_data[1] = (\n                    raw_data[ch_name.index(\"EEG F7-REF\")]\n                    - raw_data[ch_name.index(\"EEG T3-REF\")]\n                )\n                channeled_data[2] = (\n                    raw_data[ch_name.index(\"EEG T3-REF\")]\n                    - raw_data[ch_name.index(\"EEG T5-REF\")]\n                )\n                channeled_data[3] = (\n                    raw_data[ch_name.index(\"EEG T5-REF\")]\n                    - raw_data[ch_name.index(\"EEG O1-REF\")]\n                )\n                channeled_data[4] = (\n                    raw_data[ch_name.index(\"EEG FP2-REF\")]\n                    - raw_data[ch_name.index(\"EEG F8-REF\")]\n                )\n                channeled_data[5] = (\n                    raw_data[ch_name.index(\"EEG F8-REF\")]\n                    - raw_data[ch_name.index(\"EEG T4-REF\")]\n                )\n                channeled_data[6] = (\n                    raw_data[ch_name.index(\"EEG T4-REF\")]\n                    - raw_data[ch_name.index(\"EEG T6-REF\")]\n                )\n                channeled_data[7] = (\n                    raw_data[ch_name.index(\"EEG T6-REF\")]\n                    - raw_data[ch_name.index(\"EEG O2-REF\")]\n                )\n                channeled_data[8] = (\n                    raw_data[ch_name.index(\"EEG FP1-REF\")]\n                    - raw_data[ch_name.index(\"EEG F3-REF\")]\n                )\n                channeled_data[9] = (\n                    raw_data[ch_name.index(\"EEG F3-REF\")]\n                    - raw_data[ch_name.index(\"EEG C3-REF\")]\n                )\n                channeled_data[10] = (\n                    raw_data[ch_name.index(\"EEG C3-REF\")]\n                    - raw_data[ch_name.index(\"EEG P3-REF\")]\n                )\n                channeled_data[11] = (\n                    raw_data[ch_name.index(\"EEG P3-REF\")]\n                    - raw_data[ch_name.index(\"EEG O1-REF\")]\n                )\n                channeled_data[12] = (\n                    raw_data[ch_name.index(\"EEG FP2-REF\")]\n                    - raw_data[ch_name.index(\"EEG F4-REF\")]\n                )\n                channeled_data[13] = (\n                    raw_data[ch_name.index(\"EEG F4-REF\")]\n                    - raw_data[ch_name.index(\"EEG C4-REF\")]\n                )\n                channeled_data[14] = (\n                    raw_data[ch_name.index(\"EEG C4-REF\")]\n                    - raw_data[ch_name.index(\"EEG P4-REF\")]\n                )\n                channeled_data[15] = (\n                    raw_data[ch_name.index(\"EEG P4-REF\")]\n                    - raw_data[ch_name.index(\"EEG O2-REF\")]\n                )\n            except:\n                with open(\"tuab-process-error-files.txt\", \"a\") as f:\n                    f.write(file + \"\\n\")\n                continue\n            for i in range(channeled_data.shape[1] // 2000):\n                dump_path = os.path.join(\n                    dump_folder, file.split(\".\")[0] + \"_\" + str(i) + \".pkl\"\n                )\n                pickle.dump(\n                    {\"X\": channeled_data[:, i * 2000 : (i + 1) * 2000], \"y\": label},\n                    open(dump_path, \"wb\"),\n                )\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    TUAB dataset is downloaded from https://isip.piconepress.com/projects/tuh_eeg/html/downloads.shtml\n    \"\"\"\n    # root to abnormal dataset\n    root = \"/data/datasets/BigDownstream/TUAB/edf\"\n    channel_std = \"01_tcp_ar\"\n\n    # seed = 4523\n    # np.random.seed(seed)\n    # train, val abnormal subjects\n    train_val_abnormal = os.path.join(root, \"train\", \"abnormal\", channel_std)\n    train_val_a_sub = list(\n        set([item.split(\"_\")[0] for item in os.listdir(train_val_abnormal)])\n    )\n    train_val_a_sub.sort(key=lambda x: x)\n\n    train_a_sub, val_a_sub = (\n        train_val_a_sub[: int(len(train_val_a_sub) * 0.8)],\n        train_val_a_sub[int(len(train_val_a_sub) * 0.8) :],\n    )\n    print('train_a_sub:', train_a_sub)\n    print('val_a_sub:', val_a_sub)\n\n    # train, val normal subjects\n    train_val_normal = os.path.join(root, \"train\", \"normal\", channel_std)\n    train_val_n_sub = list(\n        set([item.split(\"_\")[0] for item in os.listdir(train_val_normal)])\n    )\n    train_val_n_sub.sort(key=lambda x: x)\n\n    train_n_sub, val_n_sub = (\n        train_val_n_sub[: int(len(train_val_n_sub) * 0.8)],\n        train_val_n_sub[int(len(train_val_n_sub) * 0.8) :],\n    )\n    print('train_n_sub:', train_n_sub)\n    print('val_n_sub:', val_n_sub)\n\n\n    # test abnormal subjects\n    test_abnormal = os.path.join(root, \"eval\", \"abnormal\", channel_std)\n    test_a_sub = list(set([item.split(\"_\")[0] for item in os.listdir(test_abnormal)]))\n\n    # test normal subjects\n    test_normal = os.path.join(root, \"eval\", \"normal\", channel_std)\n    test_n_sub = list(set([item.split(\"_\")[0] for item in os.listdir(test_normal)]))\n\n    # create the train, val, test sample folder\n    if not os.path.exists(os.path.join(root, \"process_refine\")):\n        os.makedirs(os.path.join(root, \"process_refine\"))\n\n    if not os.path.exists(os.path.join(root, \"process_refine\", \"train\")):\n        os.makedirs(os.path.join(root, \"process_refine\", \"train\"))\n    train_dump_folder = os.path.join(root, \"process_refine\", \"train\")\n\n    if not os.path.exists(os.path.join(root, \"process_refine\", \"val\")):\n        os.makedirs(os.path.join(root, \"process_refine\", \"val\"))\n    val_dump_folder = os.path.join(root, \"process_refine\", \"val\")\n\n    if not os.path.exists(os.path.join(root, \"process_refine\", \"test\")):\n        os.makedirs(os.path.join(root, \"process_refine\", \"test\"))\n    test_dump_folder = os.path.join(root, \"process_refine\", \"test\")\n\n    # fetch_folder, sub, dump_folder, labels\n    parameters = []\n    for train_sub in train_a_sub:\n        parameters.append([train_val_abnormal, train_sub, train_dump_folder, 1])\n    for train_sub in train_n_sub:\n        parameters.append([train_val_normal, train_sub, train_dump_folder, 0])\n    for val_sub in val_a_sub:\n        parameters.append([train_val_abnormal, val_sub, val_dump_folder, 1])\n    for val_sub in val_n_sub:\n        parameters.append([train_val_normal, val_sub, val_dump_folder, 0])\n    for test_sub in test_a_sub:\n        parameters.append([test_abnormal, test_sub, test_dump_folder, 1])\n    for test_sub in test_n_sub:\n        parameters.append([test_normal, test_sub, test_dump_folder, 0])\n\n    # split and dump in parallel\n    with Pool(processes=24) as pool:\n        # Use the pool.map function to apply the square function to each element in the numbers list\n        result = pool.map(split_and_dump, parameters)\n\n    print('Done!')"
  },
  {
    "id": "preprocessing/preprocessing_shu.py",
    "text": "import scipy\nfrom scipy import signal\nimport os\nimport lmdb\nimport pickle\n\nroot_dir = '/data/datasets/BigDownstream/MODMA/files'\nfiles = [file for file in os.listdir(root_dir)]\nfiles = sorted(files)\n# print(files)\n\nfiles_dict = {\n    'train':files[:75],\n    'val':files[75:100],\n    'test':files[100:],\n}\n\ndataset = {\n    'train': list(),\n    'val': list(),\n    'test': list(),\n}\ndb = lmdb.open('/data/datasets/shu_datasets/processed', map_size=110612736)\nfor files_key in files_dict.keys():\n    for file in files_dict[files_key]:\n        data = scipy.io.loadmat(os.path.join(root_dir, file))\n        eeg = data['data']\n        labels = data['labels'][0]\n        bz, ch_num, points = eeg.shape\n        print(eeg.shape)\n        eeg_resample = signal.resample(eeg, 800, axis=2)\n        eeg_ = eeg_resample.reshape(bz, ch_num, 4, 200)\n        print(eeg_.shape, labels.shape)\n        for i, (sample, label) in enumerate(zip(eeg_, labels)):\n            sample_key = f'{file[:-4]}-{i}'\n            # print(sample_key)\n            data_dict = {\n                'sample':sample, 'label':label-1\n            }\n            txn = db.begin(write=True)\n            txn.put(key=sample_key.encode(), value=pickle.dumps(data_dict))\n            txn.commit()\n            dataset[files_key].append(sample_key)\n\ntxn = db.begin(write=True)\ntxn.put(key='__keys__'.encode(), value=pickle.dumps(dataset))\ntxn.commit()\ndb.close()"
  },
  {
    "id": "preprocessing/__init__.py",
    "text": ""
  },
  {
    "id": "preprocessing/CHB-MIT/process2.py",
    "text": "import pickle\nimport os\nimport numpy as np\nfrom tqdm import tqdm\nimport multiprocessing as mp\n\nroot = \"/data/datasets/BigDownstream/chb-mit/processed\"\nout = \"/data/datasets/BigDownstream/chb-mit/processed_seg\"\n\n# root = 'clean_signals'\n# out = 'clean_segments'\n\nif not os.path.exists(out):\n    os.makedirs(out)\n\n# dump chb23 and chb24 to test, ch21 and ch22 to val, and the rest to train\ntest_pats = [\"chb23\", \"chb24\"]\nval_pats = [\"chb21\", \"chb22\"]\ntrain_pats = [\n    \"chb01\",\n    \"chb02\",\n    \"chb03\",\n    \"chb04\",\n    \"chb05\",\n    \"chb06\",\n    \"chb07\",\n    \"chb08\",\n    \"chb09\",\n    \"chb10\",\n    \"chb11\",\n    \"chb12\",\n    \"chb13\",\n    \"chb14\",\n    \"chb15\",\n    \"chb16\",\n    \"chb17\",\n    \"chb18\",\n    \"chb19\",\n    \"chb20\",\n]\nchannels = [\n    \"FP1-F7\",\n    \"F7-T7\",\n    \"T7-P7\",\n    \"P7-O1\",\n    \"FP2-F8\",\n    \"F8-T8\",\n    \"T8-P8\",\n    \"P8-O2\",\n    \"FP1-F3\",\n    \"F3-C3\",\n    \"C3-P3\",\n    \"P3-O1\",\n    \"FP2-F4\",\n    \"F4-C4\",\n    \"C4-P4\",\n    \"P4-O2\",\n]\nSAMPLING_RATE = 256\n\n\ndef sub_to_segments(folder, out_folder):\n    print(f\"Processing {folder}...\")\n    # each recording\n    for f in tqdm(os.listdir(os.path.join(root, folder))):\n        print(f\"Processing {folder}/{f}...\")\n        record = pickle.load(open(os.path.join(root, folder, f), \"rb\"))\n        \"\"\"\n        {'FP1-F7': array([-145.93406593,    0.1953602 ,    0.1953602 , ...,  -11.52625153, -2.93040293,   19.34065934]), \n         'F7-T7': array([-104.51770452,    0.1953602 ,    0.1953602 , ...,   23.63858364, 27.54578755,   30.67155067]), \n         'T7-P7': array([-42.78388278,   0.1953602 ,   0.1953602 , ...,  48.64468864, 45.12820513,  34.57875458]), \n        'P7-O1': array([-33.01587302,   0.1953602 ,   0.1953602 , ..., -17.77777778, -20.51282051, -25.59218559]), \n       'FP1-F3': array([-170.94017094,    0.1953602 ,    0.1953602 , ...,  -34.96947497, -25.98290598,    0.1953602 ]), \n        'F3-C3': array([-110.76923077,    0.1953602 ,    0.1953602 , ...,   38.0952381 , 48.64468864,   50.20757021]), \n         'C3-P3': array([11.91697192,  0.1953602 ,  0.1953602 , ..., 40.04884005, 33.7973138 , 25.98290598]), \n       'P3-O1': array([-56.45909646,   0.1953602 ,   0.1953602 , ...,   0.97680098, -6.44688645, -16.60561661]), \n        'FP2-F4': array([-139.29181929,    0.1953602 ,    0.1953602 , ...,   -2.14896215, -2.14896215,   -0.58608059]), \n         'F4-C4': array([-1.36752137,  0.1953602 ,  0.1953602 , ...,  1.75824176, 2.93040293,  7.22832723]), \n        'C4-P4': array([63.88278388,  0.1953602 ,  0.1953602 , ..., 16.996337  , 23.63858364, 25.59218559]), \n       'P4-O2': array([-14.26129426,   0.1953602 ,   0.1953602 , ..., -13.08913309, -8.00976801, -13.47985348]), \n        'FP2-F8': array([-2.67838828e+02,  1.95360195e-01,  1.95360195e-01, ..., 6.83760684e+00,  6.05616606e+00,  6.44688645e+00]), \n        'F8-T8': array([ 57.24053724,   0.1953602 ,   0.1953602 , ...,  -2.53968254,  -9.96336996, -12.6984127 ]), \n        'T8-P8': array([44.73748474,  0.1953602 ,  0.1953602 , ..., 16.996337  , 22.46642247, 26.37362637]), \n       'P8-O2': array([ 74.82295482,   0.1953602 ,  -0.1953602 , ..., -17.38705739, -1.75824176,  -2.53968254]), \n        'FZ-CZ': array([-106.08058608,    0.1953602 ,    0.1953602 , ...,   24.81074481, 28.71794872,   28.71794872]), \n         'CZ-PZ': array([84.59096459,  0.1953602 ,  0.1953602 , ..., 18.94993895, 20.51282051, 18.16849817]), \n       'P7-T7': array([ 43.17460317,   0.1953602 ,   0.1953602 , ..., -48.25396825, -44.73748474, -34.18803419]), \n       'T7-FT9': array([-57.24053724,   0.1953602 ,   0.1953602 , ..., -11.91697192,  -3.71184371,   2.14896215]), \n        'FT9-FT10': array([-2.64713065e+02,  1.95360195e-01,  5.86080586e-01, ..., 9.76800977e-01, -1.58241758e+01, -2.94993895e+01]), \n        'FT10-T8': array([ 94.74969475,   0.1953602 ,   0.1953602 , ...,  -7.22832723, -10.35409035, -13.47985348]), \n       'T8-P8-2': array([44.73748474,  0.1953602 ,  0.1953602 , ..., 16.996337  , 22.46642247, 26.37362637]), \n       'metadata': {'seizures': 0, 'times': [], 'channels': ['FP1-F7', 'F7-T7', 'T7-P7', 'P7-O1', 'FP1-F3', 'F3-C3', 'C3-P3', 'P3-O1', 'FP2-F4', 'F4-C4', 'C4-P4', 'P4-O2', 'FP2-F8', 'F8-T8', 'T8-P8', 'P8-O2', 'FZ-CZ', 'CZ-PZ', 'P7-T7', 'T7-FT9', 'FT9-FT10', 'FT10-T8', 'T8-P8-2']}}\n        \"\"\"\n        signal = []\n        for channel in channels:\n            if channel in record:\n                signal.append(record[channel])\n            else:\n                raise ValueError(f\"Channel {channel} not found in record {record}\")\n        signal = np.array(signal)\n\n        if \"times\" in record[\"metadata\"]:\n            seizure_times = record[\"metadata\"][\"times\"]\n        else:\n            seizure_times = []\n\n        # split the signal into segments on the second dimension by SAMPLING_RATE * 10 seconds\n        for i in range(0, signal.shape[1], SAMPLING_RATE * 10):\n            segment = signal[:, i : i + 10 * SAMPLING_RATE]\n            if segment.shape[1] == 10 * SAMPLING_RATE:\n                # judge whether the segment contains seizures\n                label = 0\n\n                for seizure_time in seizure_times:\n                    if (\n                        i < seizure_time[0] < i + 10 * SAMPLING_RATE\n                        or i < seizure_time[1] < i + 10 * SAMPLING_RATE\n                    ):\n                        label = 1\n                        break\n\n                # save the segment\n                pickle.dump(\n                    {\"X\": segment, \"y\": label},\n                    open(\n                        os.path.join(out_folder, f\"{f.split('.')[0]}-{i}.pkl\"),\n                        \"wb\",\n                    ),\n                )\n\n        for idx, seizure_time in enumerate(seizure_times):\n            for i in range(\n                max(0, seizure_time[0] - SAMPLING_RATE),\n                min(seizure_time[1] + SAMPLING_RATE, signal.shape[1]),\n                5 * SAMPLING_RATE,\n            ):\n                segment = signal[:, i : i + 10 * SAMPLING_RATE]\n                label = 1\n                # save the segment\n                pickle.dump(\n                    {\"X\": segment, \"y\": label},\n                    open(\n                        os.path.join(\n                            out_folder, f\"{f.split('.')[0]}-s-{idx}-add-{i}.pkl\"\n                        ),\n                        \"wb\",\n                    ),\n                )\n\n\n# parallel parameters\nfolders = os.listdir(root)\nout_folders = []\nfor folder in folders:\n    if folder in test_pats:\n        out_folder = os.path.join(out, \"test\")\n    elif folder in val_pats:\n        out_folder = os.path.join(out, \"val\")\n    else:\n        out_folder = os.path.join(out, \"train\")\n\n    if not os.path.exists(out_folder):\n        os.makedirs(out_folder)\n\n    out_folders.append(out_folder)\n\n# process in parallel\nwith mp.Pool(mp.cpu_count()) as pool:\n    res = pool.starmap(sub_to_segments, zip(folders, out_folders))\n"
  },
  {
    "id": "preprocessing/CHB-MIT/process1.py",
    "text": "import os\nfrom collections import defaultdict\nimport pyedflib\nimport pyedflib.highlevel as hl\nimport numpy as np\nimport copy\nimport shutil\nimport bz2\nimport pickle\nimport _pickle as cPickle\nimport multiprocessing as mp\n\n\n# Pickle a file and then compress it into a file with extension\ndef compressed_pickle(title, data):\n    # with bz2.BZ2File(title + '.pbz2', 'w') as f:\n    #     cPickle.dump(data, f)\n    pickle.dump(data, open(title, \"wb\"))\n\n\n# Process metadata\ndef process_metadata(summary, filename):\n    f = open(summary, \"r\")\n\n    metadata = {}\n    lines = f.readlines()\n    times = []\n    for i in range(len(lines)):\n        line = lines[i].split()\n        if len(line) == 3 and line[2] == filename:\n            j = i + 1\n            processed = False\n            while not processed:\n                if lines[j].split()[0] == \"Number\":\n                    seizures = int(lines[j].split()[-1])\n                    processed = True\n                j = j + 1\n\n            # If file has seizures get start and end time\n            if seizures > 0:\n                j = i + 1\n                for s in range(seizures):\n                    # Save start and end time of each seizure\n                    processed = False\n                    while not processed:\n                        l = lines[j].split()\n                        # print(l)\n\n                        if l[0] == \"Seizure\" and \"Start\" in l:\n                            start = int(l[-2]) * 256 - 1  # Index of start time\n                            end = (\n                                int(lines[j + 1].split()[-2]) * 256 - 1\n                            )  # Index of end time\n                            processed = True\n                        j = j + 1\n                    times.append((start, end))\n\n            metadata[\"seizures\"] = seizures\n            metadata[\"times\"] = times\n\n    return metadata\n\n\n# Keep some channels from a .edf and ignore the others\ndef drop_channels(edf_source, edf_target=None, to_keep=None, to_drop=None):\n    signals, signal_headers, header = hl.read_edf(\n        edf_source, ch_nrs=to_keep, digital=False\n    )\n    clean_file = {}\n    for signal, header in zip(signals, signal_headers):\n        channel = header.get(\"label\")\n        if channel in clean_file.keys():\n            channel = channel + \"-2\"\n        clean_file[channel] = signal\n    return clean_file\n\n\n# At first, it permuted the channels of a edf signal\n# Now, only keeps valid channels and compress+save into pkl\ndef move_channels(clean_dict, channels, target):\n    # Keep only valid channels\n    keys_to_delete = []\n    for key in clean_dict:\n        if key != \"metadata\" and key not in channels.keys():\n            keys_to_delete.append(key)\n    for key in keys_to_delete:\n        del clean_dict[key]\n\n    # Get size of the numpy array\n    size = 0\n    for item in clean_dict.keys():\n        if item != \"metadata\":\n            size = len(clean_dict.get(item))\n            break\n\n    for k in channels.keys():\n        if k not in clean_dict.keys():\n            clean_dict[k] = np.zeros(size, dtype=float)\n\n    compressed_pickle(target + \".pkl\", clean_dict)\n\n\n# Process edf files of a pacient from start number to end number\ndef process_files(pacient, valid_channels, channels, start, end):\n    for num in range(start, end + 1):\n        to_keep = []\n\n        num = (\"0\" + str(num))[-2:]\n        filename = \"{path}/chb{p}/chb{p}_{n}.edf\".format(\n            path=signals_path, p=pacient, n=num\n        )\n\n        # Check with (cleaned) reference file  if we have to remove more channels\n        try:\n            signals, signal_headers, header = hl.read_edf(filename, digital=False)\n            n = 0\n            for h in signal_headers:\n                if h.get(\"label\") in valid_channels:\n                    if n not in to_keep:\n                        to_keep.append(n)\n                n = n + 1\n\n        except OSError:\n            print(\"****************************************\")\n            print(\"WARNING - Do not worry\")\n            print(\"File\", filename, \"does not exist.\\nProcessing next file.\")\n            print(\"****************************************\")\n            continue\n\n        if len(to_keep) > 0:\n            try:\n                print(\n                    \"Removing\",\n                    len(signal_headers) - len(to_keep),\n                    \"channels from file \",\n                    \"chb{p}_{n}.edf\".format(p=pacient, n=num),\n                )\n                clean_dict = drop_channels(\n                    filename,\n                    edf_target=\"{path}/chb{p}/chb{p}_{n}.edf\".format(\n                        path=clean_path, p=pacient, n=num\n                    ),\n                    to_keep=to_keep,\n                )\n                print(\"Processing file \", filename)\n            except AssertionError:\n                print(\"****************************************\")\n                print(\"WARNING - Do not worry\")\n                print(\"File\", filename, \"does not exist.\\nProcessing next file.\")\n                print(\"****************************************\")\n                continue\n\n        metadata = process_metadata(\n            \"{path}/chb{p}/chb{p}-summary.txt\".format(path=signals_path, p=pacient),\n            \"chb{p}_{n}.edf\".format(p=pacient, n=num),\n        )\n        metadata[\"channels\"] = valid_channels\n        clean_dict[\"metadata\"] = metadata\n        target = \"{path}/chb{p}/chb{p}_{n}.edf\".format(\n            path=clean_path, p=pacient, n=num\n        )\n        move_channels(clean_dict, channels, target)\n\n\ndef start_process(pacient, num, start, end, sum_ind):\n    # Summary file\n    f = open(\n        \"{path}/chb{p}/chb{p}-summary.txt\".format(path=signals_path, p=pacient), \"r\"\n    )\n\n    channels = defaultdict(list)  # Dict of channels and indices\n    valid_channels = []  # Valid channels\n    to_keep = []  # Indices of channels we want to keep\n\n    channel_index = 1  # Index for each channel\n    summary_index = 0  # Index to choose which channel reference take from summary file\n\n    # Process summary file\n    for line in f:\n        line = line.split()\n        if len(line) == 0:\n            continue\n\n        if line[0] == \"Channels\" and line[1] == \"changed:\":\n            summary_index += 1\n\n        if (\n            line[0] == \"Channel\"\n            and summary_index == sum_ind\n            and (line[2] != \"-\" and line[2] != \".\")\n        ):  # '-' means a void channel\n            if (\n                line[2] in channels.keys()\n            ):  # In case of repeated channel just add '-2' to the label\n                name = line[2] + \"-2\"\n            else:\n                name = line[2]\n\n            # Add channel to dict and update lists\n            channels[name].append(str(channel_index))\n            channel_index += 1\n            valid_channels.append(name)\n            to_keep.append(int(line[1][:-1]) - 1)\n\n    # for item in channels.items(): print(item)\n\n    # Clean reference file\n    filename = \"{path}/chb{p}/chb{p}_{n}.edf\".format(\n        path=signals_path, p=pacient, n=num\n    )\n    target = \"{path}/chb{p}/chb{p}_{n}.edf\".format(path=clean_path, p=pacient, n=num)\n\n    if not os.path.exists(\"{path}/chb{p}\".format(p=pacient, path=clean_path)):\n        os.makedirs(\"{path}/chb{p}\".format(p=pacient, path=clean_path))\n\n    clean_dict = drop_channels(filename, edf_target=target, to_keep=to_keep)\n\n    # Process metadata : Number of seizures and start/end time\n    metadata = process_metadata(\n        \"{path}/chb{p}/chb{p}-summary.txt\".format(path=signals_path, p=pacient),\n        \"chb{p}_{n}.edf\".format(p=pacient, n=num),\n    )\n\n    metadata[\"channels\"] = valid_channels\n    clean_dict[\"metadata\"] = metadata\n\n    compressed_pickle(target + \".pkl\", clean_dict)\n\n    # Process the rest of the files to get same channels as reference file\n    process_files(pacient, valid_channels, channels, start, end)\n\n\n# PARAMETERS\nsignals_path = r\"/data/datasets/chb-mit-scalp-eeg-database-1.0.0\"  # Path to the data main directory\nclean_path = r\"/data/datasets/BigDownstream/chb-mit/processed\"  # Path where to store clean data\n\nif not os.path.exists(clean_path):\n    os.makedirs(clean_path)\n\n# Clean pacients one by one manually with these parameters\npacient = \"04\"\nnum = \"01\"  # Reference file\nsummary_index = 0  # Index of channels summary reference\nstart = 28  # Number of first file to process\nend = 28  # Number of last file to process\n# Start the process\n# start_process(pacient, num, start, end, summary_index)\n\n\n# FULL DATA PROCESS\nparameters = [\n    (\"01\", \"01\", 2, 46, 0),\n    (\"02\", \"01\", 2, 35, 0),\n    (\"03\", \"01\", 2, 38, 0),\n    (\"05\", \"01\", 2, 39, 0),\n    (\"06\", \"01\", 2, 24, 0),\n    (\"07\", \"01\", 2, 19, 0),\n    (\"08\", \"02\", 3, 29, 0),\n    (\"10\", \"01\", 2, 89, 0),\n    (\"11\", \"01\", 2, 99, 0),\n    (\"14\", \"01\", 2, 42, 0),\n    (\"20\", \"01\", 2, 68, 0),\n    (\"21\", \"01\", 2, 33, 0),\n    (\"22\", \"01\", 2, 77, 0),\n    (\"23\", \"06\", 7, 20, 0),\n    (\"24\", \"01\", 3, 21, 0),\n    (\"04\", \"07\", 1, 43, 1),\n    (\"09\", \"02\", 1, 19, 1),\n    (\"15\", \"02\", 1, 63, 1),\n    (\"16\", \"01\", 2, 19, 0),\n    (\"18\", \"02\", 1, 36, 1),\n    (\"19\", \"02\", 1, 30, 1),\n]\n\n# parameters = [\n#     (\"12\", \"\")\n# ]\n\n\n\n\nwith mp.Pool(mp.cpu_count()) as pool:\n    res = pool.starmap(start_process, parameters)\n"
  },
  {
    "id": "preprocessing/CHB-MIT/__init__.py",
    "text": ""
  },
  {
    "id": "preprocessing/ISRUC/edf_.py",
    "text": "\"\"\"Reading tools from EDF, EDF+, BDF, and GDF.\"\"\"\n\n# Authors: Teon Brooks <teon.brooks@gmail.com>\n#          Martin Billinger <martin.billinger@tugraz.at>\n#          Nicolas Barascud <nicolas.barascud@ens.fr>\n#          Stefan Appelhoff <stefan.appelhoff@mailbox.org>\n#          Joan Massich <mailsik@gmail.com>\n#          Clemens Brunner <clemens.brunner@gmail.com>\n#          Jeroen Van Der Donckt (IDlab - imec) <jeroen.vanderdonckt@ugent.be>\n#\n# License: BSD-3-Clause\n# Copyright the MNE-Python contributors.\n\nimport os\nimport re\nfrom datetime import datetime, timedelta, timezone\n\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\nfrom mne._fiff.constants import FIFF\nfrom mne._fiff.meas_info import _empty_info, _unique_channel_names\nfrom mne._fiff.utils import _blk_read_lims, _mult_cal_one\nfrom mne.annotations import Annotations\nfrom mne.filter import resample\nfrom mne.utils import _validate_type, fill_doc, logger, verbose, warn\nfrom mne.io.base import BaseRaw, _get_scaling\n\n# common channel type names mapped to internal ch types\nCH_TYPE_MAPPING = {\n    \"EEG\": FIFF.FIFFV_EEG_CH,\n    \"SEEG\": FIFF.FIFFV_SEEG_CH,\n    \"ECOG\": FIFF.FIFFV_ECOG_CH,\n    \"DBS\": FIFF.FIFFV_DBS_CH,\n    \"EOG\": FIFF.FIFFV_EOG_CH,\n    \"ECG\": FIFF.FIFFV_ECG_CH,\n    \"EMG\": FIFF.FIFFV_EMG_CH,\n    \"BIO\": FIFF.FIFFV_BIO_CH,\n    \"RESP\": FIFF.FIFFV_RESP_CH,\n    \"TEMP\": FIFF.FIFFV_TEMPERATURE_CH,\n    \"MISC\": FIFF.FIFFV_MISC_CH,\n    \"SAO2\": FIFF.FIFFV_BIO_CH,\n}\n\n\n@fill_doc\nclass RawEDF(BaseRaw):\n    \"\"\"Raw object from EDF, EDF+ or BDF file.\n\n    Parameters\n    ----------\n    input_fname : path-like\n        Path to the EDF, EDF+ or BDF file.\n    eog : list or tuple\n        Names of channels or list of indices that should be designated EOG\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    misc : list or tuple\n        Names of channels or list of indices that should be designated MISC\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    stim_channel : ``'auto'`` | str | list of str | int | list of int\n        Defaults to ``'auto'``, which means that channels named ``'status'`` or\n        ``'trigger'`` (case insensitive) are set to STIM. If str (or list of\n        str), all channels matching the name(s) are set to STIM. If int (or\n        list of ints), the channels corresponding to the indices are set to\n        STIM.\n    exclude : list of str\n        Channel names to exclude. This can help when reading data with\n        different sampling rates to avoid unnecessary resampling.\n    infer_types : bool\n        If True, try to infer channel types from channel labels. If a channel\n        label starts with a known type (such as 'EEG') followed by a space and\n        a name (such as 'Fp1'), the channel type will be set accordingly, and\n        the channel will be renamed to the original label without the prefix.\n        For unknown prefixes, the type will be 'EEG' and the name will not be\n        modified. If False, do not infer types and assume all channels are of\n        type 'EEG'.\n\n        .. versionadded:: 0.24.1\n    include : list of str | str\n        Channel names to be included. A str is interpreted as a regular\n        expression. 'exclude' must be empty if include is assigned.\n\n        .. versionadded:: 1.1\n    %(preload)s\n    %(units_edf_bdf_io)s\n    %(encoding_edf)s\n    %(verbose)s\n\n    See Also\n    --------\n    mne.io.Raw : Documentation of attributes and methods.\n    mne.io.read_raw_edf : Recommended way to read EDF/EDF+ files.\n    mne.io.read_raw_bdf : Recommended way to read BDF files.\n\n    Notes\n    -----\n    %(edf_resamp_note)s\n\n    Biosemi devices trigger codes are encoded in 16-bit format, whereas system\n    codes (CMS in/out-of range, battery low, etc.) are coded in bits 16-23 of\n    the status channel (see http://www.biosemi.com/faq/trigger_signals.htm).\n    To retrieve correct event values (bits 1-16), one could do:\n\n        >>> events = mne.find_events(...)  # doctest:+SKIP\n        >>> events[:, 2] &= (2**16 - 1)  # doctest:+SKIP\n\n    The above operation can be carried out directly in :func:`mne.find_events`\n    using the ``mask`` and ``mask_type`` parameters (see\n    :func:`mne.find_events` for more details).\n\n    It is also possible to retrieve system codes, but no particular effort has\n    been made to decode these in MNE. In case it is necessary, for instance to\n    check the CMS bit, the following operation can be carried out:\n\n        >>> cms_bit = 20  # doctest:+SKIP\n        >>> cms_high = (events[:, 2] & (1 << cms_bit)) != 0  # doctest:+SKIP\n\n    It is worth noting that in some special cases, it may be necessary to shift\n    event values in order to retrieve correct event triggers. This depends on\n    the triggering device used to perform the synchronization. For instance, in\n    some files events need to be shifted by 8 bits:\n\n        >>> events[:, 2] >>= 8  # doctest:+SKIP\n\n    TAL channels called 'EDF Annotations' or 'BDF Annotations' are parsed and\n    extracted annotations are stored in raw.annotations. Use\n    :func:`mne.events_from_annotations` to obtain events from these\n    annotations.\n\n    If channels named 'status' or 'trigger' are present, they are considered as\n    STIM channels by default. Use func:`mne.find_events` to parse events\n    encoded in such analog stim channels.\n    \"\"\"\n\n    @verbose\n    def __init__(\n        self,\n        input_fname,\n        eog=None,\n        misc=None,\n        stim_channel=\"auto\",\n        exclude=(),\n        infer_types=False,\n        preload=False,\n        include=None,\n        units=None,\n        encoding=\"utf8\",\n        *,\n        verbose=None,\n    ):\n        logger.info(\"Extracting EDF parameters from {}...\".format(input_fname))\n        input_fname = os.path.abspath(input_fname)\n        info, edf_info, orig_units = _get_info(\n            input_fname, stim_channel, eog, misc, exclude, infer_types, preload, include\n        )\n        logger.info(\"Creating raw.info structure...\")\n\n        _validate_type(units, (str, None, dict), \"units\")\n        if units is None:\n            units = dict()\n        elif isinstance(units, str):\n            units = {ch_name: units for ch_name in info[\"ch_names\"]}\n\n        for k, (this_ch, this_unit) in enumerate(orig_units.items()):\n            if this_ch not in units:\n                continue\n            if this_unit not in (\"\", units[this_ch]):\n                raise ValueError(\n                    f\"Unit for channel {this_ch} is present in the file as \"\n                    f\"{repr(this_unit)}, cannot overwrite it with the units \"\n                    f\"argument {repr(units[this_ch])}.\"\n                )\n            if this_unit == \"\":\n                orig_units[this_ch] = units[this_ch]\n                ch_type = edf_info[\"ch_types\"][k]\n                scaling = _get_scaling(ch_type.lower(), orig_units[this_ch])\n                edf_info[\"units\"][k] /= scaling\n\n        # Raw attributes\n        last_samps = [edf_info[\"nsamples\"] - 1]\n        super().__init__(\n            info,\n            preload,\n            filenames=[input_fname],\n            raw_extras=[edf_info],\n            last_samps=last_samps,\n            orig_format=\"int\",\n            orig_units=orig_units,\n            verbose=verbose,\n        )\n\n        # Read annotations from file and set it\n        if len(edf_info[\"tal_idx\"]) > 0:\n            # Read TAL data exploiting the header info (no regexp)\n            idx = np.empty(0, int)\n            tal_data = self._read_segment_file(\n                np.empty((0, self.n_times)),\n                idx,\n                0,\n                0,\n                int(self.n_times),\n                np.ones((len(idx), 1)),\n                None,\n            )\n            annotations = _read_annotations_edf(\n                tal_data[0],\n                ch_names=info[\"ch_names\"],\n                encoding=encoding,\n            )\n            self.set_annotations(annotations, on_missing=\"warn\")\n\n    def _read_segment_file(self, data, idx, fi, start, stop, cals, mult):\n        \"\"\"Read a chunk of raw data.\"\"\"\n        return _read_segment_file(\n            data,\n            idx,\n            fi,\n            start,\n            stop,\n            self._raw_extras[fi],\n            self._filenames[fi],\n            cals,\n            mult,\n        )\n\n\n@fill_doc\nclass RawGDF(BaseRaw):\n    \"\"\"Raw object from GDF file.\n\n    Parameters\n    ----------\n    input_fname : path-like\n        Path to the GDF file.\n    eog : list or tuple\n        Names of channels or list of indices that should be designated EOG\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    misc : list or tuple\n        Names of channels or list of indices that should be designated MISC\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    stim_channel : ``'auto'`` | str | list of str | int | list of int\n        Defaults to 'auto', which means that channels named 'status' or\n        'trigger' (case insensitive) are set to STIM. If str (or list of str),\n        all channels matching the name(s) are set to STIM. If int (or list of\n        ints), channels corresponding to the indices are set to STIM.\n    exclude : list of str\n        Channel names to exclude. This can help when reading data with\n        different sampling rates to avoid unnecessary resampling.\n\n        .. versionadded:: 0.24.1\n    include : list of str | str\n        Channel names to be included. A str is interpreted as a regular\n        expression. 'exclude' must be empty if include is assigned.\n\n        .. versionadded:: 1.1\n    %(preload)s\n    %(verbose)s\n\n    See Also\n    --------\n    mne.io.Raw : Documentation of attributes and methods.\n    mne.io.read_raw_gdf : Recommended way to read GDF files.\n\n    Notes\n    -----\n    If channels named 'status' or 'trigger' are present, they are considered as\n    STIM channels by default. Use func:`mne.find_events` to parse events\n    encoded in such analog stim channels.\n    \"\"\"\n\n    @verbose\n    def __init__(\n        self,\n        input_fname,\n        eog=None,\n        misc=None,\n        stim_channel=\"auto\",\n        exclude=(),\n        preload=False,\n        include=None,\n        verbose=None,\n    ):\n        logger.info(\"Extracting EDF parameters from {}...\".format(input_fname))\n        input_fname = os.path.abspath(input_fname)\n        info, edf_info, orig_units = _get_info(\n            input_fname, stim_channel, eog, misc, exclude, True, preload, include\n        )\n        logger.info(\"Creating raw.info structure...\")\n\n        # Raw attributes\n        last_samps = [edf_info[\"nsamples\"] - 1]\n        super().__init__(\n            info,\n            preload,\n            filenames=[input_fname],\n            raw_extras=[edf_info],\n            last_samps=last_samps,\n            orig_format=\"int\",\n            orig_units=orig_units,\n            verbose=verbose,\n        )\n\n        # Read annotations from file and set it\n        onset, duration, desc = _get_annotations_gdf(edf_info, self.info[\"sfreq\"])\n\n        self.set_annotations(\n            Annotations(\n                onset=onset, duration=duration, description=desc, orig_time=None\n            )\n        )\n\n    def _read_segment_file(self, data, idx, fi, start, stop, cals, mult):\n        \"\"\"Read a chunk of raw data.\"\"\"\n        return _read_segment_file(\n            data,\n            idx,\n            fi,\n            start,\n            stop,\n            self._raw_extras[fi],\n            self._filenames[fi],\n            cals,\n            mult,\n        )\n\n\ndef _read_ch(fid, subtype, samp, dtype_byte, dtype=None):\n    \"\"\"Read a number of samples for a single channel.\"\"\"\n    # BDF\n    if subtype == \"bdf\":\n        ch_data = np.fromfile(fid, dtype=dtype, count=samp * dtype_byte)\n        ch_data = ch_data.reshape(-1, 3).astype(INT32)\n        ch_data = (ch_data[:, 0]) + (ch_data[:, 1] << 8) + (ch_data[:, 2] << 16)\n        # 24th bit determines the sign\n        ch_data[ch_data >= (1 << 23)] -= 1 << 24\n\n    # GDF data and EDF data\n    else:\n        ch_data = np.fromfile(fid, dtype=dtype, count=samp)\n\n    return ch_data\n\n\ndef _read_segment_file(data, idx, fi, start, stop, raw_extras, filenames, cals, mult):\n    \"\"\"Read a chunk of raw data.\"\"\"\n    n_samps = raw_extras[\"n_samps\"]\n    buf_len = int(raw_extras[\"max_samp\"])\n    dtype = raw_extras[\"dtype_np\"]\n    dtype_byte = raw_extras[\"dtype_byte\"]\n    data_offset = raw_extras[\"data_offset\"]\n    stim_channel_idxs = raw_extras[\"stim_channel_idxs\"]\n    orig_sel = raw_extras[\"sel\"]\n    tal_idx = raw_extras.get(\"tal_idx\", np.empty(0, int))\n    subtype = raw_extras[\"subtype\"]\n    cal = raw_extras[\"cal\"]\n    offsets = raw_extras[\"offsets\"]\n    gains = raw_extras[\"units\"]\n\n    read_sel = np.concatenate([orig_sel[idx], tal_idx])\n    tal_data = []\n\n    # only try to read the stim channel if it's not None and it's\n    # actually one of the requested channels\n    idx_arr = np.arange(idx.start, idx.stop) if isinstance(idx, slice) else idx\n\n    # We could read this one EDF block at a time, which would be this:\n    ch_offsets = np.cumsum(np.concatenate([[0], n_samps]), dtype=np.int64)\n    block_start_idx, r_lims, d_lims = _blk_read_lims(start, stop, buf_len)\n    # But to speed it up, we really need to read multiple blocks at once,\n    # Otherwise we can end up with e.g. 18,181 chunks for a 20 MB file!\n    # Let's do ~10 MB chunks:\n    n_per = max(10 * 1024 * 1024 // (ch_offsets[-1] * dtype_byte), 1)\n    with open(filenames, \"rb\", buffering=0) as fid:\n        # Extract data\n        start_offset = data_offset + block_start_idx * ch_offsets[-1] * dtype_byte\n\n        # first read everything into the `ones` array. For channels with\n        # lower sampling frequency, there will be zeros left at the end of the\n        # row. Ignore TAL/annotations channel and only store `orig_sel`\n        ones = np.zeros((len(orig_sel), data.shape[-1]), dtype=data.dtype)\n        # save how many samples have already been read per channel\n        n_smp_read = [0 for _ in range(len(orig_sel))]\n\n        # read data in chunks\n        for ai in range(0, len(r_lims), n_per):\n            block_offset = ai * ch_offsets[-1] * dtype_byte\n            n_read = min(len(r_lims) - ai, n_per)\n            fid.seek(start_offset + block_offset, 0)\n            # Read and reshape to (n_chunks_read, ch0_ch1_ch2_ch3...)\n            many_chunk = _read_ch(\n                fid, subtype, ch_offsets[-1] * n_read, dtype_byte, dtype\n            ).reshape(n_read, -1)\n            r_sidx = r_lims[ai][0]\n            r_eidx = buf_len * (n_read - 1) + r_lims[ai + n_read - 1][1]\n\n            # loop over selected channels, ci=channel selection\n            for ii, ci in enumerate(read_sel):\n                # This now has size (n_chunks_read, n_samp[ci])\n                ch_data = many_chunk[:, ch_offsets[ci] : ch_offsets[ci + 1]].copy()\n\n                # annotation channel has to be treated separately\n                if ci in tal_idx:\n                    tal_data.append(ch_data)\n                    continue\n\n                orig_idx = idx_arr[ii]\n                ch_data = ch_data * cal[orig_idx]\n                ch_data += offsets[orig_idx]\n                ch_data *= gains[orig_idx]\n\n                assert ci == orig_sel[orig_idx]\n\n                if n_samps[ci] != buf_len:\n                    if orig_idx in stim_channel_idxs:\n                        # Stim channel will be interpolated\n                        old = np.linspace(0, 1, n_samps[ci] + 1, True)\n                        new = np.linspace(0, 1, buf_len, False)\n                        ch_data = np.append(ch_data, np.zeros((len(ch_data), 1)), -1)\n                        ch_data = interp1d(old, ch_data, kind=\"zero\", axis=-1)(new)\n                elif orig_idx in stim_channel_idxs:\n                    ch_data = np.bitwise_and(ch_data.astype(int), 2**17 - 1)\n\n                one_i = ch_data.ravel()[r_sidx:r_eidx]\n\n                # note how many samples have been read\n                smp_read = n_smp_read[orig_idx]\n                ones[orig_idx, smp_read : smp_read + len(one_i)] = one_i\n                n_smp_read[orig_idx] += len(one_i)\n\n        # skip if no data was requested, ie. only annotations were read\n        if sum(n_smp_read) > 0:\n            # expected number of samples, equals maximum sfreq\n            smp_exp = data.shape[-1]\n            assert max(n_smp_read) == smp_exp\n\n            # resample data after loading all chunks to prevent edge artifacts\n            resampled = False\n            for i, smp_read in enumerate(n_smp_read):\n                # nothing read, nothing to resample\n                if smp_read == 0:\n                    continue\n                # upsample if n_samples is lower than from highest sfreq\n                if smp_read != smp_exp:\n                    assert (ones[i, smp_read:] == 0).all()  # sanity check\n                    ones[i, :] = resample(\n                        ones[i, :smp_read].astype(np.float64),\n                        smp_exp,\n                        smp_read,\n                        npad=0,\n                        axis=-1,\n                    )\n                    resampled = True\n\n            # give warning if we resampled a subselection\n            if resampled and raw_extras[\"nsamples\"] != (stop - start):\n                warn(\n                    \"Loading an EDF with mixed sampling frequencies and \"\n                    \"preload=False will result in edge artifacts. \"\n                    \"It is recommended to use preload=True.\"\n                    \"See also https://github.com/mne-tools/mne-python/issues/10635\"\n                )\n\n            _mult_cal_one(data[:, :], ones, idx, cals, mult)\n\n    if len(tal_data) > 1:\n        tal_data = np.concatenate([tal.ravel() for tal in tal_data])\n        tal_data = tal_data[np.newaxis, :]\n    return tal_data\n\n\ndef _read_header(fname, exclude, infer_types, include=None):\n    \"\"\"Unify EDF, BDF and GDF _read_header call.\n\n    Parameters\n    ----------\n    fname : str\n        Path to the EDF+, BDF, or GDF file.\n    exclude : list of str | str\n        Channel names to exclude. This can help when reading data with\n        different sampling rates to avoid unnecessary resampling. A str is\n        interpreted as a regular expression.\n    infer_types : bool\n        If True, try to infer channel types from channel labels. If a channel\n        label starts with a known type (such as 'EEG') followed by a space and\n        a name (such as 'Fp1'), the channel type will be set accordingly, and\n        the channel will be renamed to the original label without the prefix.\n        For unknown prefixes, the type will be 'EEG' and the name will not be\n        modified. If False, do not infer types and assume all channels are of\n        type 'EEG'.\n    include : list of str | str\n        Channel names to be included. A str is interpreted as a regular\n        expression. 'exclude' must be empty if include is assigned.\n\n    Returns\n    -------\n    (edf_info, orig_units) : tuple\n    \"\"\"\n    ext = os.path.splitext(fname)[1][1:].lower()\n    logger.info(\"%s file detected\" % ext.upper())\n    if ext in (\"bdf\", \"edf\", \"rec\"):\n        return _read_edf_header(fname, exclude, infer_types, include)\n    elif ext == \"gdf\":\n        return _read_gdf_header(fname, exclude, include), None\n    else:\n        raise NotImplementedError(\n            f\"Only GDF, EDF, and BDF files are supported, got {ext}.\"\n        )\n\n\ndef _get_info(\n    fname, stim_channel, eog, misc, exclude, infer_types, preload, include=None\n):\n    \"\"\"Extract information from EDF+, BDF or GDF file.\"\"\"\n    eog = eog if eog is not None else []\n    misc = misc if misc is not None else []\n\n    edf_info, orig_units = _read_header(fname, exclude, infer_types, include)\n\n    # XXX: `tal_ch_names` to pass to `_check_stim_channel` should be computed\n    #      from `edf_info['ch_names']` and `edf_info['tal_idx']` but 'tal_idx'\n    #      contains stim channels that are not TAL.\n    stim_channel_idxs, _ = _check_stim_channel(stim_channel, edf_info[\"ch_names\"])\n\n    sel = edf_info[\"sel\"]  # selection of channels not excluded\n    ch_names = edf_info[\"ch_names\"]  # of length len(sel)\n    if \"ch_types\" in edf_info:\n        ch_types = edf_info[\"ch_types\"]  # of length len(sel)\n    else:\n        ch_types = [None] * len(sel)\n    if len(sel) == 0:  # only want stim channels\n        n_samps = edf_info[\"n_samps\"][[0]]\n    else:\n        n_samps = edf_info[\"n_samps\"][sel]\n    nchan = edf_info[\"nchan\"]\n    physical_ranges = edf_info[\"physical_max\"] - edf_info[\"physical_min\"]\n    cals = edf_info[\"digital_max\"] - edf_info[\"digital_min\"]\n    bad_idx = np.where((~np.isfinite(cals)) | (cals == 0))[0]\n    if len(bad_idx) > 0:\n        warn(\n            \"Scaling factor is not defined in following channels:\\n\"\n            + \", \".join(ch_names[i] for i in bad_idx)\n        )\n        cals[bad_idx] = 1\n    bad_idx = np.where(physical_ranges == 0)[0]\n    if len(bad_idx) > 0:\n        warn(\n            \"Physical range is not defined in following channels:\\n\"\n            + \", \".join(ch_names[i] for i in bad_idx)\n        )\n        physical_ranges[bad_idx] = 1\n\n    # Creates a list of dicts of eeg channels for raw.info\n    logger.info(\"Setting channel info structure...\")\n    chs = list()\n    pick_mask = np.ones(len(ch_names))\n\n    chs_without_types = list()\n\n    for idx, ch_name in enumerate(ch_names):\n        chan_info = {}\n        chan_info[\"cal\"] = 1.0\n        chan_info[\"logno\"] = idx + 1\n        chan_info[\"scanno\"] = idx + 1\n        chan_info[\"range\"] = 1.0\n        chan_info[\"unit_mul\"] = FIFF.FIFF_UNITM_NONE\n        chan_info[\"ch_name\"] = ch_name\n        chan_info[\"unit\"] = FIFF.FIFF_UNIT_V\n        chan_info[\"coord_frame\"] = FIFF.FIFFV_COORD_HEAD\n        chan_info[\"coil_type\"] = FIFF.FIFFV_COIL_EEG\n        chan_info[\"kind\"] = FIFF.FIFFV_EEG_CH\n        # montage can't be stored in EDF so channel locs are unknown:\n        chan_info[\"loc\"] = np.full(12, np.nan)\n\n        # if the edf info contained channel type information\n        # set it now\n        ch_type = ch_types[idx]\n        if ch_type is not None and ch_type in CH_TYPE_MAPPING:\n            chan_info[\"kind\"] = CH_TYPE_MAPPING.get(ch_type)\n            if ch_type not in [\"EEG\", \"ECOG\", \"SEEG\", \"DBS\"]:\n                chan_info[\"coil_type\"] = FIFF.FIFFV_COIL_NONE\n            pick_mask[idx] = False\n        # if user passes in explicit mapping for eog, misc and stim\n        # channels set them here\n        if ch_name in eog or idx in eog or idx - nchan in eog:\n            chan_info[\"coil_type\"] = FIFF.FIFFV_COIL_NONE\n            chan_info[\"kind\"] = FIFF.FIFFV_EOG_CH\n            pick_mask[idx] = False\n        elif ch_name in misc or idx in misc or idx - nchan in misc:\n            chan_info[\"coil_type\"] = FIFF.FIFFV_COIL_NONE\n            chan_info[\"kind\"] = FIFF.FIFFV_MISC_CH\n            pick_mask[idx] = False\n        elif idx in stim_channel_idxs:\n            chan_info[\"coil_type\"] = FIFF.FIFFV_COIL_NONE\n            chan_info[\"unit\"] = FIFF.FIFF_UNIT_NONE\n            chan_info[\"kind\"] = FIFF.FIFFV_STIM_CH\n            pick_mask[idx] = False\n            chan_info[\"ch_name\"] = ch_name\n            ch_names[idx] = chan_info[\"ch_name\"]\n            edf_info[\"units\"][idx] = 1\n        elif ch_type not in CH_TYPE_MAPPING:\n            chs_without_types.append(ch_name)\n        chs.append(chan_info)\n\n    # warn if channel type was not inferable\n    if len(chs_without_types):\n        msg = (\n            \"Could not determine channel type of the following channels, \"\n            f'they will be set as EEG:\\n{\", \".join(chs_without_types)}'\n        )\n        logger.info(msg)\n\n    edf_info[\"stim_channel_idxs\"] = stim_channel_idxs\n    if any(pick_mask):\n        picks = [item for item, mask in zip(range(nchan), pick_mask) if mask]\n        edf_info[\"max_samp\"] = max_samp = n_samps[picks].max()\n    else:\n        edf_info[\"max_samp\"] = max_samp = n_samps.max()\n\n    # Info structure\n    # -------------------------------------------------------------------------\n\n    not_stim_ch = [x for x in range(n_samps.shape[0]) if x not in stim_channel_idxs]\n    if len(not_stim_ch) == 0:  # only loading stim channels\n        not_stim_ch = list(range(len(n_samps)))\n    sfreq = (\n        np.take(n_samps, not_stim_ch).max()\n        * edf_info[\"record_length\"][1]\n        / edf_info[\"record_length\"][0]\n    )\n    del n_samps\n    info = _empty_info(sfreq)\n    info[\"meas_date\"] = edf_info[\"meas_date\"]\n    info[\"chs\"] = chs\n    info[\"ch_names\"] = ch_names\n\n    # Subject information\n    info[\"subject_info\"] = {}\n\n    # String subject identifier\n    if edf_info[\"subject_info\"].get(\"id\") is not None:\n        info[\"subject_info\"][\"his_id\"] = edf_info[\"subject_info\"][\"id\"]\n    # Subject sex (0=unknown, 1=male, 2=female)\n    if edf_info[\"subject_info\"].get(\"sex\") is not None:\n        if edf_info[\"subject_info\"][\"sex\"] == \"M\":\n            info[\"subject_info\"][\"sex\"] = 1\n        elif edf_info[\"subject_info\"][\"sex\"] == \"F\":\n            info[\"subject_info\"][\"sex\"] = 2\n        else:\n            info[\"subject_info\"][\"sex\"] = 0\n    # Subject names (first, middle, last).\n    if edf_info[\"subject_info\"].get(\"name\") is not None:\n        sub_names = edf_info[\"subject_info\"][\"name\"].split(\"_\")\n        if len(sub_names) < 2 or len(sub_names) > 3:\n            info[\"subject_info\"][\"last_name\"] = edf_info[\"subject_info\"][\"name\"]\n        elif len(sub_names) == 2:\n            info[\"subject_info\"][\"first_name\"] = sub_names[0]\n            info[\"subject_info\"][\"last_name\"] = sub_names[1]\n        else:\n            info[\"subject_info\"][\"first_name\"] = sub_names[0]\n            info[\"subject_info\"][\"middle_name\"] = sub_names[1]\n            info[\"subject_info\"][\"last_name\"] = sub_names[2]\n    # Birthday in (year, month, day) format.\n    if isinstance(edf_info[\"subject_info\"].get(\"birthday\"), datetime):\n        info[\"subject_info\"][\"birthday\"] = (\n            edf_info[\"subject_info\"][\"birthday\"].year,\n            edf_info[\"subject_info\"][\"birthday\"].month,\n            edf_info[\"subject_info\"][\"birthday\"].day,\n        )\n    # Handedness (1=right, 2=left, 3=ambidextrous).\n    if edf_info[\"subject_info\"].get(\"hand\") is not None:\n        info[\"subject_info\"][\"hand\"] = int(edf_info[\"subject_info\"][\"hand\"])\n    # Height in meters.\n    if edf_info[\"subject_info\"].get(\"height\") is not None:\n        info[\"subject_info\"][\"height\"] = float(edf_info[\"subject_info\"][\"height\"])\n    # Weight in kilograms.\n    if edf_info[\"subject_info\"].get(\"weight\") is not None:\n        info[\"subject_info\"][\"weight\"] = float(edf_info[\"subject_info\"][\"weight\"])\n\n    # Filter settings\n    highpass = edf_info[\"highpass\"]\n    lowpass = edf_info[\"lowpass\"]\n    if highpass.size == 0:\n        pass\n    elif all(highpass):\n        if highpass[0] == \"NaN\":\n            # Placeholder for future use. Highpass set in _empty_info.\n            pass\n        elif highpass[0] == \"DC\":\n            info[\"highpass\"] = 0.0\n        else:\n            hp = highpass[0]\n            try:\n                hp = float(hp)\n            except Exception:\n                hp = 0.0\n            info[\"highpass\"] = hp\n    else:\n        info[\"highpass\"] = float(np.max(highpass))\n        warn(\n            \"Channels contain different highpass filters. Highest filter \"\n            \"setting will be stored.\"\n        )\n    if np.isnan(info[\"highpass\"]):\n        info[\"highpass\"] = 0.0\n    if lowpass.size == 0:\n        # Placeholder for future use. Lowpass set in _empty_info.\n        pass\n    elif all(lowpass):\n        if lowpass[0] in (\"NaN\", \"0\", \"0.0\"):\n            # Placeholder for future use. Lowpass set in _empty_info.\n            pass\n        else:\n            info[\"lowpass\"] = float(lowpass[0])\n    else:\n        info[\"lowpass\"] = float(np.min(lowpass))\n        warn(\n            \"Channels contain different lowpass filters. Lowest filter \"\n            \"setting will be stored.\"\n        )\n    if np.isnan(info[\"lowpass\"]):\n        info[\"lowpass\"] = info[\"sfreq\"] / 2.0\n\n    if info[\"highpass\"] > info[\"lowpass\"]:\n        warn(\n            f'Highpass cutoff frequency {info[\"highpass\"]} is greater '\n            f'than lowpass cutoff frequency {info[\"lowpass\"]}, '\n            \"setting values to 0 and Nyquist.\"\n        )\n        info[\"highpass\"] = 0.0\n        info[\"lowpass\"] = info[\"sfreq\"] / 2.0\n\n    # Some keys to be consistent with FIF measurement info\n    info[\"description\"] = None\n    edf_info[\"nsamples\"] = int(edf_info[\"n_records\"] * max_samp)\n\n    info._unlocked = False\n    info._update_redundant()\n\n    # Later used for reading\n    edf_info[\"cal\"] = physical_ranges / cals\n\n    # physical dimension in V\n    edf_info[\"offsets\"] = (\n        edf_info[\"physical_min\"] - edf_info[\"digital_min\"] * edf_info[\"cal\"]\n    )\n    del edf_info[\"physical_min\"]\n    del edf_info[\"digital_min\"]\n\n    if edf_info[\"subtype\"] == \"bdf\":\n        edf_info[\"cal\"][stim_channel_idxs] = 1\n        edf_info[\"offsets\"][stim_channel_idxs] = 0\n        edf_info[\"units\"][stim_channel_idxs] = 1\n\n    return info, edf_info, orig_units\n\n\ndef _parse_prefilter_string(prefiltering):\n    \"\"\"Parse prefilter string from EDF+ and BDF headers.\"\"\"\n    highpass = np.array(\n        [\n            v\n            for hp in [\n                re.findall(r\"HP:\\s*([0-9]+[.]*[0-9]*)\", filt) for filt in prefiltering\n            ]\n            for v in hp\n        ]\n    )\n    lowpass = np.array(\n        [\n            v\n            for hp in [\n                re.findall(r\"LP:\\s*([0-9]+[.]*[0-9]*)\", filt) for filt in prefiltering\n            ]\n            for v in hp\n        ]\n    )\n    return highpass, lowpass\n\n\ndef _edf_str(x):\n    return x.decode(\"latin-1\").split(\"\\x00\")[0]\n\n\ndef _edf_str_num(x):\n    return _edf_str(x).replace(\",\", \".\")\n\n\ndef _read_edf_header(fname, exclude, infer_types, include=None):\n    \"\"\"Read header information from EDF+ or BDF file.\"\"\"\n    edf_info = {\"events\": []}\n\n    with open(fname, \"rb\") as fid:\n        fid.read(8)  # version (unused here)\n\n        # patient ID\n        patient = {}\n        id_info = fid.read(80).decode(\"latin-1\").rstrip()\n        id_info = id_info.split(\" \")\n        if len(id_info):\n            patient[\"id\"] = id_info[0]\n            if len(id_info) >= 4:\n                try:\n                    birthdate = datetime.strptime(id_info[2], \"%d-%b-%Y\")\n                except ValueError:\n                    birthdate = \"X\"\n                patient[\"sex\"] = id_info[1]\n                patient[\"birthday\"] = birthdate\n                patient[\"name\"] = id_info[3]\n                if len(id_info) > 4:\n                    for info in id_info[4:]:\n                        if \"=\" in info:\n                            key, value = info.split(\"=\")\n                            if key in [\"weight\", \"height\"]:\n                                patient[key] = float(value)\n                            elif key in [\"hand\"]:\n                                patient[key] = int(value)\n                            else:\n                                warn(f\"Invalid patient information {key}\")\n\n        # Recording ID\n        meas_id = {}\n        rec_info = fid.read(80).decode(\"latin-1\").rstrip().split(\" \")\n        valid_startdate = False\n        if len(rec_info) == 5:\n            try:\n                startdate = datetime.strptime(rec_info[1], \"%d-%b-%Y\")\n            except ValueError:\n                startdate = \"X\"\n            else:\n                valid_startdate = True\n            meas_id[\"startdate\"] = startdate\n            meas_id[\"study_id\"] = rec_info[2]\n            meas_id[\"technician\"] = rec_info[3]\n            meas_id[\"equipment\"] = rec_info[4]\n\n        # If startdate available in recording info, use it instead of the\n        # file's meas_date since it contains all 4 digits of the year\n        if valid_startdate:\n            day = meas_id[\"startdate\"].day\n            month = meas_id[\"startdate\"].month\n            year = meas_id[\"startdate\"].year\n            fid.read(8)  # skip file's meas_date\n        else:\n            meas_date = fid.read(8).decode(\"latin-1\")\n            day, month, year = [int(x) for x in meas_date.split(\".\")]\n            year = year + 2000 if year < 85 else year + 1900\n\n        meas_time = fid.read(8).decode(\"latin-1\")\n        hour, minute, sec = [int(x) for x in meas_time.split(\".\")]\n        try:\n            meas_date = datetime(\n                year, month, day, hour, minute, sec, tzinfo=timezone.utc\n            )\n        except ValueError:\n            warn(\n                f\"Invalid date encountered ({year:04d}-{month:02d}-\"\n                f\"{day:02d} {hour:02d}:{minute:02d}:{sec:02d}).\"\n            )\n            meas_date = None\n\n        header_nbytes = int(_edf_str(fid.read(8)))\n\n        # The following 44 bytes sometimes identify the file type, but this is\n        # not guaranteed. Therefore, we skip this field and use the file\n        # extension to determine the subtype (EDF or BDF, which differ in the\n        # number of bytes they use for the data records; EDF uses 2 bytes\n        # whereas BDF uses 3 bytes).\n        fid.read(44)\n        subtype = os.path.splitext(fname)[1][1:].lower()\n\n        n_records = int(_edf_str(fid.read(8)))\n        record_length = float(_edf_str(fid.read(8)))\n        record_length = np.array([record_length, 1.0])  # in seconds\n        if record_length[0] == 0:\n            record_length[0] = 1.0\n            warn(\n                \"Header information is incorrect for record length. Default \"\n                \"record length set to 1.\\nIt is possible that this file only\"\n                \" contains annotations and no signals. In that case, please \"\n                \"use mne.read_annotations() to load these annotations.\"\n            )\n\n        nchan = int(_edf_str(fid.read(4)))\n        channels = list(range(nchan))\n\n        # read in 16 byte labels and strip any extra spaces at the end\n        ch_labels = [fid.read(16).strip().decode(\"latin-1\") for _ in channels]\n\n        # get channel names and optionally channel type\n        # EDF specification contains 16 bytes that encode channel names,\n        # optionally prefixed by a string representing channel type separated\n        # by a space\n        if infer_types:\n            ch_types, ch_names = [], []\n            for ch_label in ch_labels:\n                ch_type, ch_name = \"EEG\", ch_label  # default to EEG\n                parts = ch_label.split(\" \")\n                if len(parts) > 1:\n                    if parts[0].upper() in CH_TYPE_MAPPING:\n                        ch_type = parts[0].upper()\n                        ch_name = \" \".join(parts[1:])\n                        logger.info(\n                            f\"Channel '{ch_label}' recognized as type \"\n                            f\"{ch_type} (renamed to '{ch_name}').\"\n                        )\n                ch_types.append(ch_type)\n                ch_names.append(ch_name)\n        else:\n            ch_types, ch_names = [\"EEG\"] * nchan, ch_labels\n\n        exclude = _find_exclude_idx(ch_names, exclude, include)\n        tal_idx = _find_tal_idx(ch_names)\n        exclude = np.concatenate([exclude, tal_idx])\n        sel = np.setdiff1d(np.arange(len(ch_names)), exclude)\n        for ch in channels:\n            fid.read(80)  # transducer\n        units = [fid.read(8).strip().decode(\"latin-1\") for ch in channels]\n        edf_info[\"units\"] = list()\n        for i, unit in enumerate(units):\n            if i in exclude:\n                continue\n            # allow  (greek mu),  (micro symbol) and  (sjis mu) codepoints\n            if unit in (\"\\u03BCV\", \"\\u00B5V\", \"\\x83\\xCAV\", \"uV\"):\n                edf_info[\"units\"].append(1e-6)\n            elif unit == \"mV\":\n                edf_info[\"units\"].append(1e-3)\n            else:\n                edf_info[\"units\"].append(1)\n        edf_info[\"units\"] = np.array(edf_info[\"units\"], float)\n\n        ch_names = [ch_names[idx] for idx in sel]\n        units = [units[idx] for idx in sel]\n\n        # make sure channel names are unique\n        ch_names = _unique_channel_names(ch_names)\n        orig_units = dict(zip(ch_names, units))\n\n        physical_min = np.array([float(_edf_str_num(fid.read(8))) for ch in channels])[\n            sel\n        ]\n        physical_max = np.array([float(_edf_str_num(fid.read(8))) for ch in channels])[\n            sel\n        ]\n        digital_min = np.array([float(_edf_str_num(fid.read(8))) for ch in channels])[\n            sel\n        ]\n        digital_max = np.array([float(_edf_str_num(fid.read(8))) for ch in channels])[\n            sel\n        ]\n        prefiltering = [_edf_str(fid.read(80)).strip() for ch in channels][:-1]\n        highpass, lowpass = _parse_prefilter_string(prefiltering)\n\n        # number of samples per record\n        n_samps = np.array([int(_edf_str(fid.read(8))) for ch in channels])\n\n        # Populate edf_info\n        edf_info.update(\n            ch_names=ch_names,\n            ch_types=ch_types,\n            data_offset=header_nbytes,\n            digital_max=digital_max,\n            digital_min=digital_min,\n            highpass=highpass,\n            sel=sel,\n            lowpass=lowpass,\n            meas_date=meas_date,\n            n_records=n_records,\n            n_samps=n_samps,\n            nchan=nchan,\n            subject_info=patient,\n            physical_max=physical_max,\n            physical_min=physical_min,\n            record_length=record_length,\n            subtype=subtype,\n            tal_idx=tal_idx,\n        )\n\n        fid.read(32 * nchan).decode()  # reserved\n        assert fid.tell() == header_nbytes\n\n        fid.seek(0, 2)\n        n_bytes = fid.tell()\n        n_data_bytes = n_bytes - header_nbytes\n        total_samps = n_data_bytes // 3 if subtype == \"bdf\" else n_data_bytes // 2\n        read_records = total_samps // np.sum(n_samps)\n        if n_records != read_records:\n            warn(\n                \"Number of records from the header does not match the file \"\n                \"size (perhaps the recording was not stopped before exiting).\"\n                \" Inferring from the file size.\"\n            )\n            edf_info[\"n_records\"] = read_records\n        del n_records\n\n        if subtype == \"bdf\":\n            edf_info[\"dtype_byte\"] = 3  # 24-bit (3 byte) integers\n            edf_info[\"dtype_np\"] = UINT8\n        else:\n            edf_info[\"dtype_byte\"] = 2  # 16-bit (2 byte) integers\n            edf_info[\"dtype_np\"] = INT16\n\n    return edf_info, orig_units\n\n\nINT8 = \"<i1\"\nUINT8 = \"<u1\"\nINT16 = \"<i2\"\nUINT16 = \"<u2\"\nINT32 = \"<i4\"\nUINT32 = \"<u4\"\nINT64 = \"<i8\"\nUINT64 = \"<u8\"\nFLOAT32 = \"<f4\"\nFLOAT64 = \"<f8\"\nGDFTYPE_NP = (\n    None,\n    INT8,\n    UINT8,\n    INT16,\n    UINT16,\n    INT32,\n    UINT32,\n    INT64,\n    UINT64,\n    None,\n    None,\n    None,\n    None,\n    None,\n    None,\n    None,\n    FLOAT32,\n    FLOAT64,\n)\nGDFTYPE_BYTE = tuple(np.dtype(x).itemsize if x is not None else 0 for x in GDFTYPE_NP)\n\n\ndef _check_dtype_byte(types):\n    assert sum(GDFTYPE_BYTE) == 42\n    dtype_byte = [GDFTYPE_BYTE[t] for t in types]\n    dtype_np = [GDFTYPE_NP[t] for t in types]\n    if len(np.unique(dtype_byte)) > 1:\n        # We will not read it properly, so this should be an error\n        raise RuntimeError(\"Reading multiple data types not supported\")\n    return dtype_np[0], dtype_byte[0]\n\n\ndef _read_gdf_header(fname, exclude, include=None):\n    \"\"\"Read GDF 1.x and GDF 2.x header info.\"\"\"\n    edf_info = dict()\n    events = None\n    with open(fname, \"rb\") as fid:\n        version = fid.read(8).decode()\n        edf_info[\"type\"] = edf_info[\"subtype\"] = version[:3]\n        edf_info[\"number\"] = float(version[4:])\n        meas_date = None\n\n        # GDF 1.x\n        # ---------------------------------------------------------------------\n        if edf_info[\"number\"] < 1.9:\n            # patient ID\n            pid = fid.read(80).decode(\"latin-1\")\n            pid = pid.split(\" \", 2)\n            patient = {}\n            if len(pid) >= 2:\n                patient[\"id\"] = pid[0]\n                patient[\"name\"] = pid[1]\n\n            # Recording ID\n            meas_id = {}\n            meas_id[\"recording_id\"] = _edf_str(fid.read(80)).strip()\n\n            # date\n            tm = _edf_str(fid.read(16)).strip()\n            try:\n                if tm[14:16] == \"  \":\n                    tm = tm[:14] + \"00\" + tm[16:]\n                meas_date = datetime(\n                    int(tm[0:4]),\n                    int(tm[4:6]),\n                    int(tm[6:8]),\n                    int(tm[8:10]),\n                    int(tm[10:12]),\n                    int(tm[12:14]),\n                    int(tm[14:16]) * pow(10, 4),\n                    tzinfo=timezone.utc,\n                )\n            except Exception:\n                pass\n\n            header_nbytes = np.fromfile(fid, INT64, 1)[0]\n            meas_id[\"equipment\"] = np.fromfile(fid, UINT8, 8)[0]\n            meas_id[\"hospital\"] = np.fromfile(fid, UINT8, 8)[0]\n            meas_id[\"technician\"] = np.fromfile(fid, UINT8, 8)[0]\n            fid.seek(20, 1)  # 20bytes reserved\n\n            n_records = np.fromfile(fid, INT64, 1)[0]\n            # record length in seconds\n            record_length = np.fromfile(fid, UINT32, 2)\n            if record_length[0] == 0:\n                record_length[0] = 1.0\n                warn(\n                    \"Header information is incorrect for record length. \"\n                    \"Default record length set to 1.\"\n                )\n            nchan = int(np.fromfile(fid, UINT32, 1)[0])\n            channels = list(range(nchan))\n            ch_names = [_edf_str(fid.read(16)).strip() for ch in channels]\n            exclude = _find_exclude_idx(ch_names, exclude, include)\n            sel = np.setdiff1d(np.arange(len(ch_names)), exclude)\n            fid.seek(80 * len(channels), 1)  # transducer\n            units = [_edf_str(fid.read(8)).strip() for ch in channels]\n            edf_info[\"units\"] = list()\n            for i, unit in enumerate(units):\n                if i in exclude:\n                    continue\n                if unit[:2] == \"uV\":\n                    edf_info[\"units\"].append(1e-6)\n                else:\n                    edf_info[\"units\"].append(1)\n            edf_info[\"units\"] = np.array(edf_info[\"units\"], float)\n\n            ch_names = [ch_names[idx] for idx in sel]\n            physical_min = np.fromfile(fid, FLOAT64, len(channels))\n            physical_max = np.fromfile(fid, FLOAT64, len(channels))\n            digital_min = np.fromfile(fid, INT64, len(channels))\n            digital_max = np.fromfile(fid, INT64, len(channels))\n            prefiltering = [_edf_str(fid.read(80)) for ch in channels][:-1]\n            highpass, lowpass = _parse_prefilter_string(prefiltering)\n\n            # n samples per record\n            n_samps = np.fromfile(fid, INT32, len(channels))\n\n            # channel data type\n            dtype = np.fromfile(fid, INT32, len(channels))\n\n            # total number of bytes for data\n            bytes_tot = np.sum(\n                [GDFTYPE_BYTE[t] * n_samps[i] for i, t in enumerate(dtype)]\n            )\n\n            # Populate edf_info\n            dtype_np, dtype_byte = _check_dtype_byte(dtype)\n            edf_info.update(\n                bytes_tot=bytes_tot,\n                ch_names=ch_names,\n                data_offset=header_nbytes,\n                digital_min=digital_min,\n                digital_max=digital_max,\n                dtype_byte=dtype_byte,\n                dtype_np=dtype_np,\n                exclude=exclude,\n                highpass=highpass,\n                sel=sel,\n                lowpass=lowpass,\n                meas_date=meas_date,\n                meas_id=meas_id,\n                n_records=n_records,\n                n_samps=n_samps,\n                nchan=nchan,\n                subject_info=patient,\n                physical_max=physical_max,\n                physical_min=physical_min,\n                record_length=record_length,\n            )\n\n            fid.seek(32 * edf_info[\"nchan\"], 1)  # reserved\n            assert fid.tell() == header_nbytes\n\n            # Event table\n            # -----------------------------------------------------------------\n            etp = header_nbytes + n_records * edf_info[\"bytes_tot\"]\n            # skip data to go to event table\n            fid.seek(etp)\n            etmode = np.fromfile(fid, UINT8, 1)[0]\n            if etmode in (1, 3):\n                sr = np.fromfile(fid, UINT8, 3).astype(np.uint32)\n                event_sr = sr[0]\n                for i in range(1, len(sr)):\n                    event_sr = event_sr + sr[i] * 2 ** (i * 8)\n                n_events = np.fromfile(fid, UINT32, 1)[0]\n                pos = np.fromfile(fid, UINT32, n_events) - 1  # 1-based inds\n                typ = np.fromfile(fid, UINT16, n_events)\n\n                if etmode == 3:\n                    chn = np.fromfile(fid, UINT16, n_events)\n                    dur = np.fromfile(fid, UINT32, n_events)\n                else:\n                    chn = np.zeros(n_events, dtype=np.int32)\n                    dur = np.ones(n_events, dtype=UINT32)\n                np.maximum(dur, 1, out=dur)\n                events = [n_events, pos, typ, chn, dur]\n\n        # GDF 2.x\n        # ---------------------------------------------------------------------\n        else:\n            # FIXED HEADER\n            handedness = (\"Unknown\", \"Right\", \"Left\", \"Equal\")\n            gender = (\"Unknown\", \"Male\", \"Female\")\n            scale = (\"Unknown\", \"No\", \"Yes\", \"Corrected\")\n\n            # date\n            pid = fid.read(66).decode()\n            pid = pid.split(\" \", 2)\n            patient = {}\n            if len(pid) >= 2:\n                patient[\"id\"] = pid[0]\n                patient[\"name\"] = pid[1]\n            fid.seek(10, 1)  # 10bytes reserved\n\n            # Smoking / Alcohol abuse / drug abuse / medication\n            sadm = np.fromfile(fid, UINT8, 1)[0]\n            patient[\"smoking\"] = scale[sadm % 4]\n            patient[\"alcohol_abuse\"] = scale[(sadm >> 2) % 4]\n            patient[\"drug_abuse\"] = scale[(sadm >> 4) % 4]\n            patient[\"medication\"] = scale[(sadm >> 6) % 4]\n            patient[\"weight\"] = np.fromfile(fid, UINT8, 1)[0]\n            if patient[\"weight\"] == 0 or patient[\"weight\"] == 255:\n                patient[\"weight\"] = None\n            patient[\"height\"] = np.fromfile(fid, UINT8, 1)[0]\n            if patient[\"height\"] == 0 or patient[\"height\"] == 255:\n                patient[\"height\"] = None\n\n            # Gender / Handedness / Visual Impairment\n            ghi = np.fromfile(fid, UINT8, 1)[0]\n            patient[\"sex\"] = gender[ghi % 4]\n            patient[\"handedness\"] = handedness[(ghi >> 2) % 4]\n            patient[\"visual\"] = scale[(ghi >> 4) % 4]\n\n            # Recording identification\n            meas_id = {}\n            meas_id[\"recording_id\"] = _edf_str(fid.read(64)).strip()\n            vhsv = np.fromfile(fid, UINT8, 4)\n            loc = {}\n            if vhsv[3] == 0:\n                loc[\"vertpre\"] = 10 * int(vhsv[0] >> 4) + int(vhsv[0] % 16)\n                loc[\"horzpre\"] = 10 * int(vhsv[1] >> 4) + int(vhsv[1] % 16)\n                loc[\"size\"] = 10 * int(vhsv[2] >> 4) + int(vhsv[2] % 16)\n            else:\n                loc[\"vertpre\"] = 29\n                loc[\"horzpre\"] = 29\n                loc[\"size\"] = 29\n            loc[\"version\"] = 0\n            loc[\"latitude\"] = float(np.fromfile(fid, UINT32, 1)[0]) / 3600000\n            loc[\"longitude\"] = float(np.fromfile(fid, UINT32, 1)[0]) / 3600000\n            loc[\"altitude\"] = float(np.fromfile(fid, INT32, 1)[0]) / 100\n            meas_id[\"loc\"] = loc\n\n            meas_date = np.fromfile(fid, UINT64, 1)[0]\n            if meas_date != 0:\n                meas_date = datetime(1, 1, 1, tzinfo=timezone.utc) + timedelta(\n                    meas_date * pow(2, -32) - 367\n                )\n            else:\n                meas_date = None\n\n            birthday = np.fromfile(fid, UINT64, 1).tolist()[0]\n            if birthday == 0:\n                birthday = datetime(1, 1, 1, tzinfo=timezone.utc)\n            else:\n                birthday = datetime(1, 1, 1, tzinfo=timezone.utc) + timedelta(\n                    birthday * pow(2, -32) - 367\n                )\n            patient[\"birthday\"] = birthday\n            if patient[\"birthday\"] != datetime(1, 1, 1, 0, 0, tzinfo=timezone.utc):\n                today = datetime.now(tz=timezone.utc)\n                patient[\"age\"] = today.year - patient[\"birthday\"].year\n                today = today.replace(year=patient[\"birthday\"].year)\n                if today < patient[\"birthday\"]:\n                    patient[\"age\"] -= 1\n            else:\n                patient[\"age\"] = None\n\n            header_nbytes = np.fromfile(fid, UINT16, 1)[0] * 256\n\n            fid.seek(6, 1)  # 6 bytes reserved\n            meas_id[\"equipment\"] = np.fromfile(fid, UINT8, 8)\n            meas_id[\"ip\"] = np.fromfile(fid, UINT8, 6)\n            patient[\"headsize\"] = np.fromfile(fid, UINT16, 3)\n            patient[\"headsize\"] = np.asarray(patient[\"headsize\"], np.float32)\n            patient[\"headsize\"] = np.ma.masked_array(\n                patient[\"headsize\"], np.equal(patient[\"headsize\"], 0), None\n            ).filled()\n            ref = np.fromfile(fid, FLOAT32, 3)\n            gnd = np.fromfile(fid, FLOAT32, 3)\n            n_records = np.fromfile(fid, INT64, 1)[0]\n\n            # record length in seconds\n            record_length = np.fromfile(fid, UINT32, 2)\n            if record_length[0] == 0:\n                record_length[0] = 1.0\n                warn(\n                    \"Header information is incorrect for record length. \"\n                    \"Default record length set to 1.\"\n                )\n\n            nchan = int(np.fromfile(fid, UINT16, 1)[0])\n            fid.seek(2, 1)  # 2bytes reserved\n\n            # Channels (variable header)\n            channels = list(range(nchan))\n            ch_names = [_edf_str(fid.read(16)).strip() for ch in channels]\n            exclude = _find_exclude_idx(ch_names, exclude, include)\n            sel = np.setdiff1d(np.arange(len(ch_names)), exclude)\n\n            fid.seek(80 * len(channels), 1)  # reserved space\n            fid.seek(6 * len(channels), 1)  # phys_dim, obsolete\n\n            \"\"\"The Physical Dimensions are encoded as int16, according to:\n            - Units codes :\n            https://sourceforge.net/p/biosig/svn/HEAD/tree/trunk/biosig/doc/units.csv\n            - Decimal factors codes:\n            https://sourceforge.net/p/biosig/svn/HEAD/tree/trunk/biosig/doc/DecimalFactors.txt\n            \"\"\"  # noqa\n            units = np.fromfile(fid, UINT16, len(channels)).tolist()\n            unitcodes = np.array(units[:])\n            edf_info[\"units\"] = list()\n            for i, unit in enumerate(units):\n                if i in exclude:\n                    continue\n                if unit == 4275:  # microvolts\n                    edf_info[\"units\"].append(1e-6)\n                elif unit == 4274:  # millivolts\n                    edf_info[\"units\"].append(1e-3)\n                elif unit == 512:  # dimensionless\n                    edf_info[\"units\"].append(1)\n                elif unit == 0:\n                    edf_info[\"units\"].append(1)  # unrecognized\n                else:\n                    warn(\n                        \"Unsupported physical dimension for channel %d \"\n                        \"(assuming dimensionless). Please contact the \"\n                        \"MNE-Python developers for support.\" % i\n                    )\n                    edf_info[\"units\"].append(1)\n            edf_info[\"units\"] = np.array(edf_info[\"units\"], float)\n\n            ch_names = [ch_names[idx] for idx in sel]\n            physical_min = np.fromfile(fid, FLOAT64, len(channels))\n            physical_max = np.fromfile(fid, FLOAT64, len(channels))\n            digital_min = np.fromfile(fid, FLOAT64, len(channels))\n            digital_max = np.fromfile(fid, FLOAT64, len(channels))\n\n            fid.seek(68 * len(channels), 1)  # obsolete\n            lowpass = np.fromfile(fid, FLOAT32, len(channels))\n            highpass = np.fromfile(fid, FLOAT32, len(channels))\n            notch = np.fromfile(fid, FLOAT32, len(channels))\n\n            # number of samples per record\n            n_samps = np.fromfile(fid, INT32, len(channels))\n\n            # data type\n            dtype = np.fromfile(fid, INT32, len(channels))\n\n            channel = {}\n            channel[\"xyz\"] = [np.fromfile(fid, FLOAT32, 3)[0] for ch in channels]\n\n            if edf_info[\"number\"] < 2.19:\n                impedance = np.fromfile(fid, UINT8, len(channels)).astype(float)\n                impedance[impedance == 255] = np.nan\n                channel[\"impedance\"] = pow(2, impedance / 8)\n                fid.seek(19 * len(channels), 1)  # reserved\n            else:\n                tmp = np.fromfile(fid, FLOAT32, 5 * len(channels))\n                tmp = tmp[::5]\n                fZ = tmp[:]\n                impedance = tmp[:]\n                # channels with no voltage (code 4256) data\n                ch = [unitcodes & 65504 != 4256][0]\n                impedance[np.where(ch)] = None\n                # channel with no impedance (code 4288) data\n                ch = [unitcodes & 65504 != 4288][0]\n                fZ[np.where(ch)[0]] = None\n\n            assert fid.tell() == header_nbytes\n\n            # total number of bytes for data\n            bytes_tot = np.sum(\n                [GDFTYPE_BYTE[t] * n_samps[i] for i, t in enumerate(dtype)]\n            )\n\n            # Populate edf_info\n            dtype_np, dtype_byte = _check_dtype_byte(dtype)\n            edf_info.update(\n                bytes_tot=bytes_tot,\n                ch_names=ch_names,\n                data_offset=header_nbytes,\n                dtype_byte=dtype_byte,\n                dtype_np=dtype_np,\n                digital_min=digital_min,\n                digital_max=digital_max,\n                exclude=exclude,\n                gnd=gnd,\n                highpass=highpass,\n                sel=sel,\n                impedance=impedance,\n                lowpass=lowpass,\n                meas_date=meas_date,\n                meas_id=meas_id,\n                n_records=n_records,\n                n_samps=n_samps,\n                nchan=nchan,\n                notch=notch,\n                subject_info=patient,\n                physical_max=physical_max,\n                physical_min=physical_min,\n                record_length=record_length,\n                ref=ref,\n            )\n\n            # EVENT TABLE\n            # -----------------------------------------------------------------\n            etp = (\n                edf_info[\"data_offset\"] + edf_info[\"n_records\"] * edf_info[\"bytes_tot\"]\n            )\n            fid.seek(etp)  # skip data to go to event table\n            etmode = fid.read(1).decode()\n            if etmode != \"\":\n                etmode = np.fromstring(etmode, UINT8).tolist()[0]\n\n                if edf_info[\"number\"] < 1.94:\n                    sr = np.fromfile(fid, UINT8, 3)\n                    event_sr = sr[0]\n                    for i in range(1, len(sr)):\n                        event_sr = event_sr + sr[i] * 2 ** (i * 8)\n                    n_events = np.fromfile(fid, UINT32, 1)[0]\n                else:\n                    ne = np.fromfile(fid, UINT8, 3)\n                    n_events = ne[0]\n                    for i in range(1, len(ne)):\n                        n_events = n_events + ne[i] * 2 ** (i * 8)\n                    event_sr = np.fromfile(fid, FLOAT32, 1)[0]\n\n                pos = np.fromfile(fid, UINT32, n_events) - 1  # 1-based inds\n                typ = np.fromfile(fid, UINT16, n_events)\n\n                if etmode == 3:\n                    chn = np.fromfile(fid, UINT16, n_events)\n                    dur = np.fromfile(fid, UINT32, n_events)\n                else:\n                    chn = np.zeros(n_events, dtype=np.uint32)\n                    dur = np.ones(n_events, dtype=np.uint32)\n                np.maximum(dur, 1, out=dur)\n                events = [n_events, pos, typ, chn, dur]\n                edf_info[\"event_sfreq\"] = event_sr\n\n    edf_info.update(events=events, sel=np.arange(len(edf_info[\"ch_names\"])))\n\n    return edf_info\n\n\ndef _check_stim_channel(\n    stim_channel, ch_names, tal_ch_names=[\"EDF Annotations\", \"BDF Annotations\"]\n):\n    \"\"\"Check that the stimulus channel exists in the current datafile.\"\"\"\n    DEFAULT_STIM_CH_NAMES = [\"status\", \"trigger\"]\n\n    if stim_channel is None or stim_channel is False:\n        return [], []\n\n    if stim_channel is True:  # convenient aliases\n        stim_channel = \"auto\"\n\n    elif isinstance(stim_channel, str):\n        if stim_channel == \"auto\":\n            if \"auto\" in ch_names:\n                warn(\n                    RuntimeWarning,\n                    \"Using `stim_channel='auto'` when auto\"\n                    \" also corresponds to a channel name is ambiguous.\"\n                    \" Please use `stim_channel=['auto']`.\",\n                )\n            else:\n                valid_stim_ch_names = DEFAULT_STIM_CH_NAMES\n        else:\n            valid_stim_ch_names = [stim_channel.lower()]\n\n    elif isinstance(stim_channel, int):\n        valid_stim_ch_names = [ch_names[stim_channel].lower()]\n\n    elif isinstance(stim_channel, list):\n        if all([isinstance(s, str) for s in stim_channel]):\n            valid_stim_ch_names = [s.lower() for s in stim_channel]\n        elif all([isinstance(s, int) for s in stim_channel]):\n            valid_stim_ch_names = [ch_names[s].lower() for s in stim_channel]\n        else:\n            raise ValueError(\"Invalid stim_channel\")\n    else:\n        raise ValueError(\"Invalid stim_channel\")\n\n    # Forbid the synthesis of stim channels from TAL Annotations\n    tal_ch_names_found = [\n        ch for ch in valid_stim_ch_names if ch in [t.lower() for t in tal_ch_names]\n    ]\n    if len(tal_ch_names_found):\n        _msg = (\n            \"The synthesis of the stim channel is not supported\"\n            \" since 0.18. Please remove {} from `stim_channel`\"\n            \" and use `mne.events_from_annotations` instead\"\n        ).format(tal_ch_names_found)\n        raise ValueError(_msg)\n\n    ch_names_low = [ch.lower() for ch in ch_names]\n    found = list(set(valid_stim_ch_names) & set(ch_names_low))\n\n    if not found:\n        return [], []\n    else:\n        stim_channel_idxs = [ch_names_low.index(f) for f in found]\n        names = [ch_names[idx] for idx in stim_channel_idxs]\n        return stim_channel_idxs, names\n\n\ndef _find_exclude_idx(ch_names, exclude, include=None):\n    \"\"\"Find indices of all channels to exclude.\n\n    If there are several channels called \"A\" and we want to exclude \"A\", then\n    add (the index of) all \"A\" channels to the exclusion list.\n    \"\"\"\n    if include:  # find other than include channels\n        if exclude:\n            raise ValueError(\n                \"'exclude' must be empty if 'include' is assigned. \" f\"Got {exclude}.\"\n            )\n        if isinstance(include, str):  # regex for channel names\n            indices_include = []\n            for idx, ch in enumerate(ch_names):\n                if re.match(include, ch):\n                    indices_include.append(idx)\n            indices = np.setdiff1d(np.arange(len(ch_names)), indices_include)\n            return indices\n        # list of channel names\n        return [idx for idx, ch in enumerate(ch_names) if ch not in include]\n\n    if isinstance(exclude, str):  # regex for channel names\n        indices = []\n        for idx, ch in enumerate(ch_names):\n            if re.match(exclude, ch):\n                indices.append(idx)\n        return indices\n    # list of channel names\n    return [idx for idx, ch in enumerate(ch_names) if ch in exclude]\n\n\ndef _find_tal_idx(ch_names):\n    # Annotations / TAL Channels\n    accepted_tal_ch_names = [\"EDF Annotations\", \"BDF Annotations\"]\n    tal_channel_idx = np.where(np.isin(ch_names, accepted_tal_ch_names))[0]\n    return tal_channel_idx\n\n\n@fill_doc\ndef read_raw_edf(\n    input_fname,\n    eog=None,\n    misc=None,\n    stim_channel=\"auto\",\n    exclude=(),\n    infer_types=False,\n    include=None,\n    preload=False,\n    units=None,\n    encoding=\"utf8\",\n    *,\n    verbose=None,\n):\n    \"\"\"Reader function for EDF and EDF+ files.\n\n    Parameters\n    ----------\n    input_fname : path-like\n        Path to the EDF or EDF+ file.\n    eog : list or tuple\n        Names of channels or list of indices that should be designated EOG\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    misc : list or tuple\n        Names of channels or list of indices that should be designated MISC\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    stim_channel : ``'auto'`` | str | list of str | int | list of int\n        Defaults to ``'auto'``, which means that channels named ``'status'`` or\n        ``'trigger'`` (case insensitive) are set to STIM. If str (or list of\n        str), all channels matching the name(s) are set to STIM. If int (or\n        list of ints), channels corresponding to the indices are set to STIM.\n    exclude : list of str | str\n        Channel names to exclude. This can help when reading data with\n        different sampling rates to avoid unnecessary resampling. A str is\n        interpreted as a regular expression.\n    infer_types : bool\n        If True, try to infer channel types from channel labels. If a channel\n        label starts with a known type (such as 'EEG') followed by a space and\n        a name (such as 'Fp1'), the channel type will be set accordingly, and\n        the channel will be renamed to the original label without the prefix.\n        For unknown prefixes, the type will be 'EEG' and the name will not be\n        modified. If False, do not infer types and assume all channels are of\n        type 'EEG'.\n\n        .. versionadded:: 0.24.1\n    include : list of str | str\n        Channel names to be included. A str is interpreted as a regular\n        expression. 'exclude' must be empty if include is assigned.\n\n        .. versionadded:: 1.1\n    %(preload)s\n    %(units_edf_bdf_io)s\n    %(encoding_edf)s\n    %(verbose)s\n\n    Returns\n    -------\n    raw : instance of RawEDF\n        The raw instance.\n        See :class:`mne.io.Raw` for documentation of attributes and methods.\n\n    See Also\n    --------\n    mne.io.read_raw_bdf : Reader function for BDF files.\n    mne.io.read_raw_gdf : Reader function for GDF files.\n    mne.export.export_raw : Export function for EDF files.\n    mne.io.Raw : Documentation of attributes and methods of RawEDF.\n\n    Notes\n    -----\n    %(edf_resamp_note)s\n\n    It is worth noting that in some special cases, it may be necessary to shift\n    event values in order to retrieve correct event triggers. This depends on\n    the triggering device used to perform the synchronization. For instance, in\n    some files events need to be shifted by 8 bits:\n\n        >>> events[:, 2] >>= 8  # doctest:+SKIP\n\n    TAL channels called 'EDF Annotations' are parsed and extracted annotations\n    are stored in raw.annotations. Use :func:`mne.events_from_annotations` to\n    obtain events from these annotations.\n\n    If channels named 'status' or 'trigger' are present, they are considered as\n    STIM channels by default. Use func:`mne.find_events` to parse events\n    encoded in such analog stim channels.\n\n    The EDF specification allows optional storage of channel types in the\n    prefix of the signal label for each channel. For example, ``EEG Fz``\n    implies that ``Fz`` is an EEG channel and ``MISC E`` would imply ``E`` is\n    a MISC channel. However, there is no standard way of specifying all\n    channel types. MNE-Python will try to infer the channel type, when such a\n    string exists, defaulting to EEG, when there is no prefix or the prefix is\n    not recognized.\n\n    The following prefix strings are mapped to MNE internal types:\n\n        - 'EEG': 'eeg'\n        - 'SEEG': 'seeg'\n        - 'ECOG': 'ecog'\n        - 'DBS': 'dbs'\n        - 'EOG': 'eog'\n        - 'ECG': 'ecg'\n        - 'EMG': 'emg'\n        - 'BIO': 'bio'\n        - 'RESP': 'resp'\n        - 'MISC': 'misc'\n        - 'SAO2': 'bio'\n\n    The EDF specification allows storage of subseconds in measurement date.\n    However, this reader currently sets subseconds to 0 by default.\n    \"\"\"\n    input_fname = os.path.abspath(input_fname)\n    ext = os.path.splitext(input_fname)[1][1:].lower()\n    # if ext != \"edf\":\n    #     raise NotImplementedError(f\"Only EDF files are supported, got {ext}.\")\n    return RawEDF(\n        input_fname=input_fname,\n        eog=eog,\n        misc=misc,\n        stim_channel=stim_channel,\n        exclude=exclude,\n        infer_types=infer_types,\n        preload=preload,\n        include=include,\n        units=units,\n        encoding=encoding,\n        verbose=verbose,\n    )\n\n\n@fill_doc\ndef read_raw_bdf(\n    input_fname,\n    eog=None,\n    misc=None,\n    stim_channel=\"auto\",\n    exclude=(),\n    infer_types=False,\n    include=None,\n    preload=False,\n    units=None,\n    encoding=\"utf8\",\n    *,\n    verbose=None,\n):\n    \"\"\"Reader function for BDF files.\n\n    Parameters\n    ----------\n    input_fname : path-like\n        Path to the BDF file.\n    eog : list or tuple\n        Names of channels or list of indices that should be designated EOG\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    misc : list or tuple\n        Names of channels or list of indices that should be designated MISC\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    stim_channel : ``'auto'`` | str | list of str | int | list of int\n        Defaults to ``'auto'``, which means that channels named ``'status'`` or\n        ``'trigger'`` (case insensitive) are set to STIM. If str (or list of\n        str), all channels matching the name(s) are set to STIM. If int (or\n        list of ints), channels corresponding to the indices are set to STIM.\n    exclude : list of str | str\n        Channel names to exclude. This can help when reading data with\n        different sampling rates to avoid unnecessary resampling. A str is\n        interpreted as a regular expression.\n    infer_types : bool\n        If True, try to infer channel types from channel labels. If a channel\n        label starts with a known type (such as 'EEG') followed by a space and\n        a name (such as 'Fp1'), the channel type will be set accordingly, and\n        the channel will be renamed to the original label without the prefix.\n        For unknown prefixes, the type will be 'EEG' and the name will not be\n        modified. If False, do not infer types and assume all channels are of\n        type 'EEG'.\n\n        .. versionadded:: 0.24.1\n    include : list of str | str\n        Channel names to be included. A str is interpreted as a regular\n        expression. 'exclude' must be empty if include is assigned.\n\n        .. versionadded:: 1.1\n    %(preload)s\n    %(units_edf_bdf_io)s\n    %(encoding_edf)s\n    %(verbose)s\n\n    Returns\n    -------\n    raw : instance of RawEDF\n        The raw instance.\n        See :class:`mne.io.Raw` for documentation of attributes and methods.\n\n    See Also\n    --------\n    mne.io.read_raw_edf : Reader function for EDF and EDF+ files.\n    mne.io.read_raw_gdf : Reader function for GDF files.\n    mne.io.Raw : Documentation of attributes and methods of RawEDF.\n\n    Notes\n    -----\n    :class:`mne.io.Raw` only stores signals with matching sampling frequencies.\n    Therefore, if mixed sampling frequency signals are requested, all signals\n    are upsampled to the highest loaded sampling frequency. In this case, using\n    preload=True is recommended, as otherwise, edge artifacts appear when\n    slices of the signal are requested.\n\n    Biosemi devices trigger codes are encoded in 16-bit format, whereas system\n    codes (CMS in/out-of range, battery low, etc.) are coded in bits 16-23 of\n    the status channel (see http://www.biosemi.com/faq/trigger_signals.htm).\n    To retrieve correct event values (bits 1-16), one could do:\n\n        >>> events = mne.find_events(...)  # doctest:+SKIP\n        >>> events[:, 2] &= (2**16 - 1)  # doctest:+SKIP\n\n    The above operation can be carried out directly in :func:`mne.find_events`\n    using the ``mask`` and ``mask_type`` parameters (see\n    :func:`mne.find_events` for more details).\n\n    It is also possible to retrieve system codes, but no particular effort has\n    been made to decode these in MNE. In case it is necessary, for instance to\n    check the CMS bit, the following operation can be carried out:\n\n        >>> cms_bit = 20  # doctest:+SKIP\n        >>> cms_high = (events[:, 2] & (1 << cms_bit)) != 0  # doctest:+SKIP\n\n    It is worth noting that in some special cases, it may be necessary to shift\n    event values in order to retrieve correct event triggers. This depends on\n    the triggering device used to perform the synchronization. For instance, in\n    some files events need to be shifted by 8 bits:\n\n        >>> events[:, 2] >>= 8  # doctest:+SKIP\n\n    TAL channels called 'BDF Annotations' are parsed and extracted annotations\n    are stored in raw.annotations. Use :func:`mne.events_from_annotations` to\n    obtain events from these annotations.\n\n    If channels named 'status' or 'trigger' are present, they are considered as\n    STIM channels by default. Use func:`mne.find_events` to parse events\n    encoded in such analog stim channels.\n    \"\"\"\n    input_fname = os.path.abspath(input_fname)\n    ext = os.path.splitext(input_fname)[1][1:].lower()\n    if ext != \"bdf\":\n        raise NotImplementedError(f\"Only BDF files are supported, got {ext}.\")\n    return RawEDF(\n        input_fname=input_fname,\n        eog=eog,\n        misc=misc,\n        stim_channel=stim_channel,\n        exclude=exclude,\n        infer_types=infer_types,\n        preload=preload,\n        include=include,\n        units=units,\n        encoding=encoding,\n        verbose=verbose,\n    )\n\n\n@fill_doc\ndef read_raw_gdf(\n    input_fname,\n    eog=None,\n    misc=None,\n    stim_channel=\"auto\",\n    exclude=(),\n    include=None,\n    preload=False,\n    verbose=None,\n):\n    \"\"\"Reader function for GDF files.\n\n    Parameters\n    ----------\n    input_fname : path-like\n        Path to the GDF file.\n    eog : list or tuple\n        Names of channels or list of indices that should be designated EOG\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    misc : list or tuple\n        Names of channels or list of indices that should be designated MISC\n        channels. Values should correspond to the electrodes in the file.\n        Default is None.\n    stim_channel : ``'auto'`` | str | list of str | int | list of int\n        Defaults to ``'auto'``, which means that channels named ``'status'`` or\n        ``'trigger'`` (case insensitive) are set to STIM. If str (or list of\n        str), all channels matching the name(s) are set to STIM. If int (or\n        list of ints), channels corresponding to the indices are set to STIM.\n    exclude : list of str | str\n        Channel names to exclude. This can help when reading data with\n        different sampling rates to avoid unnecessary resampling. A str is\n        interpreted as a regular expression.\n    include : list of str | str\n        Channel names to be included. A str is interpreted as a regular\n        expression. 'exclude' must be empty if include is assigned.\n    %(preload)s\n    %(verbose)s\n\n    Returns\n    -------\n    raw : instance of RawGDF\n        The raw instance.\n        See :class:`mne.io.Raw` for documentation of attributes and methods.\n\n    See Also\n    --------\n    mne.io.read_raw_edf : Reader function for EDF and EDF+ files.\n    mne.io.read_raw_bdf : Reader function for BDF files.\n    mne.io.Raw : Documentation of attributes and methods of RawGDF.\n\n    Notes\n    -----\n    If channels named 'status' or 'trigger' are present, they are considered as\n    STIM channels by default. Use func:`mne.find_events` to parse events\n    encoded in such analog stim channels.\n    \"\"\"\n    input_fname = os.path.abspath(input_fname)\n    ext = os.path.splitext(input_fname)[1][1:].lower()\n    if ext != \"gdf\":\n        raise NotImplementedError(f\"Only GDF files are supported, got {ext}.\")\n    return RawGDF(\n        input_fname=input_fname,\n        eog=eog,\n        misc=misc,\n        stim_channel=stim_channel,\n        exclude=exclude,\n        preload=preload,\n        include=include,\n        verbose=verbose,\n    )\n\n\n@fill_doc\ndef _read_annotations_edf(annotations, ch_names=None, encoding=\"utf8\"):\n    \"\"\"Annotation File Reader.\n\n    Parameters\n    ----------\n    annotations : ndarray (n_chans, n_samples) | str\n        Channel data in EDF+ TAL format or path to annotation file.\n    ch_names : list of string\n        List of channels' names.\n    %(encoding_edf)s\n\n    Returns\n    -------\n    annot : instance of Annotations\n        The annotations.\n    \"\"\"\n    pat = \"([+-]\\\\d+\\\\.?\\\\d*)(\\x15(\\\\d+\\\\.?\\\\d*))?(\\x14.*?)\\x14\\x00\"\n    if isinstance(annotations, str):\n        with open(annotations, \"rb\") as annot_file:\n            triggers = re.findall(pat.encode(), annot_file.read())\n            triggers = [tuple(map(lambda x: x.decode(encoding), t)) for t in triggers]\n    else:\n        tals = bytearray()\n        annotations = np.atleast_2d(annotations)\n        for chan in annotations:\n            this_chan = chan.ravel()\n            if this_chan.dtype == INT32:  # BDF\n                this_chan = this_chan.view(dtype=UINT8)\n                this_chan = this_chan.reshape(-1, 4)\n                # Why only keep the first 3 bytes as BDF values\n                # are stored with 24 bits (not 32)\n                this_chan = this_chan[:, :3].ravel()\n                # As ravel() returns a 1D array we can add all values at once\n                tals.extend(this_chan)\n            else:\n                this_chan = chan.astype(np.int64)\n                # Exploit np vectorized processing\n                tals.extend(np.uint8([this_chan % 256, this_chan // 256]).flatten(\"F\"))\n        try:\n            triggers = re.findall(pat, tals.decode(encoding))\n        except UnicodeDecodeError as e:\n            raise Exception(\n                \"Encountered invalid byte in at least one annotations channel.\"\n                \" You might want to try setting \\\"encoding='latin1'\\\".\"\n            ) from e\n\n    events = {}\n    offset = 0.0\n    for k, ev in enumerate(triggers):\n        onset = float(ev[0]) + offset\n        duration = float(ev[2]) if ev[2] else 0\n        for description in ev[3].split(\"\\x14\")[1:]:\n            if description:\n                if (\n                    \"@@\" in description\n                    and ch_names is not None\n                    and description.split(\"@@\")[1] in ch_names\n                ):\n                    description, ch_name = description.split(\"@@\")\n                    key = f\"{onset}_{duration}_{description}\"\n                else:\n                    ch_name = None\n                    key = f\"{onset}_{duration}_{description}\"\n                    if key in events:\n                        key += f\"_{k}\"  # make key unique\n                if key in events and ch_name:\n                    events[key][3] += (ch_name,)\n                else:\n                    events[key] = [\n                        onset,\n                        duration,\n                        description,\n                        (ch_name,) if ch_name else (),\n                    ]\n\n            elif k == 0:\n                # The startdate/time of a file is specified in the EDF+ header\n                # fields 'startdate of recording' and 'starttime of recording'.\n                # These fields must indicate the absolute second in which the\n                # start of the first data record falls. So, the first TAL in\n                # the first data record always starts with +0.X, indicating\n                # that the first data record starts a fraction, X, of a second\n                # after the startdate/time that is specified in the EDF+\n                # header. If X=0, then the .X may be omitted.\n                offset = -onset\n\n    if events:\n        onset, duration, description, annot_ch_names = zip(*events.values())\n    else:\n        onset, duration, description, annot_ch_names = list(), list(), list(), list()\n\n    assert len(onset) == len(duration) == len(description) == len(annot_ch_names)\n\n    return Annotations(\n        onset=onset,\n        duration=duration,\n        description=description,\n        orig_time=None,\n        ch_names=annot_ch_names,\n    )\n\n\ndef _get_annotations_gdf(edf_info, sfreq):\n    onset, duration, desc = list(), list(), list()\n    events = edf_info.get(\"events\", None)\n    # Annotations in GDF: events are stored as the following\n    # list: `events = [n_events, pos, typ, chn, dur]` where pos is the\n    # latency, dur is the duration in samples. They both are\n    # numpy.ndarray\n    if events is not None and events[1].shape[0] > 0:\n        onset = events[1] / sfreq\n        duration = events[4] / sfreq\n        desc = events[2]\n\n    return onset, duration, desc\n"
  },
  {
    "id": "preprocessing/ISRUC/prepare_ISRUC_1.py",
    "text": "# %%\nfrom mne.io import concatenate_raws\nfrom edf_ import read_raw_edf\nimport matplotlib.pyplot as plt\nimport mne\nimport os\nimport numpy as np\nfrom tqdm import tqdm\nimport xml.etree.ElementTree as ET\nfrom sklearn.preprocessing import StandardScaler\n\n\ndir_path = r'/data/datasets2/ISRUC_extracted/group1'\n\nseq_dir = r'/data/datasets/BigDownstream/ISRUC/precessed_filter_35/seq'\nlabel_dir = r'/data/datasets/BigDownstream/ISRUC/precessed_filter_35/labels'\n\npsg_f_names = []\nlabel_f_names = []\nfor i in range(1, 101):\n    numstr = str(i)\n    psg_f_names.append(f'{dir_path}/{numstr}/{numstr}.rec')\n    label_f_names.append(f'{dir_path}/{numstr}/{numstr}_1.txt')\n\n# psg_f_names.sort()\n# label_f_names.sort()\n\npsg_label_f_pairs = []\nfor psg_f_name, label_f_name in zip(psg_f_names, label_f_names):\n    if psg_f_name[:-4] == label_f_name[:-6]:\n        psg_label_f_pairs.append((psg_f_name, label_f_name))\nfor item in psg_label_f_pairs:\n    print(item)\n\nlabel2id = {'0': 0,\n            '1': 1,\n            '2': 2,\n            '3': 3,\n            '5': 4,}\nprint(label2id)\n# %%\n# signal_name = ['LOC-A2', 'F4-A1']\nn = 0\nnum_seqs = 0\nnum_labels = 0\nfor psg_f_name, label_f_name in tqdm(psg_label_f_pairs):\n    n += 1\n    labels_list = []\n\n    raw = read_raw_edf(os.path.join(dir_path, psg_f_name), preload=True)\n    # raw.pick_channels(signal_name)\n    # raw.resample(sfreq=200)\n    raw.filter(0.3, 35, fir_design='firwin')\n    raw.notch_filter((50))\n    print(raw.info)\n\n    psg_array = raw.to_data_frame().values\n    # print(psg_array[:10, 0])\n    print(psg_array.shape)\n    psg_array = psg_array[:, 1:]\n    psg_array = psg_array[:, 2:8]\n    print(psg_array.shape)\n\n    # std = StandardScaler()\n    # psg_array = std.fit_transform(psg_array)\n    # print(psg_array[:10, :])\n\n    i = psg_array.shape[0] % (30 * 200)\n    if i > 0:\n        psg_array = psg_array[:-i, :]\n    print(psg_array.shape)\n    psg_array = psg_array.reshape(-1, 30 * 200, 6)\n    print(psg_array.shape)\n\n    a = psg_array.shape[0] % 20\n    if a > 0:\n        psg_array = psg_array[:-a, :, :]\n    print(psg_array.shape)\n    psg_array = psg_array.reshape(-1, 20, 30 * 200, 6)\n    epochs_seq = psg_array.transpose(0, 1, 3, 2)\n    print(epochs_seq.shape)\n    # print(epochs_seq[0, 0, :, 100])\n\n    for line in open(os.path.join(dir_path, label_f_name)).readlines():\n        line_str = line.strip()\n        if line_str != '':\n            labels_list.append(label2id[line_str])\n    labels_array = np.array(labels_list)\n    if a > 0:\n        labels_array = labels_array[:-a]\n    labels_seq = labels_array.reshape(-1, 20)\n    print(labels_seq.shape)\n\n    if not os.path.isdir(rf'{seq_dir}/ISRUC-group1-{str(n)}'):\n        os.makedirs(rf'{seq_dir}/ISRUC-group1-{str(n)}')\n    for seq in epochs_seq:\n        seq_name = rf'{seq_dir}/ISRUC-group1-{str(n)}/ISRUC-group1-{str(n)}-{str(num_seqs)}.npy'\n        with open(seq_name, 'wb') as f:\n            np.save(f, seq)\n        num_seqs += 1\n\n    if not os.path.isdir(rf'{label_dir}/ISRUC-group1-{str(n)}'):\n        os.makedirs(rf'{label_dir}/ISRUC-group1-{str(n)}')\n    for label in labels_seq:\n        label_name = rf'{label_dir}/ISRUC-group1-{str(n)}/ISRUC-group1-{str(n)}-{str(num_labels)}.npy'\n        with open(label_name, 'wb') as f:\n            np.save(f, label)\n        num_labels += 1\n\n\n\n"
  },
  {
    "id": "preprocessing/ISRUC/__init__.py",
    "text": ""
  },
  {
    "id": "utils/signaltools.py",
    "text": "\"\"\"\nsignaltools.py (Only a few functions) of Scipy's Signal processing package, implimented for PyTorch\nCurrently implimeted: resample\n\n\"\"\"\n\nimport sys\nimport torch\nimport torch.fft\n\n__author__ = \"Soumick Chatterjee\"\n__copyright__ = \"Copyright 2020, Soumick Chatterjee & OvGU:ESF:MEMoRIAL\"\n__credits__ = [\"Soumick Chatterjee\"]\n\n__license__ = \"GPL\"\n__version__ = \"0.0.1\"\n__email__ = \"soumick.chatterjee@ovgu.de\"\n__status__ = \"Only x, num and axis of the resample function have been tested\"\n\n\ndef _isrealobj(x):\n    d = x.dtype\n    if d in (torch.complex32, torch.complex64, torch.complex128):\n        return False\n    else:\n        return True\n\n\ndef resample(x, num, t=None, axis=0, window=None, domain='time'):\n    \"\"\"\n    Resample `x` to `num` samples using Fourier method along the given axis.\n\n    The resampled signal starts at the same value as `x` but is sampled\n    with a spacing of ``len(x) / num * (spacing of x)``.  Because a\n    Fourier method is used, the signal is assumed to be periodic.\n\n    Parameters\n    ----------\n    x : array_like\n        The data to be resampled.\n    num : int or array_like\n        The number of samples in the resampled signal.\n        If array_like is supplied, then the resample function will be\n        called recursively for each element of num.\n    t : array_like, optional\n        If `t` is given, it is assumed to be the equally spaced sample\n        positions associated with the signal data in `x`.\n    axis : (int, optional) or (array_like)\n        The axis of `x` that is resampled.  Default is 0.\n        If num is array_like, then axis has to be supplied and has to be array_like.\n        Each element of axis should have one-on-on mapping wtih num.\n        If num is int but axis is array_like, then num will be repeated and will be\n        made a list with same number of elements as axis. Then will proceed both as array_like.\n    window : array_like, callable, string, float, or tuple, optional\n        Specifies the window applied to the signal in the Fourier\n        domain.  See below for details.\n    domain : string, optional\n        A string indicating the domain of the input `x`:\n        ``time`` Consider the input `x` as time-domain (Default),\n        ``freq`` Consider the input `x` as frequency-domain.\n\n    Returns\n    -------\n    resampled_x or (resampled_x, resampled_t)\n        Either the resampled array, or, if `t` was given, a tuple\n        containing the resampled array and the corresponding resampled\n        positions.\n\n    See Also\n    --------\n    decimate : Downsample the signal after applying an FIR or IIR filter.\n    resample_poly : Resample using polyphase filtering and an FIR filter.\n\n    Notes\n    -----\n    The argument `window` controls a Fourier-domain window that tapers\n    the Fourier spectrum before zero-padding to alleviate ringing in\n    the resampled values for sampled signals you didn't intend to be\n    interpreted as band-limited.\n\n    If `window` is a function, then it is called with a vector of inputs\n    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).\n\n    If `window` is an array of the same length as `x.shape[axis]` it is\n    assumed to be the window to be applied directly in the Fourier\n    domain (with dc and low-frequency first).\n\n    For any other type of `window`, the function `scipy.signal.get_window`\n    is called to generate the window.\n\n    The first sample of the returned vector is the same as the first\n    sample of the input vector.  The spacing between samples is changed\n    from ``dx`` to ``dx * len(x) / num``.\n\n    If `t` is not None, then it is used solely to calculate the resampled\n    positions `resampled_t`\n\n    As noted, `resample` uses FFT transformations, which can be very\n    slow if the number of input or output samples is large and prime;\n    see `scipy.fft.fft`.\n\n    Examples\n    --------\n    Note that the end of the resampled data rises to meet the first\n    sample of the next cycle:\n\n    >>> from scipy import signal\n\n    >>> x = np.linspace(0, 10, 20, endpoint=False)\n    >>> y = np.cos(-x**2/6.0)\n    >>> f = signal.resample(y, 100)\n    >>> xnew = np.linspace(0, 10, 100, endpoint=False)\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, y, 'go-', xnew, f, '.-', 10, y[0], 'ro')\n    >>> plt.legend(['data', 'resampled'], loc='best')\n    >>> plt.show()\n    \"\"\"\n\n    if domain not in ('time', 'freq'):\n        raise ValueError(\"Acceptable domain flags are 'time' or\"\n                         \" 'freq', not domain={}\".format(domain))\n\n    if hasattr(axis, \"__len__\") and not hasattr(num, \"__len__\"):\n        num = [num] * len(axis)\n\n    if hasattr(num, \"__len__\"):\n        if hasattr(axis, \"__len__\") and len(num) == len(axis):\n            _temp = x\n            _t_list = []\n            for i in range(len(num)):\n                _num = num[i]\n                _axis = axis[i]\n                if t is None:\n                    _temp = resample(_temp, _num, t, _axis, window, domain)\n                else:\n                    _temp, _t = resample(_temp, _num, t, _axis, window, domain)\n                    _t_list.append(_t)\n            if t is None:\n                return _temp\n            else:\n                return _temp, torch.stack(_t_list)\n        else:\n            raise ValueError(\"if num is array like, then axis also has to be array like and of the same length\")\n\n    Nx = x.shape[axis]\n\n    # Check if we can use faster real FFT\n    real_input = _isrealobj(x)\n\n    if domain == 'time':\n        # Forward transform\n        if real_input:\n            X = torch.fft.rfft(x, dim=axis)\n        else:  # Full complex FFT\n            X = torch.fft.fft(x, dim=axis)\n    else:  # domain == 'freq'\n        X = x\n\n    # Apply window to spectrum\n    if window is not None:\n        if callable(window):\n            W = window(torch.fft.fftfreq(Nx))\n        elif isinstance(window, torch.Tensor):\n            if window.shape != (Nx,):\n                raise ValueError('window must have the same length as data')\n            W = window\n        else:\n            sys.exit(\n                \"Window can only be either a function or Tensor. Window generation with get_window function of scipy.signal hasn't been implimented yet.\")\n            W = torch.fft.ifftshift(get_window(window, Nx))\n\n        newshape_W = [1] * x.ndim\n        newshape_W[axis] = X.shape[axis]\n        if real_input:\n            # Fold the window back on itself to mimic complex behavior\n            W_real = W.clone()\n            W_real[1:] += W_real[-1:0:-1]\n            W_real[1:] *= 0.5\n            X *= W_real[:newshape_W[axis]].reshape(newshape_W)\n        else:\n            X *= W.reshape(newshape_W)\n\n    # Copy each half of the original spectrum to the output spectrum, either\n    # truncating high frequences (downsampling) or zero-padding them\n    # (upsampling)\n\n    # Placeholder array for output spectrum\n    newshape = list(x.shape)\n    if real_input:\n        newshape[axis] = num // 2 + 1\n    else:\n        newshape[axis] = num\n    Y = torch.zeros(newshape, dtype=X.dtype, device=x.device)\n\n    # Copy positive frequency components (and Nyquist, if present)\n    N = min(num, Nx)\n    nyq = N // 2 + 1  # Slice index that includes Nyquist if present\n    sl = [slice(None)] * x.ndim\n    sl[axis] = slice(0, nyq)\n    Y[tuple(sl)] = X[tuple(sl)]\n    if not real_input:\n        # Copy negative frequency components\n        if N > 2:  # (slice expression doesn't collapse to empty array)\n            sl[axis] = slice(nyq - N, None)\n            Y[tuple(sl)] = X[tuple(sl)]\n\n    # Split/join Nyquist component(s) if present\n    # So far we have set Y[+N/2]=X[+N/2]\n    if N % 2 == 0:\n        if num < Nx:  # downsampling\n            if real_input:\n                sl[axis] = slice(N // 2, N // 2 + 1)\n                Y[tuple(sl)] *= 2.\n            else:\n                # select the component of Y at frequency +N/2,\n                # add the component of X at -N/2\n                sl[axis] = slice(-N // 2, -N // 2 + 1)\n                Y[tuple(sl)] += X[tuple(sl)]\n        elif Nx < num:  # upsampling\n            # select the component at frequency +N/2 and halve it\n            sl[axis] = slice(N // 2, N // 2 + 1)\n            Y[tuple(sl)] *= 0.5\n            if not real_input:\n                temp = Y[tuple(sl)]\n                # set the component at -N/2 equal to the component at +N/2\n                sl[axis] = slice(num - N // 2, num - N // 2 + 1)\n                Y[tuple(sl)] = temp\n\n    # Inverse transform\n    if real_input:\n        y = torch.fft.irfft(Y, num, dim=axis)\n    else:\n        y = torch.fft.ifft(Y, dim=axis, overwrite_x=True)\n\n    y *= (float(num) / float(Nx))\n\n    if t is None:\n        return y\n    else:\n        new_t = torch.arange(0, num) * (t[1] - t[0]) * Nx / float(num) + t[0]\n        return y, new_t"
  },
  {
    "id": "utils/__init__.py",
    "text": ""
  },
  {
    "id": "utils/util.py",
    "text": "import os\nimport random\nimport signal\n\nimport numpy as np\nimport torch\nimport torch.distributed as dist\nfrom tqdm import tqdm\nimport random\n\ndef generate_mask(bz, ch_num, patch_num, mask_ratio, device):\n    mask = torch.zeros((bz, ch_num, patch_num), dtype=torch.long, device=device)\n    mask = mask.bernoulli_(mask_ratio)\n    return mask\n\ndef to_tensor(array):\n    return torch.from_numpy(array).float()\n\n\nif __name__ == '__main__':\n    a = generate_mask(192, 32, 15, mask_ratio=0.5, device=None)\n    print(a)"
  }
]