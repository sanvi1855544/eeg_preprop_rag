<h1>matplotlib.axes.Axes.fill_between</h1> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.axes.Axes.fill_between"> <span class="sig-prename descclassname">Axes.</span><span class="sig-name descname">fill_between</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y1</span></em>, <em class="sig-param"><span class="n">y2</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">interpolate</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">step</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/axes/_axes.py#L5250-L5254"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fill the area between two horizontal curves.</p> <p>The curves are defined by the points (<em>x</em>, <em>y1</em>) and (<em>x</em>, <em>y2</em>). This creates one or multiple polygons describing the filled area.</p> <p>You may exclude some horizontal sections from filling using <em>where</em>.</p> <p>By default, the edges connect the given points directly. Use <em>step</em> if the filling should be a step function, i.e. constant in between <em>x</em>.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>x</strong><span class="classifier">array (length N)</span>
</dt>
<dd>
<p>The x coordinates of the nodes defining the curves.</p> </dd> <dt>
<strong>y1</strong><span class="classifier">array (length N) or scalar</span>
</dt>
<dd>
<p>The y coordinates of the nodes defining the first curve.</p> </dd> <dt>
<strong>y2</strong><span class="classifier">array (length N) or scalar, default: 0</span>
</dt>
<dd>
<p>The y coordinates of the nodes defining the second curve.</p> </dd> <dt>
<strong>where</strong><span class="classifier">array of bool (length N), optional</span>
</dt>
<dd>
<p>Define <em>where</em> to exclude some horizontal regions from being filled. The filled regions are defined by the coordinates <code>x[where]</code>. More precisely, fill between <code>x[i]</code> and <code>x[i+1]</code> if <code>where[i] and where[i+1]</code>. Note that this definition implies that an isolated <em>True</em> value between two <em>False</em> values in <em>where</em> will not result in filling. Both sides of the <em>True</em> position remain unfilled due to the adjacent <em>False</em> values.</p> </dd> <dt>
<strong>interpolate</strong><span class="classifier">bool, default: False</span>
</dt>
<dd>
<p>This option is only relevant if <em>where</em> is used and the two curves are crossing each other.</p> <p>Semantically, <em>where</em> is often used for <em>y1</em> &gt; <em>y2</em> or similar. By default, the nodes of the polygon defining the filled region will only be placed at the positions in the <em>x</em> array. Such a polygon cannot describe the above semantics close to the intersection. The x-sections containing the intersection are simply clipped.</p> <p>Setting <em>interpolate</em> to <em>True</em> will calculate the actual intersection point and extend the filled region up to this point.</p> </dd> <dt>
<strong>step</strong><span class="classifier">{'pre', 'post', 'mid'}, optional</span>
</dt>
<dd>
<p>Define <em>step</em> if the filling should be a step function, i.e. constant in between <em>x</em>. The value determines where the step will occur:</p> <ul class="simple"> <li>'pre': The y value is continued constantly to the left from every <em>x</em> position, i.e. the interval <code>(x[i-1], x[i]]</code> has the value <code>y[i]</code>.</li> <li>'post': The y value is continued constantly to the right from every <em>x</em> position, i.e. the interval <code>[x[i], x[i+1])</code> has the value <code>y[i]</code>.</li> <li>'mid': Steps occur half-way between the <em>x</em> positions.</li> </ul> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt><a class="reference internal" href="../collections_api#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code>PolyCollection</code></a></dt>
<dd>
<p>A <a class="reference internal" href="../collections_api#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code>PolyCollection</code></a> containing the plotted polygons.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>data</strong><span class="classifier">indexable object, optional</span>
</dt>
<dd>
<p>If given, the following parameters also accept a string <code>s</code>, which is interpreted as <code>data[s]</code> (unless this raises an exception):</p> <p><em>x</em>, <em>y1</em>, <em>y2</em>, <em>where</em></p> </dd> <dt><strong>**kwargs</strong></dt>
<dd>
<p>All other keyword arguments are passed on to <a class="reference internal" href="../collections_api#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><code>PolyCollection</code></a>. They control the <a class="reference internal" href="matplotlib.patches.polygon#matplotlib.patches.Polygon" title="matplotlib.patches.Polygon"><code>Polygon</code></a> properties:</p> <table class="property-table table">  <thead> <tr>
<th class="head"><p>Property</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_agg_filter#matplotlib.artist.Artist.set_agg_filter" title="matplotlib.artist.Artist.set_agg_filter"><code>agg_filter</code></a></p></td> <td><p>a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_alpha" title="matplotlib.collections.Collection.set_alpha"><code>alpha</code></a></p></td> <td><p>array-like or scalar or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_animated#matplotlib.artist.Artist.set_animated" title="matplotlib.artist.Artist.set_animated"><code>animated</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_antialiased" title="matplotlib.collections.Collection.set_antialiased"><code>antialiased</code></a> or aa or antialiaseds</p></td> <td><p>bool or list of bools</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api#matplotlib.cm.ScalarMappable.set_array" title="matplotlib.cm.ScalarMappable.set_array"><code>array</code></a></p></td> <td><p>array-like or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_capstyle" title="matplotlib.collections.Collection.set_capstyle"><code>capstyle</code></a></p></td> <td><p><a class="reference internal" href="../_enums_api#matplotlib._enums.CapStyle" title="matplotlib._enums.CapStyle"><code>CapStyle</code></a> or {'butt', 'projecting', 'round'}</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api#matplotlib.cm.ScalarMappable.set_clim" title="matplotlib.cm.ScalarMappable.set_clim"><code>clim</code></a></p></td> <td><p>(vmin: float, vmax: float)</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_clip_box#matplotlib.artist.Artist.set_clip_box" title="matplotlib.artist.Artist.set_clip_box"><code>clip_box</code></a></p></td> <td><p><a class="reference internal" href="../transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_clip_on#matplotlib.artist.Artist.set_clip_on" title="matplotlib.artist.Artist.set_clip_on"><code>clip_on</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_clip_path#matplotlib.artist.Artist.set_clip_path" title="matplotlib.artist.Artist.set_clip_path"><code>clip_path</code></a></p></td> <td><p>Patch or (Path, Transform) or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api#matplotlib.cm.ScalarMappable.set_cmap" title="matplotlib.cm.ScalarMappable.set_cmap"><code>cmap</code></a></p></td> <td><p><a class="reference internal" href="matplotlib.colors.colormap#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code>Colormap</code></a> or str or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_color" title="matplotlib.collections.Collection.set_color"><code>color</code></a></p></td> <td><p>color or list of rgba tuples</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><code>edgecolor</code></a> or ec or edgecolors</p></td> <td><p>color or list of colors or 'face'</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_facecolor" title="matplotlib.collections.Collection.set_facecolor"><code>facecolor</code></a> or facecolors or fc</p></td> <td><p>color or list of colors</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_figure#matplotlib.artist.Artist.set_figure" title="matplotlib.artist.Artist.set_figure"><code>figure</code></a></p></td> <td><p><a class="reference internal" href="../figure_api#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_gid#matplotlib.artist.Artist.set_gid" title="matplotlib.artist.Artist.set_gid"><code>gid</code></a></p></td> <td><p>str</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_hatch" title="matplotlib.collections.Collection.set_hatch"><code>hatch</code></a></p></td> <td><p>{'/', '\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_in_layout#matplotlib.artist.Artist.set_in_layout" title="matplotlib.artist.Artist.set_in_layout"><code>in_layout</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_joinstyle" title="matplotlib.collections.Collection.set_joinstyle"><code>joinstyle</code></a></p></td> <td><p><a class="reference internal" href="../_enums_api#matplotlib._enums.JoinStyle" title="matplotlib._enums.JoinStyle"><code>JoinStyle</code></a> or {'miter', 'round', 'bevel'}</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_label#matplotlib.artist.Artist.set_label" title="matplotlib.artist.Artist.set_label"><code>label</code></a></p></td> <td><p>object</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_linestyle" title="matplotlib.collections.Collection.set_linestyle"><code>linestyle</code></a> or dashes or linestyles or ls</p></td> <td><p>str or tuple or list thereof</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_linewidth" title="matplotlib.collections.Collection.set_linewidth"><code>linewidth</code></a> or linewidths or lw</p></td> <td><p>float or list of floats</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../cm_api#matplotlib.cm.ScalarMappable.set_norm" title="matplotlib.cm.ScalarMappable.set_norm"><code>norm</code></a></p></td> <td><p><a class="reference internal" href="matplotlib.colors.normalize#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code>Normalize</code></a> or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_offset_transform" title="matplotlib.collections.Collection.set_offset_transform"><code>offset_transform</code></a></p></td> <td><p><a class="reference internal" href="../transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_offsets" title="matplotlib.collections.Collection.set_offsets"><code>offsets</code></a></p></td> <td><p>(N, 2) or (2,) array-like</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_path_effects#matplotlib.artist.Artist.set_path_effects" title="matplotlib.artist.Artist.set_path_effects"><code>path_effects</code></a></p></td> <td><p><a class="reference internal" href="../patheffects_api#matplotlib.patheffects.AbstractPathEffect" title="matplotlib.patheffects.AbstractPathEffect"><code>AbstractPathEffect</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.PolyCollection.set_verts" title="matplotlib.collections.PolyCollection.set_verts"><code>paths</code></a></p></td> <td><p>list of array-like</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_picker#matplotlib.artist.Artist.set_picker" title="matplotlib.artist.Artist.set_picker"><code>picker</code></a></p></td> <td><p>None or bool or float or callable</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_pickradius" title="matplotlib.collections.Collection.set_pickradius"><code>pickradius</code></a></p></td> <td><p>float</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_rasterized#matplotlib.artist.Artist.set_rasterized" title="matplotlib.artist.Artist.set_rasterized"><code>rasterized</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><code>sizes</code></p></td> <td><p>ndarray or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_sketch_params#matplotlib.artist.Artist.set_sketch_params" title="matplotlib.artist.Artist.set_sketch_params"><code>sketch_params</code></a></p></td> <td><p>(scale: float, length: float, randomness: float)</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_snap#matplotlib.artist.Artist.set_snap" title="matplotlib.artist.Artist.set_snap"><code>snap</code></a></p></td> <td><p>bool or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_transform#matplotlib.artist.Artist.set_transform" title="matplotlib.artist.Artist.set_transform"><code>transform</code></a></p></td> <td><p><a class="reference internal" href="../transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_url#matplotlib.artist.Artist.set_url" title="matplotlib.artist.Artist.set_url"><code>url</code></a></p></td> <td><p>str</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.Collection.set_urls" title="matplotlib.collections.Collection.set_urls"><code>urls</code></a></p></td> <td><p>list of str or None</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.PolyCollection.set_verts" title="matplotlib.collections.PolyCollection.set_verts"><code>verts</code></a></p></td> <td><p>list of array-like</p></td> </tr> <tr>
<td><p><a class="reference internal" href="../collections_api#matplotlib.collections.PolyCollection.set_verts_and_codes" title="matplotlib.collections.PolyCollection.set_verts_and_codes"><code>verts_and_codes</code></a></p></td> <td><p>unknown</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_visible#matplotlib.artist.Artist.set_visible" title="matplotlib.artist.Artist.set_visible"><code>visible</code></a></p></td> <td><p>bool</p></td> </tr> <tr>
<td><p><a class="reference internal" href="matplotlib.artist.artist.set_zorder#matplotlib.artist.Artist.set_zorder" title="matplotlib.artist.Artist.set_zorder"><code>zorder</code></a></p></td> <td><p>float</p></td> </tr>  </table> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="#matplotlib.axes.Axes.fill_between" title="matplotlib.axes.Axes.fill_between"><code>fill_between</code></a></dt>
<dd>
<p>Fill between two sets of y-values.</p> </dd> <dt><a class="reference internal" href="matplotlib.axes.axes.fill_betweenx#matplotlib.axes.Axes.fill_betweenx" title="matplotlib.axes.Axes.fill_betweenx"><code>fill_betweenx</code></a></dt>
<dd>
<p>Fill between two sets of x-values.</p> </dd> </dl> </div> </dd>
</dl> <section id="examples-using-matplotlib-axes-axes-fill-between"> <h2>Examples using <code>matplotlib.axes.Axes.fill_between</code>
</h2> <div class="sphx-glr-thumbcontainer" tooltip="The ~matplotlib.axes.Axes.fill_between function generates a shaded region between a min and max...">
<figure class="align-default" id="id1"> <img alt="Fill Between and Alpha" src="data:image/png;base64,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"> <figcaption> <p><span class="caption-text"><a class="reference internal" href="https://matplotlib.org/3.5.1/gallery/lines_bars_and_markers/fill_between_alpha.html#sphx-glr-gallery-lines-bars-and-markers-fill-between-alpha-py"><span class="std std-ref">Fill Between and Alpha</span></a></span></p> </figcaption> </figure> </div>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use ~.axes.Axes.fill_between to color the area between two lines.">
<figure class="align-default" id="id2"> <img alt="Filling the area between lines" src="data:image/png;base64,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"> <figcaption> <p><span class="caption-text"><a class="reference internal" href="https://matplotlib.org/3.5.1/gallery/lines_bars_and_markers/fill_between_demo.html#sphx-glr-gallery-lines-bars-and-markers-fill-between-demo-py"><span class="std std-ref">Filling the area between lines</span></a></span></p> </figcaption> </figure> </div>
<div class="sphx-glr-thumbcontainer" tooltip="See ~matplotlib.axes.Axes.fill_between.">
<figure class="align-default" id="id3"> <img alt="fill_between(x, y1, y2)" src="data:image/png;base64,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"> <figcaption> <p><span class="caption-text"><a class="reference internal" href="https://matplotlib.org/3.5.1/plot_types/basic/fill_between.html#sphx-glr-plot-types-basic-fill-between-py"><span class="std std-ref">fill_between(x, y1, y2)</span></a></span></p> </figcaption> </figure> </div>
</section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2021 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.fill_between.html" class="_attribution-link">https://matplotlib.org/3.5.1/api/_as_gen/matplotlib.axes.Axes.fill_between.html</a>
  </p>
</div>
