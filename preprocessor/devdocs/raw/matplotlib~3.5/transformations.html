<h1>matplotlib.transforms</h1> <div class="graphviz"><img src="data:image/png;base64,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" alt="Inheritance diagram of matplotlib.transforms" usemap="#inheritance3f108372d7" class="inheritance graphviz"></div> <map id="inheritance3f108372d7" name="inheritance3f108372d7"> <area shape="rect" id="node1" href="#matplotlib.transforms.Affine2D" target="_top" title="A mutable 2D affine transformation." alt="" coords="524,2,576,18"> <area shape="rect" id="node2" href="#matplotlib.transforms.Affine2DBase" target="_top" title="The base class of all 2D affine transformations." alt="" coords="395,110,472,126"> <area shape="rect" id="node5" href="#matplotlib.transforms.AffineDeltaTransform" target="_top" title="A transform wrapper for transforming displacements between pairs of points." alt="" coords="493,29,607,45"> <area shape="rect" id="node9" href="#matplotlib.transforms.BboxTransform" target="_top" title="`BboxTransform` linearly transforms points from one `Bbox` to another." alt="" coords="508,56,592,72"> <area shape="rect" id="node10" href="#matplotlib.transforms.BboxTransformFrom" target="_top" title="`BboxTransformFrom` linearly transforms points from a given `Bbox` to the" alt="" coords="496,83,604,99"> <area shape="rect" id="node11" href="#matplotlib.transforms.BboxTransformTo" target="_top" title="`BboxTransformTo` is a transformation that linearly transforms points from" alt="" coords="503,110,597,126"> <area shape="rect" id="node13" href="#matplotlib.transforms.BlendedAffine2D" target="_top" title='A "blended" transform uses one transform for the *x*-direction, and' alt="" coords="504,137,597,153"> <area shape="rect" id="node15" href="#matplotlib.transforms.CompositeAffine2D" target="_top" title="A composite transform formed by applying transform *a* then transform *b*." alt="" coords="498,163,603,179"> <area shape="rect" id="node17" href="#matplotlib.transforms.IdentityTransform" target="_top" title="A special class that does one thing, the identity transform, in a" alt="" coords="502,190,598,206"> <area shape="rect" id="node19" href="#matplotlib.transforms.ScaledTranslation" target="_top" title="A transformation that translates by *xt* and *yt*, after *xt* and *yt*" alt="" coords="502,217,598,233"> <area shape="rect" id="node3" href="#matplotlib.transforms.AffineBase" target="_top" title="The base class of all affine transformations of any number of dimensions." alt="" coords="267,110,330,126"> <area shape="rect" id="node4" href="#matplotlib.transforms.Transform" target="_top" title="The base class of all `TransformNode` instances that" alt="" coords="126,163,185,179"> <area shape="rect" id="node14" href="#matplotlib.transforms.BlendedGenericTransform" target="_top" title='A "blended" transform uses one transform for the *x*-direction, and' alt="" coords="229,137,368,153"> <area shape="rect" id="node16" href="#matplotlib.transforms.CompositeGenericTransform" target="_top" title="A composite transform formed by applying transform *a* then" alt="" coords="224,163,373,179"> <area shape="rect" id="node20" href="#matplotlib.transforms.TransformWrapper" target="_top" title="A helper class that holds a single child transform and acts" alt="" coords="248,190,349,206"> <area shape="rect" id="node6" href="#matplotlib.transforms.Bbox" target="_top" title="A mutable bounding box." alt="" coords="281,217,316,233"> <area shape="rect" id="node7" href="#matplotlib.transforms.BboxBase" target="_top" title="The base class of all bounding boxes." alt="" coords="126,244,185,260"> <area shape="rect" id="node18" href="#matplotlib.transforms.LockableBbox" target="_top" title="A `Bbox` where some elements may be locked at certain values." alt="" coords="260,244,338,260"> <area shape="rect" id="node21" href="#matplotlib.transforms.TransformedBbox" target="_top" title="A `Bbox` that is automatically transformed by a given" alt="" coords="250,271,347,287"> <area shape="rect" id="node8" href="#matplotlib.transforms.TransformNode" target="_top" title="The base class for anything that participates in the transform tree" alt="" coords="2,244,87,260"> <area shape="rect" id="node23" href="#matplotlib.transforms.TransformedPath" target="_top" title="A `TransformedPath` caches a non-affine transformed copy of the" alt="" coords="109,284,202,300"> <area shape="rect" id="node12" href="#matplotlib.transforms.BboxTransformToMaxOnly" target="_top" title="`BboxTransformTo` is a transformation that linearly transforms points from" alt="" coords="629,110,766,126"> <area shape="rect" id="node22" href="#matplotlib.transforms.TransformedPatchPath" target="_top" title="A `TransformedPatchPath` caches a non-affine transformed copy of the" alt="" coords="239,298,359,314"> </map><p id="module-matplotlib.transforms">Matplotlib includes a framework for arbitrary geometric transformations that is used determine the final position of all elements drawn on the canvas.</p> <p>Transforms are composed into trees of <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> objects whose actual value depends on their children. When the contents of children change, their parents are automatically invalidated. The next time an invalidated transform is accessed, it is recomputed to reflect those changes. This invalidation/caching approach prevents unnecessary recomputations of transforms, and contributes to better interactive performance.</p> <p>For example, here is a graph of the transform tree used to plot data to the graph:</p> <img alt="../_images/transforms.png" src="data:image/png;base64,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"> <p>The framework can be used for both affine and non-affine transformations. However, for speed, we want use the backend renderers to perform affine transformations whenever possible. Therefore, it is possible to perform just the affine or non-affine part of a transformation on a set of data. The affine is always assumed to occur after the non-affine. For any transform:</p> <pre data-language="python">full transform == non-affine part + affine part
</pre> <p>The backends are not expected to handle non-affine transformations themselves.</p> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">Affine2D</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">matrix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1895-L2110"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A mutable 2D affine transformation.</p> <p>Initialize an Affine transform from a 3x3 numpy float array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>If <em>matrix</em> is None, initialize with the identity transform.</p> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">matrix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1900-L1915"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize an Affine transform from a 3x3 numpy float array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>If <em>matrix</em> is None, initialize with the identity transform.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1919-L1924"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.clear"> <span class="sig-name descname">clear</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1987-L1994"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Reset the underlying matrix to the identity transform.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.from_values"> <em class="property">static</em><span class="sig-name descname">from_values</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">c</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">e</span></em>, <em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1926-L1938"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new Affine2D instance from the given values:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1940-L1953"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the underlying transformation matrix as a 3x3 numpy array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.identity"> <em class="property">static</em><span class="sig-name descname">identity</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1977-L1985"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a new <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a> object that is the identity transform.</p> <p>Unless this transform will be mutated later on, consider using the faster <a class="reference internal" href="#matplotlib.transforms.IdentityTransform" title="matplotlib.transforms.IdentityTransform"><code>IdentityTransform</code></a> class instead.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.rotate"> <span class="sig-name descname">rotate</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">theta</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1996-L2010"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a rotation (in radians) to this transform in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.rotate_around"> <span class="sig-name descname">rotate_around</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">theta</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2022-L2030"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a rotation (in radians) around the point (x, y) in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.rotate_deg"> <span class="sig-name descname">rotate_deg</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">degrees</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2012-L2020"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a rotation (in degrees) to this transform in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.rotate_deg_around"> <span class="sig-name descname">rotate_deg_around</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">degrees</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2032-L2042"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a rotation (in degrees) around the point (x, y) in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.scale"> <span class="sig-name descname">scale</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">sx</span></em>, <em class="sig-param"><span class="n">sy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2057-L2078"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a scale in place.</p> <p>If <em>sy</em> is None, the same scale is applied in both the <em>x</em>- and <em>y</em>-directions.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.set"> <span class="sig-name descname">set</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1968-L1975"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set this transformation from the frozen copy of another <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.set_matrix"> <span class="sig-name descname">set_matrix</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">mtx</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1955-L1966"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the underlying transformation matrix from a 3x3 numpy array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.skew"> <span class="sig-name descname">skew</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">xShear</span></em>, <em class="sig-param"><span class="n">yShear</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2080-L2097"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a skew in place.</p> <p><em>xShear</em> and <em>yShear</em> are the shear angles along the <em>x</em>- and <em>y</em>-axes, respectively, in radians.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.skew_deg"> <span class="sig-name descname">skew_deg</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">xShear</span></em>, <em class="sig-param"><span class="n">yShear</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2099-L2110"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a skew in place.</p> <p><em>xShear</em> and <em>yShear</em> are the shear angles along the <em>x</em>- and <em>y</em>-axes, respectively, in degrees.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2D.translate"> <span class="sig-name descname">translate</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">tx</span></em>, <em class="sig-param"><span class="n">ty</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2044-L2055"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a translation in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">Affine2DBase</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1827-L1892"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.AffineBase" title="matplotlib.transforms.AffineBase"><code>matplotlib.transforms.AffineBase</code></a></p> <p>The base class of all 2D affine transformations.</p> <p>2D affine transformations are performed using a 3x3 numpy array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>This class provides the read-only interface. For a mutable 2D affine transformation, use <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a>.</p> <p>Subclasses of this class will generally only need to override a constructor and <code>get_matrix()</code> that generates a custom 3x3 matrix.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase.frozen"> <span class="sig-name descname">frozen</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1846-L1848"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a frozen copy of this transform node. The frozen copy will not be updated when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase.has_inverse"> <span class="sig-name descname">has_inverse</span><em class="property"><span class="p">=</span>True</em>
</dt> <dd>
<p>True if this transform has a corresponding inverse transform.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase.input_dims"> <span class="sig-name descname">input_dims</span><em class="property"><span class="p">=</span>2</em>
</dt> <dd>
<p>The number of input dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase.inverted"> <span class="sig-name descname">inverted</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1883-L1892"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>It holds <code>x == self.inverted().transform(self.transform(x))</code>.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase.is_separable"> <em class="property">property</em><span class="sig-name descname">is_separable</span>
</dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase.output_dims"> <span class="sig-name descname">output_dims</span><em class="property"><span class="p">=</span>2</em>
</dt> <dd>
<p>The number of output dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase.to_values"> <span class="sig-name descname">to_values</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1855-L1860"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the values of the matrix as an <code>(a, b, c, d, e, f)</code> tuple.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Affine2DBase.transform_affine"> <span class="sig-name descname">transform_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1862-L1867"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code>input_dims</code></a>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code>output_dims</code></a>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">AffineBase</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1777-L1824"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>The base class of all affine transformations of any number of dimensions.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.__array__"> <span class="sig-name descname">__array__</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1787-L1789"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Array interface to get at this Transform's affine matrix.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.__eq__"> <span class="sig-name descname">__eq__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1791-L1794"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return self==value.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.__hash__"> <span class="sig-name descname">__hash__</span><em class="property"><span class="p">=</span>None</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1783-L1785"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.get_affine"> <span class="sig-name descname">get_affine</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1822-L1824"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.is_affine"> <span class="sig-name descname">is_affine</span><em class="property"><span class="p">=</span>True</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1796-L1798"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply this transformation on the given array of <em>values</em>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <code>input_dims</code> or shape (N x <code>input_dims</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <code>input_dims</code> or shape (N x <code>output_dims</code>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.transform_affine"> <span class="sig-name descname">transform_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1800-L1803"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <code>input_dims</code> or shape (N x <code>input_dims</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <code>input_dims</code> or shape (N x <code>output_dims</code>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.transform_non_affine"> <span class="sig-name descname">transform_non_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1805-L1807"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the non-affine part of this transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <code>input_dims</code> or shape (N x <code>input_dims</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <code>input_dims</code> or shape (N x <code>output_dims</code>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.transform_path"> <span class="sig-name descname">transform_path</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1809-L1811"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p>In some cases, this transform may insert curves into the path that began as line segments.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.transform_path_affine"> <span class="sig-name descname">transform_path_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1813-L1816"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the affine part of this transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineBase.transform_path_non_affine"> <span class="sig-name descname">transform_path_non_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1818-L1820"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the non-affine part of this transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineDeltaTransform"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">AffineDeltaTransform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2699-L2726"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A transform wrapper for transforming displacements between pairs of points.</p> <p>This class is intended to be used to transform displacements ("position deltas") between pairs of points (e.g., as the <code>offset_transform</code> of <a class="reference internal" href="collections_api#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><code>Collection</code></a>s): given a transform <code>t</code> such that <code>t =
AffineDeltaTransform(t) + offset</code>, <code>AffineDeltaTransform</code> satisfies <code>AffineDeltaTransform(a - b) == AffineDeltaTransform(a) -
AffineDeltaTransform(b)</code>.</p> <p>This is implemented by forcing the offset components of the transform matrix to zero.</p> <p>This class is experimental as of 3.3, and the API may change.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineDeltaTransform.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2716-L2718"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineDeltaTransform.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineDeltaTransform.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.AffineDeltaTransform.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2722-L2726"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">Bbox</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L686-L1090"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>matplotlib.transforms.BboxBase</code></a></p> <p>A mutable bounding box.</p> <h4 class="rubric">Examples</h4> <p><strong>Create from known bounds</strong></p> <p>The default constructor takes the boundary "points" <code>[[xmin, ymin],
[xmax, ymax]]</code>.</p> <pre data-language="python">&gt;&gt;&gt; Bbox([[1, 1], [3, 7]])
Bbox([[1.0, 1.0], [3.0, 7.0]])
</pre> <p>Alternatively, a Bbox can be created from the flattened points array, the so-called "extents" <code>(xmin, ymin, xmax, ymax)</code></p> <pre data-language="python">&gt;&gt;&gt; Bbox.from_extents(1, 1, 3, 7)
Bbox([[1.0, 1.0], [3.0, 7.0]])
</pre> <p>or from the "bounds" <code>(xmin, ymin, width, height)</code>.</p> <pre data-language="python">&gt;&gt;&gt; Bbox.from_bounds(1, 1, 2, 6)
Bbox([[1.0, 1.0], [3.0, 7.0]])
</pre> <p><strong>Create from collections of points</strong></p> <p>The "empty" object for accumulating Bboxs is the null bbox, which is a stand-in for the empty set.</p> <pre data-language="python">&gt;&gt;&gt; Bbox.null()
Bbox([[inf, inf], [-inf, -inf]])
</pre> <p>Adding points to the null bbox will give you the bbox of those points.</p> <pre data-language="python">&gt;&gt;&gt; box = Bbox.null()
&gt;&gt;&gt; box.update_from_data_xy([[1, 1]])
&gt;&gt;&gt; box
Bbox([[1.0, 1.0], [1.0, 1.0]])
&gt;&gt;&gt; box.update_from_data_xy([[2, 3], [3, 2]], ignore=False)
&gt;&gt;&gt; box
Bbox([[1.0, 1.0], [3.0, 3.0]])
</pre> <p>Setting <code>ignore=True</code> is equivalent to starting over from a null bbox.</p> <pre data-language="python">&gt;&gt;&gt; box.update_from_data_xy([[1, 1]], ignore=True)
&gt;&gt;&gt; box
Bbox([[1.0, 1.0], [1.0, 1.0]])
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>It is recommended to always specify <code>ignore</code> explicitly. If not, the default value of <code>ignore</code> can be changed at any time by code with access to your Bbox, for example using the method <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore</code></a>.</p> </div> <p><strong>Properties of the ``null`` bbox</strong></p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The current behavior of <a class="reference internal" href="#matplotlib.transforms.Bbox.null" title="matplotlib.transforms.Bbox.null"><code>Bbox.null()</code></a> may be surprising as it does not have all of the properties of the "empty set", and as such does not behave like a "zero" object in the mathematical sense. We may change that in the future (with a deprecation period).</p> </div> <p>The null bbox is the identity for intersections</p> <pre data-language="python">&gt;&gt;&gt; Bbox.intersection(Bbox([[1, 1], [3, 7]]), Bbox.null())
Bbox([[1.0, 1.0], [3.0, 7.0]])
</pre> <p>except with itself, where it returns the full space.</p> <pre data-language="python">&gt;&gt;&gt; Bbox.intersection(Bbox.null(), Bbox.null())
Bbox([[-inf, -inf], [inf, inf]])
</pre> <p>A union containing null will always return the full space (not the other set!)</p> <pre data-language="python">&gt;&gt;&gt; Bbox.union([Bbox([[0, 0], [0, 0]]), Bbox.null()])
Bbox([[-inf, -inf], [inf, inf]])
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>points</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>A 2x2 numpy array of the form <code>[[x0, y0], [x1, y1]]</code>.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.__format__"> <span class="sig-name descname">__format__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">fmt</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L844-L847"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Default object formatter.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L767-L785"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>points</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>A 2x2 numpy array of the form <code>[[x0, y0], [x1, y1]]</code>.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.__repr__"> <span class="sig-name descname">__repr__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L852-L853"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return repr(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L849-L850"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.bounds"> <em class="property">property</em><span class="sig-name descname">bounds</span>
</dt> <dd>
<p>Return (<a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code>y0</code></a>, <code>width</code>, <code>height</code>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.from_bounds"> <em class="property">static</em><span class="sig-name descname">from_bounds</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x0</span></em>, <em class="sig-param"><span class="n">y0</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">height</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L813-L820"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> from <em>x0</em>, <em>y0</em>, <em>width</em> and <em>height</em>.</p> <p><em>width</em> and <em>height</em> may be negative.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.from_extents"> <em class="property">static</em><span class="sig-name descname">from_extents</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">minpos</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L822-L842"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new Bbox from <em>left</em>, <em>bottom</em>, <em>right</em> and <em>top</em>.</p> <p>The <em>y</em>-axis increases upwards.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>left, bottom, right, top</strong><span class="classifier">float</span>
</dt>
<dd>
<p>The four extents of the bounding box.</p> </dd> <dt>
<strong>minpos</strong><span class="classifier">float or None</span>
</dt>
<dd>
<p>If this is supplied, the Bbox will have a minimum positive value set. This is useful when dealing with logarithmic scales and other scales where negative bounds result in floating point errors.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.frozen"> <span class="sig-name descname">frozen</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L797-L801"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The base class for anything that participates in the transform tree and needs to invalidate its parents or be invalidated. This includes classes that are not really transforms, such as bounding boxes, since some transforms depend on bounding boxes to compute their values.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.get_points"> <span class="sig-name descname">get_points</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1052-L1058"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the points of the bounding box directly as a numpy array of the form: <code>[[x0, y0], [x1, y1]]</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.ignore"> <span class="sig-name descname">ignore</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L855-L867"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set whether the existing bounds of the box should be ignored by subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code>update_from_data_xy()</code></a>.</p> <dl class="simple"> <dt>value<span class="classifier">bool</span>
</dt>
<dd>
<ul class="simple"> <li>When <code>True</code>, subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code>update_from_data_xy()</code></a> will ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>False</code>, subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code>update_from_data_xy()</code></a> will include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.intervalx"> <em class="property">property</em><span class="sig-name descname">intervalx</span>
</dt> <dd>
<p>The pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be sorted from left to right.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.intervaly"> <em class="property">property</em><span class="sig-name descname">intervaly</span>
</dt> <dd>
<p>The pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be sorted from bottom to top.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.minpos"> <em class="property">property</em><span class="sig-name descname">minpos</span>
</dt> <dd>
<p>The minimum positive value in both directions within the Bbox.</p> <p>This is useful when dealing with logarithmic scales and other scales where negative bounds result in floating point errors, and will be used as the minimum extent instead of <em>p0</em>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.minposx"> <em class="property">property</em><span class="sig-name descname">minposx</span>
</dt> <dd>
<p>The minimum positive value in the <em>x</em>-direction within the Bbox.</p> <p>This is useful when dealing with logarithmic scales and other scales where negative bounds result in floating point errors, and will be used as the minimum <em>x</em>-extent instead of <em>x0</em>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.minposy"> <em class="property">property</em><span class="sig-name descname">minposy</span>
</dt> <dd>
<p>The minimum positive value in the <em>y</em>-direction within the Bbox.</p> <p>This is useful when dealing with logarithmic scales and other scales where negative bounds result in floating point errors, and will be used as the minimum <em>y</em>-extent instead of <em>y0</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.mutated"> <span class="sig-name descname">mutated</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1078-L1080"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the bbox has changed since init.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.mutatedx"> <span class="sig-name descname">mutatedx</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1082-L1085"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the x-limits have changed since init.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.mutatedy"> <span class="sig-name descname">mutatedy</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1087-L1090"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the y-limits have changed since init.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.null"> <em class="property">static</em><span class="sig-name descname">null</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L808-L811"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new null <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> from (inf, inf) to (-inf, -inf).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.p0"> <em class="property">property</em><span class="sig-name descname">p0</span>
</dt> <dd>
<p>The first pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box.</p> <p>This is not guaranteed to be the bottom-left corner (for that, use <code>min</code>).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.p1"> <em class="property">property</em><span class="sig-name descname">p1</span>
</dt> <dd>
<p>The second pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box.</p> <p>This is not guaranteed to be the top-right corner (for that, use <code>max</code>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.set"> <span class="sig-name descname">set</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1070-L1076"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set this bounding box from the "frozen" bounds of another <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.set_points"> <span class="sig-name descname">set_points</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1060-L1068"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the points of the bounding box directly from a numpy array of the form: <code>[[x0, y0], [x1, y1]]</code>. No error checking is performed, as this method is mainly for internal use.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.unit"> <em class="property">static</em><span class="sig-name descname">unit</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L803-L806"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new unit <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> from (0, 0) to (1, 1).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.update_from_data_x"> <span class="sig-name descname">update_from_data_x</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">ignore</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L905-L923"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Update the x-bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> based on the passed in data. After updating, the bounds will have positive <em>width</em>, and <em>x0</em> will be the minimal value.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>Array of x-values.</p> </dd> <dt>
<strong>ignore</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<ul class="simple"> <li>When <code>True</code>, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>False</code>, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>None</code>, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore()</code></a>.</li> </ul> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.update_from_data_xy"> <span class="sig-name descname">update_from_data_xy</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">xy</span></em>, <em class="sig-param"><span class="n">ignore</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">updatex</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">updatey</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L945-L969"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Update the bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> based on the passed in data. After updating, the bounds will have positive <em>width</em> and <em>height</em>; <em>x0</em> and <em>y0</em> will be the minimal values.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>xy</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>A numpy array of 2D points.</p> </dd> <dt>
<strong>ignore</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<ul class="simple"> <li>When <code>True</code>, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>False</code>, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>None</code>, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore()</code></a>.</li> </ul> </dd> <dt>
<strong>updatex, updatey</strong><span class="classifier">bool, default: True</span>
</dt>
<dd>
<p>When <code>True</code>, update the x/y values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.update_from_data_y"> <span class="sig-name descname">update_from_data_y</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">ignore</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L925-L943"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Update the y-bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> based on the passed in data. After updating, the bounds will have positive <em>height</em>, and <em>y0</em> will be the minimal value.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>y</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>Array of y-values.</p> </dd> <dt>
<strong>ignore</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<ul class="simple"> <li>When <code>True</code>, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>False</code>, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>None</code>, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore()</code></a>.</li> </ul> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.update_from_path"> <span class="sig-name descname">update_from_path</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">ignore</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">updatex</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">updatey</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L869-L903"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Update the bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> to contain the vertices of the provided path. After updating, the bounds will have positive <em>width</em> and <em>height</em>; <em>x0</em> and <em>y0</em> will be the minimal values.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>path</strong><span class="classifier"><a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a></span>
</dt>
 <dt>
<strong>ignore</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<ul class="simple"> <li>when <code>True</code>, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when <code>False</code>, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when <code>None</code>, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore()</code></a>.</li> </ul> </dd> <dt>
<strong>updatex, updatey</strong><span class="classifier">bool, default: True</span>
</dt>
<dd>
<p>When <code>True</code>, update the x/y values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.x0"> <em class="property">property</em><span class="sig-name descname">x0</span>
</dt> <dd>
<p>The first of the pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.Bbox.x1" title="matplotlib.transforms.Bbox.x1"><code>x1</code></a> (for that, use <code>xmin</code>).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.x1"> <em class="property">property</em><span class="sig-name descname">x1</span>
</dt> <dd>
<p>The second of the pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code>x0</code></a> (for that, use <code>xmax</code>).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.y0"> <em class="property">property</em><span class="sig-name descname">y0</span>
</dt> <dd>
<p>The first of the pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.Bbox.y1" title="matplotlib.transforms.Bbox.y1"><code>y1</code></a> (for that, use <code>ymin</code>).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Bbox.y1"> <em class="property">property</em><span class="sig-name descname">y1</span>
</dt> <dd>
<p>The second of the pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code>y0</code></a> (for that, use <code>ymax</code>).</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">BboxBase</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">shorthand_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L235-L683"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>matplotlib.transforms.TransformNode</code></a></p> <p>The base class of all bounding boxes.</p> <p>This class is immutable; <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> is a mutable subclass.</p> <p>The canonical representation is as two points, with no restrictions on their ordering. Convenience properties are provided to get the left, bottom, right and top edges and width and height, but these are not stored explicitly.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.__array__"> <span class="sig-name descname">__array__</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L263-L264"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.anchored"> <span class="sig-name descname">anchored</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">c</span></em>, <em class="sig-param"><span class="n">container</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L506-L534"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> anchored to <em>c</em> within <em>container</em>.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>c</strong><span class="classifier">(float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}</span>
</dt>
<dd>
<p>Either an (<em>x</em>, <em>y</em>) pair of relative coordinates (0 is left or bottom, 1 is right or top), 'C' (center), or a cardinal direction ('SW', southwest, is bottom left, etc.).</p> </dd> <dt>
<strong>container</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, optional</span>
</dt>
<dd>
<p>The box within which the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> is positioned; it defaults to the initial <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="_as_gen/matplotlib.axes.axes.set_anchor#matplotlib.axes.Axes.set_anchor" title="matplotlib.axes.Axes.set_anchor"><code>Axes.set_anchor</code></a></dt>
 </dl> </div> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.bounds"> <em class="property">property</em><span class="sig-name descname">bounds</span>
</dt> <dd>
<p>Return (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.width" title="matplotlib.transforms.BboxBase.width"><code>width</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.height" title="matplotlib.transforms.BboxBase.height"><code>height</code></a>).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.coefs"> <span class="sig-name descname">coefs</span><em class="property"><span class="p">=</span>{'C': (0.5, 0.5), 'E': (1.0, 0.5), 'N': (0.5, 1.0), 'NE': (1.0, 1.0), 'NW': (0, 1.0), 'S': (0.5, 0), 'SE': (1.0, 0), 'SW': (0, 0), 'W': (0, 0.5)}</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.contains"> <span class="sig-name descname">contains</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L420-L424"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <code>(x, y)</code> is in the bounding box or on its edge.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.containsx"> <span class="sig-name descname">containsx</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L406-L411"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <em>x</em> is in the closed (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>) interval.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.containsy"> <span class="sig-name descname">containsy</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L413-L418"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <em>y</em> is in the closed (<a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>) interval.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.corners"> <span class="sig-name descname">corners</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L641-L649"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corners of this rectangle as an array of points.</p> <p>Specifically, this returns the array <code>[[x0, y0], [x0, y1], [x1, y0], [x1, y1]]</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.count_contains"> <span class="sig-name descname">count_contains</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L593-L607"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Count the number of vertices contained in the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>. Any vertices with a non-finite x or y value are ignored.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>vertices</strong><span class="classifier">Nx2 Numpy array.</span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.count_overlaps"> <span class="sig-name descname">count_overlaps</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bboxes</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L609-L618"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Count the number of bounding boxes that overlap this one.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>bboxes</strong><span class="classifier">sequence of <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>BboxBase</code></a></span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.expanded"> <span class="sig-name descname">expanded</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">sw</span></em>, <em class="sig-param"><span class="n">sh</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L620-L630"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by expanding this one around its center by the factors <em>sw</em> and <em>sh</em>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.extents"> <em class="property">property</em><span class="sig-name descname">extents</span>
</dt> <dd>
<p>Return (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.frozen"> <span class="sig-name descname">frozen</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L259-L260"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The base class for anything that participates in the transform tree and needs to invalidate its parents or be invalidated. This includes classes that are not really transforms, such as bounding boxes, since some transforms depend on bounding boxes to compute their values.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.fully_contains"> <span class="sig-name descname">fully_contains</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L460-L464"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <code>x, y</code> is in the bounding box, but not on its edge.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.fully_containsx"> <span class="sig-name descname">fully_containsx</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L446-L451"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <em>x</em> is in the open (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>) interval.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.fully_containsy"> <span class="sig-name descname">fully_containsy</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L453-L458"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <em>y</em> is in the open (<a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>) interval.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.fully_overlaps"> <span class="sig-name descname">fully_overlaps</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L466-L485"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether this bounding box overlaps with the other bounding box, not including the edges.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>other</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>BboxBase</code></a></span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.get_points"> <span class="sig-name descname">get_points</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L403-L404"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.height"> <em class="property">property</em><span class="sig-name descname">height</span>
</dt> <dd>
<p>The (signed) height of the bounding box.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.intersection"> <em class="property">static</em><span class="sig-name descname">intersection</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bbox1</span></em>, <em class="sig-param"><span class="n">bbox2</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L673-L683"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the intersection of <em>bbox1</em> and <em>bbox2</em> if they intersect, or None if they don't.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.intervalx"> <em class="property">property</em><span class="sig-name descname">intervalx</span>
</dt> <dd>
<p>The pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be sorted from left to right.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.intervaly"> <em class="property">property</em><span class="sig-name descname">intervaly</span>
</dt> <dd>
<p>The pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be sorted from bottom to top.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.is_affine"> <span class="sig-name descname">is_affine</span><em class="property"><span class="p">=</span>True</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.is_bbox"> <span class="sig-name descname">is_bbox</span><em class="property"><span class="p">=</span>True</em>
</dt> 
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.max"> <em class="property">property</em><span class="sig-name descname">max</span>
</dt> <dd>
<p>The top-right corner of the bounding box.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.min"> <em class="property">property</em><span class="sig-name descname">min</span>
</dt> <dd>
<p>The bottom-left corner of the bounding box.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.overlaps"> <span class="sig-name descname">overlaps</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L426-L444"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether this bounding box overlaps with the other bounding box.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>other</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>BboxBase</code></a></span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.p0"> <em class="property">property</em><span class="sig-name descname">p0</span>
</dt> <dd>
<p>The first pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box.</p> <p>This is not guaranteed to be the bottom-left corner (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.min" title="matplotlib.transforms.BboxBase.min"><code>min</code></a>).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.p1"> <em class="property">property</em><span class="sig-name descname">p1</span>
</dt> <dd>
<p>The second pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box.</p> <p>This is not guaranteed to be the top-right corner (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.max" title="matplotlib.transforms.BboxBase.max"><code>max</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.padded"> <span class="sig-name descname">padded</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L632-L635"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by padding this one on all four sides by <em>p</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.rotated"> <span class="sig-name descname">rotated</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">radians</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L651-L660"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the axes-aligned bounding box that bounds the result of rotating this <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by an angle of <em>radians</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.shrunk"> <span class="sig-name descname">shrunk</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">mx</span></em>, <em class="sig-param"><span class="n">my</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L536-L545"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, shrunk by the factor <em>mx</em> in the <em>x</em> direction and the factor <em>my</em> in the <em>y</em> direction. The lower left corner of the box remains unchanged. Normally <em>mx</em> and <em>my</em> will be less than 1, but this is not enforced.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.shrunk_to_aspect"> <span class="sig-name descname">shrunk_to_aspect</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">box_aspect</span></em>, <em class="sig-param"><span class="n">container</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fig_aspect</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L547-L569"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, shrunk so that it is as large as it can be while having the desired aspect ratio, <em>box_aspect</em>. If the box coordinates are relative (i.e. fractions of a larger box such as a figure) then the physical aspect ratio of that figure is specified with <em>fig_aspect</em>, so that <em>box_aspect</em> can also be given as a ratio of the absolute dimensions, not the relative dimensions.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.size"> <em class="property">property</em><span class="sig-name descname">size</span>
</dt> <dd>
<p>The (signed) width and height of the bounding box.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.splitx"> <span class="sig-name descname">splitx</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L571-L580"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a list of new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> objects formed by splitting the original one with vertical lines at fractional positions given by <em>args</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.splity"> <span class="sig-name descname">splity</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L582-L591"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a list of new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> objects formed by splitting the original one with horizontal lines at fractional positions given by <em>args</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.transformed"> <span class="sig-name descname">transformed</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L487-L494"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by statically transforming this one by <em>transform</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.translated"> <span class="sig-name descname">translated</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">tx</span></em>, <em class="sig-param"><span class="n">ty</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L637-L639"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by translating this one by <em>tx</em> and <em>ty</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.union"> <em class="property">static</em><span class="sig-name descname">union</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bboxes</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L662-L671"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> that contains all of the given <em>bboxes</em>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.width"> <em class="property">property</em><span class="sig-name descname">width</span>
</dt> <dd>
<p>The (signed) width of the bounding box.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.x0"> <em class="property">property</em><span class="sig-name descname">x0</span>
</dt> <dd>
<p>The first of the pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a> (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmin" title="matplotlib.transforms.BboxBase.xmin"><code>xmin</code></a>).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.x1"> <em class="property">property</em><span class="sig-name descname">x1</span>
</dt> <dd>
<p>The second of the pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a> (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmax" title="matplotlib.transforms.BboxBase.xmax"><code>xmax</code></a>).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.xmax"> <em class="property">property</em><span class="sig-name descname">xmax</span>
</dt> <dd>
<p>The right edge of the bounding box.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.xmin"> <em class="property">property</em><span class="sig-name descname">xmin</span>
</dt> <dd>
<p>The left edge of the bounding box.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.y0"> <em class="property">property</em><span class="sig-name descname">y0</span>
</dt> <dd>
<p>The first of the pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a> (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymin" title="matplotlib.transforms.BboxBase.ymin"><code>ymin</code></a>).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.y1"> <em class="property">property</em><span class="sig-name descname">y1</span>
</dt> <dd>
<p>The second of the pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a> (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymax" title="matplotlib.transforms.BboxBase.ymax"><code>ymax</code></a>).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.ymax"> <em class="property">property</em><span class="sig-name descname">ymax</span>
</dt> <dd>
<p>The top edge of the bounding box.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxBase.ymin"> <em class="property">property</em><span class="sig-name descname">ymin</span>
</dt> <dd>
<p>The bottom edge of the bounding box.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransform"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">BboxTransform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">boxin</span></em>, <em class="sig-param"><span class="n">boxout</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2535-L2575"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransform" title="matplotlib.transforms.BboxTransform"><code>BboxTransform</code></a> linearly transforms points from one <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> to another.</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransform" title="matplotlib.transforms.BboxTransform"><code>BboxTransform</code></a> that linearly transforms points from <em>boxin</em> to <em>boxout</em>.</p> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransform.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">boxin</span></em>, <em class="sig-param"><span class="n">boxout</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2542-L2555"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransform" title="matplotlib.transforms.BboxTransform"><code>BboxTransform</code></a> that linearly transforms points from <em>boxin</em> to <em>boxout</em>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransform.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransform.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransform.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2559-L2575"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransform.is_separable"> <span class="sig-name descname">is_separable</span><em class="property"><span class="p">=</span>True</em>
</dt> <dd>
<p>True if this transform is separable in the x- and y- dimensions.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformFrom"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">BboxTransformFrom</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">boxin</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2637-L2670"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransformFrom" title="matplotlib.transforms.BboxTransformFrom"><code>BboxTransformFrom</code></a> linearly transforms points from a given <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> to the unit bounding box.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformFrom.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">boxin</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2644-L2652"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformFrom.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformFrom.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformFrom.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2656-L2670"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformFrom.is_separable"> <span class="sig-name descname">is_separable</span><em class="property"><span class="p">=</span>True</em>
</dt> <dd>
<p>True if this transform is separable in the x- and y- dimensions.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformTo"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">BboxTransformTo</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">boxout</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2578-L2614"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> is a transformation that linearly transforms points from the unit bounding box to a given <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> that linearly transforms points from the unit bounding box to <em>boxout</em>.</p> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformTo.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">boxout</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2586-L2598"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> that linearly transforms points from the unit bounding box to <em>boxout</em>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformTo.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformTo.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformTo.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2602-L2614"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformTo.is_separable"> <span class="sig-name descname">is_separable</span><em class="property"><span class="p">=</span>True</em>
</dt> <dd>
<p>True if this transform is separable in the x- and y- dimensions.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformToMaxOnly"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">BboxTransformToMaxOnly</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">boxout</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2617-L2634"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>matplotlib.transforms.BboxTransformTo</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> is a transformation that linearly transforms points from the unit bounding box to a given <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> with a fixed upper left of (0, 0).</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> that linearly transforms points from the unit bounding box to <em>boxout</em>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformToMaxOnly.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BboxTransformToMaxOnly.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2622-L2634"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedAffine2D"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">BlendedAffine2D</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_transform</span></em>, <em class="sig-param"><span class="n">y_transform</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2274-L2324"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.transforms._BlendedMixin</code>, <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A "blended" transform uses one transform for the <em>x</em>-direction, and another transform for the <em>y</em>-direction.</p> <p>This version is an optimization for the case where both child transforms are of type <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a>.</p> <p>Create a new "blended" transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>Both <em>x_transform</em> and <em>y_transform</em> must be 2D affine transforms.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code>blended_transform_factory</code></a> function instead, which can determine automatically which kind of blended transform to create.</p> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedAffine2D.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_transform</span></em>, <em class="sig-param"><span class="n">y_transform</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2285-L2309"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new "blended" transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>Both <em>x_transform</em> and <em>y_transform</em> must be 2D affine transforms.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code>blended_transform_factory</code></a> function instead, which can determine automatically which kind of blended transform to create.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedAffine2D.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedAffine2D.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2311-L2324"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedAffine2D.is_separable"> <span class="sig-name descname">is_separable</span><em class="property"><span class="p">=</span>True</em>
</dt> <dd>
<p>True if this transform is separable in the x- and y- dimensions.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">BlendedGenericTransform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_transform</span></em>, <em class="sig-param"><span class="n">y_transform</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2181-L2271"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.transforms._BlendedMixin</code>, <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>A "blended" transform uses one transform for the <em>x</em>-direction, and another transform for the <em>y</em>-direction.</p> <p>This "generic" version can handle any given child transform in the <em>x</em>- and <em>y</em>-directions.</p> <p>Create a new "blended" transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code>blended_transform_factory</code></a> function instead, which can determine automatically which kind of blended transform to create.</p> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_transform</span></em>, <em class="sig-param"><span class="n">y_transform</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2194-L2207"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new "blended" transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code>blended_transform_factory</code></a> function instead, which can determine automatically which kind of blended transform to create.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.contains_branch"> <span class="sig-name descname">contains_branch</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2213-L2216"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the given transform is a sub-tree of this transform.</p> <p>This routine uses transform equality to identify sub-trees, therefore in many situations it is object id which will be used.</p> <p>For the case where the given transform represents the whole of this transform, returns True.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.depth"> <em class="property">property</em><span class="sig-name descname">depth</span>
</dt> <dd>
<p>Return the number of transforms which have been chained together to form this Transform instance.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For the special case of a Composite transform, the maximum depth of the two is returned.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.frozen"> <span class="sig-name descname">frozen</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2222-L2224"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a frozen copy of this transform node. The frozen copy will not be updated when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.get_affine"> <span class="sig-name descname">get_affine</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2258-L2271"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.has_inverse"> <em class="property">property</em><span class="sig-name descname">has_inverse</span>
</dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.input_dims"> <span class="sig-name descname">input_dims</span><em class="property"><span class="p">=</span>2</em>
</dt> <dd>
<p>The number of input dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.inverted"> <span class="sig-name descname">inverted</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2254-L2256"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>It holds <code>x == self.inverted().transform(self.transform(x))</code>.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.is_affine"> <em class="property">property</em><span class="sig-name descname">is_affine</span>
</dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.is_separable"> <span class="sig-name descname">is_separable</span><em class="property"><span class="p">=</span>True</em>
</dt> <dd>
<p>True if this transform is separable in the x- and y- dimensions.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.output_dims"> <span class="sig-name descname">output_dims</span><em class="property"><span class="p">=</span>2</em>
</dt> <dd>
<p>The number of output dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.pass_through"> <span class="sig-name descname">pass_through</span><em class="property"><span class="p">=</span>True</em>
</dt> <dd>
<p>If pass_through is True, all ancestors will always be invalidated, even if 'self' is already invalid.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.BlendedGenericTransform.transform_non_affine"> <span class="sig-name descname">transform_non_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2226-L2252"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the non-affine part of this transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="matplotlib.transforms.BlendedGenericTransform.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="matplotlib.transforms.BlendedGenericTransform.input_dims"><code>input_dims</code></a>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="matplotlib.transforms.BlendedGenericTransform.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.output_dims" title="matplotlib.transforms.BlendedGenericTransform.output_dims"><code>output_dims</code></a>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeAffine2D"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">CompositeAffine2D</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2455-L2505"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A composite transform formed by applying transform <em>a</em> then transform <em>b</em>.</p> <p>This version is an optimization that handles the case where both <em>a</em> and <em>b</em> are 2D affines.</p> <p>Create a new composite transform that is the result of applying <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> <em>a</em> then <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> <em>b</em>.</p> <p>You will generally not call this constructor directly but write <code>a +
b</code> instead, which will automatically choose the best kind of composite transform instance to create.</p> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeAffine2D.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2462-L2483"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new composite transform that is the result of applying <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> <em>a</em> then <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> <em>b</em>.</p> <p>You will generally not call this constructor directly but write <code>a +
b</code> instead, which will automatically choose the best kind of composite transform instance to create.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeAffine2D.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeAffine2D.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeAffine2D.depth"> <em class="property">property</em><span class="sig-name descname">depth</span>
</dt> <dd>
<p>Return the number of transforms which have been chained together to form this Transform instance.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For the special case of a Composite transform, the maximum depth of the two is returned.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeAffine2D.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2497-L2505"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">CompositeGenericTransform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2341-L2452"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>A composite transform formed by applying transform <em>a</em> then transform <em>b</em>.</p> <p>This "generic" version can handle any two arbitrary transformations.</p> <p>Create a new composite transform that is the result of applying transform <em>a</em> then transform <em>b</em>.</p> <p>You will generally not call this constructor directly but write <code>a +
b</code> instead, which will automatically choose the best kind of composite transform instance to create.</p> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.__eq__"> <span class="sig-name descname">__eq__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2395-L2400"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return self==value.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.__hash__"> <span class="sig-name descname">__hash__</span><em class="property"><span class="p">=</span>None</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2351-L2369"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new composite transform that is the result of applying transform <em>a</em> then transform <em>b</em>.</p> <p>You will generally not call this constructor directly but write <code>a +
b</code> instead, which will automatically choose the best kind of composite transform instance to create.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.depth"> <em class="property">property</em><span class="sig-name descname">depth</span>
</dt> <dd>
<p>Return the number of transforms which have been chained together to form this Transform instance.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For the special case of a Composite transform, the maximum depth of the two is returned.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.frozen"> <span class="sig-name descname">frozen</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2371-L2378"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a frozen copy of this transform node. The frozen copy will not be updated when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.get_affine"> <span class="sig-name descname">get_affine</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2441-L2447"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.has_inverse"> <em class="property">property</em><span class="sig-name descname">has_inverse</span>
</dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.inverted"> <span class="sig-name descname">inverted</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2449-L2452"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>It holds <code>x == self.inverted().transform(self.transform(x))</code>.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.is_affine"> <em class="property">property</em><span class="sig-name descname">is_affine</span>
</dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.is_separable"> <em class="property">property</em><span class="sig-name descname">is_separable</span>
</dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.pass_through"> <span class="sig-name descname">pass_through</span><em class="property"><span class="p">=</span>True</em>
</dt> <dd>
<p>If pass_through is True, all ancestors will always be invalidated, even if 'self' is already invalid.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.transform_affine"> <span class="sig-name descname">transform_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2417-L2419"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <code>input_dims</code> or shape (N x <code>input_dims</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <code>input_dims</code> or shape (N x <code>output_dims</code>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.transform_non_affine"> <span class="sig-name descname">transform_non_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2421-L2429"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the non-affine part of this transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <code>input_dims</code> or shape (N x <code>input_dims</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <code>input_dims</code> or shape (N x <code>output_dims</code>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine"> <span class="sig-name descname">transform_path_non_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2431-L2439"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the non-affine part of this transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">IdentityTransform</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2113-L2160"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A special class that does one thing, the identity transform, in a fast way.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.frozen"> <span class="sig-name descname">frozen</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2120-L2122"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a frozen copy of this transform node. The frozen copy will not be updated when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.get_affine"> <span class="sig-name descname">get_affine</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2154-L2156"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2126-L2128"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.inverted"> <span class="sig-name descname">inverted</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2158-L2160"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>It holds <code>x == self.inverted().transform(self.transform(x))</code>.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2130-L2132"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply this transformation on the given array of <em>values</em>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <code>input_dims</code> or shape (N x <code>input_dims</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <code>input_dims</code> or shape (N x <code>output_dims</code>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.transform_affine"> <span class="sig-name descname">transform_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2134-L2136"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <code>input_dims</code> or shape (N x <code>input_dims</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <code>input_dims</code> or shape (N x <code>output_dims</code>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.transform_non_affine"> <span class="sig-name descname">transform_non_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2138-L2140"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the non-affine part of this transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <code>input_dims</code> or shape (N x <code>input_dims</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <code>input_dims</code> or shape (N x <code>output_dims</code>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.transform_path"> <span class="sig-name descname">transform_path</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2142-L2144"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p>In some cases, this transform may insert curves into the path that began as line segments.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.transform_path_affine"> <span class="sig-name descname">transform_path_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2146-L2148"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the affine part of this transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.IdentityTransform.transform_path_non_affine"> <span class="sig-name descname">transform_path_non_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2150-L2152"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the non-affine part of this transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.LockableBbox"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">LockableBbox</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bbox</span></em>, <em class="sig-param"><span class="n">x0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1161-L1281"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>matplotlib.transforms.BboxBase</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> where some elements may be locked at certain values.</p> <p>When the child bounding box changes, the bounds of this bbox will update accordingly with the exception of the locked elements.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>bbox</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a></span>
</dt>
<dd>
<p>The child bounding box to wrap.</p> </dd> <dt>
<strong>x0</strong><span class="classifier">float or None</span>
</dt>
<dd>
<p>The locked value for x0, or None to leave unlocked.</p> </dd> <dt>
<strong>y0</strong><span class="classifier">float or None</span>
</dt>
<dd>
<p>The locked value for y0, or None to leave unlocked.</p> </dd> <dt>
<strong>x1</strong><span class="classifier">float or None</span>
</dt>
<dd>
<p>The locked value for x1, or None to leave unlocked.</p> </dd> <dt>
<strong>y1</strong><span class="classifier">float or None</span>
</dt>
<dd>
<p>The locked value for y1, or None to leave unlocked.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.LockableBbox.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bbox</span></em>, <em class="sig-param"><span class="n">x0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1168-L1197"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>bbox</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a></span>
</dt>
<dd>
<p>The child bounding box to wrap.</p> </dd> <dt>
<strong>x0</strong><span class="classifier">float or None</span>
</dt>
<dd>
<p>The locked value for x0, or None to leave unlocked.</p> </dd> <dt>
<strong>y0</strong><span class="classifier">float or None</span>
</dt>
<dd>
<p>The locked value for y0, or None to leave unlocked.</p> </dd> <dt>
<strong>x1</strong><span class="classifier">float or None</span>
</dt>
<dd>
<p>The locked value for x1, or None to leave unlocked.</p> </dd> <dt>
<strong>y1</strong><span class="classifier">float or None</span>
</dt>
<dd>
<p>The locked value for y1, or None to leave unlocked.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.LockableBbox.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.LockableBbox.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.LockableBbox.get_points"> <span class="sig-name descname">get_points</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1201-L1209"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.LockableBbox.locked_x0"> <em class="property">property</em><span class="sig-name descname">locked_x0</span>
</dt> <dd>
<p>float or None: The value used for the locked x0.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.LockableBbox.locked_x1"> <em class="property">property</em><span class="sig-name descname">locked_x1</span>
</dt> <dd>
<p>float or None: The value used for the locked x1.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.LockableBbox.locked_y0"> <em class="property">property</em><span class="sig-name descname">locked_y0</span>
</dt> <dd>
<p>float or None: The value used for the locked y0.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.LockableBbox.locked_y1"> <em class="property">property</em><span class="sig-name descname">locked_y1</span>
</dt> <dd>
<p>float or None: The value used for the locked y1.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.ScaledTranslation"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">ScaledTranslation</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">xt</span></em>, <em class="sig-param"><span class="n">yt</span></em>, <em class="sig-param"><span class="n">scale_trans</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2673-L2696"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A transformation that translates by <em>xt</em> and <em>yt</em>, after <em>xt</em> and <em>yt</em> have been transformed by <em>scale_trans</em>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.ScaledTranslation.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">xt</span></em>, <em class="sig-param"><span class="n">yt</span></em>, <em class="sig-param"><span class="n">scale_trans</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2678-L2684"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.ScaledTranslation.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.ScaledTranslation.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.ScaledTranslation.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2688-L2696"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">Transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">shorthand_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1284-L1691"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>matplotlib.transforms.TransformNode</code></a></p> <p>The base class of all <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> instances that actually perform a transformation.</p> <p>All non-affine transformations should be subclasses of this class. New affine transformations should be subclasses of <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a>.</p> <p>Subclasses of this class should override the following members (at minimum):</p> <ul class="simple"> <li><a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.transform" title="matplotlib.transforms.Transform.transform"><code>transform()</code></a></li> <li>
<a class="reference internal" href="#matplotlib.transforms.Transform.inverted" title="matplotlib.transforms.Transform.inverted"><code>inverted()</code></a> (if an inverse exists)</li> </ul> <p>The following attributes may be overridden if the default is unsuitable:</p> <ul class="simple"> <li>
<a class="reference internal" href="#matplotlib.transforms.Transform.is_separable" title="matplotlib.transforms.Transform.is_separable"><code>is_separable</code></a> (defaults to True for 1D -&gt; 1D transforms, False otherwise)</li> <li>
<a class="reference internal" href="#matplotlib.transforms.Transform.has_inverse" title="matplotlib.transforms.Transform.has_inverse"><code>has_inverse</code></a> (defaults to True if <a class="reference internal" href="#matplotlib.transforms.Transform.inverted" title="matplotlib.transforms.Transform.inverted"><code>inverted()</code></a> is overridden, False otherwise)</li> </ul> <p>If the transform needs to do something non-standard with <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>matplotlib.path.Path</code></a> objects, such as adding curves where there were once line segments, it should override:</p> <ul class="simple"> <li><a class="reference internal" href="#matplotlib.transforms.Transform.transform_path" title="matplotlib.transforms.Transform.transform_path"><code>transform_path()</code></a></li> </ul> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.__add__"> <span class="sig-name descname">__add__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1348-L1357"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compose two transforms together so that <em>self</em> is followed by <em>other</em>.</p> <p><code>A + B</code> returns a transform <code>C</code> so that <code>C.transform(x) == B.transform(A.transform(x))</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.__array__"> <span class="sig-name descname">__array__</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1476-L1478"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Array interface to get at this Transform's affine matrix.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.__init_subclass__"> <em class="property">classmethod</em><span class="sig-name descname">__init_subclass__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1332-L1346"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This method is called when a class is subclassed.</p> <p>The default implementation does nothing. It may be overridden to extend subclasses.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.__sub__"> <span class="sig-name descname">__sub__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1426-L1474"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compose <em>self</em> with the inverse of <em>other</em>, cancelling identical terms if any:</p> <pre data-language="python"># In general:
A - B == A + B.inverted()
# (but see note regarding frozen transforms below).

# If A "ends with" B (i.e. A == A' + B for some A') we can cancel
# out B:
(A' + B) - B == A'

# Likewise, if B "starts with" A (B = A + B'), we can cancel out A:
A - (A + B') == B'.inverted() == B'^-1
</pre> <p>Cancellation (rather than naively returning <code>A + B.inverted()</code>) is important for multiple reasons:</p> <ul class="simple"> <li>It avoids floating-point inaccuracies when computing the inverse of B: <code>B - B</code> is guaranteed to cancel out exactly (resulting in the identity transform), whereas <code>B + B.inverted()</code> may differ by a small epsilon.</li> <li>
<code>B.inverted()</code> always returns a frozen transform: if one computes <code>A + B + B.inverted()</code> and later mutates <code>B</code>, then <code>B.inverted()</code> won't be updated and the last two terms won't cancel out anymore; on the other hand, <code>A + B - B</code> will always be equal to <code>A</code> even if <code>B</code> is mutated.</li> </ul> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.contains_branch"> <span class="sig-name descname">contains_branch</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1389-L1406"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the given transform is a sub-tree of this transform.</p> <p>This routine uses transform equality to identify sub-trees, therefore in many situations it is object id which will be used.</p> <p>For the case where the given transform represents the whole of this transform, returns True.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.contains_branch_seperately"> <span class="sig-name descname">contains_branch_seperately</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other_transform</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1408-L1424"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the given branch is a sub-tree of this transform on each separate dimension.</p> <p>A common use for this method is to identify if a transform is a blended transform containing an axes' data transform. e.g.:</p> <pre data-language="python">x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)
</pre> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.depth"> <em class="property">property</em><span class="sig-name descname">depth</span>
</dt> <dd>
<p>Return the number of transforms which have been chained together to form this Transform instance.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For the special case of a Composite transform, the maximum depth of the two is returned.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.get_affine"> <span class="sig-name descname">get_affine</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1577-L1579"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.get_matrix"> <span class="sig-name descname">get_matrix</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1581-L1583"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the matrix for the affine part of this transform.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.has_inverse"> <span class="sig-name descname">has_inverse</span><em class="property"><span class="p">=</span>False</em>
</dt> <dd>
<p>True if this transform has a corresponding inverse transform.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.input_dims"> <span class="sig-name descname">input_dims</span><em class="property"><span class="p">=</span>None</em>
</dt> <dd>
<p>The number of input dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.inverted"> <span class="sig-name descname">inverted</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1681-L1691"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>It holds <code>x == self.inverted().transform(self.transform(x))</code>.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.is_separable"> <span class="sig-name descname">is_separable</span><em class="property"><span class="p">=</span>False</em>
</dt> <dd>
<p>True if this transform is separable in the x- and y- dimensions.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.output_dims"> <span class="sig-name descname">output_dims</span><em class="property"><span class="p">=</span>None</em>
</dt> <dd>
<p>The number of output dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.transform"> <span class="sig-name descname">transform</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1480-L1515"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply this transformation on the given array of <em>values</em>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.transform_affine"> <span class="sig-name descname">transform_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1517-L1541"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.transform_angles"> <span class="sig-name descname">transform_angles</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">angles</span></em>, <em class="sig-param"><span class="n">pts</span></em>, <em class="sig-param"><span class="n">radians</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">pushoff</span><span class="o">=</span><span class="default_value">1e-05</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1631-L1679"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform a set of angles anchored at specific locations.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>angles</strong><span class="classifier">(N,) array-like</span>
</dt>
<dd>
<p>The angles to transform.</p> </dd> <dt>
<strong>pts</strong><span class="classifier">(N, 2) array-like</span>
</dt>
<dd>
<p>The points where the angles are anchored.</p> </dd> <dt>
<strong>radians</strong><span class="classifier">bool, default: False</span>
</dt>
<dd>
<p>Whether <em>angles</em> are radians or degrees.</p> </dd> <dt>
<strong>pushoff</strong><span class="classifier">float</span>
</dt>
<dd>
<p>For each point in <em>pts</em> and angle in <em>angles</em>, the transformed angle is computed by transforming a segment of length <em>pushoff</em> starting at that point and making that angle relative to the horizontal axis, and measuring the angle between the horizontal axis and the transformed segment.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>(N,) array</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.transform_bbox"> <span class="sig-name descname">transform_bbox</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bbox</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1568-L1575"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform the given bounding box.</p> <p>For smarter transforms including caching (a common requirement in Matplotlib), see <a class="reference internal" href="#matplotlib.transforms.TransformedBbox" title="matplotlib.transforms.TransformedBbox"><code>TransformedBbox</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.transform_non_affine"> <span class="sig-name descname">transform_non_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1543-L1566"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply only the non-affine part of this transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>values</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The input values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array</dt>
<dd>
<p>The output values as NumPy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> or shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>), depending on the input.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.transform_path"> <span class="sig-name descname">transform_path</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1601-L1608"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p>In some cases, this transform may insert curves into the path that began as line segments.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.transform_path_affine"> <span class="sig-name descname">transform_path_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1610-L1618"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the affine part of this transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.transform_path_non_affine"> <span class="sig-name descname">transform_path_non_affine</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1620-L1629"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the non-affine part of this transform to <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> <em>path</em>, returning a new <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.Transform.transform_point"> <span class="sig-name descname">transform_point</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">point</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1585-L1599"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a transformed point.</p> <p>This function is only kept for backcompatibility; the more general <a class="reference internal" href="#matplotlib.transforms.Transform.transform" title="matplotlib.transforms.Transform.transform"><code>transform</code></a> method is capable of transforming both a list of points and a single point.</p> <p>The point is given as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>. The transformed point is returned as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">TransformNode</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">shorthand_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L81-L232"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)"><code>object</code></a></p> <p>The base class for anything that participates in the transform tree and needs to invalidate its parents or be invalidated. This includes classes that are not really transforms, such as bounding boxes, since some transforms depend on bounding boxes to compute their values.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.INVALID"> <span class="sig-name descname">INVALID</span><em class="property"><span class="p">=</span>3</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.INVALID_AFFINE"> <span class="sig-name descname">INVALID_AFFINE</span><em class="property"><span class="p">=</span>2</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.INVALID_NON_AFFINE"> <span class="sig-name descname">INVALID_NON_AFFINE</span><em class="property"><span class="p">=</span>1</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.__copy__"> <span class="sig-name descname">__copy__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L142-L152"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.__deepcopy__"> <span class="sig-name descname">__deepcopy__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">memo</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L154-L168"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.__dict__"> <span class="sig-name descname">__dict__</span><em class="property"><span class="p">=</span>mappingproxy({'__module__': 'matplotlib.transforms', '__doc__': '\n The base class for anything that participates in the transform tree\n and needs to invalidate its parents or be invalidated. This includes\n classes that are not really transforms, such as bounding boxes, since some\n transforms depend on bounding boxes to compute their values.\n ', 'INVALID_NON_AFFINE': 1, 'INVALID_AFFINE': 2, 'INVALID': 3, 'is_affine': False, 'is_bbox': False, 'pass_through': False, '__init__': &lt;function TransformNode.__init__&gt;, '__getstate__': &lt;function TransformNode.__getstate__&gt;, '__setstate__': &lt;function TransformNode.__setstate__&gt;, '__copy__': &lt;function TransformNode.__copy__&gt;, '__deepcopy__': &lt;function TransformNode.__deepcopy__&gt;, 'invalidate': &lt;function TransformNode.invalidate&gt;, '_invalidate_internal': &lt;function TransformNode._invalidate_internal&gt;, 'set_children': &lt;function TransformNode.set_children&gt;, 'frozen': &lt;function TransformNode.frozen&gt;, '__dict__': &lt;attribute '__dict__' of 'TransformNode' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'TransformNode' objects&gt;, '__annotations__': {}})</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.__getstate__"> <span class="sig-name descname">__getstate__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L128-L131"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">shorthand_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L107-L121"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>shorthand_name</strong><span class="classifier">str</span>
</dt>
<dd>
<p>A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.__setstate__"> <span class="sig-name descname">__setstate__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">data_dict</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L133-L140"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.__weakref__"> <span class="sig-name descname">__weakref__</span>
</dt> <dd>
<p>list of weak references to the object (if defined)</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.frozen"> <span class="sig-name descname">frozen</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L225-L232"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a frozen copy of this transform node. The frozen copy will not be updated when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.invalidate"> <span class="sig-name descname">invalidate</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L170-L178"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Invalidate this <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> and triggers an invalidation of its ancestors. Should be called any time the transform changes.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.is_affine"> <span class="sig-name descname">is_affine</span><em class="property"><span class="p">=</span>False</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.is_bbox"> <span class="sig-name descname">is_bbox</span><em class="property"><span class="p">=</span>False</em>
</dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.pass_through"> <span class="sig-name descname">pass_through</span><em class="property"><span class="p">=</span>False</em>
</dt> <dd>
<p>If pass_through is True, all ancestors will always be invalidated, even if 'self' is already invalid.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformNode.set_children"> <span class="sig-name descname">set_children</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">children</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L207-L223"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the children of the transform, to let the invalidation system know which transforms can invalidate this transform. Should be called from the constructor of any transforms that depend on other transforms.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">TransformWrapper</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">child</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1694-L1774"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>A helper class that holds a single child transform and acts equivalently to it.</p> <p>This is useful if a node of the transform tree must be replaced at run time with a transform of a different type. This class allows that replacement to correctly trigger invalidation.</p> <p><a class="reference internal" href="#matplotlib.transforms.TransformWrapper" title="matplotlib.transforms.TransformWrapper"><code>TransformWrapper</code></a> instances must have the same input and output dimensions during their entire lifetime, so the child transform may only be replaced with another child transform of the same dimensions.</p> <p><em>child</em>: A <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance. This child may later be replaced with <a class="reference internal" href="#matplotlib.transforms.TransformWrapper.set" title="matplotlib.transforms.TransformWrapper.set"><code>set()</code></a>.</p> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.__eq__"> <span class="sig-name descname">__eq__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1726-L1727"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return self==value.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.__hash__"> <span class="sig-name descname">__hash__</span><em class="property"><span class="p">=</span>None</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">child</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1710-L1717"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><em>child</em>: A <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance. This child may later be replaced with <a class="reference internal" href="#matplotlib.transforms.TransformWrapper.set" title="matplotlib.transforms.TransformWrapper.set"><code>set()</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.frozen"> <span class="sig-name descname">frozen</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1731-L1733"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a frozen copy of this transform node. The frozen copy will not be updated when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.has_inverse"> <em class="property">property</em><span class="sig-name descname">has_inverse</span>
</dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.is_affine"> <em class="property">property</em><span class="sig-name descname">is_affine</span>
</dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.is_separable"> <em class="property">property</em><span class="sig-name descname">is_separable</span>
</dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.pass_through"> <span class="sig-name descname">pass_through</span><em class="property"><span class="p">=</span>True</em>
</dt> <dd>
<p>If pass_through is True, all ancestors will always be invalidated, even if 'self' is already invalid.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformWrapper.set"> <span class="sig-name descname">set</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">child</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1752-L1770"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Replace the current child of this transform with another one.</p> <p>The new child must have the same number of input and output dimensions as the current child.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedBbox"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">TransformedBbox</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bbox</span></em>, <em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1093-L1158"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>matplotlib.transforms.BboxBase</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> that is automatically transformed by a given transform. When either the child bounding box or transform changes, the bounds of this bbox will update accordingly.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>bbox</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a></span>
</dt>
 <dt>
<strong>transform</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></span>
</dt>
 </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedBbox.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">bbox</span></em>, <em class="sig-param"><span class="n">transform</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1100-L1118"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>bbox</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a></span>
</dt>
 <dt>
<strong>transform</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedBbox.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedBbox.__str__"> <span class="sig-name descname">__str__</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L72-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return str(self).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedBbox.get_points"> <span class="sig-name descname">get_points</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L1122-L1150"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPatchPath"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">TransformedPatchPath</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">patch</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2800-L2836"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>matplotlib.transforms.TransformedPath</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.TransformedPatchPath" title="matplotlib.transforms.TransformedPatchPath"><code>TransformedPatchPath</code></a> caches a non-affine transformed copy of the <a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a>. This cached copy is automatically updated when the non-affine part of the transform or the patch changes.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>patch</strong><span class="classifier"><a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a></span>
</dt>
 </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPatchPath.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">patch</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2806-L2820"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>patch</strong><span class="classifier"><a class="reference internal" href="_as_gen/matplotlib.patches.patch#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a></span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPatchPath.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPath"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">TransformedPath</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">transform</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2729-L2797"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>matplotlib.transforms.TransformNode</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>TransformedPath</code></a> caches a non-affine transformed copy of the <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>. This cached copy is automatically updated when the non-affine part of the transform changes.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Paths are considered immutable by this class. Any update to the path's vertices/codes will not trigger a transform recomputation.</p> </div> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>path</strong><span class="classifier"><a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a></span>
</dt>
 <dt>
<strong>transform</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></span>
</dt>
 </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPath.__init__"> <span class="sig-name descname">__init__</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">transform</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2741-L2754"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>path</strong><span class="classifier"><a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a></span>
</dt>
 <dt>
<strong>transform</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a></span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPath.__module__"> <span class="sig-name descname">__module__</span><em class="property"><span class="p">=</span>'matplotlib.transforms'</em>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPath.get_affine"> <span class="sig-name descname">get_affine</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2796-L2797"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPath.get_fully_transformed_path"> <span class="sig-name descname">get_fully_transformed_path</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2789-L2794"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a fully-transformed copy of the child path.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPath.get_transformed_path_and_affine"> <span class="sig-name descname">get_transformed_path_and_affine</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2780-L2787"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the child path, with the non-affine part of the transform already applied, along with the affine part of the path necessary to complete the transformation.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.transforms.TransformedPath.get_transformed_points_and_affine"> <span class="sig-name descname">get_transformed_points_and_affine</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2769-L2778"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the child path, with the non-affine part of the transform already applied, along with the affine part of the path necessary to complete the transformation. Unlike <a class="reference internal" href="#matplotlib.transforms.TransformedPath.get_transformed_path_and_affine" title="matplotlib.transforms.TransformedPath.get_transformed_path_and_affine"><code>get_transformed_path_and_affine()</code></a>, no interpolation will be performed.</p> </dd>
</dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.transforms.blended_transform_factory"> <span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">blended_transform_factory</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_transform</span></em>, <em class="sig-param"><span class="n">y_transform</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2327-L2338"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new "blended" transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>A faster version of the blended transform is returned for the case where both child transforms are affine.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.transforms.composite_transform_factory"> <span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">composite_transform_factory</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2508-L2532"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new composite transform that is the result of applying transform a then transform b.</p> <p>Shortcut versions of the blended transform are provided for the case where both child transforms are affine, or one or the other is the identity transform.</p> <p>Composite transforms may also be created using the '+' operator, e.g.:</p> <pre data-language="python">c = a + b
</pre> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.transforms.interval_contains"> <span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">interval_contains</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">interval</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2897-L2916"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Check, inclusively, whether an interval includes a given value.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>interval</strong><span class="classifier">(float, float)</span>
</dt>
<dd>
<p>The endpoints of the interval.</p> </dd> <dt>
<strong>val</strong><span class="classifier">float</span>
</dt>
<dd>
<p>Value to check is within interval.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>bool</dt>
<dd>
<p>Whether <em>val</em> is within the <em>interval</em>.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.transforms.interval_contains_open"> <span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">interval_contains_open</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">interval</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2948-L2965"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Check, excluding endpoints, whether an interval includes a given value.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>interval</strong><span class="classifier">(float, float)</span>
</dt>
<dd>
<p>The endpoints of the interval.</p> </dd> <dt>
<strong>val</strong><span class="classifier">float</span>
</dt>
<dd>
<p>Value to check is within interval.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>bool</dt>
<dd>
<p>Whether <em>val</em> is within the <em>interval</em>.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.transforms.nonsingular"> <span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">nonsingular</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">vmin</span></em>, <em class="sig-param"><span class="n">vmax</span></em>, <em class="sig-param"><span class="n">expander</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">tiny</span><span class="o">=</span><span class="default_value">1e-15</span></em>, <em class="sig-param"><span class="n">increasing</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2839-L2894"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Modify the endpoints of a range as needed to avoid singularities.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>vmin, vmax</strong><span class="classifier">float</span>
</dt>
<dd>
<p>The initial endpoints.</p> </dd> <dt>
<strong>expander</strong><span class="classifier">float, default: 0.001</span>
</dt>
<dd>
<p>Fractional amount by which <em>vmin</em> and <em>vmax</em> are expanded if the original interval is too small, based on <em>tiny</em>.</p> </dd> <dt>
<strong>tiny</strong><span class="classifier">float, default: 1e-15</span>
</dt>
<dd>
<p>Threshold for the ratio of the interval to the maximum absolute value of its endpoints. If the interval is smaller than this, it will be expanded. This value should be around 1e-15 or larger; otherwise the interval will be approaching the double precision resolution limit.</p> </dd> <dt>
<strong>increasing</strong><span class="classifier">bool, default: True</span>
</dt>
<dd>
<p>If True, swap <em>vmin</em>, <em>vmax</em> if <em>vmin</em> &gt; <em>vmax</em>.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>vmin, vmax</strong><span class="classifier">float</span>
</dt>
<dd>
<p>Endpoints, expanded and/or swapped if necessary. If either input is inf or NaN, or if both inputs are 0 or very close to zero, it returns -<em>expander</em>, <em>expander</em>.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="matplotlib.transforms.offset_copy"> <span class="sig-prename descclassname">matplotlib.transforms.</span><span class="sig-name descname">offset_copy</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">trans</span></em>, <em class="sig-param"><span class="n">fig</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">units</span><span class="o">=</span><span class="default_value">'inches'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/transforms.py#L2968-L2999"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a new transform with an added offset.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>trans</strong><span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> subclass</span>
</dt>
<dd>
<p>Any transform, to which offset will be applied.</p> </dd> <dt>
<strong>fig</strong><span class="classifier"><a class="reference internal" href="figure_api#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a>, default: None</span>
</dt>
<dd>
<p>Current figure. It can be None if <em>units</em> are 'dots'.</p> </dd> <dt>
<strong>x, y</strong><span class="classifier">float, default: 0.0</span>
</dt>
<dd>
<p>The offset to apply.</p> </dd> <dt>
<strong>units</strong><span class="classifier">{'inches', 'points', 'dots'}, default: 'inches'</span>
</dt>
<dd>
<p>Units of the offset.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> subclass</dt>
<dd>
<p>Transform with applied offset.</p> </dd> </dl> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2021 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.5.1/api/transformations.html" class="_attribution-link">https://matplotlib.org/3.5.1/api/transformations.html</a>
  </p>
</div>
