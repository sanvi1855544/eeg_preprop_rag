[{"name": "_sdl2.touch", "path": "ref/touch", "type": "pygame._sdl2.touch", "text": " pygame._sdl2.touch\n  \n pygame module to work with touch input   New in pygame 2: This module requires SDL2.    pygame._sdl2.touch.get_num_devices() \n get the number of touch devices get_num_devices() -> int  Return the number of available touch devices. \n   pygame._sdl2.touch.get_device() \n get the a touch device id for a given index get_device(index) -> touchid      \nParameters:\n\nindex (int) -- This number is at least 0 and less than the number of devices.    Return an integer id associated with the given index. \n   pygame._sdl2.touch.get_num_fingers() \n the number of active fingers for a given touch device get_num_fingers(touchid) -> int  Return the number of fingers active for the touch device whose id is touchid. \n   pygame._sdl2.touch.get_finger() \n get information about an active finger get_finger(touchid, index) -> int      \nParameters:\n\n \ntouchid (int) -- The touch device id. \nindex (int) -- The index of the finger to return information about, between 0 and the number of active fingers.      Return a dict for the finger index active on touchid. The dict contains these keys: id         the id of the finger (an integer).\nx          the normalized x position of the finger, between 0 and 1.\ny          the normalized y position of the finger, between 0 and 1.\npressure   the amount of pressure applied by the finger, between 0 and 1. \n \n \n"}, {"name": "_sdl2.touch.get_device", "path": "ref/touch#pygame._sdl2.touch.get_device", "type": "pygame._sdl2.touch", "text": "  pygame._sdl2.touch.get_device() \n get the a touch device id for a given index get_device(index) -> touchid      \nParameters:\n\nindex (int) -- This number is at least 0 and less than the number of devices.    Return an integer id associated with the given index. \n"}, {"name": "_sdl2.touch.get_finger", "path": "ref/touch#pygame._sdl2.touch.get_finger", "type": "pygame._sdl2.touch", "text": "  pygame._sdl2.touch.get_finger() \n get information about an active finger get_finger(touchid, index) -> int      \nParameters:\n\n \ntouchid (int) -- The touch device id. \nindex (int) -- The index of the finger to return information about, between 0 and the number of active fingers.      Return a dict for the finger index active on touchid. The dict contains these keys: id         the id of the finger (an integer).\nx          the normalized x position of the finger, between 0 and 1.\ny          the normalized y position of the finger, between 0 and 1.\npressure   the amount of pressure applied by the finger, between 0 and 1. \n"}, {"name": "_sdl2.touch.get_num_devices", "path": "ref/touch#pygame._sdl2.touch.get_num_devices", "type": "pygame._sdl2.touch", "text": "  pygame._sdl2.touch.get_num_devices() \n get the number of touch devices get_num_devices() -> int  Return the number of available touch devices. \n"}, {"name": "_sdl2.touch.get_num_fingers", "path": "ref/touch#pygame._sdl2.touch.get_num_fingers", "type": "pygame._sdl2.touch", "text": "  pygame._sdl2.touch.get_num_fingers() \n the number of active fingers for a given touch device get_num_fingers(touchid) -> int  Return the number of fingers active for the touch device whose id is touchid. \n"}, {"name": "BufferProxy", "path": "ref/bufferproxy", "type": "pygame.BufferProxy", "text": " pygame.BufferProxy\n  \n pygame object to export a surface buffer through an array protocol BufferProxy(<parent>) -> BufferProxy  BufferProxy is a pygame support type, designed as the return value of the Surface.get_buffer() and Surface.get_view() methods. For all Python versions a BufferProxy object exports a C struct and Python level array interface on behalf of its parent object's buffer. For CPython 2.6 and later a new buffer interface is also exported. In pygame, BufferProxy is key to implementing the pygame.surfarray module. BufferProxy instances can be created directly from Python code, either for a parent that exports an interface, or from a Python dict describing an object's buffer layout. The dict entries are based on the Python level array interface mapping. The following keys are recognized:  \n \"shape\" : tuple The length of each array dimension as a tuple of integers. The length of the tuple is the number of dimensions in the array. \"typestr\" : string The array element type as a length 3 string. The first character gives byteorder, '<' for little-endian, '>' for big-endian, and '|' for not applicable. The second character is the element type, 'i' for signed integer, 'u' for unsigned integer, 'f' for floating point, and 'V' for an chunk of bytes. The third character gives the bytesize of the element, from '1' to '9' bytes. So, for example, \"<u4\" is an unsigned 4 byte little-endian integer, such as a 32 bit pixel on a PC, while \"|V3\" would represent a 24 bit pixel, which has no integer equivalent. \"data\" : tuple The physical buffer start address and a read-only flag as a length 2 tuple. The address is an integer value, while the read-only flag is a bool\u2014False for writable, True for read-only. \"strides\" : tuple : (optional) Array stride information as a tuple of integers. It is required only of non C-contiguous arrays. The tuple length must match that of \"shape\". \"parent\" : object : (optional) The exporting object. It can be used to keep the parent object alive while its buffer is visible. \"before\" : callable : (optional) Callback invoked when the BufferProxy instance exports the buffer. The callback is given one argument, the \"parent\" object if given, otherwise None. The callback is useful for setting a lock on the parent. \"after\" : callable : (optional) Callback invoked when an exported buffer is released. The callback is passed on argument, the \"parent\" object if given, otherwise None. The callback is useful for releasing a lock on the parent.  \n The BufferProxy class supports subclassing, instance variables, and weak references.  New in pygame 1.8.0.   Extended in pygame 1.9.2.    parent \n Return wrapped exporting object. parent -> Surface parent -> <parent>  The Surface which returned the BufferProxy object or the object passed to a BufferProxy call. \n   length \n The size, in bytes, of the exported buffer. length -> int  The number of valid bytes of data exported. For discontinuous data, that is data which is not a single block of memory, the bytes within the gaps are excluded from the count. This property is equivalent to the Py_buffer C struct len field. \n   raw \n A copy of the exported buffer as a single block of bytes. raw -> bytes  The buffer data as a str/bytes object. Any gaps in the exported data are removed. \n   write() \n Write raw bytes to object buffer. write(buffer, offset=0)  Overwrite bytes in the parent object's data. The data must be C or F contiguous, otherwise a ValueError is raised. Argument buffer is a str/bytes object. An optional offset gives a start position, in bytes, within the buffer where overwriting begins. If the offset is negative or greater that or equal to the buffer proxy's length value, an IndexException is raised. If len(buffer) > proxy.length + offset, a ValueError is raised. \n \n \n"}, {"name": "BufferProxy.length", "path": "ref/bufferproxy#pygame.BufferProxy.length", "type": "pygame.BufferProxy", "text": "  length \n The size, in bytes, of the exported buffer. length -> int  The number of valid bytes of data exported. For discontinuous data, that is data which is not a single block of memory, the bytes within the gaps are excluded from the count. This property is equivalent to the Py_buffer C struct len field. \n"}, {"name": "BufferProxy.parent", "path": "ref/bufferproxy#pygame.BufferProxy.parent", "type": "pygame.BufferProxy", "text": "  parent \n Return wrapped exporting object. parent -> Surface parent -> <parent>  The Surface which returned the BufferProxy object or the object passed to a BufferProxy call. \n"}, {"name": "BufferProxy.raw", "path": "ref/bufferproxy#pygame.BufferProxy.raw", "type": "pygame.BufferProxy", "text": "  raw \n A copy of the exported buffer as a single block of bytes. raw -> bytes  The buffer data as a str/bytes object. Any gaps in the exported data are removed. \n"}, {"name": "BufferProxy.write", "path": "ref/bufferproxy#pygame.BufferProxy.write", "type": "pygame.BufferProxy", "text": "  write() \n Write raw bytes to object buffer. write(buffer, offset=0)  Overwrite bytes in the parent object's data. The data must be C or F contiguous, otherwise a ValueError is raised. Argument buffer is a str/bytes object. An optional offset gives a start position, in bytes, within the buffer where overwriting begins. If the offset is negative or greater that or equal to the buffer proxy's length value, an IndexException is raised. If len(buffer) > proxy.length + offset, a ValueError is raised. \n"}, {"name": "camera", "path": "ref/camera", "type": "pygame.camera", "text": " pygame.camera\n  \n pygame module for camera use  Pygame currently supports only Linux and v4l2 cameras. EXPERIMENTAL!: This API may change or disappear in later pygame releases. If you use this, your code will very likely break with the next pygame release. The Bayer to RGB function is based on: Sonix SN9C101 based webcam basic I/F routines\nCopyright (C) 2004 Takafumi Mizuno <taka-qce@ls-a.jp>\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\nOR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\nOUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE. New in pygame 1.9.0.   pygame.camera.colorspace() \n Surface colorspace conversion colorspace(Surface, format, DestSurface = None) -> Surface  Allows for conversion from \"RGB\" to a destination colorspace of \"HSV\" or \"YUV\". The source and destination surfaces must be the same size and pixel depth. This is useful for computer vision on devices with limited processing power. Capture as small of an image as possible, transform.scale() it even smaller, and then convert the colorspace to YUV or HSV before doing any processing on it. \n   pygame.camera.list_cameras() \n returns a list of available cameras list_cameras() -> [cameras]  Checks the computer for available cameras and returns a list of strings of camera names, ready to be fed into pygame.camera.Camera. \n   pygame.camera.Camera \n load a camera Camera(device, (width, height), format) -> Camera  Loads a v4l2 camera. The device is typically something like \"/dev/video0\". Default width and height are 640 by 480. Format is the desired colorspace of the output. This is useful for computer vision purposes. The default is RGB. The following are supported:  \n \nRGB - Red, Green, Blue \nYUV - Luma, Blue Chrominance, Red Chrominance \nHSV - Hue, Saturation, Value  \n   start() \n opens, initializes, and starts capturing start() -> None  Opens the camera device, attempts to initialize it, and begins recording images to a buffer. The camera must be started before any of the below functions can be used. \n   stop() \n stops, uninitializes, and closes the camera stop() -> None  Stops recording, uninitializes the camera, and closes it. Once a camera is stopped, the below functions cannot be used until it is started again. \n   get_controls() \n gets current values of user controls get_controls() -> (hflip = bool, vflip = bool, brightness)  If the camera supports it, get_controls will return the current settings for horizontal and vertical image flip as bools and brightness as an int. If unsupported, it will return the default values of (0, 0, 0). Note that the return values here may be different than those returned by set_controls, though these are more likely to be correct. \n   set_controls() \n changes camera settings if supported by the camera set_controls(hflip = bool, vflip = bool, brightness) -> (hflip = bool, vflip = bool, brightness)  Allows you to change camera settings if the camera supports it. The return values will be the input values if the camera claims it succeeded or the values previously in use if not. Each argument is optional, and the desired one can be chosen by supplying the keyword, like hflip. Note that the actual settings being used by the camera may not be the same as those returned by set_controls. \n   get_size() \n returns the dimensions of the images being recorded get_size() -> (width, height)  Returns the current dimensions of the images being captured by the camera. This will return the actual size, which may be different than the one specified during initialization if the camera did not support that size. \n   query_image() \n checks if a frame is ready query_image() -> bool  If an image is ready to get, it returns true. Otherwise it returns false. Note that some webcams will always return False and will only queue a frame when called with a blocking function like get_image(). This is useful to separate the framerate of the game from that of the camera without having to use threading. \n   get_image() \n captures an image as a Surface get_image(Surface = None) -> Surface  Pulls an image off of the buffer as an RGB Surface. It can optionally reuse an existing Surface to save time. The bit-depth of the surface is either 24 bits or the same as the optionally supplied Surface. \n   get_raw() \n returns an unmodified image as a string get_raw() -> string  Gets an image from a camera as a string in the native pixelformat of the camera. Useful for integration with other libraries. \n \n \n \n"}, {"name": "camera.Camera", "path": "ref/camera#pygame.camera.Camera", "type": "pygame.camera", "text": "  pygame.camera.Camera \n load a camera Camera(device, (width, height), format) -> Camera  Loads a v4l2 camera. The device is typically something like \"/dev/video0\". Default width and height are 640 by 480. Format is the desired colorspace of the output. This is useful for computer vision purposes. The default is RGB. The following are supported:  \n \nRGB - Red, Green, Blue \nYUV - Luma, Blue Chrominance, Red Chrominance \nHSV - Hue, Saturation, Value  \n   start() \n opens, initializes, and starts capturing start() -> None  Opens the camera device, attempts to initialize it, and begins recording images to a buffer. The camera must be started before any of the below functions can be used. \n   stop() \n stops, uninitializes, and closes the camera stop() -> None  Stops recording, uninitializes the camera, and closes it. Once a camera is stopped, the below functions cannot be used until it is started again. \n   get_controls() \n gets current values of user controls get_controls() -> (hflip = bool, vflip = bool, brightness)  If the camera supports it, get_controls will return the current settings for horizontal and vertical image flip as bools and brightness as an int. If unsupported, it will return the default values of (0, 0, 0). Note that the return values here may be different than those returned by set_controls, though these are more likely to be correct. \n   set_controls() \n changes camera settings if supported by the camera set_controls(hflip = bool, vflip = bool, brightness) -> (hflip = bool, vflip = bool, brightness)  Allows you to change camera settings if the camera supports it. The return values will be the input values if the camera claims it succeeded or the values previously in use if not. Each argument is optional, and the desired one can be chosen by supplying the keyword, like hflip. Note that the actual settings being used by the camera may not be the same as those returned by set_controls. \n   get_size() \n returns the dimensions of the images being recorded get_size() -> (width, height)  Returns the current dimensions of the images being captured by the camera. This will return the actual size, which may be different than the one specified during initialization if the camera did not support that size. \n   query_image() \n checks if a frame is ready query_image() -> bool  If an image is ready to get, it returns true. Otherwise it returns false. Note that some webcams will always return False and will only queue a frame when called with a blocking function like get_image(). This is useful to separate the framerate of the game from that of the camera without having to use threading. \n   get_image() \n captures an image as a Surface get_image(Surface = None) -> Surface  Pulls an image off of the buffer as an RGB Surface. It can optionally reuse an existing Surface to save time. The bit-depth of the surface is either 24 bits or the same as the optionally supplied Surface. \n   get_raw() \n returns an unmodified image as a string get_raw() -> string  Gets an image from a camera as a string in the native pixelformat of the camera. Useful for integration with other libraries. \n \n"}, {"name": "camera.Camera.get_controls", "path": "ref/camera#pygame.camera.Camera.get_controls", "type": "pygame.camera", "text": "  get_controls() \n gets current values of user controls get_controls() -> (hflip = bool, vflip = bool, brightness)  If the camera supports it, get_controls will return the current settings for horizontal and vertical image flip as bools and brightness as an int. If unsupported, it will return the default values of (0, 0, 0). Note that the return values here may be different than those returned by set_controls, though these are more likely to be correct. \n"}, {"name": "camera.Camera.get_image", "path": "ref/camera#pygame.camera.Camera.get_image", "type": "pygame.camera", "text": "  get_image() \n captures an image as a Surface get_image(Surface = None) -> Surface  Pulls an image off of the buffer as an RGB Surface. It can optionally reuse an existing Surface to save time. The bit-depth of the surface is either 24 bits or the same as the optionally supplied Surface. \n"}, {"name": "camera.Camera.get_raw", "path": "ref/camera#pygame.camera.Camera.get_raw", "type": "pygame.camera", "text": "  get_raw() \n returns an unmodified image as a string get_raw() -> string  Gets an image from a camera as a string in the native pixelformat of the camera. Useful for integration with other libraries. \n"}, {"name": "camera.Camera.get_size", "path": "ref/camera#pygame.camera.Camera.get_size", "type": "pygame.camera", "text": "  get_size() \n returns the dimensions of the images being recorded get_size() -> (width, height)  Returns the current dimensions of the images being captured by the camera. This will return the actual size, which may be different than the one specified during initialization if the camera did not support that size. \n"}, {"name": "camera.Camera.query_image", "path": "ref/camera#pygame.camera.Camera.query_image", "type": "pygame.camera", "text": "  query_image() \n checks if a frame is ready query_image() -> bool  If an image is ready to get, it returns true. Otherwise it returns false. Note that some webcams will always return False and will only queue a frame when called with a blocking function like get_image(). This is useful to separate the framerate of the game from that of the camera without having to use threading. \n"}, {"name": "camera.Camera.set_controls", "path": "ref/camera#pygame.camera.Camera.set_controls", "type": "pygame.camera", "text": "  set_controls() \n changes camera settings if supported by the camera set_controls(hflip = bool, vflip = bool, brightness) -> (hflip = bool, vflip = bool, brightness)  Allows you to change camera settings if the camera supports it. The return values will be the input values if the camera claims it succeeded or the values previously in use if not. Each argument is optional, and the desired one can be chosen by supplying the keyword, like hflip. Note that the actual settings being used by the camera may not be the same as those returned by set_controls. \n"}, {"name": "camera.Camera.start", "path": "ref/camera#pygame.camera.Camera.start", "type": "pygame.camera", "text": "  start() \n opens, initializes, and starts capturing start() -> None  Opens the camera device, attempts to initialize it, and begins recording images to a buffer. The camera must be started before any of the below functions can be used. \n"}, {"name": "camera.Camera.stop", "path": "ref/camera#pygame.camera.Camera.stop", "type": "pygame.camera", "text": "  stop() \n stops, uninitializes, and closes the camera stop() -> None  Stops recording, uninitializes the camera, and closes it. Once a camera is stopped, the below functions cannot be used until it is started again. \n"}, {"name": "camera.colorspace", "path": "ref/camera#pygame.camera.colorspace", "type": "pygame.camera", "text": "  pygame.camera.colorspace() \n Surface colorspace conversion colorspace(Surface, format, DestSurface = None) -> Surface  Allows for conversion from \"RGB\" to a destination colorspace of \"HSV\" or \"YUV\". The source and destination surfaces must be the same size and pixel depth. This is useful for computer vision on devices with limited processing power. Capture as small of an image as possible, transform.scale() it even smaller, and then convert the colorspace to YUV or HSV before doing any processing on it. \n"}, {"name": "camera.list_cameras", "path": "ref/camera#pygame.camera.list_cameras", "type": "pygame.camera", "text": "  pygame.camera.list_cameras() \n returns a list of available cameras list_cameras() -> [cameras]  Checks the computer for available cameras and returns a list of strings of camera names, ready to be fed into pygame.camera.Camera. \n"}, {"name": "cdrom", "path": "ref/cdrom", "type": "pygame.cdrom", "text": " pygame.cdrom\n  \n pygame module for audio cdrom control  The cdrom module manages the CD and DVD drives on a computer. It can also control the playback of audio CDs. This module needs to be initialized before it can do anything. Each CD object you create represents a cdrom drive and must also be initialized individually before it can do most things.   pygame.cdrom.init() \n initialize the cdrom module init() -> None  Initialize the cdrom module. This will scan the system for all CD devices. The module must be initialized before any other functions will work. This automatically happens when you call pygame.init(). It is safe to call this function more than once. \n   pygame.cdrom.quit() \n uninitialize the cdrom module quit() -> None  Uninitialize the cdrom module. After you call this any existing CD objects will no longer work. It is safe to call this function more than once. \n   pygame.cdrom.get_init() \n true if the cdrom module is initialized get_init() -> bool  Test if the cdrom module is initialized or not. This is different than the CD.init() since each drive must also be initialized individually. \n   pygame.cdrom.get_count() \n number of cd drives on the system get_count() -> count  Return the number of cd drives on the system. When you create CD objects you need to pass an integer id that must be lower than this count. The count will be 0 if there are no drives on the system. \n   pygame.cdrom.CD \n class to manage a cdrom drive CD(id) -> CD  You can create a CD object for each cdrom on the system. Use pygame.cdrom.get_count() to determine how many drives actually exist. The id argument is an integer of the drive, starting at zero. The CD object is not initialized, you can only call CD.get_id() and CD.get_name() on an uninitialized drive. It is safe to create multiple CD objects for the same drive, they will all cooperate normally.   init() \n initialize a cdrom drive for use init() -> None  Initialize the cdrom drive for use. The drive must be initialized for most CD methods to work. Even if the rest of pygame has been initialized. There may be a brief pause while the drive is initialized. Avoid CD.init() if the program should not stop for a second or two. \n   quit() \n uninitialize a cdrom drive for use quit() -> None  Uninitialize a drive for use. Call this when your program will not be accessing the drive for awhile. \n   get_init() \n true if this cd device initialized get_init() -> bool  Test if this CDROM device is initialized. This is different than the pygame.cdrom.init() since each drive must also be initialized individually. \n   play() \n start playing audio play(track, start=None, end=None) -> None  Playback audio from an audio cdrom in the drive. Besides the track number argument, you can also pass a starting and ending time for playback. The start and end time are in seconds, and can limit the section of an audio track played. If you pass a start time but no end, the audio will play to the end of the track. If you pass a start time and 'None' for the end time, the audio will play to the end of the entire disc. See the CD.get_numtracks() and CD.get_track_audio() to find tracks to playback. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   stop() \n stop audio playback stop() -> None  Stops playback of audio from the cdrom. This will also lose the current playback position. This method does nothing if the drive isn't already playing audio. \n   pause() \n temporarily stop audio playback pause() -> None  Temporarily stop audio playback on the CD. The playback can be resumed at the same point with the CD.resume() method. If the CD is not playing this method does nothing. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   resume() \n unpause audio playback resume() -> None  Unpause a paused CD. If the CD is not paused or already playing, this method does nothing. \n   eject() \n eject or open the cdrom drive eject() -> None  This will open the cdrom drive and eject the cdrom. If the drive is playing or paused it will be stopped. \n   get_id() \n the index of the cdrom drive get_id() -> id  Returns the integer id that was used to create the CD instance. This method can work on an uninitialized CD. \n   get_name() \n the system name of the cdrom drive get_name() -> name  Return the string name of the drive. This is the system name used to represent the drive. It is often the drive letter or device name. This method can work on an uninitialized CD. \n   get_busy() \n true if the drive is playing audio get_busy() -> bool  Returns True if the drive busy playing back audio. \n   get_paused() \n true if the drive is paused get_paused() -> bool  Returns True if the drive is currently paused. \n   get_current() \n the current audio playback position get_current() -> track, seconds  Returns both the current track and time of that track. This method works when the drive is either playing or paused. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   get_empty() \n False if a cdrom is in the drive get_empty() -> bool  Return False if there is a cdrom currently in the drive. If the drive is empty this will return True. \n   get_numtracks() \n the number of tracks on the cdrom get_numtracks() -> count  Return the number of tracks on the cdrom in the drive. This will return zero of the drive is empty or has no tracks. \n   get_track_audio() \n true if the cdrom track has audio data get_track_audio(track) -> bool  Determine if a track on a cdrom contains audio data. You can also call CD.num_tracks() and CD.get_all() to determine more information about the cdrom. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   get_all() \n get all track information get_all() -> [(audio, start, end, length), ...]  Return a list with information for every track on the cdrom. The information consists of a tuple with four values. The audio value is True if the track contains audio data. The start, end, and length values are floating point numbers in seconds. Start and end represent absolute times on the entire disc. \n   get_track_start() \n start time of a cdrom track get_track_start(track) -> seconds  Return the absolute time in seconds where at start of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   get_track_length() \n length of a cdrom track get_track_length(track) -> seconds  Return a floating point value in seconds of the length of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero. \n \n \n \n"}, {"name": "cdrom.CD", "path": "ref/cdrom#pygame.cdrom.CD", "type": "pygame.cdrom", "text": "  pygame.cdrom.CD \n class to manage a cdrom drive CD(id) -> CD  You can create a CD object for each cdrom on the system. Use pygame.cdrom.get_count() to determine how many drives actually exist. The id argument is an integer of the drive, starting at zero. The CD object is not initialized, you can only call CD.get_id() and CD.get_name() on an uninitialized drive. It is safe to create multiple CD objects for the same drive, they will all cooperate normally.   init() \n initialize a cdrom drive for use init() -> None  Initialize the cdrom drive for use. The drive must be initialized for most CD methods to work. Even if the rest of pygame has been initialized. There may be a brief pause while the drive is initialized. Avoid CD.init() if the program should not stop for a second or two. \n   quit() \n uninitialize a cdrom drive for use quit() -> None  Uninitialize a drive for use. Call this when your program will not be accessing the drive for awhile. \n   get_init() \n true if this cd device initialized get_init() -> bool  Test if this CDROM device is initialized. This is different than the pygame.cdrom.init() since each drive must also be initialized individually. \n   play() \n start playing audio play(track, start=None, end=None) -> None  Playback audio from an audio cdrom in the drive. Besides the track number argument, you can also pass a starting and ending time for playback. The start and end time are in seconds, and can limit the section of an audio track played. If you pass a start time but no end, the audio will play to the end of the track. If you pass a start time and 'None' for the end time, the audio will play to the end of the entire disc. See the CD.get_numtracks() and CD.get_track_audio() to find tracks to playback. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   stop() \n stop audio playback stop() -> None  Stops playback of audio from the cdrom. This will also lose the current playback position. This method does nothing if the drive isn't already playing audio. \n   pause() \n temporarily stop audio playback pause() -> None  Temporarily stop audio playback on the CD. The playback can be resumed at the same point with the CD.resume() method. If the CD is not playing this method does nothing. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   resume() \n unpause audio playback resume() -> None  Unpause a paused CD. If the CD is not paused or already playing, this method does nothing. \n   eject() \n eject or open the cdrom drive eject() -> None  This will open the cdrom drive and eject the cdrom. If the drive is playing or paused it will be stopped. \n   get_id() \n the index of the cdrom drive get_id() -> id  Returns the integer id that was used to create the CD instance. This method can work on an uninitialized CD. \n   get_name() \n the system name of the cdrom drive get_name() -> name  Return the string name of the drive. This is the system name used to represent the drive. It is often the drive letter or device name. This method can work on an uninitialized CD. \n   get_busy() \n true if the drive is playing audio get_busy() -> bool  Returns True if the drive busy playing back audio. \n   get_paused() \n true if the drive is paused get_paused() -> bool  Returns True if the drive is currently paused. \n   get_current() \n the current audio playback position get_current() -> track, seconds  Returns both the current track and time of that track. This method works when the drive is either playing or paused. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   get_empty() \n False if a cdrom is in the drive get_empty() -> bool  Return False if there is a cdrom currently in the drive. If the drive is empty this will return True. \n   get_numtracks() \n the number of tracks on the cdrom get_numtracks() -> count  Return the number of tracks on the cdrom in the drive. This will return zero of the drive is empty or has no tracks. \n   get_track_audio() \n true if the cdrom track has audio data get_track_audio(track) -> bool  Determine if a track on a cdrom contains audio data. You can also call CD.num_tracks() and CD.get_all() to determine more information about the cdrom. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   get_all() \n get all track information get_all() -> [(audio, start, end, length), ...]  Return a list with information for every track on the cdrom. The information consists of a tuple with four values. The audio value is True if the track contains audio data. The start, end, and length values are floating point numbers in seconds. Start and end represent absolute times on the entire disc. \n   get_track_start() \n start time of a cdrom track get_track_start(track) -> seconds  Return the absolute time in seconds where at start of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   get_track_length() \n length of a cdrom track get_track_length(track) -> seconds  Return a floating point value in seconds of the length of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero. \n \n"}, {"name": "cdrom.CD.eject", "path": "ref/cdrom#pygame.cdrom.CD.eject", "type": "pygame.cdrom", "text": "  eject() \n eject or open the cdrom drive eject() -> None  This will open the cdrom drive and eject the cdrom. If the drive is playing or paused it will be stopped. \n"}, {"name": "cdrom.CD.get_all", "path": "ref/cdrom#pygame.cdrom.CD.get_all", "type": "pygame.cdrom", "text": "  get_all() \n get all track information get_all() -> [(audio, start, end, length), ...]  Return a list with information for every track on the cdrom. The information consists of a tuple with four values. The audio value is True if the track contains audio data. The start, end, and length values are floating point numbers in seconds. Start and end represent absolute times on the entire disc. \n"}, {"name": "cdrom.CD.get_busy", "path": "ref/cdrom#pygame.cdrom.CD.get_busy", "type": "pygame.cdrom", "text": "  get_busy() \n true if the drive is playing audio get_busy() -> bool  Returns True if the drive busy playing back audio. \n"}, {"name": "cdrom.CD.get_current", "path": "ref/cdrom#pygame.cdrom.CD.get_current", "type": "pygame.cdrom", "text": "  get_current() \n the current audio playback position get_current() -> track, seconds  Returns both the current track and time of that track. This method works when the drive is either playing or paused. Note, track 0 is the first track on the CD. Track numbers start at zero. \n"}, {"name": "cdrom.CD.get_empty", "path": "ref/cdrom#pygame.cdrom.CD.get_empty", "type": "pygame.cdrom", "text": "  get_empty() \n False if a cdrom is in the drive get_empty() -> bool  Return False if there is a cdrom currently in the drive. If the drive is empty this will return True. \n"}, {"name": "cdrom.CD.get_id", "path": "ref/cdrom#pygame.cdrom.CD.get_id", "type": "pygame.cdrom", "text": "  get_id() \n the index of the cdrom drive get_id() -> id  Returns the integer id that was used to create the CD instance. This method can work on an uninitialized CD. \n"}, {"name": "cdrom.CD.get_init", "path": "ref/cdrom#pygame.cdrom.CD.get_init", "type": "pygame.cdrom", "text": "  get_init() \n true if this cd device initialized get_init() -> bool  Test if this CDROM device is initialized. This is different than the pygame.cdrom.init() since each drive must also be initialized individually. \n"}, {"name": "cdrom.CD.get_name", "path": "ref/cdrom#pygame.cdrom.CD.get_name", "type": "pygame.cdrom", "text": "  get_name() \n the system name of the cdrom drive get_name() -> name  Return the string name of the drive. This is the system name used to represent the drive. It is often the drive letter or device name. This method can work on an uninitialized CD. \n"}, {"name": "cdrom.CD.get_numtracks", "path": "ref/cdrom#pygame.cdrom.CD.get_numtracks", "type": "pygame.cdrom", "text": "  get_numtracks() \n the number of tracks on the cdrom get_numtracks() -> count  Return the number of tracks on the cdrom in the drive. This will return zero of the drive is empty or has no tracks. \n"}, {"name": "cdrom.CD.get_paused", "path": "ref/cdrom#pygame.cdrom.CD.get_paused", "type": "pygame.cdrom", "text": "  get_paused() \n true if the drive is paused get_paused() -> bool  Returns True if the drive is currently paused. \n"}, {"name": "cdrom.CD.get_track_audio", "path": "ref/cdrom#pygame.cdrom.CD.get_track_audio", "type": "pygame.cdrom", "text": "  get_track_audio() \n true if the cdrom track has audio data get_track_audio(track) -> bool  Determine if a track on a cdrom contains audio data. You can also call CD.num_tracks() and CD.get_all() to determine more information about the cdrom. Note, track 0 is the first track on the CD. Track numbers start at zero. \n"}, {"name": "cdrom.CD.get_track_length", "path": "ref/cdrom#pygame.cdrom.CD.get_track_length", "type": "pygame.cdrom", "text": "  get_track_length() \n length of a cdrom track get_track_length(track) -> seconds  Return a floating point value in seconds of the length of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero. \n"}, {"name": "cdrom.CD.get_track_start", "path": "ref/cdrom#pygame.cdrom.CD.get_track_start", "type": "pygame.cdrom", "text": "  get_track_start() \n start time of a cdrom track get_track_start(track) -> seconds  Return the absolute time in seconds where at start of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero. \n"}, {"name": "cdrom.CD.init", "path": "ref/cdrom#pygame.cdrom.CD.init", "type": "pygame.cdrom", "text": "  init() \n initialize a cdrom drive for use init() -> None  Initialize the cdrom drive for use. The drive must be initialized for most CD methods to work. Even if the rest of pygame has been initialized. There may be a brief pause while the drive is initialized. Avoid CD.init() if the program should not stop for a second or two. \n"}, {"name": "cdrom.CD.pause", "path": "ref/cdrom#pygame.cdrom.CD.pause", "type": "pygame.cdrom", "text": "  pause() \n temporarily stop audio playback pause() -> None  Temporarily stop audio playback on the CD. The playback can be resumed at the same point with the CD.resume() method. If the CD is not playing this method does nothing. Note, track 0 is the first track on the CD. Track numbers start at zero. \n"}, {"name": "cdrom.CD.play", "path": "ref/cdrom#pygame.cdrom.CD.play", "type": "pygame.cdrom", "text": "  play() \n start playing audio play(track, start=None, end=None) -> None  Playback audio from an audio cdrom in the drive. Besides the track number argument, you can also pass a starting and ending time for playback. The start and end time are in seconds, and can limit the section of an audio track played. If you pass a start time but no end, the audio will play to the end of the track. If you pass a start time and 'None' for the end time, the audio will play to the end of the entire disc. See the CD.get_numtracks() and CD.get_track_audio() to find tracks to playback. Note, track 0 is the first track on the CD. Track numbers start at zero. \n"}, {"name": "cdrom.CD.quit", "path": "ref/cdrom#pygame.cdrom.CD.quit", "type": "pygame.cdrom", "text": "  quit() \n uninitialize a cdrom drive for use quit() -> None  Uninitialize a drive for use. Call this when your program will not be accessing the drive for awhile. \n"}, {"name": "cdrom.CD.resume", "path": "ref/cdrom#pygame.cdrom.CD.resume", "type": "pygame.cdrom", "text": "  resume() \n unpause audio playback resume() -> None  Unpause a paused CD. If the CD is not paused or already playing, this method does nothing. \n"}, {"name": "cdrom.CD.stop", "path": "ref/cdrom#pygame.cdrom.CD.stop", "type": "pygame.cdrom", "text": "  stop() \n stop audio playback stop() -> None  Stops playback of audio from the cdrom. This will also lose the current playback position. This method does nothing if the drive isn't already playing audio. \n"}, {"name": "cdrom.get_count", "path": "ref/cdrom#pygame.cdrom.get_count", "type": "pygame.cdrom", "text": "  pygame.cdrom.get_count() \n number of cd drives on the system get_count() -> count  Return the number of cd drives on the system. When you create CD objects you need to pass an integer id that must be lower than this count. The count will be 0 if there are no drives on the system. \n"}, {"name": "cdrom.get_init", "path": "ref/cdrom#pygame.cdrom.get_init", "type": "pygame.cdrom", "text": "  pygame.cdrom.get_init() \n true if the cdrom module is initialized get_init() -> bool  Test if the cdrom module is initialized or not. This is different than the CD.init() since each drive must also be initialized individually. \n"}, {"name": "cdrom.init", "path": "ref/cdrom#pygame.cdrom.init", "type": "pygame.cdrom", "text": "  pygame.cdrom.init() \n initialize the cdrom module init() -> None  Initialize the cdrom module. This will scan the system for all CD devices. The module must be initialized before any other functions will work. This automatically happens when you call pygame.init(). It is safe to call this function more than once. \n"}, {"name": "cdrom.quit", "path": "ref/cdrom#pygame.cdrom.quit", "type": "pygame.cdrom", "text": "  pygame.cdrom.quit() \n uninitialize the cdrom module quit() -> None  Uninitialize the cdrom module. After you call this any existing CD objects will no longer work. It is safe to call this function more than once. \n"}, {"name": "Color", "path": "ref/color", "type": "pygame.Color", "text": " pygame.Color\n  \n pygame object for color representations Color(r, g, b) -> Color Color(r, g, b, a=255) -> Color Color(color_value) -> Color  The Color class represents RGBA color values using a value range of 0 to 255 inclusive. It allows basic arithmetic operations \u2014 binary operations +, -, *, //, %, and unary operation ~ \u2014 to create new colors, supports conversions to other color spaces such as HSV or HSL and lets you adjust single color channels. Alpha defaults to 255 (fully opaque) when not given. The arithmetic operations and correct_gamma() method preserve subclasses. For the binary operators, the class of the returned color is that of the left hand color object of the operator. Color objects support equality comparison with other color objects and 3 or 4 element tuples of integers. There was a bug in pygame 1.8.1 where the default alpha was 0, not 255 like previously. Color objects export the C level array interface. The interface exports a read-only one dimensional unsigned byte array of the same assigned length as the color. For CPython 2.6 and later, the new buffer interface is also exported, with the same characteristics as the array interface. The floor division, //, and modulus, %, operators do not raise an exception for division by zero. Instead, if a color, or alpha, channel in the right hand color is 0, then the result is 0. For example: # These expressions are True\nColor(255, 255, 255, 255) // Color(0, 64, 64, 64) == Color(0, 3, 3, 3)\nColor(255, 255, 255, 255) % Color(64, 64, 64, 0) == Color(63, 63, 63, 0)     \nParameters:\n\n \nr (int) -- red value in the range of 0 to 255 inclusive \ng (int) -- green value in the range of 0 to 255 inclusive \nb (int) -- blue value in the range of 0 to 255 inclusive \na (int) -- (optional) alpha value in the range of 0 to 255 inclusive, default is 255 \ncolor_value (Color or str or int or tuple(int, int, int, [int]) or list(int, int, int, [int])) -- color value (see note below for the supported formats)  Note  Supported color_value formats: \n - Color object: clones the given Color object - color name str: name of the color to use, e.g. 'red' (all the supported name strings can be found in the colordict module) - HTML color format str: '#rrggbbaa' or '#rrggbb', where rr, gg, bb, and aa are 2-digit hex numbers in the range of 0 to 0xFF inclusive, the aa (alpha) value defaults to 0xFF if not provided - hex number str: '0xrrggbbaa' or '0xrrggbb', where rr, gg, bb, and aa are 2-digit hex numbers in the range of 0x00 to 0xFF inclusive, the aa (alpha) value defaults to 0xFF if not provided - int: int value of the color to use, using hex numbers can make this parameter more readable, e.g. 0xrrggbbaa, where rr, gg, bb, and aa are 2-digit hex numbers in the range of 0x00 to 0xFF inclusive, note that the aa (alpha) value is not optional for the int format and must be provided - tuple/list of int color values: (R, G, B, A) or (R, G, B), where R, G, B, and A are int values in the range of 0 to 255 inclusive, the A (alpha) value defaults to 255 if not provided         \nReturns:\n\na newly created Color object   \nReturn type:\n\nColor      Changed in pygame 2.0.0: Support for tuples, lists, and Color objects when creating Color objects.   Changed in pygame 1.9.2: Color objects export the C level array interface.   Changed in pygame 1.9.0: Color objects support 4-element tuples of integers.   Changed in pygame 1.8.1: New implementation of the class.    r \n Gets or sets the red value of the Color. r -> int  The red value of the Color. \n   g \n Gets or sets the green value of the Color. g -> int  The green value of the Color. \n   b \n Gets or sets the blue value of the Color. b -> int  The blue value of the Color. \n   a \n Gets or sets the alpha value of the Color. a -> int  The alpha value of the Color. \n   cmy \n Gets or sets the CMY representation of the Color. cmy -> tuple  The CMY representation of the Color. The CMY components are in the ranges C = [0, 1], M = [0, 1], Y = [0, 1]. Note that this will not return the absolutely exact CMY values for the set RGB values in all cases. Due to the RGB mapping from 0-255 and the CMY mapping from 0-1 rounding errors may cause the CMY values to differ slightly from what you might expect. \n   hsva \n Gets or sets the HSVA representation of the Color. hsva -> tuple  The HSVA representation of the Color. The HSVA components are in the ranges H = [0, 360], S = [0, 100], V = [0, 100], A = [0, 100]. Note that this will not return the absolutely exact HSV values for the set RGB values in all cases. Due to the RGB mapping from 0-255 and the HSV mapping from 0-100 and 0-360 rounding errors may cause the HSV values to differ slightly from what you might expect. \n   hsla \n Gets or sets the HSLA representation of the Color. hsla -> tuple  The HSLA representation of the Color. The HSLA components are in the ranges H = [0, 360], S = [0, 100], V = [0, 100], A = [0, 100]. Note that this will not return the absolutely exact HSL values for the set RGB values in all cases. Due to the RGB mapping from 0-255 and the HSL mapping from 0-100 and 0-360 rounding errors may cause the HSL values to differ slightly from what you might expect. \n   i1i2i3 \n Gets or sets the I1I2I3 representation of the Color. i1i2i3 -> tuple  The I1I2I3 representation of the Color. The I1I2I3 components are in the ranges I1 = [0, 1], I2 = [-0.5, 0.5], I3 = [-0.5, 0.5]. Note that this will not return the absolutely exact I1I2I3 values for the set RGB values in all cases. Due to the RGB mapping from 0-255 and the I1I2I3 mapping from 0-1 rounding errors may cause the I1I2I3 values to differ slightly from what you might expect. \n   normalize() \n Returns the normalized RGBA values of the Color. normalize() -> tuple  Returns the normalized RGBA values of the Color as floating point values. \n   correct_gamma() \n Applies a certain gamma value to the Color. correct_gamma (gamma) -> Color  Applies a certain gamma value to the Color and returns a new Color with the adjusted RGBA values. \n   set_length() \n Set the number of elements in the Color to 1,2,3, or 4. set_length(len) -> None  The default Color length is 4. Colors can have lengths 1,2,3 or 4. This is useful if you want to unpack to r,g,b and not r,g,b,a. If you want to get the length of a Color do len(acolor).  New in pygame 1.9.0.  \n   lerp() \n returns a linear interpolation to the given Color. lerp(Color, float) -> Color  Returns a Color which is a linear interpolation between self and the given Color in RGBA space. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned.  New in pygame 2.0.1.  \n   premul_alpha() \n returns a Color where the r,g,b components have been multiplied by the alpha. premul_alpha() -> Color  Returns a new Color where each of the red, green and blue colour channels have been multiplied by the alpha channel of the original color. The alpha channel remains unchanged. This is useful when working with the BLEND_PREMULTIPLIED blending mode flag for pygame.Surface.blit(), which assumes that all surfaces using it are using pre-multiplied alpha colors.  New in pygame 2.0.0.  \n   update() \n Sets the elements of the color update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None  Sets the elements of the color. See parameters for pygame.Color() for the parameters of this function. If the alpha value was not set it will not change.  New in pygame 2.0.1.  \n \n \n"}, {"name": "Color.a", "path": "ref/color#pygame.Color.a", "type": "pygame.Color", "text": "  a \n Gets or sets the alpha value of the Color. a -> int  The alpha value of the Color. \n"}, {"name": "Color.b", "path": "ref/color#pygame.Color.b", "type": "pygame.Color", "text": "  b \n Gets or sets the blue value of the Color. b -> int  The blue value of the Color. \n"}, {"name": "Color.cmy", "path": "ref/color#pygame.Color.cmy", "type": "pygame.Color", "text": "  cmy \n Gets or sets the CMY representation of the Color. cmy -> tuple  The CMY representation of the Color. The CMY components are in the ranges C = [0, 1], M = [0, 1], Y = [0, 1]. Note that this will not return the absolutely exact CMY values for the set RGB values in all cases. Due to the RGB mapping from 0-255 and the CMY mapping from 0-1 rounding errors may cause the CMY values to differ slightly from what you might expect. \n"}, {"name": "Color.correct_gamma", "path": "ref/color#pygame.Color.correct_gamma", "type": "pygame.Color", "text": "  correct_gamma() \n Applies a certain gamma value to the Color. correct_gamma (gamma) -> Color  Applies a certain gamma value to the Color and returns a new Color with the adjusted RGBA values. \n"}, {"name": "Color.g", "path": "ref/color#pygame.Color.g", "type": "pygame.Color", "text": "  g \n Gets or sets the green value of the Color. g -> int  The green value of the Color. \n"}, {"name": "Color.hsla", "path": "ref/color#pygame.Color.hsla", "type": "pygame.Color", "text": "  hsla \n Gets or sets the HSLA representation of the Color. hsla -> tuple  The HSLA representation of the Color. The HSLA components are in the ranges H = [0, 360], S = [0, 100], V = [0, 100], A = [0, 100]. Note that this will not return the absolutely exact HSL values for the set RGB values in all cases. Due to the RGB mapping from 0-255 and the HSL mapping from 0-100 and 0-360 rounding errors may cause the HSL values to differ slightly from what you might expect. \n"}, {"name": "Color.hsva", "path": "ref/color#pygame.Color.hsva", "type": "pygame.Color", "text": "  hsva \n Gets or sets the HSVA representation of the Color. hsva -> tuple  The HSVA representation of the Color. The HSVA components are in the ranges H = [0, 360], S = [0, 100], V = [0, 100], A = [0, 100]. Note that this will not return the absolutely exact HSV values for the set RGB values in all cases. Due to the RGB mapping from 0-255 and the HSV mapping from 0-100 and 0-360 rounding errors may cause the HSV values to differ slightly from what you might expect. \n"}, {"name": "Color.i1i2i3", "path": "ref/color#pygame.Color.i1i2i3", "type": "pygame.Color", "text": "  i1i2i3 \n Gets or sets the I1I2I3 representation of the Color. i1i2i3 -> tuple  The I1I2I3 representation of the Color. The I1I2I3 components are in the ranges I1 = [0, 1], I2 = [-0.5, 0.5], I3 = [-0.5, 0.5]. Note that this will not return the absolutely exact I1I2I3 values for the set RGB values in all cases. Due to the RGB mapping from 0-255 and the I1I2I3 mapping from 0-1 rounding errors may cause the I1I2I3 values to differ slightly from what you might expect. \n"}, {"name": "Color.lerp", "path": "ref/color#pygame.Color.lerp", "type": "pygame.Color", "text": "  lerp() \n returns a linear interpolation to the given Color. lerp(Color, float) -> Color  Returns a Color which is a linear interpolation between self and the given Color in RGBA space. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned.  New in pygame 2.0.1.  \n"}, {"name": "Color.normalize", "path": "ref/color#pygame.Color.normalize", "type": "pygame.Color", "text": "  normalize() \n Returns the normalized RGBA values of the Color. normalize() -> tuple  Returns the normalized RGBA values of the Color as floating point values. \n"}, {"name": "Color.premul_alpha", "path": "ref/color#pygame.Color.premul_alpha", "type": "pygame.Color", "text": "  premul_alpha() \n returns a Color where the r,g,b components have been multiplied by the alpha. premul_alpha() -> Color  Returns a new Color where each of the red, green and blue colour channels have been multiplied by the alpha channel of the original color. The alpha channel remains unchanged. This is useful when working with the BLEND_PREMULTIPLIED blending mode flag for pygame.Surface.blit(), which assumes that all surfaces using it are using pre-multiplied alpha colors.  New in pygame 2.0.0.  \n"}, {"name": "Color.r", "path": "ref/color#pygame.Color.r", "type": "pygame.Color", "text": "  r \n Gets or sets the red value of the Color. r -> int  The red value of the Color. \n"}, {"name": "Color.set_length", "path": "ref/color#pygame.Color.set_length", "type": "pygame.Color", "text": "  set_length() \n Set the number of elements in the Color to 1,2,3, or 4. set_length(len) -> None  The default Color length is 4. Colors can have lengths 1,2,3 or 4. This is useful if you want to unpack to r,g,b and not r,g,b,a. If you want to get the length of a Color do len(acolor).  New in pygame 1.9.0.  \n"}, {"name": "Color.update", "path": "ref/color#pygame.Color.update", "type": "pygame.Color", "text": "  update() \n Sets the elements of the color update(r, g, b) -> None update(r, g, b, a=255) -> None update(color_value) -> None  Sets the elements of the color. See parameters for pygame.Color() for the parameters of this function. If the alpha value was not set it will not change.  New in pygame 2.0.1.  \n"}, {"name": "cursors", "path": "ref/cursors", "type": "pygame.cursors", "text": " pygame.cursors\n  \n pygame module for cursor resources  Pygame offers control over the system hardware cursor. Pygame only supports black and white cursors for the system. You control the cursor with functions inside pygame.mouse. This cursors module contains functions for loading and decoding various cursor formats. These allow you to easily store your cursors in external files or directly as encoded python strings. The module includes several standard cursors. The pygame.mouse.set_cursor() function takes several arguments. All those arguments have been stored in a single tuple you can call like this: >>> pygame.mouse.set_cursor(*pygame.cursors.arrow) The following variables can be passed to pygame.mouse.set_cursor function:  \n pygame.cursors.arrow pygame.cursors.diamond pygame.cursors.broken_x pygame.cursors.tri_left pygame.cursors.tri_right  \n This module also contains a few cursors as formatted strings. You'll need to pass these to pygame.cursors.compile() function before you can use them. The example call would look like this: >>> cursor = pygame.cursors.compile(pygame.cursors.textmarker_strings)\n>>> pygame.mouse.set_cursor((8, 16), (0, 0), *cursor) The following strings can be converted into cursor bitmaps with pygame.cursors.compile() :  \n pygame.cursors.thickarrow_strings pygame.cursors.sizer_x_strings pygame.cursors.sizer_y_strings pygame.cursors.sizer_xy_strings pygame.cursor.textmarker_strings  \n   pygame.cursors.compile() \n create binary cursor data from simple strings compile(strings, black='X', white='.', xor='o') -> data, mask  A sequence of strings can be used to create binary cursor data for the system cursor. This returns the binary data in the form of two tuples. Those can be passed as the third and fourth arguments respectively of the pygame.mouse.set_cursor() function. If you are creating your own cursor strings, you can use any value represent the black and white pixels. Some system allow you to set a special toggle color for the system color, this is also called the xor color. If the system does not support xor cursors, that color will simply be black. The height must be divisible by 8. The width of the strings must all be equal and be divisible by 8. If these two conditions are not met, ValueError is raised. An example set of cursor strings looks like this thickarrow_strings = (               #sized 24x24\n  \"XX                      \",\n  \"XXX                     \",\n  \"XXXX                    \",\n  \"XX.XX                   \",\n  \"XX..XX                  \",\n  \"XX...XX                 \",\n  \"XX....XX                \",\n  \"XX.....XX               \",\n  \"XX......XX              \",\n  \"XX.......XX             \",\n  \"XX........XX            \",\n  \"XX........XXX           \",\n  \"XX......XXXXX           \",\n  \"XX.XXX..XX              \",\n  \"XXXX XX..XX             \",\n  \"XX   XX..XX             \",\n  \"     XX..XX             \",\n  \"      XX..XX            \",\n  \"      XX..XX            \",\n  \"       XXXX             \",\n  \"       XX               \",\n  \"                        \",\n  \"                        \",\n  \"                        \") \n   pygame.cursors.load_xbm() \n load cursor data from an XBM file load_xbm(cursorfile) -> cursor_args load_xbm(cursorfile, maskfile) -> cursor_args  This loads cursors for a simple subset of XBM files. XBM files are traditionally used to store cursors on UNIX systems, they are an ASCII format used to represent simple images. Sometimes the black and white color values will be split into two separate XBM files. You can pass a second maskfile argument to load the two images into a single cursor. The cursorfile and maskfile arguments can either be filenames or file-like object with the readlines method. The return value cursor_args can be passed directly to the pygame.mouse.set_cursor() function. \n \n \n"}, {"name": "cursors.compile", "path": "ref/cursors#pygame.cursors.compile", "type": "pygame.cursors", "text": "  pygame.cursors.compile() \n create binary cursor data from simple strings compile(strings, black='X', white='.', xor='o') -> data, mask  A sequence of strings can be used to create binary cursor data for the system cursor. This returns the binary data in the form of two tuples. Those can be passed as the third and fourth arguments respectively of the pygame.mouse.set_cursor() function. If you are creating your own cursor strings, you can use any value represent the black and white pixels. Some system allow you to set a special toggle color for the system color, this is also called the xor color. If the system does not support xor cursors, that color will simply be black. The height must be divisible by 8. The width of the strings must all be equal and be divisible by 8. If these two conditions are not met, ValueError is raised. An example set of cursor strings looks like this thickarrow_strings = (               #sized 24x24\n  \"XX                      \",\n  \"XXX                     \",\n  \"XXXX                    \",\n  \"XX.XX                   \",\n  \"XX..XX                  \",\n  \"XX...XX                 \",\n  \"XX....XX                \",\n  \"XX.....XX               \",\n  \"XX......XX              \",\n  \"XX.......XX             \",\n  \"XX........XX            \",\n  \"XX........XXX           \",\n  \"XX......XXXXX           \",\n  \"XX.XXX..XX              \",\n  \"XXXX XX..XX             \",\n  \"XX   XX..XX             \",\n  \"     XX..XX             \",\n  \"      XX..XX            \",\n  \"      XX..XX            \",\n  \"       XXXX             \",\n  \"       XX               \",\n  \"                        \",\n  \"                        \",\n  \"                        \") \n"}, {"name": "cursors.load_xbm", "path": "ref/cursors#pygame.cursors.load_xbm", "type": "pygame.cursors", "text": "  pygame.cursors.load_xbm() \n load cursor data from an XBM file load_xbm(cursorfile) -> cursor_args load_xbm(cursorfile, maskfile) -> cursor_args  This loads cursors for a simple subset of XBM files. XBM files are traditionally used to store cursors on UNIX systems, they are an ASCII format used to represent simple images. Sometimes the black and white color values will be split into two separate XBM files. You can pass a second maskfile argument to load the two images into a single cursor. The cursorfile and maskfile arguments can either be filenames or file-like object with the readlines method. The return value cursor_args can be passed directly to the pygame.mouse.set_cursor() function. \n"}, {"name": "display", "path": "ref/display", "type": "pygame.display", "text": " pygame.display\n  \n pygame module to control the display window and screen  This module offers control over the pygame display. Pygame has a single display Surface that is either contained in a window or runs full screen. Once you create the display you treat it as a regular Surface. Changes are not immediately visible onscreen; you must choose one of the two flipping functions to update the actual display. The origin of the display, where x = 0 and y = 0, is the top left of the screen. Both axes increase positively towards the bottom right of the screen. The pygame display can actually be initialized in one of several modes. By default, the display is a basic software driven framebuffer. You can request special modules like hardware acceleration and OpenGL support. These are controlled by flags passed to pygame.display.set_mode(). Pygame can only have a single display active at any time. Creating a new one with pygame.display.set_mode() will close the previous display. If precise control is needed over the pixel format or display resolutions, use the functions pygame.display.mode_ok(), pygame.display.list_modes(), and pygame.display.Info() to query information about the display. Once the display Surface is created, the functions from this module affect the single existing display. The Surface becomes invalid if the module is uninitialized. If a new display mode is set, the existing Surface will automatically switch to operate on the new display. When the display mode is set, several events are placed on the pygame event queue. pygame.QUIT is sent when the user has requested the program to shut down. The window will receive pygame.ACTIVEEVENT events as the display gains and loses input focus. If the display is set with the pygame.RESIZABLE flag, pygame.VIDEORESIZE events will be sent when the user adjusts the window dimensions. Hardware displays that draw direct to the screen will get pygame.VIDEOEXPOSE events when portions of the window must be redrawn. In pygame 2, there is a new type of event called pygame.WINDOWEVENT that is meant to replace all window related events like pygame.VIDEORESIZE, pygame.VIDEOEXPOSE and pygame.ACTIVEEVENT. Note that the WINDOWEVENT API is considered experimental, and may change in future releases. The new events of type pygame.WINDOWEVENT have an event attribute that can take the following values. Value of event attribute      Short description\n\nWINDOWEVENT_SHOWN            Window became shown\nWINDOWEVENT_HIDDEN           Window became hidden\nWINDOWEVENT_EXPOSED          Window got updated by some external event\nWINDOWEVENT_MOVED            Window got moved\nWINDOWEVENT_RESIZED          Window got resized\nWINDOWEVENT_SIZE_CHANGED     Window changed it's size\nWINDOWEVENT_MINIMIZED        Window was minimised\nWINDOWEVENT_MAXIMIZED        Window was maximised\nWINDOWEVENT_RESTORED         Window was restored\nWINDOWEVENT_ENTER            Mouse entered the window\nWINDOWEVENT_LEAVE            Mouse left the window\nWINDOWEVENT_FOCUS_GAINED     Window gained focus\nWINDOWEVENT_FOCUS_LOST       Window lost focus\nWINDOWEVENT_CLOSE            Window was closed\nWINDOWEVENT_TAKE_FOCUS       Window was offered focus\nWINDOWEVENT_HIT_TEST         Window has a special hit test If SDL version used is less than 2.0.5, the last two values WINDOWEVENT_TAKE_FOCUS and WINDOWEVENT_HIT_TEST will not work. See the SDL implementation (in C programming) of the same over here. Some display environments have an option for automatically stretching all windows. When this option is enabled, this automatic stretching distorts the appearance of the pygame window. In the pygame examples directory, there is example code (prevent_display_stretching.py) which shows how to disable this automatic stretching of the pygame display on Microsoft Windows (Vista or newer required).   pygame.display.init() \n Initialize the display module init() -> None  Initializes the pygame display module. The display module cannot do anything until it is initialized. This is usually handled for you automatically when you call the higher level pygame.init(). Pygame will select from one of several internal display backends when it is initialized. The display mode will be chosen depending on the platform and permissions of current user. Before the display module is initialized the environment variable SDL_VIDEODRIVER can be set to control which backend is used. The systems with multiple choices are listed here. Windows : windib, directx\nUnix    : x11, dga, fbcon, directfb, ggi, vgl, svgalib, aalib On some platforms it is possible to embed the pygame display into an already existing window. To do this, the environment variable SDL_WINDOWID must be set to a string containing the window id or handle. The environment variable is checked when the pygame display is initialized. Be aware that there can be many strange side effects when running in an embedded display. It is harmless to call this more than once, repeated calls have no effect. \n   pygame.display.quit() \n Uninitialize the display module quit() -> None  This will shut down the entire display module. This means any active displays will be closed. This will also be handled automatically when the program exits. It is harmless to call this more than once, repeated calls have no effect. \n   pygame.display.get_init() \n Returns True if the display module has been initialized get_init() -> bool  Returns True if the pygame.display module is currently initialized. \n   pygame.display.set_mode() \n Initialize a window or screen for display set_mode(size=(0, 0), flags=0, depth=0, display=0, vsync=0) -> Surface  This function will create a display Surface. The arguments passed in are requests for a display type. The actual created display will be the best possible match supported by the system. The size argument is a pair of numbers representing the width and height. The flags argument is a collection of additional options. The depth argument represents the number of bits to use for color. The Surface that gets returned can be drawn to like a regular Surface but changes will eventually be seen on the monitor. If no size is passed or is set to (0, 0) and pygame uses SDL version 1.2.10 or above, the created Surface will have the same size as the current screen resolution. If only the width or height are set to 0, the Surface will have the same width or height as the screen resolution. Using a SDL version prior to 1.2.10 will raise an exception. It is usually best to not pass the depth argument. It will default to the best and fastest color depth for the system. If your game requires a specific color format you can control the depth with this argument. Pygame will emulate an unavailable color depth which can be slow. When requesting fullscreen display modes, sometimes an exact match for the requested size cannot be made. In these situations pygame will select the closest compatible match. The returned surface will still always match the requested size. On high resolution displays(4k, 1080p) and tiny graphics games (640x480) show up very small so that they are unplayable. SCALED scales up the window for you. The game thinks it's a 640x480 window, but really it can be bigger. Mouse events are scaled for you, so your game doesn't need to do it. Note that SCALED is considered an experimental API and may change in future releases. The flags argument controls which type of display you want. There are several to choose from, and you can even combine multiple types using the bitwise or operator, (the pipe \"|\" character). If you pass 0 or no flags argument it will default to a software driven window. Here are the display flags you will want to choose from: pygame.FULLSCREEN    create a fullscreen display\npygame.DOUBLEBUF     recommended for HWSURFACE or OPENGL\npygame.HWSURFACE     hardware accelerated, only in FULLSCREEN\npygame.OPENGL        create an OpenGL-renderable display\npygame.RESIZABLE     display window should be sizeable\npygame.NOFRAME       display window will have no border or controls Pygame 2 has the following additional flags available. pygame.SCALED        resolution depends on desktop size and scale\n                     graphics\npygame.SHOWN         window is opened in visible mode (default)\npygame.HIDDEN        window is opened in hidden mode  New in pygame 2.0.0: SCALED, SHOWN and HIDDEN  By setting the vsync parameter to 1, it is possible to get a display with vertical sync, but you are not guaranteed to get one. The request only works at all for calls to set_mode() with the pygame.OPENGL or pygame.SCALED flags set, and is still not guaranteed even with one of those set. What you get depends on the hardware and driver configuration of the system pygame is running on. Here is an example usage of a call to set_mode() that may give you a display with vsync: flags = pygame.OPENGL | pygame.FULLSCREEN\nwindow_surface = pygame.display.set_mode((1920, 1080), flags, vsync=1) Vsync behaviour is considered experimental, and may change in future releases.  New in pygame 2.0.0: vsync  Basic example: # Open a window on the screen\nscreen_width=700\nscreen_height=400\nscreen=pygame.display.set_mode([screen_width, screen_height]) The display index 0 means the default display is used.  Changed in pygame 1.9.5: display argument added  \n   pygame.display.get_surface() \n Get a reference to the currently set display surface get_surface() -> Surface  Return a reference to the currently set display Surface. If no display mode has been set this will return None. \n   pygame.display.flip() \n Update the full display Surface to the screen flip() -> None  This will update the contents of the entire display. If your display mode is using the flags pygame.HWSURFACE and pygame.DOUBLEBUF, this will wait for a vertical retrace and swap the surfaces. If you are using a different type of display mode, it will simply update the entire contents of the surface. When using an pygame.OPENGL display mode this will perform a gl buffer swap. \n   pygame.display.update() \n Update portions of the screen for software displays update(rectangle=None) -> None update(rectangle_list) -> None  This function is like an optimized version of pygame.display.flip() for software displays. It allows only a portion of the screen to updated, instead of the entire area. If no argument is passed it updates the entire Surface area like pygame.display.flip(). You can pass the function a single rectangle, or a sequence of rectangles. It is more efficient to pass many rectangles at once than to call update multiple times with single or a partial list of rectangles. If passing a sequence of rectangles it is safe to include None values in the list, which will be skipped. This call cannot be used on pygame.OPENGL displays and will generate an exception. \n   pygame.display.get_driver() \n Get the name of the pygame display backend get_driver() -> name  Pygame chooses one of many available display backends when it is initialized. This returns the internal name used for the display backend. This can be used to provide limited information about what display capabilities might be accelerated. See the SDL_VIDEODRIVER flags in pygame.display.set_mode() to see some of the common options. \n   pygame.display.Info() \n Create a video display information object Info() -> VideoInfo  Creates a simple object containing several attributes to describe the current graphics environment. If this is called before pygame.display.set_mode() some platforms can provide information about the default display mode. This can also be called after setting the display mode to verify specific display options were satisfied. The VidInfo object has several attributes: hw:         1 if the display is hardware accelerated\nwm:         1 if windowed display modes can be used\nvideo_mem:  The megabytes of video memory on the display. This is 0 if\n            unknown\nbitsize:    Number of bits used to store each pixel\nbytesize:   Number of bytes used to store each pixel\nmasks:      Four values used to pack RGBA values into pixels\nshifts:     Four values used to pack RGBA values into pixels\nlosses:     Four values used to pack RGBA values into pixels\nblit_hw:    1 if hardware Surface blitting is accelerated\nblit_hw_CC: 1 if hardware Surface colorkey blitting is accelerated\nblit_hw_A:  1 if hardware Surface pixel alpha blitting is accelerated\nblit_sw:    1 if software Surface blitting is accelerated\nblit_sw_CC: 1 if software Surface colorkey blitting is accelerated\nblit_sw_A:  1 if software Surface pixel alpha blitting is accelerated\ncurrent_h, current_w:  Height and width of the current video mode, or\n            of the desktop mode if called before the display.set_mode\n            is called. (current_h, current_w are available since\n            SDL 1.2.10, and pygame 1.8.0). They are -1 on error, or if\n            an old SDL is being used. \n   pygame.display.get_wm_info() \n Get information about the current windowing system get_wm_info() -> dict  Creates a dictionary filled with string keys. The strings and values are arbitrarily created by the system. Some systems may have no information and an empty dictionary will be returned. Most platforms will return a \"window\" key with the value set to the system id for the current display.  New in pygame 1.7.1.  \n   pygame.display.list_modes() \n Get list of available fullscreen modes list_modes(depth=0, flags=pygame.FULLSCREEN, display=0) -> list  This function returns a list of possible sizes for a specified color depth. The return value will be an empty list if no display modes are available with the given arguments. A return value of -1 means that any requested size should work (this is likely the case for windowed modes). Mode sizes are sorted from biggest to smallest. If depth is 0, the current/best color depth for the display is used. The flags defaults to pygame.FULLSCREEN, but you may need to add additional flags for specific fullscreen modes. The display index 0 means the default display is used.  Changed in pygame 1.9.5: display argument added  \n   pygame.display.mode_ok() \n Pick the best color depth for a display mode mode_ok(size, flags=0, depth=0, display=0) -> depth  This function uses the same arguments as pygame.display.set_mode(). It is used to determine if a requested display mode is available. It will return 0 if the display mode cannot be set. Otherwise it will return a pixel depth that best matches the display asked for. Usually the depth argument is not passed, but some platforms can support multiple display depths. If passed it will hint to which depth is a better match. The most useful flags to pass will be pygame.HWSURFACE, pygame.DOUBLEBUF, and maybe pygame.FULLSCREEN. The function will return 0 if these display flags cannot be set. The display index 0 means the default display is used.  Changed in pygame 1.9.5: display argument added  \n   pygame.display.gl_get_attribute() \n Get the value for an OpenGL flag for the current display gl_get_attribute(flag) -> value  After calling pygame.display.set_mode() with the pygame.OPENGL flag, it is a good idea to check the value of any requested OpenGL attributes. See pygame.display.gl_set_attribute() for a list of valid flags. \n   pygame.display.gl_set_attribute() \n Request an OpenGL display attribute for the display mode gl_set_attribute(flag, value) -> None  When calling pygame.display.set_mode() with the pygame.OPENGL flag, Pygame automatically handles setting the OpenGL attributes like color and double-buffering. OpenGL offers several other attributes you may want control over. Pass one of these attributes as the flag, and its appropriate value. This must be called before pygame.display.set_mode(). Many settings are the requested minimum. Creating a window with an OpenGL context will fail if OpenGL cannot provide the requested attribute, but it may for example give you a stencil buffer even if you request none, or it may give you a larger one than requested. The OPENGL flags are: GL_ALPHA_SIZE, GL_DEPTH_SIZE, GL_STENCIL_SIZE, GL_ACCUM_RED_SIZE,\nGL_ACCUM_GREEN_SIZE,  GL_ACCUM_BLUE_SIZE, GL_ACCUM_ALPHA_SIZE,\nGL_MULTISAMPLEBUFFERS, GL_MULTISAMPLESAMPLES, GL_STEREO GL_MULTISAMPLEBUFFERS  \nWhether to enable multisampling anti-aliasing. Defaults to 0 (disabled). Set GL_MULTISAMPLESAMPLES to a value above 0 to control the amount of anti-aliasing. A typical value is 2 or 3. \n GL_STENCIL_SIZE  Minimum bit size of the stencil buffer. Defaults to 0.\n GL_DEPTH_SIZE  Minimum bit size of the depth buffer. Defaults to 16.\n GL_STEREO  1 enables stereo 3D. Defaults to 0.\n GL_BUFFER_SIZE  Minimum bit size of the frame buffer. Defaults to 0.\n  New in pygame 2.0.0: Additional attributes:  GL_ACCELERATED_VISUAL,\nGL_CONTEXT_MAJOR_VERSION, GL_CONTEXT_MINOR_VERSION,\nGL_CONTEXT_FLAGS, GL_CONTEXT_PROFILE_MASK,\nGL_SHARE_WITH_CURRENT_CONTEXT,\nGL_CONTEXT_RELEASE_BEHAVIOR,\nGL_FRAMEBUFFER_SRGB_CAPABLE GL_CONTEXT_PROFILE_MASK  \nSets the OpenGL profile to one of these values: GL_CONTEXT_PROFILE_CORE             disable deprecated features\nGL_CONTEXT_PROFILE_COMPATIBILITY    allow deprecated features\nGL_CONTEXT_PROFILE_ES               allow only the ES feature\n                                    subset of OpenGL \n GL_ACCELERATED_VISUAL  Set to 1 to require hardware acceleration, or 0 to force software render. By default, both are allowed.\n \n   pygame.display.get_active() \n Returns True when the display is active on the screen get_active() -> bool  Returns True when the display Surface is considered actively renderable on the screen and may be visible to the user. This is the default state immediately after pygame.display.set_mode(). This method may return True even if the application is fully hidden behind another application window. This will return False if the display Surface has been iconified or minimized (either via pygame.display.iconify() or via an OS specific method such as the minimize-icon available on most desktops). The method can also return False for other reasons without the application being explicitly iconified or minimized by the user. A notable example being if the user has multiple virtual desktops and the display Surface is not on the active virtual desktop.  Note This function returning True is unrelated to whether the application has input focus. Please see pygame.key.get_focused() and pygame.mouse.get_focused() for APIs related to input focus.  \n   pygame.display.iconify() \n Iconify the display surface iconify() -> bool  Request the window for the display surface be iconified or hidden. Not all systems and displays support an iconified display. The function will return True if successful. When the display is iconified pygame.display.get_active() will return False. The event queue should receive an ACTIVEEVENT event when the window has been iconified. Additionally, the event queue also recieves a WINDOWEVENT_MINIMIZED event when the window has been iconified on pygame 2. \n   pygame.display.toggle_fullscreen() \n Switch between fullscreen and windowed displays toggle_fullscreen() -> int  Switches the display window between windowed and fullscreen modes. Display driver support is not great when using pygame 1, but with pygame 2 it is the most reliable method to switch to and from fullscreen. Supported display drivers in pygame 1:  \n x11 (Linux/Unix) wayland (Linux/Unix)  \n Supported display drivers in pygame 2:  \n windows (Windows) x11 (Linux/Unix) wayland (Linux/Unix) cocoa (OSX/Mac)  \n \n   pygame.display.set_gamma() \n Change the hardware gamma ramps set_gamma(red, green=None, blue=None) -> bool  Set the red, green, and blue gamma values on the display hardware. If the green and blue arguments are not passed, they will both be the same as red. Not all systems and hardware support gamma ramps, if the function succeeds it will return True. A gamma value of 1.0 creates a linear color table. Lower values will darken the display and higher values will brighten. \n   pygame.display.set_gamma_ramp() \n Change the hardware gamma ramps with a custom lookup set_gamma_ramp(red, green, blue) -> bool  Set the red, green, and blue gamma ramps with an explicit lookup table. Each argument should be sequence of 256 integers. The integers should range between 0 and 0xffff. Not all systems and hardware support gamma ramps, if the function succeeds it will return True. \n   pygame.display.set_icon() \n Change the system image for the display window set_icon(Surface) -> None  Sets the runtime icon the system will use to represent the display window. All windows default to a simple pygame logo for the window icon. You can pass any surface, but most systems want a smaller image around 32x32. The image can have colorkey transparency which will be passed to the system. Some systems do not allow the window icon to change after it has been shown. This function can be called before pygame.display.set_mode() to create the icon before the display mode is set. \n   pygame.display.set_caption() \n Set the current window caption set_caption(title, icontitle=None) -> None  If the display has a window title, this function will change the name on the window. Some systems support an alternate shorter title to be used for minimized displays. \n   pygame.display.get_caption() \n Get the current window caption get_caption() -> (title, icontitle)  Returns the title and icontitle for the display Surface. These will often be the same value. \n   pygame.display.set_palette() \n Set the display color palette for indexed displays set_palette(palette=None) -> None  This will change the video display color palette for 8-bit displays. This does not change the palette for the actual display Surface, only the palette that is used to display the Surface. If no palette argument is passed, the system default palette will be restored. The palette is a sequence of RGB triplets. \n   pygame.display.get_num_displays() \n Return the number of displays get_num_displays() -> int  Returns the number of available displays. This is always 1 if pygame.get_sdl_version() returns a major version number below 2.  New in pygame 1.9.5.  \n   pygame.display.get_window_size() \n Return the size of the window or screen get_window_size() -> tuple  Returns the size of the window initialized with pygame.display.set_mode(). This may differ from the size of the display surface if SCALED is used.  New in pygame 2.0.0.  \n   pygame.display.get_allow_screensaver() \n Return whether the screensaver is allowed to run. get_allow_screensaver() -> bool  Return whether screensaver is allowed to run whilst the app is running. Default is False. By default pygame does not allow the screensaver during game play.  Note Some platforms do not have a screensaver or support disabling the screensaver. Please see pygame.display.set_allow_screensaver() for caveats with screensaver support.   New in pygame 2.0.0.  \n   pygame.display.set_allow_screensaver() \n Set whether the screensaver may run set_allow_screensaver(bool) -> None  Change whether screensavers should be allowed whilst the app is running. The default is False. By default pygame does not allow the screensaver during game play. If the screensaver has been disallowed due to this function, it will automatically be allowed to run when pygame.quit() is called. It is possible to influence the default value via the environment variable SDL_HINT_VIDEO_ALLOW_SCREENSAVER, which can be set to either 0 (disable) or 1 (enable).  Note Disabling screensaver is subject to platform support. When platform support is absent, this function will silently appear to work even though the screensaver state is unchanged. The lack of feedback is due to SDL not providing any supported method for determining whether it supports changing the screensaver state. SDL_HINT_VIDEO_ALLOW_SCREENSAVER is available in SDL 2.0.2 or later. SDL1.2 does not implement this.   New in pygame 2.0.0.  \n \n \n"}, {"name": "display.flip", "path": "ref/display#pygame.display.flip", "type": "pygame.display", "text": "  pygame.display.flip() \n Update the full display Surface to the screen flip() -> None  This will update the contents of the entire display. If your display mode is using the flags pygame.HWSURFACE and pygame.DOUBLEBUF, this will wait for a vertical retrace and swap the surfaces. If you are using a different type of display mode, it will simply update the entire contents of the surface. When using an pygame.OPENGL display mode this will perform a gl buffer swap. \n"}, {"name": "display.get_active", "path": "ref/display#pygame.display.get_active", "type": "pygame.display", "text": "  pygame.display.get_active() \n Returns True when the display is active on the screen get_active() -> bool  Returns True when the display Surface is considered actively renderable on the screen and may be visible to the user. This is the default state immediately after pygame.display.set_mode(). This method may return True even if the application is fully hidden behind another application window. This will return False if the display Surface has been iconified or minimized (either via pygame.display.iconify() or via an OS specific method such as the minimize-icon available on most desktops). The method can also return False for other reasons without the application being explicitly iconified or minimized by the user. A notable example being if the user has multiple virtual desktops and the display Surface is not on the active virtual desktop.  Note This function returning True is unrelated to whether the application has input focus. Please see pygame.key.get_focused() and pygame.mouse.get_focused() for APIs related to input focus.  \n"}, {"name": "display.get_allow_screensaver", "path": "ref/display#pygame.display.get_allow_screensaver", "type": "pygame.display", "text": "  pygame.display.get_allow_screensaver() \n Return whether the screensaver is allowed to run. get_allow_screensaver() -> bool  Return whether screensaver is allowed to run whilst the app is running. Default is False. By default pygame does not allow the screensaver during game play.  Note Some platforms do not have a screensaver or support disabling the screensaver. Please see pygame.display.set_allow_screensaver() for caveats with screensaver support.   New in pygame 2.0.0.  \n"}, {"name": "display.get_caption", "path": "ref/display#pygame.display.get_caption", "type": "pygame.display", "text": "  pygame.display.get_caption() \n Get the current window caption get_caption() -> (title, icontitle)  Returns the title and icontitle for the display Surface. These will often be the same value. \n"}, {"name": "display.get_driver", "path": "ref/display#pygame.display.get_driver", "type": "pygame.display", "text": "  pygame.display.get_driver() \n Get the name of the pygame display backend get_driver() -> name  Pygame chooses one of many available display backends when it is initialized. This returns the internal name used for the display backend. This can be used to provide limited information about what display capabilities might be accelerated. See the SDL_VIDEODRIVER flags in pygame.display.set_mode() to see some of the common options. \n"}, {"name": "display.get_init", "path": "ref/display#pygame.display.get_init", "type": "pygame.display", "text": "  pygame.display.get_init() \n Returns True if the display module has been initialized get_init() -> bool  Returns True if the pygame.display module is currently initialized. \n"}, {"name": "display.get_num_displays", "path": "ref/display#pygame.display.get_num_displays", "type": "pygame.display", "text": "  pygame.display.get_num_displays() \n Return the number of displays get_num_displays() -> int  Returns the number of available displays. This is always 1 if pygame.get_sdl_version() returns a major version number below 2.  New in pygame 1.9.5.  \n"}, {"name": "display.get_surface", "path": "ref/display#pygame.display.get_surface", "type": "pygame.display", "text": "  pygame.display.get_surface() \n Get a reference to the currently set display surface get_surface() -> Surface  Return a reference to the currently set display Surface. If no display mode has been set this will return None. \n"}, {"name": "display.get_window_size", "path": "ref/display#pygame.display.get_window_size", "type": "pygame.display", "text": "  pygame.display.get_window_size() \n Return the size of the window or screen get_window_size() -> tuple  Returns the size of the window initialized with pygame.display.set_mode(). This may differ from the size of the display surface if SCALED is used.  New in pygame 2.0.0.  \n"}, {"name": "display.get_wm_info", "path": "ref/display#pygame.display.get_wm_info", "type": "pygame.display", "text": "  pygame.display.get_wm_info() \n Get information about the current windowing system get_wm_info() -> dict  Creates a dictionary filled with string keys. The strings and values are arbitrarily created by the system. Some systems may have no information and an empty dictionary will be returned. Most platforms will return a \"window\" key with the value set to the system id for the current display.  New in pygame 1.7.1.  \n"}, {"name": "display.gl_get_attribute", "path": "ref/display#pygame.display.gl_get_attribute", "type": "pygame.display", "text": "  pygame.display.gl_get_attribute() \n Get the value for an OpenGL flag for the current display gl_get_attribute(flag) -> value  After calling pygame.display.set_mode() with the pygame.OPENGL flag, it is a good idea to check the value of any requested OpenGL attributes. See pygame.display.gl_set_attribute() for a list of valid flags. \n"}, {"name": "display.gl_set_attribute", "path": "ref/display#pygame.display.gl_set_attribute", "type": "pygame.display", "text": "  pygame.display.gl_set_attribute() \n Request an OpenGL display attribute for the display mode gl_set_attribute(flag, value) -> None  When calling pygame.display.set_mode() with the pygame.OPENGL flag, Pygame automatically handles setting the OpenGL attributes like color and double-buffering. OpenGL offers several other attributes you may want control over. Pass one of these attributes as the flag, and its appropriate value. This must be called before pygame.display.set_mode(). Many settings are the requested minimum. Creating a window with an OpenGL context will fail if OpenGL cannot provide the requested attribute, but it may for example give you a stencil buffer even if you request none, or it may give you a larger one than requested. The OPENGL flags are: GL_ALPHA_SIZE, GL_DEPTH_SIZE, GL_STENCIL_SIZE, GL_ACCUM_RED_SIZE,\nGL_ACCUM_GREEN_SIZE,  GL_ACCUM_BLUE_SIZE, GL_ACCUM_ALPHA_SIZE,\nGL_MULTISAMPLEBUFFERS, GL_MULTISAMPLESAMPLES, GL_STEREO GL_MULTISAMPLEBUFFERS  \nWhether to enable multisampling anti-aliasing. Defaults to 0 (disabled). Set GL_MULTISAMPLESAMPLES to a value above 0 to control the amount of anti-aliasing. A typical value is 2 or 3. \n GL_STENCIL_SIZE  Minimum bit size of the stencil buffer. Defaults to 0.\n GL_DEPTH_SIZE  Minimum bit size of the depth buffer. Defaults to 16.\n GL_STEREO  1 enables stereo 3D. Defaults to 0.\n GL_BUFFER_SIZE  Minimum bit size of the frame buffer. Defaults to 0.\n  New in pygame 2.0.0: Additional attributes:  GL_ACCELERATED_VISUAL,\nGL_CONTEXT_MAJOR_VERSION, GL_CONTEXT_MINOR_VERSION,\nGL_CONTEXT_FLAGS, GL_CONTEXT_PROFILE_MASK,\nGL_SHARE_WITH_CURRENT_CONTEXT,\nGL_CONTEXT_RELEASE_BEHAVIOR,\nGL_FRAMEBUFFER_SRGB_CAPABLE GL_CONTEXT_PROFILE_MASK  \nSets the OpenGL profile to one of these values: GL_CONTEXT_PROFILE_CORE             disable deprecated features\nGL_CONTEXT_PROFILE_COMPATIBILITY    allow deprecated features\nGL_CONTEXT_PROFILE_ES               allow only the ES feature\n                                    subset of OpenGL \n GL_ACCELERATED_VISUAL  Set to 1 to require hardware acceleration, or 0 to force software render. By default, both are allowed.\n \n"}, {"name": "display.iconify", "path": "ref/display#pygame.display.iconify", "type": "pygame.display", "text": "  pygame.display.iconify() \n Iconify the display surface iconify() -> bool  Request the window for the display surface be iconified or hidden. Not all systems and displays support an iconified display. The function will return True if successful. When the display is iconified pygame.display.get_active() will return False. The event queue should receive an ACTIVEEVENT event when the window has been iconified. Additionally, the event queue also recieves a WINDOWEVENT_MINIMIZED event when the window has been iconified on pygame 2. \n"}, {"name": "display.Info", "path": "ref/display#pygame.display.Info", "type": "pygame.display", "text": "  pygame.display.Info() \n Create a video display information object Info() -> VideoInfo  Creates a simple object containing several attributes to describe the current graphics environment. If this is called before pygame.display.set_mode() some platforms can provide information about the default display mode. This can also be called after setting the display mode to verify specific display options were satisfied. The VidInfo object has several attributes: hw:         1 if the display is hardware accelerated\nwm:         1 if windowed display modes can be used\nvideo_mem:  The megabytes of video memory on the display. This is 0 if\n            unknown\nbitsize:    Number of bits used to store each pixel\nbytesize:   Number of bytes used to store each pixel\nmasks:      Four values used to pack RGBA values into pixels\nshifts:     Four values used to pack RGBA values into pixels\nlosses:     Four values used to pack RGBA values into pixels\nblit_hw:    1 if hardware Surface blitting is accelerated\nblit_hw_CC: 1 if hardware Surface colorkey blitting is accelerated\nblit_hw_A:  1 if hardware Surface pixel alpha blitting is accelerated\nblit_sw:    1 if software Surface blitting is accelerated\nblit_sw_CC: 1 if software Surface colorkey blitting is accelerated\nblit_sw_A:  1 if software Surface pixel alpha blitting is accelerated\ncurrent_h, current_w:  Height and width of the current video mode, or\n            of the desktop mode if called before the display.set_mode\n            is called. (current_h, current_w are available since\n            SDL 1.2.10, and pygame 1.8.0). They are -1 on error, or if\n            an old SDL is being used. \n"}, {"name": "display.init", "path": "ref/display#pygame.display.init", "type": "pygame.display", "text": "  pygame.display.init() \n Initialize the display module init() -> None  Initializes the pygame display module. The display module cannot do anything until it is initialized. This is usually handled for you automatically when you call the higher level pygame.init(). Pygame will select from one of several internal display backends when it is initialized. The display mode will be chosen depending on the platform and permissions of current user. Before the display module is initialized the environment variable SDL_VIDEODRIVER can be set to control which backend is used. The systems with multiple choices are listed here. Windows : windib, directx\nUnix    : x11, dga, fbcon, directfb, ggi, vgl, svgalib, aalib On some platforms it is possible to embed the pygame display into an already existing window. To do this, the environment variable SDL_WINDOWID must be set to a string containing the window id or handle. The environment variable is checked when the pygame display is initialized. Be aware that there can be many strange side effects when running in an embedded display. It is harmless to call this more than once, repeated calls have no effect. \n"}, {"name": "display.list_modes", "path": "ref/display#pygame.display.list_modes", "type": "pygame.display", "text": "  pygame.display.list_modes() \n Get list of available fullscreen modes list_modes(depth=0, flags=pygame.FULLSCREEN, display=0) -> list  This function returns a list of possible sizes for a specified color depth. The return value will be an empty list if no display modes are available with the given arguments. A return value of -1 means that any requested size should work (this is likely the case for windowed modes). Mode sizes are sorted from biggest to smallest. If depth is 0, the current/best color depth for the display is used. The flags defaults to pygame.FULLSCREEN, but you may need to add additional flags for specific fullscreen modes. The display index 0 means the default display is used.  Changed in pygame 1.9.5: display argument added  \n"}, {"name": "display.mode_ok", "path": "ref/display#pygame.display.mode_ok", "type": "pygame.display", "text": "  pygame.display.mode_ok() \n Pick the best color depth for a display mode mode_ok(size, flags=0, depth=0, display=0) -> depth  This function uses the same arguments as pygame.display.set_mode(). It is used to determine if a requested display mode is available. It will return 0 if the display mode cannot be set. Otherwise it will return a pixel depth that best matches the display asked for. Usually the depth argument is not passed, but some platforms can support multiple display depths. If passed it will hint to which depth is a better match. The most useful flags to pass will be pygame.HWSURFACE, pygame.DOUBLEBUF, and maybe pygame.FULLSCREEN. The function will return 0 if these display flags cannot be set. The display index 0 means the default display is used.  Changed in pygame 1.9.5: display argument added  \n"}, {"name": "display.quit", "path": "ref/display#pygame.display.quit", "type": "pygame.display", "text": "  pygame.display.quit() \n Uninitialize the display module quit() -> None  This will shut down the entire display module. This means any active displays will be closed. This will also be handled automatically when the program exits. It is harmless to call this more than once, repeated calls have no effect. \n"}, {"name": "display.set_allow_screensaver", "path": "ref/display#pygame.display.set_allow_screensaver", "type": "pygame.display", "text": "  pygame.display.set_allow_screensaver() \n Set whether the screensaver may run set_allow_screensaver(bool) -> None  Change whether screensavers should be allowed whilst the app is running. The default is False. By default pygame does not allow the screensaver during game play. If the screensaver has been disallowed due to this function, it will automatically be allowed to run when pygame.quit() is called. It is possible to influence the default value via the environment variable SDL_HINT_VIDEO_ALLOW_SCREENSAVER, which can be set to either 0 (disable) or 1 (enable).  Note Disabling screensaver is subject to platform support. When platform support is absent, this function will silently appear to work even though the screensaver state is unchanged. The lack of feedback is due to SDL not providing any supported method for determining whether it supports changing the screensaver state. SDL_HINT_VIDEO_ALLOW_SCREENSAVER is available in SDL 2.0.2 or later. SDL1.2 does not implement this.   New in pygame 2.0.0.  \n"}, {"name": "display.set_caption", "path": "ref/display#pygame.display.set_caption", "type": "pygame.display", "text": "  pygame.display.set_caption() \n Set the current window caption set_caption(title, icontitle=None) -> None  If the display has a window title, this function will change the name on the window. Some systems support an alternate shorter title to be used for minimized displays. \n"}, {"name": "display.set_gamma", "path": "ref/display#pygame.display.set_gamma", "type": "pygame.display", "text": "  pygame.display.set_gamma() \n Change the hardware gamma ramps set_gamma(red, green=None, blue=None) -> bool  Set the red, green, and blue gamma values on the display hardware. If the green and blue arguments are not passed, they will both be the same as red. Not all systems and hardware support gamma ramps, if the function succeeds it will return True. A gamma value of 1.0 creates a linear color table. Lower values will darken the display and higher values will brighten. \n"}, {"name": "display.set_gamma_ramp", "path": "ref/display#pygame.display.set_gamma_ramp", "type": "pygame.display", "text": "  pygame.display.set_gamma_ramp() \n Change the hardware gamma ramps with a custom lookup set_gamma_ramp(red, green, blue) -> bool  Set the red, green, and blue gamma ramps with an explicit lookup table. Each argument should be sequence of 256 integers. The integers should range between 0 and 0xffff. Not all systems and hardware support gamma ramps, if the function succeeds it will return True. \n"}, {"name": "display.set_icon", "path": "ref/display#pygame.display.set_icon", "type": "pygame.display", "text": "  pygame.display.set_icon() \n Change the system image for the display window set_icon(Surface) -> None  Sets the runtime icon the system will use to represent the display window. All windows default to a simple pygame logo for the window icon. You can pass any surface, but most systems want a smaller image around 32x32. The image can have colorkey transparency which will be passed to the system. Some systems do not allow the window icon to change after it has been shown. This function can be called before pygame.display.set_mode() to create the icon before the display mode is set. \n"}, {"name": "display.set_mode", "path": "ref/display#pygame.display.set_mode", "type": "pygame.display", "text": "  pygame.display.set_mode() \n Initialize a window or screen for display set_mode(size=(0, 0), flags=0, depth=0, display=0, vsync=0) -> Surface  This function will create a display Surface. The arguments passed in are requests for a display type. The actual created display will be the best possible match supported by the system. The size argument is a pair of numbers representing the width and height. The flags argument is a collection of additional options. The depth argument represents the number of bits to use for color. The Surface that gets returned can be drawn to like a regular Surface but changes will eventually be seen on the monitor. If no size is passed or is set to (0, 0) and pygame uses SDL version 1.2.10 or above, the created Surface will have the same size as the current screen resolution. If only the width or height are set to 0, the Surface will have the same width or height as the screen resolution. Using a SDL version prior to 1.2.10 will raise an exception. It is usually best to not pass the depth argument. It will default to the best and fastest color depth for the system. If your game requires a specific color format you can control the depth with this argument. Pygame will emulate an unavailable color depth which can be slow. When requesting fullscreen display modes, sometimes an exact match for the requested size cannot be made. In these situations pygame will select the closest compatible match. The returned surface will still always match the requested size. On high resolution displays(4k, 1080p) and tiny graphics games (640x480) show up very small so that they are unplayable. SCALED scales up the window for you. The game thinks it's a 640x480 window, but really it can be bigger. Mouse events are scaled for you, so your game doesn't need to do it. Note that SCALED is considered an experimental API and may change in future releases. The flags argument controls which type of display you want. There are several to choose from, and you can even combine multiple types using the bitwise or operator, (the pipe \"|\" character). If you pass 0 or no flags argument it will default to a software driven window. Here are the display flags you will want to choose from: pygame.FULLSCREEN    create a fullscreen display\npygame.DOUBLEBUF     recommended for HWSURFACE or OPENGL\npygame.HWSURFACE     hardware accelerated, only in FULLSCREEN\npygame.OPENGL        create an OpenGL-renderable display\npygame.RESIZABLE     display window should be sizeable\npygame.NOFRAME       display window will have no border or controls Pygame 2 has the following additional flags available. pygame.SCALED        resolution depends on desktop size and scale\n                     graphics\npygame.SHOWN         window is opened in visible mode (default)\npygame.HIDDEN        window is opened in hidden mode  New in pygame 2.0.0: SCALED, SHOWN and HIDDEN  By setting the vsync parameter to 1, it is possible to get a display with vertical sync, but you are not guaranteed to get one. The request only works at all for calls to set_mode() with the pygame.OPENGL or pygame.SCALED flags set, and is still not guaranteed even with one of those set. What you get depends on the hardware and driver configuration of the system pygame is running on. Here is an example usage of a call to set_mode() that may give you a display with vsync: flags = pygame.OPENGL | pygame.FULLSCREEN\nwindow_surface = pygame.display.set_mode((1920, 1080), flags, vsync=1) Vsync behaviour is considered experimental, and may change in future releases.  New in pygame 2.0.0: vsync  Basic example: # Open a window on the screen\nscreen_width=700\nscreen_height=400\nscreen=pygame.display.set_mode([screen_width, screen_height]) The display index 0 means the default display is used.  Changed in pygame 1.9.5: display argument added  \n"}, {"name": "display.set_palette", "path": "ref/display#pygame.display.set_palette", "type": "pygame.display", "text": "  pygame.display.set_palette() \n Set the display color palette for indexed displays set_palette(palette=None) -> None  This will change the video display color palette for 8-bit displays. This does not change the palette for the actual display Surface, only the palette that is used to display the Surface. If no palette argument is passed, the system default palette will be restored. The palette is a sequence of RGB triplets. \n"}, {"name": "display.toggle_fullscreen", "path": "ref/display#pygame.display.toggle_fullscreen", "type": "pygame.display", "text": "  pygame.display.toggle_fullscreen() \n Switch between fullscreen and windowed displays toggle_fullscreen() -> int  Switches the display window between windowed and fullscreen modes. Display driver support is not great when using pygame 1, but with pygame 2 it is the most reliable method to switch to and from fullscreen. Supported display drivers in pygame 1:  \n x11 (Linux/Unix) wayland (Linux/Unix)  \n Supported display drivers in pygame 2:  \n windows (Windows) x11 (Linux/Unix) wayland (Linux/Unix) cocoa (OSX/Mac)  \n \n"}, {"name": "display.update", "path": "ref/display#pygame.display.update", "type": "pygame.display", "text": "  pygame.display.update() \n Update portions of the screen for software displays update(rectangle=None) -> None update(rectangle_list) -> None  This function is like an optimized version of pygame.display.flip() for software displays. It allows only a portion of the screen to updated, instead of the entire area. If no argument is passed it updates the entire Surface area like pygame.display.flip(). You can pass the function a single rectangle, or a sequence of rectangles. It is more efficient to pass many rectangles at once than to call update multiple times with single or a partial list of rectangles. If passing a sequence of rectangles it is safe to include None values in the list, which will be skipped. This call cannot be used on pygame.OPENGL displays and will generate an exception. \n"}, {"name": "draw", "path": "ref/draw", "type": "pygame.draw", "text": " pygame.draw\n  \n pygame module for drawing shapes  Draw several simple shapes to a surface. These functions will work for rendering to any format of surface. Rendering to hardware surfaces will be slower than regular software surfaces. Most of the functions take a width argument to represent the size of stroke (thickness) around the edge of the shape. If a width of 0 is passed the shape will be filled (solid). All the drawing functions respect the clip area for the surface and will be constrained to that area. The functions return a rectangle representing the bounding area of changed pixels. This bounding rectangle is the 'minimum' bounding box that encloses the affected area. All the drawing functions accept a color argument that can be one of the following formats:  \n a pygame.Color object an (RGB) triplet (tuple/list) an (RGBA) quadruplet (tuple/list) an integer value that has been mapped to the surface's pixel format (see pygame.Surface.map_rgb() and pygame.Surface.unmap_rgb())  \n A color's alpha value will be written directly into the surface (if the surface contains pixel alphas), but the draw function will not draw transparently. These functions temporarily lock the surface they are operating on. Many sequential drawing calls can be sped up by locking and unlocking the surface object around the draw calls (see pygame.Surface.lock() and pygame.Surface.unlock()).  Note See the pygame.gfxdraw module for alternative draw methods.    pygame.draw.rect() \n draw a rectangle rect(surface, color, rect) -> Rect rect(surface, color, rect, width=0, border_radius=0, border_top_left_radius=-1, border_top_right_radius=-1, border_bottom_left_radius=-1, border_bottom_right_radius=-1) -> Rect  Draws a rectangle on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nrect (Rect) -- rectangle to draw, position and dimensions \nwidth (int) -- (optional) used for line thickness or to indicate that the rectangle is to be filled (not to be confused with the width value of the rect parameter)  \n if width == 0, (default) fill the rectangle if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will grow outside the original boundary of the rect. For more details on how the thickness for edge lines grow, refer to the width notes of the pygame.draw.line() function.  \n  \nborder_radius (int) -- (optional) used for drawing rectangle with rounded corners. The supported range is [0, min(height, width) / 2], with 0 representing a rectangle without rounded corners. \nborder_top_left_radius (int) -- (optional) used for setting the value of top left border. If you don't set this value, it will use the border_radius value. \nborder_top_right_radius (int) -- (optional) used for setting the value of top right border. If you don't set this value, it will use the border_radius value. \nborder_bottom_left_radius (int) -- (optional) used for setting the value of bottom left border. If you don't set this value, it will use the border_radius value. \nborder_bottom_right_radius (int) -- (optional) used for setting the value of bottom right border. If you don't set this value, it will use the border_radius value.  \n if border_radius < 1 it will draw rectangle without rounded corners if any of border radii has the value < 0 it will use value of the border_radius If sum of radii on the same side of the rectangle is greater than the rect size the radii will get scaled  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given rect parameter and its width and height will be 0   \nReturn type:\n\nRect      Note The pygame.Surface.fill() method works just as well for drawing filled rectangles and can be hardware accelerated on some platforms with both software and hardware display modes.   Changed in pygame 2.0.0: Added support for keyword arguments.   Changed in pygame 2.0.0.dev8: Added support for border radius.  \n   pygame.draw.polygon() \n draw a polygon polygon(surface, color, points) -> Rect polygon(surface, color, points, width=0) -> Rect  Draws a polygon on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates that make up the vertices of the polygon, each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats, e.g. [(x1, y1), (x2, y2), (x3, y3)]\n \nwidth (int) -- (optional) used for line thickness or to indicate that the polygon is to be filled  \n if width == 0, (default) fill the polygon if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will grow outside the original boundary of the polygon. For more details on how the thickness for edge lines grow, refer to the width notes of the pygame.draw.line() function.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the points parameter (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nTypeError -- if points is not a sequence or points does not contain number pairs       Note For an aapolygon, use aalines() with closed=True.   Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.circle() \n draw a circle circle(surface, color, center, radius) -> Rect circle(surface, color, center, radius, width=0, draw_top_right=None, draw_top_left=None, draw_bottom_left=None, draw_bottom_right=None) -> Rect  Draws a circle on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \ncenter (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- center point of the circle as a sequence of 2 ints/floats, e.g. (x, y)\n \nradius (int or float) -- radius of the circle, measured from the center parameter, nothing will be drawn if the radius is less than 1 \nwidth (int) -- (optional) used for line thickness or to indicate that the circle is to be filled  \n if width == 0, (default) fill the circle if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will only grow inward.  \n  \ndraw_top_right (bool) -- (optional) if this is set to True then the top right corner of the circle will be drawn \ndraw_top_left (bool) -- (optional) if this is set to True then the top left corner of the circle will be drawn \ndraw_bottom_left (bool) -- (optional) if this is set to True then the bottom left corner of the circle will be drawn \ndraw_bottom_right (bool) -- (optional) if this is set to True then the bottom right corner of the circle will be drawn  \n if any of the draw_circle_part is True then it will draw all circle parts that have the True value, otherwise it will draw the entire circle.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the center parameter value (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nTypeError -- if center is not a sequence of two numbers \nTypeError -- if radius is not a number       Changed in pygame 2.0.0: Added support for keyword arguments. Nothing is drawn when the radius is 0 (a pixel at the center coordinates used to be drawn when the radius equaled 0). Floats, and Vector2 are accepted for the center param. The drawing algorithm was improved to look more like a circle.   Changed in pygame 2.0.0.dev8: Added support for drawing circle quadrants.  \n   pygame.draw.ellipse() \n draw an ellipse ellipse(surface, color, rect) -> Rect ellipse(surface, color, rect, width=0) -> Rect  Draws an ellipse on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nrect (Rect) -- rectangle to indicate the position and dimensions of the ellipse, the ellipse will be centered inside the rectangle and bounded by it \nwidth (int) -- (optional) used for line thickness or to indicate that the ellipse is to be filled (not to be confused with the width value of the rect parameter)  \n if width == 0, (default) fill the ellipse if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will only grow inward from the original boundary of the rect parameter.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given rect parameter and its width and height will be 0   \nReturn type:\n\nRect      Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.arc() \n draw an elliptical arc arc(surface, color, rect, start_angle, stop_angle) -> Rect arc(surface, color, rect, start_angle, stop_angle, width=1) -> Rect  Draws an elliptical arc on the given surface. The two angle arguments are given in radians and indicate the start and stop positions of the arc. The arc is drawn in a counterclockwise direction from the start_angle to the stop_angle.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nrect (Rect) -- rectangle to indicate the position and dimensions of the ellipse which the arc will be based on, the ellipse will be centered inside the rectangle \nstart_angle (float) -- start angle of the arc in radians \nstop_angle (float) -- stop angle of the arc in radians  \n if start_angle < stop_angle, the arc is drawn in a counterclockwise direction from the start_angle to the stop_angle\n if start_angle > stop_angle, tau (tau == 2 * pi) will be added to the stop_angle, if the resulting stop angle value is greater than the start_angle the above start_angle < stop_angle case applies, otherwise nothing will be drawn if start_angle == stop_angle, nothing will be drawn   \n  \nwidth (int) -- (optional) used for line thickness (not to be confused with the width value of the rect parameter)  \n if width == 0, nothing will be drawn if width > 0, (default is 1) used for line thickness if width < 0, same as width == 0\n   Note When using width values > 1, the edge lines will only grow inward from the original boundary of the rect parameter.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given rect parameter and its width and height will be 0   \nReturn type:\n\nRect      Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.line() \n draw a straight line line(surface, color, start_pos, end_pos, width) -> Rect line(surface, color, start_pos, end_pos, width=1) -> Rect  Draws a straight line on the given surface. There are no endcaps. For thick lines the ends are squared off.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nstart_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- start position of the line, (x, y) \nend_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- end position of the line, (x, y) \nwidth (int) -- (optional) used for line thickness  if width >= 1, used for line thickness (default is 1) if width < 1, nothing will be drawn    Note When using width values > 1, lines will grow as follows. For odd width values, the thickness of each line grows with the original line being in the center. For even width values, the thickness of each line grows with the original line being offset from the center (as there is no exact center line drawn). As a result, lines with a slope < 1 (horizontal-ish) will have 1 more pixel of thickness below the original line (in the y direction). Lines with a slope >= 1 (vertical-ish) will have 1 more pixel of thickness to the right of the original line (in the x direction).      \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the start_pos parameter value (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\nTypeError -- if start_pos or end_pos is not a sequence of two numbers      Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.lines() \n draw multiple contiguous straight line segments lines(surface, color, closed, points) -> Rect lines(surface, color, closed, points, width=1) -> Rect  Draws a sequence of contiguous straight lines on the given surface. There are no endcaps or miter joints. For thick lines the ends are squared off. Drawing thick lines with sharp corners can have undesired looking results.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nclosed (bool) -- if True an additional line segment is drawn between the first and last points in the points sequence \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 2 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats and adjacent coordinates will be connected by a line segment, e.g. for the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2) and from (x2, y2) to (x3, y3), additionally if the closed parameter is True another line segment will be drawn from (x3, y3) to (x1, y1)\n \nwidth (int) -- (optional) used for line thickness  if width >= 1, used for line thickness (default is 1) if width < 1, nothing will be drawn    Note When using width values > 1 refer to the width notes of line() for details on how thick lines grow.      \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the points parameter (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nValueError -- if len(points) < 2 (must have at least 2 points) \nTypeError -- if points is not a sequence or points does not contain number pairs       Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.aaline() \n draw a straight antialiased line aaline(surface, color, start_pos, end_pos) -> Rect aaline(surface, color, start_pos, end_pos, blend=1) -> Rect  Draws a straight antialiased line on the given surface. The line has a thickness of one pixel and the endpoints have a height and width of one pixel each.  The way a line and it's endpoints are drawn: \nIf both endpoints are equal, only a single pixel is drawn (after rounding floats to nearest integer). Otherwise if the line is not steep (i.e. if the length along the x-axis is greater than the height along the y-axis):  \nFor each endpoint:  \nIf x, the endpoint's x-coordinate, is a whole number find which pixels would be covered by it and draw them. Otherwise:  \nCalculate the position of the nearest point with a whole number for it's x-coordinate, when extending the line past the endpoint. Find which pixels would be covered and how much by that point. If the endpoint is the left one, multiply the coverage by (1 - the decimal part of x). Otherwise multiply the coverage by the decimal part of x. Then draw those pixels.  e.g.: \n The left endpoint of the line ((1, 1.3), (5, 3)) would cover 70% of the pixel (1, 1) and 30% of the pixel (1, 2) while the right one would cover 100% of the pixel (5, 3). The left endpoint of the line ((1.2, 1.4), (4.6, 3.1)) would cover 56% (i.e. 0.8 * 70%) of the pixel (1, 1) and 24% (i.e. 0.8 * 30%) of the pixel (1, 2) while the right one would cover 42% (i.e. 0.6 * 70%) of the pixel (5, 3) and 18% (i.e. 0.6 * 30%) of the pixel (5, 4) while the right    \n \n Then for each point between the endpoints, along the line, whose x-coordinate is a whole number:  \nFind which pixels would be covered and how much by that point and draw them.  e.g.: \n The points along the line ((1, 1), (4, 2.5)) would be (2, 1.5) and (3, 2) and would cover 50% of the pixel (2, 1), 50% of the pixel (2, 2) and 100% of the pixel (3, 2). The points along the line ((1.2, 1.4), (4.6, 3.1)) would be (2, 1.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)), (3, 2.3) (covering 70% of the pixel (3, 2) and 30% of the pixel (3, 3)) and (4,\n2.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2))    \n \n Otherwise do the same for steep lines as for non-steep lines except along the y-axis instead of the x-axis (using y instead of x, top instead of left and bottom instead of right).    Note Regarding float values for coordinates, a point with coordinate consisting of two whole numbers is considered being right in the center of said pixel (and having a height and width of 1 pixel would therefore completely cover it), while a point with coordinate where one (or both) of the numbers have non-zero decimal parts would be partially covering two (or four if both numbers have decimal parts) adjacent pixels, e.g. the point (1.4, 2) covers 60% of the pixel (1, 2) and 40% of the pixel (2,2).      \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nstart_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- start position of the line, (x, y) \nend_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- end position of the line, (x, y) \nblend (int) -- (optional) if non-zero (default) the line will be blended with the surface's existing pixel shades, otherwise it will overwrite them    \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the start_pos parameter value (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\nTypeError -- if start_pos or end_pos is not a sequence of two numbers      Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.aalines() \n draw multiple contiguous straight antialiased line segments aalines(surface, color, closed, points) -> Rect aalines(surface, color, closed, points, blend=1) -> Rect  Draws a sequence of contiguous straight antialiased lines on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nclosed (bool) -- if True an additional line segment is drawn between the first and last points in the points sequence \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 2 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats and adjacent coordinates will be connected by a line segment, e.g. for the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2) and from (x2, y2) to (x3, y3), additionally if the closed parameter is True another line segment will be drawn from (x3, y3) to (x1, y1)\n \nblend (int) -- (optional) if non-zero (default) each line will be blended with the surface's existing pixel shades, otherwise the pixels will be overwritten    \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the points parameter (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nValueError -- if len(points) < 2 (must have at least 2 points) \nTypeError -- if points is not a sequence or points does not contain number pairs       Changed in pygame 2.0.0: Added support for keyword arguments.  \n   Example code for draw module.  # Import a library of functions called 'pygame'\nimport pygame\nfrom math import pi\n \n# Initialize the game engine\npygame.init()\n \n# Define the colors we will use in RGB format\nBLACK = (  0,   0,   0)\nWHITE = (255, 255, 255)\nBLUE =  (  0,   0, 255)\nGREEN = (  0, 255,   0)\nRED =   (255,   0,   0)\n \n# Set the height and width of the screen\nsize = [400, 300]\nscreen = pygame.display.set_mode(size)\n \npygame.display.set_caption(\"Example code for the draw module\")\n \n#Loop until the user clicks the close button.\ndone = False\nclock = pygame.time.Clock()\n \nwhile not done:\n \n    # This limits the while loop to a max of 10 times per second.\n    # Leave this out and we will use all CPU we can.\n    clock.tick(10)\n     \n    for event in pygame.event.get(): # User did something\n        if event.type == pygame.QUIT: # If user clicked close\n            done=True # Flag that we are done so we exit this loop\n \n    # All drawing code happens after the for loop and but\n    # inside the main while done==False loop.\n     \n    # Clear the screen and set the screen background\n    screen.fill(WHITE)\n \n    # Draw on the screen a GREEN line from (0, 0) to (50, 30) \n    # 5 pixels wide.\n    pygame.draw.line(screen, GREEN, [0, 0], [50,30], 5)\n \n    # Draw on the screen 3 BLACK lines, each 5 pixels wide.\n    # The 'False' means the first and last points are not connected.\n    pygame.draw.lines(screen, BLACK, False, [[0, 80], [50, 90], [200, 80], [220, 30]], 5)\n    \n    # Draw on the screen a GREEN line from (0, 50) to (50, 80) \n    # Because it is an antialiased line, it is 1 pixel wide.\n    pygame.draw.aaline(screen, GREEN, [0, 50],[50, 80], True)\n\n    # Draw a rectangle outline\n    pygame.draw.rect(screen, BLACK, [75, 10, 50, 20], 2)\n     \n    # Draw a solid rectangle\n    pygame.draw.rect(screen, BLACK, [150, 10, 50, 20])\n\n    # Draw a rectangle with rounded corners\n    pygame.draw.rect(screen, GREEN, [115, 210, 70, 40], 10, border_radius=15)\n    pygame.draw.rect(screen, RED, [135, 260, 50, 30], 0, border_radius=10, border_top_left_radius=0,\n                     border_bottom_right_radius=15)\n\n    # Draw an ellipse outline, using a rectangle as the outside boundaries\n    pygame.draw.ellipse(screen, RED, [225, 10, 50, 20], 2) \n\n    # Draw an solid ellipse, using a rectangle as the outside boundaries\n    pygame.draw.ellipse(screen, RED, [300, 10, 50, 20]) \n \n    # This draws a triangle using the polygon command\n    pygame.draw.polygon(screen, BLACK, [[100, 100], [0, 200], [200, 200]], 5)\n  \n    # Draw an arc as part of an ellipse. \n    # Use radians to determine what angle to draw.\n    pygame.draw.arc(screen, BLACK,[210, 75, 150, 125], 0, pi/2, 2)\n    pygame.draw.arc(screen, GREEN,[210, 75, 150, 125], pi/2, pi, 2)\n    pygame.draw.arc(screen, BLUE, [210, 75, 150, 125], pi,3*pi/2, 2)\n    pygame.draw.arc(screen, RED,  [210, 75, 150, 125], 3*pi/2, 2*pi, 2)\n    \n    # Draw a circle\n    pygame.draw.circle(screen, BLUE, [60, 250], 40)\n\n    # Draw only one circle quadrant\n    pygame.draw.circle(screen, BLUE, [250, 250], 40, 0, draw_top_right=True)\n    pygame.draw.circle(screen, RED, [250, 250], 40, 30, draw_top_left=True)\n    pygame.draw.circle(screen, GREEN, [250, 250], 40, 20, draw_bottom_left=True)\n    pygame.draw.circle(screen, BLACK, [250, 250], 40, 10, draw_bottom_right=True)\n\n    # Go ahead and update the screen with what we've drawn.\n    # This MUST happen after all the other drawing commands.\n    pygame.display.flip()\n \n# Be IDLE friendly\npygame.quit() \n \n"}, {"name": "draw.aaline", "path": "ref/draw#pygame.draw.aaline", "type": "pygame.draw", "text": "  pygame.draw.aaline() \n draw a straight antialiased line aaline(surface, color, start_pos, end_pos) -> Rect aaline(surface, color, start_pos, end_pos, blend=1) -> Rect  Draws a straight antialiased line on the given surface. The line has a thickness of one pixel and the endpoints have a height and width of one pixel each.  The way a line and it's endpoints are drawn: \nIf both endpoints are equal, only a single pixel is drawn (after rounding floats to nearest integer). Otherwise if the line is not steep (i.e. if the length along the x-axis is greater than the height along the y-axis):  \nFor each endpoint:  \nIf x, the endpoint's x-coordinate, is a whole number find which pixels would be covered by it and draw them. Otherwise:  \nCalculate the position of the nearest point with a whole number for it's x-coordinate, when extending the line past the endpoint. Find which pixels would be covered and how much by that point. If the endpoint is the left one, multiply the coverage by (1 - the decimal part of x). Otherwise multiply the coverage by the decimal part of x. Then draw those pixels.  e.g.: \n The left endpoint of the line ((1, 1.3), (5, 3)) would cover 70% of the pixel (1, 1) and 30% of the pixel (1, 2) while the right one would cover 100% of the pixel (5, 3). The left endpoint of the line ((1.2, 1.4), (4.6, 3.1)) would cover 56% (i.e. 0.8 * 70%) of the pixel (1, 1) and 24% (i.e. 0.8 * 30%) of the pixel (1, 2) while the right one would cover 42% (i.e. 0.6 * 70%) of the pixel (5, 3) and 18% (i.e. 0.6 * 30%) of the pixel (5, 4) while the right    \n \n Then for each point between the endpoints, along the line, whose x-coordinate is a whole number:  \nFind which pixels would be covered and how much by that point and draw them.  e.g.: \n The points along the line ((1, 1), (4, 2.5)) would be (2, 1.5) and (3, 2) and would cover 50% of the pixel (2, 1), 50% of the pixel (2, 2) and 100% of the pixel (3, 2). The points along the line ((1.2, 1.4), (4.6, 3.1)) would be (2, 1.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)), (3, 2.3) (covering 70% of the pixel (3, 2) and 30% of the pixel (3, 3)) and (4,\n2.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2))    \n \n Otherwise do the same for steep lines as for non-steep lines except along the y-axis instead of the x-axis (using y instead of x, top instead of left and bottom instead of right).    Note Regarding float values for coordinates, a point with coordinate consisting of two whole numbers is considered being right in the center of said pixel (and having a height and width of 1 pixel would therefore completely cover it), while a point with coordinate where one (or both) of the numbers have non-zero decimal parts would be partially covering two (or four if both numbers have decimal parts) adjacent pixels, e.g. the point (1.4, 2) covers 60% of the pixel (1, 2) and 40% of the pixel (2,2).      \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nstart_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- start position of the line, (x, y) \nend_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- end position of the line, (x, y) \nblend (int) -- (optional) if non-zero (default) the line will be blended with the surface's existing pixel shades, otherwise it will overwrite them    \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the start_pos parameter value (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\nTypeError -- if start_pos or end_pos is not a sequence of two numbers      Changed in pygame 2.0.0: Added support for keyword arguments.  \n"}, {"name": "draw.aalines", "path": "ref/draw#pygame.draw.aalines", "type": "pygame.draw", "text": "  pygame.draw.aalines() \n draw multiple contiguous straight antialiased line segments aalines(surface, color, closed, points) -> Rect aalines(surface, color, closed, points, blend=1) -> Rect  Draws a sequence of contiguous straight antialiased lines on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nclosed (bool) -- if True an additional line segment is drawn between the first and last points in the points sequence \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 2 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats and adjacent coordinates will be connected by a line segment, e.g. for the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2) and from (x2, y2) to (x3, y3), additionally if the closed parameter is True another line segment will be drawn from (x3, y3) to (x1, y1)\n \nblend (int) -- (optional) if non-zero (default) each line will be blended with the surface's existing pixel shades, otherwise the pixels will be overwritten    \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the points parameter (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nValueError -- if len(points) < 2 (must have at least 2 points) \nTypeError -- if points is not a sequence or points does not contain number pairs       Changed in pygame 2.0.0: Added support for keyword arguments.  \n"}, {"name": "draw.arc", "path": "ref/draw#pygame.draw.arc", "type": "pygame.draw", "text": "  pygame.draw.arc() \n draw an elliptical arc arc(surface, color, rect, start_angle, stop_angle) -> Rect arc(surface, color, rect, start_angle, stop_angle, width=1) -> Rect  Draws an elliptical arc on the given surface. The two angle arguments are given in radians and indicate the start and stop positions of the arc. The arc is drawn in a counterclockwise direction from the start_angle to the stop_angle.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nrect (Rect) -- rectangle to indicate the position and dimensions of the ellipse which the arc will be based on, the ellipse will be centered inside the rectangle \nstart_angle (float) -- start angle of the arc in radians \nstop_angle (float) -- stop angle of the arc in radians  \n if start_angle < stop_angle, the arc is drawn in a counterclockwise direction from the start_angle to the stop_angle\n if start_angle > stop_angle, tau (tau == 2 * pi) will be added to the stop_angle, if the resulting stop angle value is greater than the start_angle the above start_angle < stop_angle case applies, otherwise nothing will be drawn if start_angle == stop_angle, nothing will be drawn   \n  \nwidth (int) -- (optional) used for line thickness (not to be confused with the width value of the rect parameter)  \n if width == 0, nothing will be drawn if width > 0, (default is 1) used for line thickness if width < 0, same as width == 0\n   Note When using width values > 1, the edge lines will only grow inward from the original boundary of the rect parameter.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given rect parameter and its width and height will be 0   \nReturn type:\n\nRect      Changed in pygame 2.0.0: Added support for keyword arguments.  \n"}, {"name": "draw.circle", "path": "ref/draw#pygame.draw.circle", "type": "pygame.draw", "text": "  pygame.draw.circle() \n draw a circle circle(surface, color, center, radius) -> Rect circle(surface, color, center, radius, width=0, draw_top_right=None, draw_top_left=None, draw_bottom_left=None, draw_bottom_right=None) -> Rect  Draws a circle on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \ncenter (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- center point of the circle as a sequence of 2 ints/floats, e.g. (x, y)\n \nradius (int or float) -- radius of the circle, measured from the center parameter, nothing will be drawn if the radius is less than 1 \nwidth (int) -- (optional) used for line thickness or to indicate that the circle is to be filled  \n if width == 0, (default) fill the circle if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will only grow inward.  \n  \ndraw_top_right (bool) -- (optional) if this is set to True then the top right corner of the circle will be drawn \ndraw_top_left (bool) -- (optional) if this is set to True then the top left corner of the circle will be drawn \ndraw_bottom_left (bool) -- (optional) if this is set to True then the bottom left corner of the circle will be drawn \ndraw_bottom_right (bool) -- (optional) if this is set to True then the bottom right corner of the circle will be drawn  \n if any of the draw_circle_part is True then it will draw all circle parts that have the True value, otherwise it will draw the entire circle.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the center parameter value (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nTypeError -- if center is not a sequence of two numbers \nTypeError -- if radius is not a number       Changed in pygame 2.0.0: Added support for keyword arguments. Nothing is drawn when the radius is 0 (a pixel at the center coordinates used to be drawn when the radius equaled 0). Floats, and Vector2 are accepted for the center param. The drawing algorithm was improved to look more like a circle.   Changed in pygame 2.0.0.dev8: Added support for drawing circle quadrants.  \n"}, {"name": "draw.ellipse", "path": "ref/draw#pygame.draw.ellipse", "type": "pygame.draw", "text": "  pygame.draw.ellipse() \n draw an ellipse ellipse(surface, color, rect) -> Rect ellipse(surface, color, rect, width=0) -> Rect  Draws an ellipse on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nrect (Rect) -- rectangle to indicate the position and dimensions of the ellipse, the ellipse will be centered inside the rectangle and bounded by it \nwidth (int) -- (optional) used for line thickness or to indicate that the ellipse is to be filled (not to be confused with the width value of the rect parameter)  \n if width == 0, (default) fill the ellipse if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will only grow inward from the original boundary of the rect parameter.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given rect parameter and its width and height will be 0   \nReturn type:\n\nRect      Changed in pygame 2.0.0: Added support for keyword arguments.  \n"}, {"name": "draw.line", "path": "ref/draw#pygame.draw.line", "type": "pygame.draw", "text": "  pygame.draw.line() \n draw a straight line line(surface, color, start_pos, end_pos, width) -> Rect line(surface, color, start_pos, end_pos, width=1) -> Rect  Draws a straight line on the given surface. There are no endcaps. For thick lines the ends are squared off.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nstart_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- start position of the line, (x, y) \nend_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- end position of the line, (x, y) \nwidth (int) -- (optional) used for line thickness  if width >= 1, used for line thickness (default is 1) if width < 1, nothing will be drawn    Note When using width values > 1, lines will grow as follows. For odd width values, the thickness of each line grows with the original line being in the center. For even width values, the thickness of each line grows with the original line being offset from the center (as there is no exact center line drawn). As a result, lines with a slope < 1 (horizontal-ish) will have 1 more pixel of thickness below the original line (in the y direction). Lines with a slope >= 1 (vertical-ish) will have 1 more pixel of thickness to the right of the original line (in the x direction).      \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the start_pos parameter value (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\nTypeError -- if start_pos or end_pos is not a sequence of two numbers      Changed in pygame 2.0.0: Added support for keyword arguments.  \n"}, {"name": "draw.lines", "path": "ref/draw#pygame.draw.lines", "type": "pygame.draw", "text": "  pygame.draw.lines() \n draw multiple contiguous straight line segments lines(surface, color, closed, points) -> Rect lines(surface, color, closed, points, width=1) -> Rect  Draws a sequence of contiguous straight lines on the given surface. There are no endcaps or miter joints. For thick lines the ends are squared off. Drawing thick lines with sharp corners can have undesired looking results.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nclosed (bool) -- if True an additional line segment is drawn between the first and last points in the points sequence \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 2 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats and adjacent coordinates will be connected by a line segment, e.g. for the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2) and from (x2, y2) to (x3, y3), additionally if the closed parameter is True another line segment will be drawn from (x3, y3) to (x1, y1)\n \nwidth (int) -- (optional) used for line thickness  if width >= 1, used for line thickness (default is 1) if width < 1, nothing will be drawn    Note When using width values > 1 refer to the width notes of line() for details on how thick lines grow.      \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the points parameter (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nValueError -- if len(points) < 2 (must have at least 2 points) \nTypeError -- if points is not a sequence or points does not contain number pairs       Changed in pygame 2.0.0: Added support for keyword arguments.  \n"}, {"name": "draw.polygon", "path": "ref/draw#pygame.draw.polygon", "type": "pygame.draw", "text": "  pygame.draw.polygon() \n draw a polygon polygon(surface, color, points) -> Rect polygon(surface, color, points, width=0) -> Rect  Draws a polygon on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates that make up the vertices of the polygon, each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats, e.g. [(x1, y1), (x2, y2), (x3, y3)]\n \nwidth (int) -- (optional) used for line thickness or to indicate that the polygon is to be filled  \n if width == 0, (default) fill the polygon if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will grow outside the original boundary of the polygon. For more details on how the thickness for edge lines grow, refer to the width notes of the pygame.draw.line() function.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the points parameter (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nTypeError -- if points is not a sequence or points does not contain number pairs       Note For an aapolygon, use aalines() with closed=True.   Changed in pygame 2.0.0: Added support for keyword arguments.  \n"}, {"name": "draw.rect", "path": "ref/draw#pygame.draw.rect", "type": "pygame.draw", "text": "  pygame.draw.rect() \n draw a rectangle rect(surface, color, rect) -> Rect rect(surface, color, rect, width=0, border_radius=0, border_top_left_radius=-1, border_top_right_radius=-1, border_bottom_left_radius=-1, border_bottom_right_radius=-1) -> Rect  Draws a rectangle on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nrect (Rect) -- rectangle to draw, position and dimensions \nwidth (int) -- (optional) used for line thickness or to indicate that the rectangle is to be filled (not to be confused with the width value of the rect parameter)  \n if width == 0, (default) fill the rectangle if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will grow outside the original boundary of the rect. For more details on how the thickness for edge lines grow, refer to the width notes of the pygame.draw.line() function.  \n  \nborder_radius (int) -- (optional) used for drawing rectangle with rounded corners. The supported range is [0, min(height, width) / 2], with 0 representing a rectangle without rounded corners. \nborder_top_left_radius (int) -- (optional) used for setting the value of top left border. If you don't set this value, it will use the border_radius value. \nborder_top_right_radius (int) -- (optional) used for setting the value of top right border. If you don't set this value, it will use the border_radius value. \nborder_bottom_left_radius (int) -- (optional) used for setting the value of bottom left border. If you don't set this value, it will use the border_radius value. \nborder_bottom_right_radius (int) -- (optional) used for setting the value of bottom right border. If you don't set this value, it will use the border_radius value.  \n if border_radius < 1 it will draw rectangle without rounded corners if any of border radii has the value < 0 it will use value of the border_radius If sum of radii on the same side of the rectangle is greater than the rect size the radii will get scaled  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given rect parameter and its width and height will be 0   \nReturn type:\n\nRect      Note The pygame.Surface.fill() method works just as well for drawing filled rectangles and can be hardware accelerated on some platforms with both software and hardware display modes.   Changed in pygame 2.0.0: Added support for keyword arguments.   Changed in pygame 2.0.0.dev8: Added support for border radius.  \n"}, {"name": "encode_file_path", "path": "ref/pygame#pygame.encode_file_path", "type": "pygame", "text": "  pygame.encode_file_path() \n Encode a Unicode or bytes object as a file system path encode_file_path([obj [, etype]]) -> bytes or None  obj: If Unicode, encode; if bytes, return unaltered; if anything else, return None; if not given, raise SyntaxError. etype (exception type): If given, the exception type to raise for an encoding error. The default is UnicodeEncodeError, as returned by PyUnicode_AsEncodedString(). This function is used to encode file paths in pygame. Encoding is to the codec as returned by sys.getfilesystemencoding(). Keyword arguments are supported.  New in pygame 1.9.2: (primarily for use in unit tests)  \n"}, {"name": "encode_string", "path": "ref/pygame#pygame.encode_string", "type": "pygame", "text": "  pygame.encode_string() \n Encode a Unicode or bytes object encode_string([obj [, encoding [, errors [, etype]]]]) -> bytes or None  obj: If Unicode, encode; if bytes, return unaltered; if anything else, return None; if not given, raise SyntaxError. encoding (string): If present, encoding to use. The default is 'unicode_escape'. errors (string): If given, how to handle unencodable characters. The default is 'backslashreplace'. etype (exception type): If given, the exception type to raise for an encoding error. The default is UnicodeEncodeError, as returned by PyUnicode_AsEncodedString(). For the default encoding and errors values there should be no encoding errors. This function is used in encoding file paths. Keyword arguments are supported.  New in pygame 1.9.2: (primarily for use in unit tests)  \n"}, {"name": "error", "path": "ref/pygame#pygame.error", "type": "pygame", "text": "  exception pygame.error \n standard pygame exception raise pygame.error(message)  This exception is raised whenever a pygame or SDL operation fails. You can catch any anticipated problems and deal with the error. The exception is always raised with a descriptive message about the problem. Derived from the RuntimeError exception, which can also be used to catch these raised errors. \n"}, {"name": "event", "path": "ref/event", "type": "pygame.event", "text": " pygame.event\n  \n pygame module for interacting with events and queues  Pygame handles all its event messaging through an event queue. The routines in this module help you manage that event queue. The input queue is heavily dependent on the pygame.display module. If the display has not been initialized and a video mode not set, the event queue may not work properly. The event subsystem should be called from the main thread. If you want to post events into the queue from other threads, please use the pygame.fastevent module. The event queue has an upper limit on the number of events it can hold (128 for standard SDL 1.2). When the queue becomes full new events are quietly dropped. To prevent lost events, especially input events which signal a quit command, your program must handle events every frame (with pygame.event.get(), pygame.event.pump(), pygame.event.wait(), pygame.event.peek() or pygame.event.clear()) and process them. Not handling events may cause your system to decide your program has locked up. To speed up queue processing use pygame.event.set_blocked() to limit which events get queued. To get the state of various input devices, you can forego the event queue and access the input devices directly with their appropriate modules: pygame.mouse, pygame.key, and pygame.joystick. If you use this method, remember that pygame requires some form of communication with the system window manager and other parts of the platform. To keep pygame in sync with the system, you will need to call pygame.event.pump() to keep everything current. Usually, this should be called once per game loop. Note: Joysticks will not send any events until the device has been initialized. The event queue contains pygame.event.EventType event objects. There are a variety of ways to access the queued events, from simply checking for the existence of events, to grabbing them directly off the stack. The event queue also offers some simple filtering which can slightly help performance by blocking certain event types from the queue. Use pygame.event.set_allowed() and pygame.event.set_blocked() to change this filtering. By default, all event types can be placed on the queue. All pygame.event.EventType instances contain an event type identifier and attributes specific to that event type. The event type identifier is accessible as the pygame.event.EventType.type property. Any of the event specific attributes can be accessed through the pygame.event.EventType.__dict__ attribute or directly as an attribute of the event object (as member lookups are passed through to the object's dictionary values). The event object has no method functions. Users can create their own new events with the pygame.event.Event() function. The event type identifier is in between the values of NOEVENT and NUMEVENTS. User defined events should have a value in the inclusive range of USEREVENT to NUMEVENTS - 1. It is recommended all user events follow this system. Events support equality and inequality comparisons. Two events are equal if they are the same type and have identical attribute values. While debugging and experimenting, you can print an event object for a quick display of its type and members. The function pygame.event.event_name() can be used to get a string representing the name of the event type. Events that come from the system will have a guaranteed set of member attributes based on the type. The following is a list event types with their specific attributes. QUIT              none\nACTIVEEVENT       gain, state\nKEYDOWN           key, mod, unicode, scancode\nKEYUP             key, mod\nMOUSEMOTION       pos, rel, buttons\nMOUSEBUTTONUP     pos, button\nMOUSEBUTTONDOWN   pos, button\nJOYAXISMOTION     joy (deprecated), instance_id, axis, value\nJOYBALLMOTION     joy (deprecated), instance_id, ball, rel\nJOYHATMOTION      joy (deprecated), instance_id, hat, value\nJOYBUTTONUP       joy (deprecated), instance_id, button\nJOYBUTTONDOWN     joy (deprecated), instance_id, button\nVIDEORESIZE       size, w, h\nVIDEOEXPOSE       none\nUSEREVENT         code  Changed in pygame 2.0.0: The joy attribute was deprecated, instance_id was added.  You can also find a list of constants for keyboard keys here.    On MacOSX when a file is opened using a pygame application, a USEREVENT with its code attribute set to pygame.USEREVENT_DROPFILE is generated. There is an additional attribute called filename where the name of the file being accessed is stored. USEREVENT         code=pygame.USEREVENT_DROPFILE, filename  New in pygame 1.9.2.     When compiled with SDL2, pygame has these additional events and their attributes. AUDIODEVICEADDED   which, iscapture\nAUDIODEVICEREMOVED which, iscapture\nFINGERMOTION       touch_id, finger_id, x, y, dx, dy\nFINGERDOWN         touch_id, finger_id, x, y, dx, dy\nFINGERUP           touch_id, finger_id, x, y, dx, dy\nMOUSEWHEEL         which, flipped, x, y\nMULTIGESTURE       touch_id, x, y, pinched, rotated, num_fingers\nTEXTEDITING        text, start, length\nTEXTINPUT          text\nWINDOWEVENT        event  New in pygame 1.9.5.     pygame can recognize text or files dropped in its window. If a file is dropped, file will be its path. The DROPTEXT event is only supported on X11. DROPBEGIN\nDROPCOMPLETE\nDROPFILE        file\nDROPTEXT        text  New in pygame 2.0.0.     Events reserved for pygame.midi use. MIDIIN\nMIDIOUT  New in pygame 2.0.0.     SDL2 supports controller hotplugging: CONTROLLERDEVICEADDED    device_index\nJOYDEVICEADDED           device_index\nCONTROLLERDEVICEREMOVED  instance_id\nJOYDEVICEREMOVED         instance_id\nCONTROLLERDEVICEREMAPPED instance_id Also in this version, instance_id attributes were added to joystick events, and the joy attribute was deprecated.  New in pygame 2.0.0.       pygame.event.pump() \n internally process pygame event handlers pump() -> None  For each frame of your game, you will need to make some sort of call to the event queue. This ensures your program can internally interact with the rest of the operating system. If you are not using other event functions in your game, you should call pygame.event.pump() to allow pygame to handle internal actions. This function is not necessary if your program is consistently processing events on the queue through the other pygame.event functions. There are important things that must be dealt with internally in the event queue. The main window may need to be repainted or respond to the system. If you fail to make a call to the event queue for too long, the system may decide your program has locked up.  Caution This function should only be called in the thread that initialized pygame.display.  \n   pygame.event.get() \n get events from the queue get(eventtype=None) -> Eventlist get(eventtype=None, pump=True) -> Eventlist  This will get all the messages and remove them from the queue. If a type or sequence of types is given only those messages will be removed from the queue. If you are only taking specific events from the queue, be aware that the queue could eventually fill up with the events you are not interested. If pump is True (the default), then pygame.event.pump() will be called.  Changed in pygame 1.9.5: Added pump argument  \n   pygame.event.poll() \n get a single event from the queue poll() -> EventType instance  Returns a single event from the queue. If the event queue is empty an event of type pygame.NOEVENT will be returned immediately. The returned event is removed from the queue.  Caution This function should only be called in the thread that initialized pygame.display.  \n   pygame.event.wait() \n wait for a single event from the queue wait() -> EventType instance wait(timeout) -> EventType instance  Returns a single event from the queue. If the queue is empty this function will wait until one is created. From pygame 2.0.0, if a timeout argument is given, the function will return an event of type pygame.NOEVENT if no events enter the queue in timeout milliseconds. The event is removed from the queue once it has been returned. While the program is waiting it will sleep in an idle state. This is important for programs that want to share the system with other applications.  Changed in pygame 2.0.0.dev13: Added timeout argument   Caution This function should only be called in the thread that initialized pygame.display.  \n   pygame.event.peek() \n test if event types are waiting on the queue peek(eventtype=None) -> bool peek(eventtype=None, pump=True) -> bool  Returns True if there are any events of the given type waiting on the queue. If a sequence of event types is passed, this will return True if any of those events are on the queue. If pump is True (the default), then pygame.event.pump() will be called.  Changed in pygame 1.9.5: Added pump argument  \n   pygame.event.clear() \n remove all events from the queue clear(eventtype=None) -> None clear(eventtype=None, pump=True) -> None  Removes all events from the queue. If eventtype is given, removes the given event or sequence of events. This has the same effect as pygame.event.get() except None is returned. It can be slightly more efficient when clearing a full event queue. If pump is True (the default), then pygame.event.pump() will be called.  Changed in pygame 1.9.5: Added pump argument  \n   pygame.event.event_name() \n get the string name from an event id event_name(type) -> string  Returns a string representing the name (in CapWords style) of the given event type. \"UserEvent\" is returned for all values in the user event id range. \"Unknown\" is returned when the event type does not exist. \n   pygame.event.set_blocked() \n control which events are allowed on the queue set_blocked(type) -> None set_blocked(typelist) -> None set_blocked(None) -> None  The given event types are not allowed to appear on the event queue. By default all events can be placed on the queue. It is safe to disable an event type multiple times. If None is passed as the argument, ALL of the event types are blocked from being placed on the queue. \n   pygame.event.set_allowed() \n control which events are allowed on the queue set_allowed(type) -> None set_allowed(typelist) -> None set_allowed(None) -> None  The given event types are allowed to appear on the event queue. By default, all event types can be placed on the queue. It is safe to enable an event type multiple times. If None is passed as the argument, ALL of the event types are allowed to be placed on the queue. \n   pygame.event.get_blocked() \n test if a type of event is blocked from the queue get_blocked(type) -> bool get_blocked(typelist) -> bool  Returns True if the given event type is blocked from the queue. If a sequence of event types is passed, this will return True if any of those event types are blocked. \n   pygame.event.set_grab() \n control the sharing of input devices with other applications set_grab(bool) -> None  When your program runs in a windowed environment, it will share the mouse and keyboard devices with other applications that have focus. If your program sets the event grab to True, it will lock all input into your program. It is best to not always grab the input, since it prevents the user from doing other things on their system. \n   pygame.event.get_grab() \n test if the program is sharing input devices get_grab() -> bool  Returns True when the input events are grabbed for this application. \n   pygame.event.post() \n place a new event on the queue post(Event) -> None  Places the given event at the end of the event queue. This is usually used for placing pygame.USEREVENT events on the queue. Although any type of event can be placed, if using the system event types your program should be sure to create the standard attributes with appropriate values. If the event queue is full a pygame.error is raised. Caution: In pygame 2.0, calling this function with event types defined by pygame (such as pygame.KEYDOWN) may put events into the SDL2 event queue. In this case, an error may be raised if standard attributes of that event are missing or have incompatible values, and unexpected properties may be silently omitted. In order to avoid this behaviour, custom event properties should be used with custom event types. This behaviour is not guaranteed. \n   pygame.event.custom_type() \n make custom user event type custom_type() -> int  Reserves a pygame.USEREVENT for a custom use. If too many events are made a pygame.error is raised.  New in pygame 2.0.0.dev3.  \n   pygame.event.Event() \n create a new event object Event(type, dict) -> EventType instance Event(type, **attributes) -> EventType instance  Creates a new event with the given type and attributes. The attributes can come from a dictionary argument with string keys or from keyword arguments. \n   pygame.event.EventType \n pygame object for representing events  A pygame object that represents an event. User event instances are created with an pygame.event.Event() function call. The EventType type is not directly callable. EventType instances support attribute assignment and deletion.   type \n event type identifier. type -> int  Read-only. The event type identifier. For user created event objects, this is the type argument passed to pygame.event.Event(). For example, some predefined event identifiers are QUIT and MOUSEMOTION. \n   __dict__ \n event attribute dictionary __dict__ -> dict  Read-only. The event type specific attributes of an event. The dict attribute is a synonym for backward compatibility. For example, the attributes of a KEYDOWN event would be unicode, key, and mod \n  New in pygame 1.9.2: Mutable attributes.  \n \n \n"}, {"name": "event.clear", "path": "ref/event#pygame.event.clear", "type": "pygame.event", "text": "  pygame.event.clear() \n remove all events from the queue clear(eventtype=None) -> None clear(eventtype=None, pump=True) -> None  Removes all events from the queue. If eventtype is given, removes the given event or sequence of events. This has the same effect as pygame.event.get() except None is returned. It can be slightly more efficient when clearing a full event queue. If pump is True (the default), then pygame.event.pump() will be called.  Changed in pygame 1.9.5: Added pump argument  \n"}, {"name": "event.custom_type", "path": "ref/event#pygame.event.custom_type", "type": "pygame.event", "text": "  pygame.event.custom_type() \n make custom user event type custom_type() -> int  Reserves a pygame.USEREVENT for a custom use. If too many events are made a pygame.error is raised.  New in pygame 2.0.0.dev3.  \n"}, {"name": "event.Event", "path": "ref/event#pygame.event.Event", "type": "pygame.event", "text": "  pygame.event.Event() \n create a new event object Event(type, dict) -> EventType instance Event(type, **attributes) -> EventType instance  Creates a new event with the given type and attributes. The attributes can come from a dictionary argument with string keys or from keyword arguments. \n"}, {"name": "event.event_name", "path": "ref/event#pygame.event.event_name", "type": "pygame.event", "text": "  pygame.event.event_name() \n get the string name from an event id event_name(type) -> string  Returns a string representing the name (in CapWords style) of the given event type. \"UserEvent\" is returned for all values in the user event id range. \"Unknown\" is returned when the event type does not exist. \n"}, {"name": "event.EventType", "path": "ref/event#pygame.event.EventType", "type": "pygame.event", "text": "  pygame.event.EventType \n pygame object for representing events  A pygame object that represents an event. User event instances are created with an pygame.event.Event() function call. The EventType type is not directly callable. EventType instances support attribute assignment and deletion.   type \n event type identifier. type -> int  Read-only. The event type identifier. For user created event objects, this is the type argument passed to pygame.event.Event(). For example, some predefined event identifiers are QUIT and MOUSEMOTION. \n   __dict__ \n event attribute dictionary __dict__ -> dict  Read-only. The event type specific attributes of an event. The dict attribute is a synonym for backward compatibility. For example, the attributes of a KEYDOWN event would be unicode, key, and mod \n  New in pygame 1.9.2: Mutable attributes.  \n"}, {"name": "event.EventType.__dict__", "path": "ref/event#pygame.event.EventType.__dict__", "type": "pygame.event", "text": "  __dict__ \n event attribute dictionary __dict__ -> dict  Read-only. The event type specific attributes of an event. The dict attribute is a synonym for backward compatibility. For example, the attributes of a KEYDOWN event would be unicode, key, and mod \n"}, {"name": "event.EventType.type", "path": "ref/event#pygame.event.EventType.type", "type": "pygame.event", "text": "  type \n event type identifier. type -> int  Read-only. The event type identifier. For user created event objects, this is the type argument passed to pygame.event.Event(). For example, some predefined event identifiers are QUIT and MOUSEMOTION. \n"}, {"name": "event.get", "path": "ref/event#pygame.event.get", "type": "pygame.event", "text": "  pygame.event.get() \n get events from the queue get(eventtype=None) -> Eventlist get(eventtype=None, pump=True) -> Eventlist  This will get all the messages and remove them from the queue. If a type or sequence of types is given only those messages will be removed from the queue. If you are only taking specific events from the queue, be aware that the queue could eventually fill up with the events you are not interested. If pump is True (the default), then pygame.event.pump() will be called.  Changed in pygame 1.9.5: Added pump argument  \n"}, {"name": "event.get_blocked", "path": "ref/event#pygame.event.get_blocked", "type": "pygame.event", "text": "  pygame.event.get_blocked() \n test if a type of event is blocked from the queue get_blocked(type) -> bool get_blocked(typelist) -> bool  Returns True if the given event type is blocked from the queue. If a sequence of event types is passed, this will return True if any of those event types are blocked. \n"}, {"name": "event.get_grab", "path": "ref/event#pygame.event.get_grab", "type": "pygame.event", "text": "  pygame.event.get_grab() \n test if the program is sharing input devices get_grab() -> bool  Returns True when the input events are grabbed for this application. \n"}, {"name": "event.peek", "path": "ref/event#pygame.event.peek", "type": "pygame.event", "text": "  pygame.event.peek() \n test if event types are waiting on the queue peek(eventtype=None) -> bool peek(eventtype=None, pump=True) -> bool  Returns True if there are any events of the given type waiting on the queue. If a sequence of event types is passed, this will return True if any of those events are on the queue. If pump is True (the default), then pygame.event.pump() will be called.  Changed in pygame 1.9.5: Added pump argument  \n"}, {"name": "event.poll", "path": "ref/event#pygame.event.poll", "type": "pygame.event", "text": "  pygame.event.poll() \n get a single event from the queue poll() -> EventType instance  Returns a single event from the queue. If the event queue is empty an event of type pygame.NOEVENT will be returned immediately. The returned event is removed from the queue.  Caution This function should only be called in the thread that initialized pygame.display.  \n"}, {"name": "event.post", "path": "ref/event#pygame.event.post", "type": "pygame.event", "text": "  pygame.event.post() \n place a new event on the queue post(Event) -> None  Places the given event at the end of the event queue. This is usually used for placing pygame.USEREVENT events on the queue. Although any type of event can be placed, if using the system event types your program should be sure to create the standard attributes with appropriate values. If the event queue is full a pygame.error is raised. Caution: In pygame 2.0, calling this function with event types defined by pygame (such as pygame.KEYDOWN) may put events into the SDL2 event queue. In this case, an error may be raised if standard attributes of that event are missing or have incompatible values, and unexpected properties may be silently omitted. In order to avoid this behaviour, custom event properties should be used with custom event types. This behaviour is not guaranteed. \n"}, {"name": "event.pump", "path": "ref/event#pygame.event.pump", "type": "pygame.event", "text": "  pygame.event.pump() \n internally process pygame event handlers pump() -> None  For each frame of your game, you will need to make some sort of call to the event queue. This ensures your program can internally interact with the rest of the operating system. If you are not using other event functions in your game, you should call pygame.event.pump() to allow pygame to handle internal actions. This function is not necessary if your program is consistently processing events on the queue through the other pygame.event functions. There are important things that must be dealt with internally in the event queue. The main window may need to be repainted or respond to the system. If you fail to make a call to the event queue for too long, the system may decide your program has locked up.  Caution This function should only be called in the thread that initialized pygame.display.  \n"}, {"name": "event.set_allowed", "path": "ref/event#pygame.event.set_allowed", "type": "pygame.event", "text": "  pygame.event.set_allowed() \n control which events are allowed on the queue set_allowed(type) -> None set_allowed(typelist) -> None set_allowed(None) -> None  The given event types are allowed to appear on the event queue. By default, all event types can be placed on the queue. It is safe to enable an event type multiple times. If None is passed as the argument, ALL of the event types are allowed to be placed on the queue. \n"}, {"name": "event.set_blocked", "path": "ref/event#pygame.event.set_blocked", "type": "pygame.event", "text": "  pygame.event.set_blocked() \n control which events are allowed on the queue set_blocked(type) -> None set_blocked(typelist) -> None set_blocked(None) -> None  The given event types are not allowed to appear on the event queue. By default all events can be placed on the queue. It is safe to disable an event type multiple times. If None is passed as the argument, ALL of the event types are blocked from being placed on the queue. \n"}, {"name": "event.set_grab", "path": "ref/event#pygame.event.set_grab", "type": "pygame.event", "text": "  pygame.event.set_grab() \n control the sharing of input devices with other applications set_grab(bool) -> None  When your program runs in a windowed environment, it will share the mouse and keyboard devices with other applications that have focus. If your program sets the event grab to True, it will lock all input into your program. It is best to not always grab the input, since it prevents the user from doing other things on their system. \n"}, {"name": "event.wait", "path": "ref/event#pygame.event.wait", "type": "pygame.event", "text": "  pygame.event.wait() \n wait for a single event from the queue wait() -> EventType instance wait(timeout) -> EventType instance  Returns a single event from the queue. If the queue is empty this function will wait until one is created. From pygame 2.0.0, if a timeout argument is given, the function will return an event of type pygame.NOEVENT if no events enter the queue in timeout milliseconds. The event is removed from the queue once it has been returned. While the program is waiting it will sleep in an idle state. This is important for programs that want to share the system with other applications.  Changed in pygame 2.0.0.dev13: Added timeout argument   Caution This function should only be called in the thread that initialized pygame.display.  \n"}, {"name": "examples", "path": "ref/examples", "type": "pygame.examples", "text": " pygame.examples\n  \n module of example programs  These examples should help get you started with pygame. Here is a brief rundown of what you get. The source code for these examples is in the public domain. Feel free to use for your own projects. There are several ways to run the examples. First they can be run as stand-alone programs. Second they can be imported and their main() methods called (see below). Finally, the easiest way is to use the python -m option: python -m pygame.examples.<example name> <example arguments> eg: python -m pygame.examples.scaletest someimage.png Resources such as images and sounds for the examples are found in the pygame/examples/data subdirectory. You can find where the example files are installed by using the following commands inside the python interpreter. >>> import pygame.examples.scaletest\n>>> pygame.examples.scaletest.__file__\n'/usr/lib/python2.6/site-packages/pygame/examples/scaletest.py' On each OS and version of Python the location will be slightly different. For example on Windows it might be in 'C:/Python26/Lib/site-packages/pygame/examples/' On Mac OS X it might be in '/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/site-packages/pygame/examples/' You can also run the examples in the python interpreter by calling each modules main() function. >>> import pygame.examples.scaletest\n>>> pygame.examples.scaletest.main() We're always on the lookout for more examples and/or example requests. Code like this is probably the best way to start getting involved with python gaming. examples as a package is new to pygame 1.9.0. But most of the examples came with pygame much earlier.   aliens.main() \n play the full aliens example aliens.main() -> None  This started off as a port of the SDL demonstration, Aliens. Now it has evolved into something sort of resembling fun. This demonstrates a lot of different uses of sprites and optimized blitting. Also transparency, colorkeys, fonts, sound, music, joystick, and more. (PS, my high score is 117! goodluck) \n   oldalien.main() \n play the original aliens example oldalien.main() -> None  This more closely resembles a port of the SDL Aliens demo. The code is a lot simpler, so it makes a better starting point for people looking at code for the first times. These blitting routines are not as optimized as they should/could be, but the code is easier to follow, and it plays quick enough. \n   stars.main() \n run a simple starfield example stars.main() -> None  A simple starfield example. You can change the center of perspective by leftclicking the mouse on the screen. \n   chimp.main() \n hit the moving chimp chimp.main() -> None  This simple example is derived from the line-by-line tutorial that comes with pygame. It is based on a 'popular' web banner. Note there are comments here, but for the full explanation, follow along in the tutorial. \n   moveit.main() \n display animated objects on the screen moveit.main() -> None  This is the full and final example from the Pygame Tutorial, \"How Do I Make It Move\". It creates 10 objects and animates them on the screen. Note it's a bit scant on error checking, but it's easy to read. :] Fortunately, this is python, and we needn't wrestle with a pile of error codes. \n   fonty.main() \n run a font rendering example fonty.main() -> None  Super quick, super simple application demonstrating the different ways to render fonts with the font module \n   freetype_misc.main() \n run a FreeType rendering example freetype_misc.main() -> None  A showcase of rendering features the pygame.freetype.Font class provides in addition to those available with pygame.font.Font. It is a demonstration of direct to surface rendering, with vertical text and rotated text, opaque text and semi transparent text, horizontally stretched text and vertically stretched text. \n   vgrade.main() \n display a vertical gradient vgrade.main() -> None  Demonstrates creating a vertical gradient with pixelcopy and NumPy python. The app will create a new gradient every half second and report the time needed to create and display the image. If you're not prepared to start working with the NumPy arrays, don't worry about the source for this one :] \n   eventlist.main() \n display pygame events eventlist.main() -> None  Eventlist is a sloppy style of pygame, but is a handy tool for learning about pygame events and input. At the top of the screen are the state of several device values, and a scrolling list of events are displayed on the bottom. This is not quality 'ui' code at all, but you can see how to implement very non-interactive status displays, or even a crude text output control. \n   arraydemo.main() \n show various surfarray effects arraydemo.main(arraytype=None) -> None  Another example filled with various surfarray effects. It requires the surfarray and image modules to be installed. This little demo can also make a good starting point for any of your own tests with surfarray The arraytype parameter is deprecated; passing any value besides 'numpy' will raise ValueError. \n   sound.main() \n load and play a sound sound.main(file_path=None) -> None  Extremely basic testing of the mixer module. Load a sound and play it. All from the command shell, no graphics. If provided, use the audio file 'file_path', otherwise use a default file. sound.py optional command line argument: an audio file \n   sound_array_demos.main() \n play various sndarray effects sound_array_demos.main(arraytype=None) -> None  Uses sndarray and NumPy to create offset faded copies of the original sound. Currently it just uses hardcoded values for the number of echoes and the delay. Easy for you to recreate as needed. The arraytype parameter is deprecated; passing any value besides 'numpy' will raise ValueError. \n   liquid.main() \n display an animated liquid effect liquid.main() -> None  This example was created in a quick comparison with the BlitzBasic gaming language. Nonetheless, it demonstrates a quick 8-bit setup (with colormap). \n   glcube.main() \n display an animated 3D cube using OpenGL glcube.main() -> None  Using PyOpenGL and pygame, this creates a spinning 3D multicolored cube. \n   scrap_clipboard.main() \n access the clipboard scrap_clipboard.main() -> None  A simple demonstration example for the clipboard support. \n   mask.main() \n display multiple images bounce off each other using collision detection mask.main(*args) -> None  Positional arguments: one or more image file names. This pygame.masks demo will display multiple moving sprites bouncing off each other. More than one sprite image can be provided. If run as a program then mask.py takes one or more image files as command line arguments. \n   testsprite.main() \n show lots of sprites moving around testsprite.main(update_rects = True, use_static = False, use_FastRenderGroup = False, screen_dims = [640, 480], use_alpha = False, flags = 0) -> None  Optional keyword arguments: update_rects - use the RenderUpdate sprite group class\nuse_static - include non-moving images\nuse_FastRenderGroup - Use the FastRenderGroup sprite group\nscreen_dims - pygame window dimensions\nuse_alpha - use alpha blending\nflags - additional display mode flags Like the testsprite.c that comes with SDL, this pygame version shows lots of sprites moving around. If run as a stand-alone program then no command line arguments are taken. \n   headless_no_windows_needed.main() \n write an image file that is smoothscaled copy of an input file headless_no_windows_needed.main(fin, fout, w, h) -> None  arguments: fin - name of an input image file\nfout - name of the output file to create/overwrite\nw, h - size of the rescaled image, as integer width and height How to use pygame with no windowing system, like on headless servers. Thumbnail generation with scaling is an example of what you can do with pygame. NOTE: the pygame scale function uses MMX/SSE if available, and can be run in multiple threads. If headless_no_windows_needed.py is run as a program it takes the following command line arguments: -scale inputimage outputimage new_width new_height\neg. -scale in.png outpng 50 50 \n   fastevents.main() \n stress test the fastevents module fastevents.main() -> None  This is a stress test for the fastevents module.  \n Fast events does not appear faster!   \n So far it looks like normal pygame.event is faster by up to two times. So maybe fastevent isn't fast at all. Tested on Windows XP SP2 Athlon, and FreeBSD. However... on my Debian Duron 850 machine fastevents is faster. \n   overlay.main() \n play a .pgm video using overlays overlay.main(fname) -> None  Play the .pgm video file given by a path fname. If run as a program overlay.py takes the file name as a command line argument. \n   blend_fill.main() \n demonstrate the various surface.fill method blend options blend_fill.main() -> None  A interactive demo that lets one choose which BLEND_xxx option to apply to a surface. \n   blit_blends.main() \n uses alternative additive fill to that of surface.fill blit_blends.main() -> None  Fake additive blending. Using NumPy. it doesn't clamp. Press r,g,b Somewhat like blend_fill. \n   cursors.main() \n display two different custom cursors cursors.main() -> None  Display an arrow or circle with crossbar cursor. \n   pixelarray.main() \n display various pixelarray generated effects pixelarray.main() -> None  Display various pixelarray generated effects. \n   scaletest.main() \n interactively scale an image using smoothscale scaletest.main(imagefile, convert_alpha=False, run_speed_test=True) -> None  arguments: imagefile - file name of source image (required)\nconvert_alpha - use convert_alpha() on the surf (default False)\nrun_speed_test - (default False) A smoothscale example that resized an image on the screen. Vertical and horizontal arrow keys are used to change the width and height of the displayed image. If the convert_alpha option is True then the source image is forced to have source alpha, whether or not the original images does. If run_speed_test is True then a background timing test is performed instead of the interactive scaler. If scaletest.py is run as a program then the command line options are: ImageFile [-t] [-convert_alpha]\n[-t] = Run Speed Test\n[-convert_alpha] = Use convert_alpha() on the surf. \n   midi.main() \n run a midi example midi.main(mode='output', device_id=None) -> None  Arguments: mode - if 'output' run a midi keyboard output example\n          'input' run a midi event logger input example\n          'list' list available midi devices\n       (default 'output')\ndevice_id - midi device number; if None then use the default midi input or\n            output device for the system The output example shows how to translate mouse clicks or computer keyboard events into midi notes. It implements a rudimentary button widget and state machine. The input example shows how to translate midi input to pygame events. With the use of a virtual midi patch cord the output and input examples can be run as separate processes and connected so the keyboard output is displayed on a console. new to pygame 1.9.0 \n   scroll.main() \n run a Surface.scroll example that shows a magnified image scroll.main(image_file=None) -> None  This example shows a scrollable image that has a zoom factor of eight. It uses the Surface.scroll() function to shift the image on the display surface. A clip rectangle protects a margin area. If called as a function, the example accepts an optional image file path. If run as a program it takes an optional file path command line argument. If no file is provided a default image file is used. When running click on a black triangle to move one pixel in the direction the triangle points. Or use the arrow keys. Close the window or press ESC to quit. \n   camera.main() \n display video captured live from an attached camera camera.main() -> None  A simple live video player, it uses the first available camera it finds on the system. \n   playmus.main() \n play an audio file playmus.main(file_path) -> None  A simple music player with window and keyboard playback control. Playback can be paused and rewound to the beginning. \n \n \n"}, {"name": "examples.aliens.main", "path": "ref/examples#pygame.examples.aliens.main", "type": "pygame.examples", "text": "  aliens.main() \n play the full aliens example aliens.main() -> None  This started off as a port of the SDL demonstration, Aliens. Now it has evolved into something sort of resembling fun. This demonstrates a lot of different uses of sprites and optimized blitting. Also transparency, colorkeys, fonts, sound, music, joystick, and more. (PS, my high score is 117! goodluck) \n"}, {"name": "examples.arraydemo.main", "path": "ref/examples#pygame.examples.arraydemo.main", "type": "pygame.examples", "text": "  arraydemo.main() \n show various surfarray effects arraydemo.main(arraytype=None) -> None  Another example filled with various surfarray effects. It requires the surfarray and image modules to be installed. This little demo can also make a good starting point for any of your own tests with surfarray The arraytype parameter is deprecated; passing any value besides 'numpy' will raise ValueError. \n"}, {"name": "examples.blend_fill.main", "path": "ref/examples#pygame.examples.blend_fill.main", "type": "pygame.examples", "text": "  blend_fill.main() \n demonstrate the various surface.fill method blend options blend_fill.main() -> None  A interactive demo that lets one choose which BLEND_xxx option to apply to a surface. \n"}, {"name": "examples.blit_blends.main", "path": "ref/examples#pygame.examples.blit_blends.main", "type": "pygame.examples", "text": "  blit_blends.main() \n uses alternative additive fill to that of surface.fill blit_blends.main() -> None  Fake additive blending. Using NumPy. it doesn't clamp. Press r,g,b Somewhat like blend_fill. \n"}, {"name": "examples.camera.main", "path": "ref/examples#pygame.examples.camera.main", "type": "pygame.examples", "text": "  camera.main() \n display video captured live from an attached camera camera.main() -> None  A simple live video player, it uses the first available camera it finds on the system. \n"}, {"name": "examples.chimp.main", "path": "ref/examples#pygame.examples.chimp.main", "type": "pygame.examples", "text": "  chimp.main() \n hit the moving chimp chimp.main() -> None  This simple example is derived from the line-by-line tutorial that comes with pygame. It is based on a 'popular' web banner. Note there are comments here, but for the full explanation, follow along in the tutorial. \n"}, {"name": "examples.cursors.main", "path": "ref/examples#pygame.examples.cursors.main", "type": "pygame.examples", "text": "  cursors.main() \n display two different custom cursors cursors.main() -> None  Display an arrow or circle with crossbar cursor. \n"}, {"name": "examples.eventlist.main", "path": "ref/examples#pygame.examples.eventlist.main", "type": "pygame.examples", "text": "  eventlist.main() \n display pygame events eventlist.main() -> None  Eventlist is a sloppy style of pygame, but is a handy tool for learning about pygame events and input. At the top of the screen are the state of several device values, and a scrolling list of events are displayed on the bottom. This is not quality 'ui' code at all, but you can see how to implement very non-interactive status displays, or even a crude text output control. \n"}, {"name": "examples.fastevents.main", "path": "ref/examples#pygame.examples.fastevents.main", "type": "pygame.examples", "text": "  fastevents.main() \n stress test the fastevents module fastevents.main() -> None  This is a stress test for the fastevents module.  \n Fast events does not appear faster!   \n So far it looks like normal pygame.event is faster by up to two times. So maybe fastevent isn't fast at all. Tested on Windows XP SP2 Athlon, and FreeBSD. However... on my Debian Duron 850 machine fastevents is faster. \n"}, {"name": "examples.fonty.main", "path": "ref/examples#pygame.examples.fonty.main", "type": "pygame.examples", "text": "  fonty.main() \n run a font rendering example fonty.main() -> None  Super quick, super simple application demonstrating the different ways to render fonts with the font module \n"}, {"name": "examples.freetype_misc.main", "path": "ref/examples#pygame.examples.freetype_misc.main", "type": "pygame.examples", "text": "  freetype_misc.main() \n run a FreeType rendering example freetype_misc.main() -> None  A showcase of rendering features the pygame.freetype.Font class provides in addition to those available with pygame.font.Font. It is a demonstration of direct to surface rendering, with vertical text and rotated text, opaque text and semi transparent text, horizontally stretched text and vertically stretched text. \n"}, {"name": "examples.glcube.main", "path": "ref/examples#pygame.examples.glcube.main", "type": "pygame.examples", "text": "  glcube.main() \n display an animated 3D cube using OpenGL glcube.main() -> None  Using PyOpenGL and pygame, this creates a spinning 3D multicolored cube. \n"}, {"name": "examples.headless_no_windows_needed.main", "path": "ref/examples#pygame.examples.headless_no_windows_needed.main", "type": "pygame.examples", "text": "  headless_no_windows_needed.main() \n write an image file that is smoothscaled copy of an input file headless_no_windows_needed.main(fin, fout, w, h) -> None  arguments: fin - name of an input image file\nfout - name of the output file to create/overwrite\nw, h - size of the rescaled image, as integer width and height How to use pygame with no windowing system, like on headless servers. Thumbnail generation with scaling is an example of what you can do with pygame. NOTE: the pygame scale function uses MMX/SSE if available, and can be run in multiple threads. If headless_no_windows_needed.py is run as a program it takes the following command line arguments: -scale inputimage outputimage new_width new_height\neg. -scale in.png outpng 50 50 \n"}, {"name": "examples.liquid.main", "path": "ref/examples#pygame.examples.liquid.main", "type": "pygame.examples", "text": "  liquid.main() \n display an animated liquid effect liquid.main() -> None  This example was created in a quick comparison with the BlitzBasic gaming language. Nonetheless, it demonstrates a quick 8-bit setup (with colormap). \n"}, {"name": "examples.mask.main", "path": "ref/examples#pygame.examples.mask.main", "type": "pygame.examples", "text": "  mask.main() \n display multiple images bounce off each other using collision detection mask.main(*args) -> None  Positional arguments: one or more image file names. This pygame.masks demo will display multiple moving sprites bouncing off each other. More than one sprite image can be provided. If run as a program then mask.py takes one or more image files as command line arguments. \n"}, {"name": "examples.midi.main", "path": "ref/examples#pygame.examples.midi.main", "type": "pygame.examples", "text": "  midi.main() \n run a midi example midi.main(mode='output', device_id=None) -> None  Arguments: mode - if 'output' run a midi keyboard output example\n          'input' run a midi event logger input example\n          'list' list available midi devices\n       (default 'output')\ndevice_id - midi device number; if None then use the default midi input or\n            output device for the system The output example shows how to translate mouse clicks or computer keyboard events into midi notes. It implements a rudimentary button widget and state machine. The input example shows how to translate midi input to pygame events. With the use of a virtual midi patch cord the output and input examples can be run as separate processes and connected so the keyboard output is displayed on a console. new to pygame 1.9.0 \n"}, {"name": "examples.moveit.main", "path": "ref/examples#pygame.examples.moveit.main", "type": "pygame.examples", "text": "  moveit.main() \n display animated objects on the screen moveit.main() -> None  This is the full and final example from the Pygame Tutorial, \"How Do I Make It Move\". It creates 10 objects and animates them on the screen. Note it's a bit scant on error checking, but it's easy to read. :] Fortunately, this is python, and we needn't wrestle with a pile of error codes. \n"}, {"name": "examples.oldalien.main", "path": "ref/examples#pygame.examples.oldalien.main", "type": "pygame.examples", "text": "  oldalien.main() \n play the original aliens example oldalien.main() -> None  This more closely resembles a port of the SDL Aliens demo. The code is a lot simpler, so it makes a better starting point for people looking at code for the first times. These blitting routines are not as optimized as they should/could be, but the code is easier to follow, and it plays quick enough. \n"}, {"name": "examples.overlay.main", "path": "ref/examples#pygame.examples.overlay.main", "type": "pygame.examples", "text": "  overlay.main() \n play a .pgm video using overlays overlay.main(fname) -> None  Play the .pgm video file given by a path fname. If run as a program overlay.py takes the file name as a command line argument. \n"}, {"name": "examples.pixelarray.main", "path": "ref/examples#pygame.examples.pixelarray.main", "type": "pygame.examples", "text": "  pixelarray.main() \n display various pixelarray generated effects pixelarray.main() -> None  Display various pixelarray generated effects. \n"}, {"name": "examples.playmus.main", "path": "ref/examples#pygame.examples.playmus.main", "type": "pygame.examples", "text": "  playmus.main() \n play an audio file playmus.main(file_path) -> None  A simple music player with window and keyboard playback control. Playback can be paused and rewound to the beginning. \n"}, {"name": "examples.scaletest.main", "path": "ref/examples#pygame.examples.scaletest.main", "type": "pygame.examples", "text": "  scaletest.main() \n interactively scale an image using smoothscale scaletest.main(imagefile, convert_alpha=False, run_speed_test=True) -> None  arguments: imagefile - file name of source image (required)\nconvert_alpha - use convert_alpha() on the surf (default False)\nrun_speed_test - (default False) A smoothscale example that resized an image on the screen. Vertical and horizontal arrow keys are used to change the width and height of the displayed image. If the convert_alpha option is True then the source image is forced to have source alpha, whether or not the original images does. If run_speed_test is True then a background timing test is performed instead of the interactive scaler. If scaletest.py is run as a program then the command line options are: ImageFile [-t] [-convert_alpha]\n[-t] = Run Speed Test\n[-convert_alpha] = Use convert_alpha() on the surf. \n"}, {"name": "examples.scrap_clipboard.main", "path": "ref/examples#pygame.examples.scrap_clipboard.main", "type": "pygame.examples", "text": "  scrap_clipboard.main() \n access the clipboard scrap_clipboard.main() -> None  A simple demonstration example for the clipboard support. \n"}, {"name": "examples.scroll.main", "path": "ref/examples#pygame.examples.scroll.main", "type": "pygame.examples", "text": "  scroll.main() \n run a Surface.scroll example that shows a magnified image scroll.main(image_file=None) -> None  This example shows a scrollable image that has a zoom factor of eight. It uses the Surface.scroll() function to shift the image on the display surface. A clip rectangle protects a margin area. If called as a function, the example accepts an optional image file path. If run as a program it takes an optional file path command line argument. If no file is provided a default image file is used. When running click on a black triangle to move one pixel in the direction the triangle points. Or use the arrow keys. Close the window or press ESC to quit. \n"}, {"name": "examples.sound.main", "path": "ref/examples#pygame.examples.sound.main", "type": "pygame.examples", "text": "  sound.main() \n load and play a sound sound.main(file_path=None) -> None  Extremely basic testing of the mixer module. Load a sound and play it. All from the command shell, no graphics. If provided, use the audio file 'file_path', otherwise use a default file. sound.py optional command line argument: an audio file \n"}, {"name": "examples.sound_array_demos.main", "path": "ref/examples#pygame.examples.sound_array_demos.main", "type": "pygame.examples", "text": "  sound_array_demos.main() \n play various sndarray effects sound_array_demos.main(arraytype=None) -> None  Uses sndarray and NumPy to create offset faded copies of the original sound. Currently it just uses hardcoded values for the number of echoes and the delay. Easy for you to recreate as needed. The arraytype parameter is deprecated; passing any value besides 'numpy' will raise ValueError. \n"}, {"name": "examples.stars.main", "path": "ref/examples#pygame.examples.stars.main", "type": "pygame.examples", "text": "  stars.main() \n run a simple starfield example stars.main() -> None  A simple starfield example. You can change the center of perspective by leftclicking the mouse on the screen. \n"}, {"name": "examples.testsprite.main", "path": "ref/examples#pygame.examples.testsprite.main", "type": "pygame.examples", "text": "  testsprite.main() \n show lots of sprites moving around testsprite.main(update_rects = True, use_static = False, use_FastRenderGroup = False, screen_dims = [640, 480], use_alpha = False, flags = 0) -> None  Optional keyword arguments: update_rects - use the RenderUpdate sprite group class\nuse_static - include non-moving images\nuse_FastRenderGroup - Use the FastRenderGroup sprite group\nscreen_dims - pygame window dimensions\nuse_alpha - use alpha blending\nflags - additional display mode flags Like the testsprite.c that comes with SDL, this pygame version shows lots of sprites moving around. If run as a stand-alone program then no command line arguments are taken. \n"}, {"name": "examples.vgrade.main", "path": "ref/examples#pygame.examples.vgrade.main", "type": "pygame.examples", "text": "  vgrade.main() \n display a vertical gradient vgrade.main() -> None  Demonstrates creating a vertical gradient with pixelcopy and NumPy python. The app will create a new gradient every half second and report the time needed to create and display the image. If you're not prepared to start working with the NumPy arrays, don't worry about the source for this one :] \n"}, {"name": "fastevent", "path": "ref/fastevent", "type": "pygame.fastevent", "text": " pygame.fastevent\n  \n pygame module for interacting with events and queues  pygame.fastevent is a wrapper for Bob Pendleton's fastevent library. It provides fast events for use in multithreaded environments. When using pygame.fastevent, you can not use any of the pump, wait, poll, post, get, peek, etc. functions from pygame.event, but you should use the Event objects.   pygame.fastevent.init() \n initialize pygame.fastevent init() -> None  Initialize the pygame.fastevent module. \n   pygame.fastevent.get_init() \n returns True if the fastevent module is currently initialized get_init() -> bool  Returns True if the pygame.fastevent module is currently initialized. \n   pygame.fastevent.pump() \n internally process pygame event handlers pump() -> None  For each frame of your game, you will need to make some sort of call to the event queue. This ensures your program can internally interact with the rest of the operating system. This function is not necessary if your program is consistently processing events on the queue through the other pygame.fastevent functions. There are important things that must be dealt with internally in the event queue. The main window may need to be repainted or respond to the system. If you fail to make a call to the event queue for too long, the system may decide your program has locked up. \n   pygame.fastevent.wait() \n wait for an event wait() -> Event  Returns the current event on the queue. If there are no messages waiting on the queue, this will not return until one is available. Sometimes it is important to use this wait to get events from the queue, it will allow your application to idle when the user isn't doing anything with it. \n   pygame.fastevent.poll() \n get an available event poll() -> Event  Returns next event on queue. If there is no event waiting on the queue, this will return an event with type NOEVENT. \n   pygame.fastevent.get() \n get all events from the queue get() -> list of Events  This will get all the messages and remove them from the queue. \n   pygame.fastevent.post() \n place an event on the queue post(Event) -> None  This will post your own event objects onto the event queue. You can post any event type you want, but some care must be taken. For example, if you post a MOUSEBUTTONDOWN event to the queue, it is likely any code receiving the event will expect the standard MOUSEBUTTONDOWN attributes to be available, like 'pos' and 'button'. Because pygame.fastevent.post() may have to wait for the queue to empty, you can get into a dead lock if you try to append an event on to a full queue from the thread that processes events. For that reason I do not recommend using this function in the main thread of an SDL program. \n \n \n"}, {"name": "fastevent.get", "path": "ref/fastevent#pygame.fastevent.get", "type": "pygame.fastevent", "text": "  pygame.fastevent.get() \n get all events from the queue get() -> list of Events  This will get all the messages and remove them from the queue. \n"}, {"name": "fastevent.get_init", "path": "ref/fastevent#pygame.fastevent.get_init", "type": "pygame.fastevent", "text": "  pygame.fastevent.get_init() \n returns True if the fastevent module is currently initialized get_init() -> bool  Returns True if the pygame.fastevent module is currently initialized. \n"}, {"name": "fastevent.init", "path": "ref/fastevent#pygame.fastevent.init", "type": "pygame.fastevent", "text": "  pygame.fastevent.init() \n initialize pygame.fastevent init() -> None  Initialize the pygame.fastevent module. \n"}, {"name": "fastevent.poll", "path": "ref/fastevent#pygame.fastevent.poll", "type": "pygame.fastevent", "text": "  pygame.fastevent.poll() \n get an available event poll() -> Event  Returns next event on queue. If there is no event waiting on the queue, this will return an event with type NOEVENT. \n"}, {"name": "fastevent.post", "path": "ref/fastevent#pygame.fastevent.post", "type": "pygame.fastevent", "text": "  pygame.fastevent.post() \n place an event on the queue post(Event) -> None  This will post your own event objects onto the event queue. You can post any event type you want, but some care must be taken. For example, if you post a MOUSEBUTTONDOWN event to the queue, it is likely any code receiving the event will expect the standard MOUSEBUTTONDOWN attributes to be available, like 'pos' and 'button'. Because pygame.fastevent.post() may have to wait for the queue to empty, you can get into a dead lock if you try to append an event on to a full queue from the thread that processes events. For that reason I do not recommend using this function in the main thread of an SDL program. \n"}, {"name": "fastevent.pump", "path": "ref/fastevent#pygame.fastevent.pump", "type": "pygame.fastevent", "text": "  pygame.fastevent.pump() \n internally process pygame event handlers pump() -> None  For each frame of your game, you will need to make some sort of call to the event queue. This ensures your program can internally interact with the rest of the operating system. This function is not necessary if your program is consistently processing events on the queue through the other pygame.fastevent functions. There are important things that must be dealt with internally in the event queue. The main window may need to be repainted or respond to the system. If you fail to make a call to the event queue for too long, the system may decide your program has locked up. \n"}, {"name": "fastevent.wait", "path": "ref/fastevent#pygame.fastevent.wait", "type": "pygame.fastevent", "text": "  pygame.fastevent.wait() \n wait for an event wait() -> Event  Returns the current event on the queue. If there are no messages waiting on the queue, this will not return until one is available. Sometimes it is important to use this wait to get events from the queue, it will allow your application to idle when the user isn't doing anything with it. \n"}, {"name": "font", "path": "ref/font", "type": "pygame.font", "text": " pygame.font\n  \n pygame module for loading and rendering fonts  The font module allows for rendering TrueType fonts into a new Surface object. It accepts any UCS-2 character ('u0001' to 'uFFFF'). This module is optional and requires SDL_ttf as a dependency. You should test that pygame.font is available and initialized before attempting to use the module. Most of the work done with fonts are done by using the actual Font objects. The module by itself only has routines to initialize the module and create Font objects with pygame.font.Font(). You can load fonts from the system by using the pygame.font.SysFont() function. There are a few other functions to help lookup the system fonts. Pygame comes with a builtin default font. This can always be accessed by passing None as the font name. To use the pygame.freetype based pygame.ftfont as pygame.font define the environment variable PYGAME_FREETYPE before the first import of pygame. Module pygame.ftfont is a pygame.font compatible module that passes all but one of the font module unit tests: it does not have the UCS-2 limitation of the SDL_ttf based font module, so fails to raise an exception for a code point greater than 'uFFFF'. If pygame.freetype is unavailable then the SDL_ttf font module will be loaded instead.   pygame.font.init() \n initialize the font module init() -> None  This method is called automatically by pygame.init(). It initializes the font module. The module must be initialized before any other functions will work. It is safe to call this function more than once. \n   pygame.font.quit() \n uninitialize the font module quit() -> None  Manually uninitialize SDL_ttf's font system. This is called automatically by pygame.quit(). It is safe to call this function even if font is currently not initialized. \n   pygame.font.get_init() \n true if the font module is initialized get_init() -> bool  Test if the font module is initialized or not. \n   pygame.font.get_default_font() \n get the filename of the default font get_default_font() -> string  Return the filename of the system font. This is not the full path to the file. This file can usually be found in the same directory as the font module, but it can also be bundled in separate archives. \n   pygame.font.get_fonts() \n get all available fonts get_fonts() -> list of strings  Returns a list of all the fonts available on the system. The names of the fonts will be set to lowercase with all spaces and punctuation removed. This works on most systems, but some will return an empty list if they cannot find fonts. \n   pygame.font.match_font() \n find a specific font on the system match_font(name, bold=False, italic=False) -> path  Returns the full path to a font file on the system. If bold or italic are set to true, this will attempt to find the correct family of font. The font name can also be an iterable of font names, a string of comma-separated font names, or a bytes of comma-separated font names, in which case the set of names will be searched in order. If none of the given names are found, None is returned.  New in pygame 2.0.1: Accept an iterable of font names.  Example: print pygame.font.match_font('bitstreamverasans')\n# output is: /usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf\n# (but only if you have Vera on your system) \n   pygame.font.SysFont() \n create a Font object from the system fonts SysFont(name, size, bold=False, italic=False) -> Font  Return a new Font object that is loaded from the system fonts. The font will match the requested bold and italic flags. Pygame uses a small set of common font aliases. If the specific font you ask for is not available, a reasonable alternative may be used. If a suitable system font is not found this will fall back on loading the default pygame font. The font name can also be an iterable of font names, a string of comma-separated font names, or a bytes of comma-separated font names, in which case the set of names will be searched in order.  New in pygame 2.0.1: Accept an iterable of font names.  \n   pygame.font.Font \n create a new Font object from a file Font(filename, size) -> Font Font(object, size) -> Font  Load a new font from a given filename or a python file object. The size is the height of the font in pixels. If the filename is None the pygame default font will be loaded. If a font cannot be loaded from the arguments given an exception will be raised. Once the font is created the size cannot be changed. Font objects are mainly used to render text into new Surface objects. The render can emulate bold or italic features, but it is better to load from a font with actual italic or bold glyphs. The rendered text can be regular strings or unicode.   bold \n Gets or sets whether the font should be rendered in (faked) bold. bold -> bool  Whether the font should be rendered in bold. When set to True, this enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic and underline modes.  New in pygame 2.0.0.  \n   italic \n Gets or sets whether the font should be rendered in (faked) italics. italic -> bool  Whether the font should be rendered in italic. When set to True, this enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold and underline modes.  New in pygame 2.0.0.  \n   underline \n Gets or sets whether the font should be rendered with an underline. underline -> bool  Whether the font should be rendered in underline. When set to True, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold and italic modes.  New in pygame 2.0.0.  \n   render() \n draw text on a new Surface render(text, antialias, color, background=None) -> Surface  This creates a new Surface with the specified text rendered on it. pygame provides no way to directly draw text on an existing Surface: instead you must use Font.render() to create an image (Surface) of the text, then blit this image onto another Surface. The text can only be a single line: newline characters are not rendered. Null characters ('x00') raise a TypeError. Both Unicode and char (byte) strings are accepted. For Unicode strings only UCS-2 characters ('u0001' to 'uFFFF') are recognized. Anything greater raises a UnicodeError. For char strings a LATIN1 encoding is assumed. The antialias argument is a boolean: if true the characters will have smooth edges. The color argument is the color of the text [e.g.: (0,0,255) for blue]. The optional background argument is a color to use for the text background. If no background is passed the area outside the text will be transparent. The Surface returned will be of the dimensions required to hold the text. (the same as those returned by Font.size()). If an empty string is passed for the text, a blank surface will be returned that is zero pixel wide and the height of the font. Depending on the type of background and antialiasing used, this returns different types of Surfaces. For performance reasons, it is good to know what type of image will be used. If antialiasing is not used, the return image will always be an 8-bit image with a two-color palette. If the background is transparent a colorkey will be set. Antialiased images are rendered to 24-bit RGB images. If the background is transparent a pixel alpha will be included. Optimization: if you know that the final destination for the text (on the screen) will always have a solid background, and the text is antialiased, you can improve performance by specifying the background color. This will cause the resulting image to maintain transparency information by colorkey rather than (much less efficient) alpha values. If you render '\\n' an unknown char will be rendered. Usually a rectangle. Instead you need to handle new lines yourself. Font rendering is not thread safe: only a single thread can render text at any time. \n   size() \n determine the amount of space needed to render text size(text) -> (width, height)  Returns the dimensions needed to render the text. This can be used to help determine the positioning needed for text before it is rendered. It can also be used for wordwrapping and other layout effects. Be aware that most fonts use kerning which adjusts the widths for specific letter pairs. For example, the width for \"ae\" will not always match the width for \"a\" + \"e\". \n   set_underline() \n control if text is rendered with an underline set_underline(bool) -> None  When enabled, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold and italic modes.  Note This is the same as the underline attribute.  \n   get_underline() \n check if text will be rendered with an underline get_underline() -> bool  Return True when the font underline is enabled.  \n Note This is the same as the underline attribute.  \n \n   set_bold() \n enable fake rendering of bold text set_bold(bool) -> None  Enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic and underline modes.  Note This is the same as the bold attribute.  \n   get_bold() \n check if text will be rendered bold get_bold() -> bool  Return True when the font bold rendering mode is enabled.  Note This is the same as the bold attribute.  \n   set_italic() \n enable fake rendering of italic text set_italic(bool) -> None  Enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold and underline modes.  Note This is the same as the italic attribute.  \n   metrics() \n gets the metrics for each character in the passed string metrics(text) -> list  The list contains tuples for each character, which contain the minimum X offset, the maximum X offset, the minimum Y offset, the maximum Y offset and the advance offset (bearing plus width) of the character. [(minx, maxx, miny, maxy, advance), (minx, maxx, miny, maxy, advance), ...]. None is entered in the list for each unrecognized character. \n   get_italic() \n check if the text will be rendered italic get_italic() -> bool  Return True when the font italic rendering mode is enabled.  Note This is the same as the italic attribute.  \n   get_linesize() \n get the line space of the font text get_linesize() -> int  Return the height in pixels for a line of text with the font. When rendering multiple lines of text this is the recommended amount of space between lines. \n   get_height() \n get the height of the font get_height() -> int  Return the height in pixels of the actual rendered text. This is the average size for each glyph in the font. \n   get_ascent() \n get the ascent of the font get_ascent() -> int  Return the height in pixels for the font ascent. The ascent is the number of pixels from the font baseline to the top of the font. \n   get_descent() \n get the descent of the font get_descent() -> int  Return the height in pixels for the font descent. The descent is the number of pixels from the font baseline to the bottom of the font. \n \n \n \n"}, {"name": "font.Font", "path": "ref/font#pygame.font.Font", "type": "pygame.font", "text": "  pygame.font.Font \n create a new Font object from a file Font(filename, size) -> Font Font(object, size) -> Font  Load a new font from a given filename or a python file object. The size is the height of the font in pixels. If the filename is None the pygame default font will be loaded. If a font cannot be loaded from the arguments given an exception will be raised. Once the font is created the size cannot be changed. Font objects are mainly used to render text into new Surface objects. The render can emulate bold or italic features, but it is better to load from a font with actual italic or bold glyphs. The rendered text can be regular strings or unicode.   bold \n Gets or sets whether the font should be rendered in (faked) bold. bold -> bool  Whether the font should be rendered in bold. When set to True, this enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic and underline modes.  New in pygame 2.0.0.  \n   italic \n Gets or sets whether the font should be rendered in (faked) italics. italic -> bool  Whether the font should be rendered in italic. When set to True, this enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold and underline modes.  New in pygame 2.0.0.  \n   underline \n Gets or sets whether the font should be rendered with an underline. underline -> bool  Whether the font should be rendered in underline. When set to True, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold and italic modes.  New in pygame 2.0.0.  \n   render() \n draw text on a new Surface render(text, antialias, color, background=None) -> Surface  This creates a new Surface with the specified text rendered on it. pygame provides no way to directly draw text on an existing Surface: instead you must use Font.render() to create an image (Surface) of the text, then blit this image onto another Surface. The text can only be a single line: newline characters are not rendered. Null characters ('x00') raise a TypeError. Both Unicode and char (byte) strings are accepted. For Unicode strings only UCS-2 characters ('u0001' to 'uFFFF') are recognized. Anything greater raises a UnicodeError. For char strings a LATIN1 encoding is assumed. The antialias argument is a boolean: if true the characters will have smooth edges. The color argument is the color of the text [e.g.: (0,0,255) for blue]. The optional background argument is a color to use for the text background. If no background is passed the area outside the text will be transparent. The Surface returned will be of the dimensions required to hold the text. (the same as those returned by Font.size()). If an empty string is passed for the text, a blank surface will be returned that is zero pixel wide and the height of the font. Depending on the type of background and antialiasing used, this returns different types of Surfaces. For performance reasons, it is good to know what type of image will be used. If antialiasing is not used, the return image will always be an 8-bit image with a two-color palette. If the background is transparent a colorkey will be set. Antialiased images are rendered to 24-bit RGB images. If the background is transparent a pixel alpha will be included. Optimization: if you know that the final destination for the text (on the screen) will always have a solid background, and the text is antialiased, you can improve performance by specifying the background color. This will cause the resulting image to maintain transparency information by colorkey rather than (much less efficient) alpha values. If you render '\\n' an unknown char will be rendered. Usually a rectangle. Instead you need to handle new lines yourself. Font rendering is not thread safe: only a single thread can render text at any time. \n   size() \n determine the amount of space needed to render text size(text) -> (width, height)  Returns the dimensions needed to render the text. This can be used to help determine the positioning needed for text before it is rendered. It can also be used for wordwrapping and other layout effects. Be aware that most fonts use kerning which adjusts the widths for specific letter pairs. For example, the width for \"ae\" will not always match the width for \"a\" + \"e\". \n   set_underline() \n control if text is rendered with an underline set_underline(bool) -> None  When enabled, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold and italic modes.  Note This is the same as the underline attribute.  \n   get_underline() \n check if text will be rendered with an underline get_underline() -> bool  Return True when the font underline is enabled.  \n Note This is the same as the underline attribute.  \n \n   set_bold() \n enable fake rendering of bold text set_bold(bool) -> None  Enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic and underline modes.  Note This is the same as the bold attribute.  \n   get_bold() \n check if text will be rendered bold get_bold() -> bool  Return True when the font bold rendering mode is enabled.  Note This is the same as the bold attribute.  \n   set_italic() \n enable fake rendering of italic text set_italic(bool) -> None  Enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold and underline modes.  Note This is the same as the italic attribute.  \n   metrics() \n gets the metrics for each character in the passed string metrics(text) -> list  The list contains tuples for each character, which contain the minimum X offset, the maximum X offset, the minimum Y offset, the maximum Y offset and the advance offset (bearing plus width) of the character. [(minx, maxx, miny, maxy, advance), (minx, maxx, miny, maxy, advance), ...]. None is entered in the list for each unrecognized character. \n   get_italic() \n check if the text will be rendered italic get_italic() -> bool  Return True when the font italic rendering mode is enabled.  Note This is the same as the italic attribute.  \n   get_linesize() \n get the line space of the font text get_linesize() -> int  Return the height in pixels for a line of text with the font. When rendering multiple lines of text this is the recommended amount of space between lines. \n   get_height() \n get the height of the font get_height() -> int  Return the height in pixels of the actual rendered text. This is the average size for each glyph in the font. \n   get_ascent() \n get the ascent of the font get_ascent() -> int  Return the height in pixels for the font ascent. The ascent is the number of pixels from the font baseline to the top of the font. \n   get_descent() \n get the descent of the font get_descent() -> int  Return the height in pixels for the font descent. The descent is the number of pixels from the font baseline to the bottom of the font. \n \n"}, {"name": "font.Font.bold", "path": "ref/font#pygame.font.Font.bold", "type": "pygame.font", "text": "  bold \n Gets or sets whether the font should be rendered in (faked) bold. bold -> bool  Whether the font should be rendered in bold. When set to True, this enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic and underline modes.  New in pygame 2.0.0.  \n"}, {"name": "font.Font.get_ascent", "path": "ref/font#pygame.font.Font.get_ascent", "type": "pygame.font", "text": "  get_ascent() \n get the ascent of the font get_ascent() -> int  Return the height in pixels for the font ascent. The ascent is the number of pixels from the font baseline to the top of the font. \n"}, {"name": "font.Font.get_bold", "path": "ref/font#pygame.font.Font.get_bold", "type": "pygame.font", "text": "  get_bold() \n check if text will be rendered bold get_bold() -> bool  Return True when the font bold rendering mode is enabled.  Note This is the same as the bold attribute.  \n"}, {"name": "font.Font.get_descent", "path": "ref/font#pygame.font.Font.get_descent", "type": "pygame.font", "text": "  get_descent() \n get the descent of the font get_descent() -> int  Return the height in pixels for the font descent. The descent is the number of pixels from the font baseline to the bottom of the font. \n"}, {"name": "font.Font.get_height", "path": "ref/font#pygame.font.Font.get_height", "type": "pygame.font", "text": "  get_height() \n get the height of the font get_height() -> int  Return the height in pixels of the actual rendered text. This is the average size for each glyph in the font. \n"}, {"name": "font.Font.get_italic", "path": "ref/font#pygame.font.Font.get_italic", "type": "pygame.font", "text": "  get_italic() \n check if the text will be rendered italic get_italic() -> bool  Return True when the font italic rendering mode is enabled.  Note This is the same as the italic attribute.  \n"}, {"name": "font.Font.get_linesize", "path": "ref/font#pygame.font.Font.get_linesize", "type": "pygame.font", "text": "  get_linesize() \n get the line space of the font text get_linesize() -> int  Return the height in pixels for a line of text with the font. When rendering multiple lines of text this is the recommended amount of space between lines. \n"}, {"name": "font.Font.get_underline", "path": "ref/font#pygame.font.Font.get_underline", "type": "pygame.font", "text": "  get_underline() \n check if text will be rendered with an underline get_underline() -> bool  Return True when the font underline is enabled.  \n Note This is the same as the underline attribute.  \n \n"}, {"name": "font.Font.italic", "path": "ref/font#pygame.font.Font.italic", "type": "pygame.font", "text": "  italic \n Gets or sets whether the font should be rendered in (faked) italics. italic -> bool  Whether the font should be rendered in italic. When set to True, this enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold and underline modes.  New in pygame 2.0.0.  \n"}, {"name": "font.Font.metrics", "path": "ref/font#pygame.font.Font.metrics", "type": "pygame.font", "text": "  metrics() \n gets the metrics for each character in the passed string metrics(text) -> list  The list contains tuples for each character, which contain the minimum X offset, the maximum X offset, the minimum Y offset, the maximum Y offset and the advance offset (bearing plus width) of the character. [(minx, maxx, miny, maxy, advance), (minx, maxx, miny, maxy, advance), ...]. None is entered in the list for each unrecognized character. \n"}, {"name": "font.Font.render", "path": "ref/font#pygame.font.Font.render", "type": "pygame.font", "text": "  render() \n draw text on a new Surface render(text, antialias, color, background=None) -> Surface  This creates a new Surface with the specified text rendered on it. pygame provides no way to directly draw text on an existing Surface: instead you must use Font.render() to create an image (Surface) of the text, then blit this image onto another Surface. The text can only be a single line: newline characters are not rendered. Null characters ('x00') raise a TypeError. Both Unicode and char (byte) strings are accepted. For Unicode strings only UCS-2 characters ('u0001' to 'uFFFF') are recognized. Anything greater raises a UnicodeError. For char strings a LATIN1 encoding is assumed. The antialias argument is a boolean: if true the characters will have smooth edges. The color argument is the color of the text [e.g.: (0,0,255) for blue]. The optional background argument is a color to use for the text background. If no background is passed the area outside the text will be transparent. The Surface returned will be of the dimensions required to hold the text. (the same as those returned by Font.size()). If an empty string is passed for the text, a blank surface will be returned that is zero pixel wide and the height of the font. Depending on the type of background and antialiasing used, this returns different types of Surfaces. For performance reasons, it is good to know what type of image will be used. If antialiasing is not used, the return image will always be an 8-bit image with a two-color palette. If the background is transparent a colorkey will be set. Antialiased images are rendered to 24-bit RGB images. If the background is transparent a pixel alpha will be included. Optimization: if you know that the final destination for the text (on the screen) will always have a solid background, and the text is antialiased, you can improve performance by specifying the background color. This will cause the resulting image to maintain transparency information by colorkey rather than (much less efficient) alpha values. If you render '\\n' an unknown char will be rendered. Usually a rectangle. Instead you need to handle new lines yourself. Font rendering is not thread safe: only a single thread can render text at any time. \n"}, {"name": "font.Font.set_bold", "path": "ref/font#pygame.font.Font.set_bold", "type": "pygame.font", "text": "  set_bold() \n enable fake rendering of bold text set_bold(bool) -> None  Enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic and underline modes.  Note This is the same as the bold attribute.  \n"}, {"name": "font.Font.set_italic", "path": "ref/font#pygame.font.Font.set_italic", "type": "pygame.font", "text": "  set_italic() \n enable fake rendering of italic text set_italic(bool) -> None  Enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold and underline modes.  Note This is the same as the italic attribute.  \n"}, {"name": "font.Font.set_underline", "path": "ref/font#pygame.font.Font.set_underline", "type": "pygame.font", "text": "  set_underline() \n control if text is rendered with an underline set_underline(bool) -> None  When enabled, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold and italic modes.  Note This is the same as the underline attribute.  \n"}, {"name": "font.Font.size", "path": "ref/font#pygame.font.Font.size", "type": "pygame.font", "text": "  size() \n determine the amount of space needed to render text size(text) -> (width, height)  Returns the dimensions needed to render the text. This can be used to help determine the positioning needed for text before it is rendered. It can also be used for wordwrapping and other layout effects. Be aware that most fonts use kerning which adjusts the widths for specific letter pairs. For example, the width for \"ae\" will not always match the width for \"a\" + \"e\". \n"}, {"name": "font.Font.underline", "path": "ref/font#pygame.font.Font.underline", "type": "pygame.font", "text": "  underline \n Gets or sets whether the font should be rendered with an underline. underline -> bool  Whether the font should be rendered in underline. When set to True, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold and italic modes.  New in pygame 2.0.0.  \n"}, {"name": "font.get_default_font", "path": "ref/font#pygame.font.get_default_font", "type": "pygame.font", "text": "  pygame.font.get_default_font() \n get the filename of the default font get_default_font() -> string  Return the filename of the system font. This is not the full path to the file. This file can usually be found in the same directory as the font module, but it can also be bundled in separate archives. \n"}, {"name": "font.get_fonts", "path": "ref/font#pygame.font.get_fonts", "type": "pygame.font", "text": "  pygame.font.get_fonts() \n get all available fonts get_fonts() -> list of strings  Returns a list of all the fonts available on the system. The names of the fonts will be set to lowercase with all spaces and punctuation removed. This works on most systems, but some will return an empty list if they cannot find fonts. \n"}, {"name": "font.get_init", "path": "ref/font#pygame.font.get_init", "type": "pygame.font", "text": "  pygame.font.get_init() \n true if the font module is initialized get_init() -> bool  Test if the font module is initialized or not. \n"}, {"name": "font.init", "path": "ref/font#pygame.font.init", "type": "pygame.font", "text": "  pygame.font.init() \n initialize the font module init() -> None  This method is called automatically by pygame.init(). It initializes the font module. The module must be initialized before any other functions will work. It is safe to call this function more than once. \n"}, {"name": "font.match_font", "path": "ref/font#pygame.font.match_font", "type": "pygame.font", "text": "  pygame.font.match_font() \n find a specific font on the system match_font(name, bold=False, italic=False) -> path  Returns the full path to a font file on the system. If bold or italic are set to true, this will attempt to find the correct family of font. The font name can also be an iterable of font names, a string of comma-separated font names, or a bytes of comma-separated font names, in which case the set of names will be searched in order. If none of the given names are found, None is returned.  New in pygame 2.0.1: Accept an iterable of font names.  Example: print pygame.font.match_font('bitstreamverasans')\n# output is: /usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf\n# (but only if you have Vera on your system) \n"}, {"name": "font.quit", "path": "ref/font#pygame.font.quit", "type": "pygame.font", "text": "  pygame.font.quit() \n uninitialize the font module quit() -> None  Manually uninitialize SDL_ttf's font system. This is called automatically by pygame.quit(). It is safe to call this function even if font is currently not initialized. \n"}, {"name": "font.SysFont", "path": "ref/font#pygame.font.SysFont", "type": "pygame.font", "text": "  pygame.font.SysFont() \n create a Font object from the system fonts SysFont(name, size, bold=False, italic=False) -> Font  Return a new Font object that is loaded from the system fonts. The font will match the requested bold and italic flags. Pygame uses a small set of common font aliases. If the specific font you ask for is not available, a reasonable alternative may be used. If a suitable system font is not found this will fall back on loading the default pygame font. The font name can also be an iterable of font names, a string of comma-separated font names, or a bytes of comma-separated font names, in which case the set of names will be searched in order.  New in pygame 2.0.1: Accept an iterable of font names.  \n"}, {"name": "freetype", "path": "ref/freetype", "type": "pygame.freetype", "text": " pygame.freetype\n  \n Enhanced pygame module for loading and rendering computer fonts  The pygame.freetype module is a replacement for pygame.font. It has all of the functionality of the original, plus many new features. Yet is has absolutely no dependencies on the SDL_ttf library. It is implemented directly on the FreeType 2 library. The pygame.freetype module is not itself backward compatible with pygame.font. Instead, use the pygame.ftfont module as a drop-in replacement for pygame.font. All font file formats supported by FreeType can be rendered by pygame.freetype, namely TTF, Type1, CFF, OpenType, SFNT, PCF, FNT, BDF, PFR and Type42 fonts. All glyphs having UTF-32 code points are accessible (see Font.ucs4). Most work on fonts is done using Font instances. The module itself only has routines for initialization and creation of Font objects. You can load fonts from the system using the SysFont() function. Extra support of bitmap fonts is available. Available bitmap sizes can be listed (see Font.get_sizes()). For bitmap only fonts Font can set the size for you (see the Font.size property). For now undefined character codes are replaced with the .notdef (not defined) character. How undefined codes are handled may become configurable in a future release. Pygame comes with a built-in default font. This can always be accessed by passing None as the font name to the Font constructor. Extra rendering features available to pygame.freetype.Font are direct to surface rendering (see Font.render_to()), character kerning (see Font.kerning), vertical layout (see Font.vertical), rotation of rendered text (see Font.rotation), and the strong style (see Font.strong). Some properties are configurable, such as strong style strength (see Font.strength) and underline positioning (see Font.underline_adjustment). Text can be positioned by the upper right corner of the text box or by the text baseline (see Font.origin). Finally, a font's vertical and horizontal size can be adjusted separately (see Font.size). The pygame.examples.freetype_misc example shows these features in use. The pygame package does not import freetype automatically when loaded. This module must be imported explicitly to be used. import pygame\nimport pygame.freetype  New in pygame 1.9.2: freetype    pygame.freetype.get_error() \n Return the latest FreeType error get_error() -> str get_error() -> None  Return a description of the last error which occurred in the FreeType2 library, or None if no errors have occurred. \n   pygame.freetype.get_version() \n Return the FreeType version get_version() -> (int, int, int)  Returns the version of the FreeType library in use by this module. Note that the freetype module depends on the FreeType 2 library. It will not compile with the original FreeType 1.0. Hence, the first element of the tuple will always be \"2\". \n   pygame.freetype.init() \n Initialize the underlying FreeType library. init(cache_size=64, resolution=72)  This function initializes the underlying FreeType library and must be called before trying to use any of the functionality of the freetype module. However, pygame.init() will automatically call this function if the freetype module is already imported. It is safe to call this function more than once. Optionally, you may specify a default cache_size for the Glyph cache: the maximum number of glyphs that will be cached at any given time by the module. Exceedingly small values will be automatically tuned for performance. Also a default pixel resolution, in dots per inch, can be given to adjust font scaling. \n   pygame.freetype.quit() \n Shut down the underlying FreeType library. quit()  This function closes the freetype module. After calling this function, you should not invoke any class, method or function related to the freetype module as they are likely to fail or might give unpredictable results. It is safe to call this function even if the module hasn't been initialized yet. \n   pygame.freetype.get_init() \n Returns True if the FreeType module is currently initialized. get_init() -> bool  Returns True if the pygame.freetype module is currently initialized.  New in pygame 1.9.5.  \n   pygame.freetype.was_init() \n DEPRECATED: Use get_init() instead. was_init() -> bool  DEPRECATED: Returns True if the pygame.freetype module is currently initialized. Use get_init() instead. \n   pygame.freetype.get_cache_size() \n Return the glyph case size get_cache_size() -> long  See pygame.freetype.init(). \n   pygame.freetype.get_default_resolution() \n Return the default pixel size in dots per inch get_default_resolution() -> long  Returns the default pixel size, in dots per inch, for the module. The default is 72 DPI. \n   pygame.freetype.set_default_resolution() \n Set the default pixel size in dots per inch for the module set_default_resolution([resolution])  Set the default pixel size, in dots per inch, for the module. If the optional argument is omitted or zero the resolution is reset to 72 DPI. \n   pygame.freetype.SysFont() \n create a Font object from the system fonts SysFont(name, size, bold=False, italic=False) -> Font  Return a new Font object that is loaded from the system fonts. The font will match the requested bold and italic flags. Pygame uses a small set of common font aliases. If the specific font you ask for is not available, a reasonable alternative may be used. If a suitable system font is not found this will fall back on loading the default pygame font. The font name can also be an iterable of font names, a string of comma-separated font names, or a bytes of comma-separated font names, in which case the set of names will be searched in order.  New in pygame 2.0.1: Accept an iterable of font names.  \n   pygame.freetype.get_default_font() \n Get the filename of the default font get_default_font() -> string  Return the filename of the default pygame font. This is not the full path to the file. The file is usually in the same directory as the font module, but can also be bundled in a separate archive. \n   pygame.freetype.Font \n Create a new Font instance from a supported font file. Font(file, size=0, font_index=0, resolution=0, ucs4=False) -> Font  Argument file can be either a string representing the font's filename, a file-like object containing the font, or None; if None, a default, Pygame, font is used. Optionally, a size argument may be specified to set the default size in points, which determines the size of the rendered characters. The size can also be passed explicitly to each method call. Because of the way the caching system works, specifying a default size on the constructor doesn't imply a performance gain over manually passing the size on each function call. If the font is bitmap and no size is given, the default size is set to the first available size for the font. If the font file has more than one font, the font to load can be chosen with the index argument. An exception is raised for an out-of-range font index value. The optional resolution argument sets the pixel size, in dots per inch, for use in scaling glyphs for this Font instance. If 0 then the default module value, set by init(), is used. The Font object's resolution can only be changed by re-initializing the Font instance. The optional ucs4 argument, an integer, sets the default text translation mode: 0 (False) recognize UTF-16 surrogate pairs, any other value (True), to treat Unicode text as UCS-4, with no surrogate pairs. See Font.ucs4.   name \n Proper font name. name -> string  Read only. Returns the real (long) name of the font, as recorded in the font file. \n   path \n Font file path path -> unicode  Read only. Returns the path of the loaded font file \n   size \n The default point size used in rendering size -> float size -> (float, float)  Get or set the default size for text metrics and rendering. It can be a single point size, given as a Python int or float, or a font ppem (width, height) tuple. Size values are non-negative. A zero size or width represents an undefined size. In this case the size must be given as a method argument, or an exception is raised. A zero width but non-zero height is a ValueError. For a scalable font, a single number value is equivalent to a tuple with width equal height. A font can be stretched vertically with height set greater than width, or horizontally with width set greater than height. For embedded bitmaps, as listed by get_sizes(), use the nominal width and height to select an available size. Font size differs for a non-scalable, bitmap, font. During a method call it must match one of the available sizes returned by method get_sizes(). If not, an exception is raised. If the size is a single number, the size is first matched against the point size value. If no match, then the available size with the same nominal width and height is chosen. \n   get_rect() \n Return the size and offset of rendered text get_rect(text, style=STYLE_DEFAULT, rotation=0, size=0) -> rect  Gets the final dimensions and origin, in pixels, of text using the optional size in points, style, and rotation. For other relevant render properties, and for any optional argument not given, the default values set for the Font instance are used. Returns a Rect instance containing the width and height of the text's bounding box and the position of the text's origin. The origin is useful in aligning separately rendered pieces of text. It gives the baseline position and bearing at the start of the text. See the render_to() method for an example. If text is a char (byte) string, its encoding is assumed to be LATIN1. Optionally, text can be None, which will return the bounding rectangle for the text passed to a previous get_rect(), render(), render_to(), render_raw(), or render_raw_to() call. See render_to() for more details. \n   get_metrics() \n Return the glyph metrics for the given text get_metrics(text, size=0) -> [(...), ...]  Returns the glyph metrics for each character in text. The glyph metrics are returned as a list of tuples. Each tuple gives metrics of a single character glyph. The glyph metrics are: (min_x, max_x, min_y, max_y, horizontal_advance_x, horizontal_advance_y) The bounding box min_x, max_x, min_y, and max_y values are returned as grid-fitted pixel coordinates of type int. The advance values are float values. The calculations are done using the font's default size in points. Optionally you may specify another point size with the size argument. The metrics are adjusted for the current rotation, strong, and oblique settings. If text is a char (byte) string, then its encoding is assumed to be LATIN1. \n   height \n The unscaled height of the font in font units height -> int  Read only. Gets the height of the font. This is the average value of all glyphs in the font. \n   ascender \n The unscaled ascent of the font in font units ascender -> int  Read only. Return the number of units from the font's baseline to the top of the bounding box. \n   descender \n The unscaled descent of the font in font units descender -> int  Read only. Return the height in font units for the font descent. The descent is the number of units from the font's baseline to the bottom of the bounding box. \n   get_sized_ascender() \n The scaled ascent of the font in pixels get_sized_ascender(<size>=0) -> int  Return the number of units from the font's baseline to the top of the bounding box. It is not adjusted for strong or rotation. \n   get_sized_descender() \n The scaled descent of the font in pixels get_sized_descender(<size>=0) -> int  Return the number of pixels from the font's baseline to the top of the bounding box. It is not adjusted for strong or rotation. \n   get_sized_height() \n The scaled height of the font in pixels get_sized_height(<size>=0) -> int  Returns the height of the font. This is the average value of all glyphs in the font. It is not adjusted for strong or rotation. \n   get_sized_glyph_height() \n The scaled bounding box height of the font in pixels get_sized_glyph_height(<size>=0) -> int  Return the glyph bounding box height of the font in pixels. This is the average value of all glyphs in the font. It is not adjusted for strong or rotation. \n   get_sizes() \n return the available sizes of embedded bitmaps get_sizes() -> [(int, int, int, float, float), ...] get_sizes() -> []  Returns a list of tuple records, one for each point size supported. Each tuple containing the point size, the height in pixels, width in pixels, horizontal ppem (nominal width) in fractional pixels, and vertical ppem (nominal height) in fractional pixels. \n   render() \n Return rendered text as a surface render(text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -> (Surface, Rect)  Returns a new Surface, with the text rendered to it in the color given by 'fgcolor'. If no foreground color is given, the default foreground color, fgcolor is used. If bgcolor is given, the surface will be filled with this color. When no background color is given, the surface background is transparent, zero alpha. Normally the returned surface has a 32 bit pixel size. However, if bgcolor is None and anti-aliasing is disabled a monochrome 8 bit colorkey surface, with colorkey set for the background color, is returned. The return value is a tuple: the new surface and the bounding rectangle giving the size and origin of the rendered text. If an empty string is passed for text then the returned Rect is zero width and the height of the font. Optional fgcolor, style, rotation, and size arguments override the default values set for the Font instance. If text is a char (byte) string, then its encoding is assumed to be LATIN1. Optionally, text can be None, which will render the text passed to a previous get_rect(), render(), render_to(), render_raw(), or render_raw_to() call. See render_to() for details. \n   render_to() \n Render text onto an existing surface render_to(surf, dest, text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -> Rect  Renders the string text to the pygame.Surface surf, at position dest, a (x, y) surface coordinate pair. If either x or y is not an integer it is converted to one if possible. Any sequence where the first two items are x and y positional elements is accepted, including a Rect instance. As with render(), optional fgcolor, style, rotation, and size argument are available. If a background color bgcolor is given, the text bounding box is first filled with that color. The text is blitted next. Both the background fill and text rendering involve full alpha blits. That is, the alpha values of the foreground, background, and destination target surface all affect the blit. The return value is a rectangle giving the size and position of the rendered text within the surface. If an empty string is passed for text then the returned Rect is zero width and the height of the font. The rect will test False. Optionally, text can be set None, which will re-render text passed to a previous render_to(), get_rect(), render(), render_raw(), or render_raw_to() call. Primarily, this feature is an aid to using render_to() in combination with get_rect(). An example: def word_wrap(surf, text, font, color=(0, 0, 0)):\n    font.origin = True\n    words = text.split(' ')\n    width, height = surf.get_size()\n    line_spacing = font.get_sized_height() + 2\n    x, y = 0, line_spacing\n    space = font.get_rect(' ')\n    for word in words:\n        bounds = font.get_rect(word)\n        if x + bounds.width + bounds.x >= width:\n            x, y = 0, y + line_spacing\n        if x + bounds.width + bounds.x >= width:\n            raise ValueError(\"word too wide for the surface\")\n        if y + bounds.height - bounds.y >= height:\n            raise ValueError(\"text to long for the surface\")\n        font.render_to(surf, (x, y), None, color)\n        x += bounds.width + space.width\n    return x, y When render_to() is called with the same font properties \u2015 size, style, strength, wide, antialiased, vertical, rotation, kerning, and use_bitmap_strikes \u2015 as get_rect(), render_to() will use the layout calculated by get_rect(). Otherwise, render_to() will recalculate the layout if called with a text string or one of the above properties has changed after the get_rect() call. If text is a char (byte) string, then its encoding is assumed to be LATIN1. \n   render_raw() \n Return rendered text as a string of bytes render_raw(text, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -> (bytes, (int, int))  Like render() but with the pixels returned as a byte string of 8-bit gray-scale values. The foreground color is 255, the background 0, useful as an alpha mask for a foreground pattern. \n   render_raw_to() \n Render text into an array of ints render_raw_to(array, text, dest=None, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -> Rect  Render to an array object exposing an array struct interface. The array must be two dimensional with integer items. The default dest value, None, is equivalent to position (0, 0). See render_to(). As with the other render methods, text can be None to render a text string passed previously to another method. The return value is a pygame.Rect() giving the size and position of the rendered text. \n   style \n The font's style flags style -> int  Gets or sets the default style of the Font. This default style will be used for all text rendering and size calculations unless overridden specifically a render or get_rect() call. The style value may be a bit-wise OR of one or more of the following constants: STYLE_NORMAL\nSTYLE_UNDERLINE\nSTYLE_OBLIQUE\nSTYLE_STRONG\nSTYLE_WIDE\nSTYLE_DEFAULT These constants may be found on the FreeType constants module. Optionally, the default style can be modified or obtained accessing the individual style attributes (underline, oblique, strong). The STYLE_OBLIQUE and STYLE_STRONG styles are for scalable fonts only. An attempt to set either for a bitmap font raises an AttributeError. An attempt to set either for an inactive font, as returned by Font.__new__(), raises a RuntimeError. Assigning STYLE_DEFAULT to the style property leaves the property unchanged, as this property defines the default. The style property will never return STYLE_DEFAULT. \n   underline \n The state of the font's underline style flag underline -> bool  Gets or sets whether the font will be underlined when drawing text. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the 'style' parameter. \n   strong \n The state of the font's strong style flag strong -> bool  Gets or sets whether the font will be bold when drawing text. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the 'style' parameter. \n   oblique \n The state of the font's oblique style flag oblique -> bool  Gets or sets whether the font will be rendered as oblique. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the style parameter. The oblique style is only supported for scalable (outline) fonts. An attempt to set this style on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by Font.__new__(), setting this property raises a RuntimeError. \n   wide \n The state of the font's wide style flag wide -> bool  Gets or sets whether the font will be stretched horizontally when drawing text. It produces a result similar to pygame.font.Font's bold. This style not available for rotated text. \n   strength \n The strength associated with the strong or wide font styles strength -> float  The amount by which a font glyph's size is enlarged for the strong or wide transformations, as a fraction of the untransformed size. For the wide style only the horizontal dimension is increased. For strong text both the horizontal and vertical dimensions are enlarged. A wide style of strength 0.08333 ( 1/12 ) is equivalent to the pygame.font.Font bold style. The default is 0.02778 ( 1/36 ). The strength style is only supported for scalable (outline) fonts. An attempt to set this property on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by Font.__new__(), assignment to this property raises a RuntimeError. \n   underline_adjustment \n Adjustment factor for the underline position underline_adjustment -> float  Gets or sets a factor which, when positive, is multiplied with the font's underline offset to adjust the underline position. A negative value turns an underline into a strike-through or overline. It is multiplied with the ascender. Accepted values range between -2.0 and 2.0 inclusive. A value of 0.5 closely matches Tango underlining. A value of 1.0 mimics pygame.font.Font underlining. \n   fixed_width \n Gets whether the font is fixed-width fixed_width -> bool  Read only. Returns True if the font contains fixed-width characters (for example Courier, Bitstream Vera Sans Mono, Andale Mono). \n   fixed_sizes \n the number of available bitmap sizes for the font fixed_sizes -> int  Read only. Returns the number of point sizes for which the font contains bitmap character images. If zero then the font is not a bitmap font. A scalable font may contain pre-rendered point sizes as strikes. \n   scalable \n Gets whether the font is scalable scalable -> bool  Read only. Returns True if the font contains outline glyphs. If so, the point size is not limited to available bitmap sizes. \n   use_bitmap_strikes \n allow the use of embedded bitmaps in an outline font file use_bitmap_strikes -> bool  Some scalable fonts include embedded bitmaps for particular point sizes. This property controls whether or not those bitmap strikes are used. Set it False to disable the loading of any bitmap strike. Set it True, the default, to permit bitmap strikes for a non-rotated render with no style other than wide or underline. This property is ignored for bitmap fonts. See also fixed_sizes and get_sizes(). \n   antialiased \n Font anti-aliasing mode antialiased -> bool  Gets or sets the font's anti-aliasing mode. This defaults to True on all fonts, which are rendered with full 8 bit blending. Set to False to do monochrome rendering. This should provide a small speed gain and reduce cache memory size. \n   kerning \n Character kerning mode kerning -> bool  Gets or sets the font's kerning mode. This defaults to False on all fonts, which will be rendered without kerning. Set to True to add kerning between character pairs, if supported by the font, when positioning glyphs. \n   vertical \n Font vertical mode vertical -> bool  Gets or sets whether the characters are laid out vertically rather than horizontally. May be useful when rendering Kanji or some other vertical script. Set to True to switch to a vertical text layout. The default is False, place horizontally. Note that the Font class does not automatically determine script orientation. Vertical layout must be selected explicitly. Also note that several font formats (especially bitmap based ones) don't contain the necessary metrics to draw glyphs vertically, so drawing in those cases will give unspecified results. \n   rotation \n text rotation in degrees counterclockwise rotation -> int  Gets or sets the baseline angle of the rendered text. The angle is represented as integer degrees. The default angle is 0, with horizontal text rendered along the X-axis, and vertical text along the Y-axis. A positive value rotates these axes counterclockwise that many degrees. A negative angle corresponds to a clockwise rotation. The rotation value is normalized to a value within the range 0 to 359 inclusive (eg. 390 -> 390 - 360 -> 30, -45 -> 360 + -45 -> 315, 720 -> 720 - (2 * 360) -> 0). Only scalable (outline) fonts can be rotated. An attempt to change the rotation of a bitmap font raises an AttributeError. An attempt to change the rotation of an inactive font instance, as returned by Font.__new__(), raises a RuntimeError. \n   fgcolor \n default foreground color fgcolor -> Color  Gets or sets the default glyph rendering color. It is initially opaque black \u2015 (0, 0, 0, 255). Applies to render() and render_to(). \n   bgcolor \n default background color bgcolor -> Color  Gets or sets the default background rendering color. Initially it is unset and text will render with a transparent background by default. Applies to render() and render_to(). \n  New in pygame 2.0.0.    origin \n Font render to text origin mode origin -> bool  If set True, render_to() and render_raw_to() will take the dest position to be that of the text origin, as opposed to the top-left corner of the bounding box. See get_rect() for details. \n   pad \n padded boundary mode pad -> bool  If set True, then the text boundary rectangle will be inflated to match that of font.Font. Otherwise, the boundary rectangle is just large enough for the text. \n   ucs4 \n Enable UCS-4 mode ucs4 -> bool  Gets or sets the decoding of Unicode text. By default, the freetype module performs UTF-16 surrogate pair decoding on Unicode text. This allows 32-bit escape sequences ('Uxxxxxxxx') between 0x10000 and 0x10FFFF to represent their corresponding UTF-32 code points on Python interpreters built with a UCS-2 Unicode type (on Windows, for instance). It also means character values within the UTF-16 surrogate area (0xD800 to 0xDFFF) are considered part of a surrogate pair. A malformed surrogate pair will raise a UnicodeEncodeError. Setting ucs4 True turns surrogate pair decoding off, allowing access the full UCS-4 character range to a Python interpreter built with four-byte Unicode character support. \n   resolution \n Pixel resolution in dots per inch resolution -> int  Read only. Gets pixel size used in scaling font glyphs for this Font instance. \n \n \n \n"}, {"name": "freetype.Font", "path": "ref/freetype#pygame.freetype.Font", "type": "pygame.freetype", "text": "  pygame.freetype.Font \n Create a new Font instance from a supported font file. Font(file, size=0, font_index=0, resolution=0, ucs4=False) -> Font  Argument file can be either a string representing the font's filename, a file-like object containing the font, or None; if None, a default, Pygame, font is used. Optionally, a size argument may be specified to set the default size in points, which determines the size of the rendered characters. The size can also be passed explicitly to each method call. Because of the way the caching system works, specifying a default size on the constructor doesn't imply a performance gain over manually passing the size on each function call. If the font is bitmap and no size is given, the default size is set to the first available size for the font. If the font file has more than one font, the font to load can be chosen with the index argument. An exception is raised for an out-of-range font index value. The optional resolution argument sets the pixel size, in dots per inch, for use in scaling glyphs for this Font instance. If 0 then the default module value, set by init(), is used. The Font object's resolution can only be changed by re-initializing the Font instance. The optional ucs4 argument, an integer, sets the default text translation mode: 0 (False) recognize UTF-16 surrogate pairs, any other value (True), to treat Unicode text as UCS-4, with no surrogate pairs. See Font.ucs4.   name \n Proper font name. name -> string  Read only. Returns the real (long) name of the font, as recorded in the font file. \n   path \n Font file path path -> unicode  Read only. Returns the path of the loaded font file \n   size \n The default point size used in rendering size -> float size -> (float, float)  Get or set the default size for text metrics and rendering. It can be a single point size, given as a Python int or float, or a font ppem (width, height) tuple. Size values are non-negative. A zero size or width represents an undefined size. In this case the size must be given as a method argument, or an exception is raised. A zero width but non-zero height is a ValueError. For a scalable font, a single number value is equivalent to a tuple with width equal height. A font can be stretched vertically with height set greater than width, or horizontally with width set greater than height. For embedded bitmaps, as listed by get_sizes(), use the nominal width and height to select an available size. Font size differs for a non-scalable, bitmap, font. During a method call it must match one of the available sizes returned by method get_sizes(). If not, an exception is raised. If the size is a single number, the size is first matched against the point size value. If no match, then the available size with the same nominal width and height is chosen. \n   get_rect() \n Return the size and offset of rendered text get_rect(text, style=STYLE_DEFAULT, rotation=0, size=0) -> rect  Gets the final dimensions and origin, in pixels, of text using the optional size in points, style, and rotation. For other relevant render properties, and for any optional argument not given, the default values set for the Font instance are used. Returns a Rect instance containing the width and height of the text's bounding box and the position of the text's origin. The origin is useful in aligning separately rendered pieces of text. It gives the baseline position and bearing at the start of the text. See the render_to() method for an example. If text is a char (byte) string, its encoding is assumed to be LATIN1. Optionally, text can be None, which will return the bounding rectangle for the text passed to a previous get_rect(), render(), render_to(), render_raw(), or render_raw_to() call. See render_to() for more details. \n   get_metrics() \n Return the glyph metrics for the given text get_metrics(text, size=0) -> [(...), ...]  Returns the glyph metrics for each character in text. The glyph metrics are returned as a list of tuples. Each tuple gives metrics of a single character glyph. The glyph metrics are: (min_x, max_x, min_y, max_y, horizontal_advance_x, horizontal_advance_y) The bounding box min_x, max_x, min_y, and max_y values are returned as grid-fitted pixel coordinates of type int. The advance values are float values. The calculations are done using the font's default size in points. Optionally you may specify another point size with the size argument. The metrics are adjusted for the current rotation, strong, and oblique settings. If text is a char (byte) string, then its encoding is assumed to be LATIN1. \n   height \n The unscaled height of the font in font units height -> int  Read only. Gets the height of the font. This is the average value of all glyphs in the font. \n   ascender \n The unscaled ascent of the font in font units ascender -> int  Read only. Return the number of units from the font's baseline to the top of the bounding box. \n   descender \n The unscaled descent of the font in font units descender -> int  Read only. Return the height in font units for the font descent. The descent is the number of units from the font's baseline to the bottom of the bounding box. \n   get_sized_ascender() \n The scaled ascent of the font in pixels get_sized_ascender(<size>=0) -> int  Return the number of units from the font's baseline to the top of the bounding box. It is not adjusted for strong or rotation. \n   get_sized_descender() \n The scaled descent of the font in pixels get_sized_descender(<size>=0) -> int  Return the number of pixels from the font's baseline to the top of the bounding box. It is not adjusted for strong or rotation. \n   get_sized_height() \n The scaled height of the font in pixels get_sized_height(<size>=0) -> int  Returns the height of the font. This is the average value of all glyphs in the font. It is not adjusted for strong or rotation. \n   get_sized_glyph_height() \n The scaled bounding box height of the font in pixels get_sized_glyph_height(<size>=0) -> int  Return the glyph bounding box height of the font in pixels. This is the average value of all glyphs in the font. It is not adjusted for strong or rotation. \n   get_sizes() \n return the available sizes of embedded bitmaps get_sizes() -> [(int, int, int, float, float), ...] get_sizes() -> []  Returns a list of tuple records, one for each point size supported. Each tuple containing the point size, the height in pixels, width in pixels, horizontal ppem (nominal width) in fractional pixels, and vertical ppem (nominal height) in fractional pixels. \n   render() \n Return rendered text as a surface render(text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -> (Surface, Rect)  Returns a new Surface, with the text rendered to it in the color given by 'fgcolor'. If no foreground color is given, the default foreground color, fgcolor is used. If bgcolor is given, the surface will be filled with this color. When no background color is given, the surface background is transparent, zero alpha. Normally the returned surface has a 32 bit pixel size. However, if bgcolor is None and anti-aliasing is disabled a monochrome 8 bit colorkey surface, with colorkey set for the background color, is returned. The return value is a tuple: the new surface and the bounding rectangle giving the size and origin of the rendered text. If an empty string is passed for text then the returned Rect is zero width and the height of the font. Optional fgcolor, style, rotation, and size arguments override the default values set for the Font instance. If text is a char (byte) string, then its encoding is assumed to be LATIN1. Optionally, text can be None, which will render the text passed to a previous get_rect(), render(), render_to(), render_raw(), or render_raw_to() call. See render_to() for details. \n   render_to() \n Render text onto an existing surface render_to(surf, dest, text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -> Rect  Renders the string text to the pygame.Surface surf, at position dest, a (x, y) surface coordinate pair. If either x or y is not an integer it is converted to one if possible. Any sequence where the first two items are x and y positional elements is accepted, including a Rect instance. As with render(), optional fgcolor, style, rotation, and size argument are available. If a background color bgcolor is given, the text bounding box is first filled with that color. The text is blitted next. Both the background fill and text rendering involve full alpha blits. That is, the alpha values of the foreground, background, and destination target surface all affect the blit. The return value is a rectangle giving the size and position of the rendered text within the surface. If an empty string is passed for text then the returned Rect is zero width and the height of the font. The rect will test False. Optionally, text can be set None, which will re-render text passed to a previous render_to(), get_rect(), render(), render_raw(), or render_raw_to() call. Primarily, this feature is an aid to using render_to() in combination with get_rect(). An example: def word_wrap(surf, text, font, color=(0, 0, 0)):\n    font.origin = True\n    words = text.split(' ')\n    width, height = surf.get_size()\n    line_spacing = font.get_sized_height() + 2\n    x, y = 0, line_spacing\n    space = font.get_rect(' ')\n    for word in words:\n        bounds = font.get_rect(word)\n        if x + bounds.width + bounds.x >= width:\n            x, y = 0, y + line_spacing\n        if x + bounds.width + bounds.x >= width:\n            raise ValueError(\"word too wide for the surface\")\n        if y + bounds.height - bounds.y >= height:\n            raise ValueError(\"text to long for the surface\")\n        font.render_to(surf, (x, y), None, color)\n        x += bounds.width + space.width\n    return x, y When render_to() is called with the same font properties \u2015 size, style, strength, wide, antialiased, vertical, rotation, kerning, and use_bitmap_strikes \u2015 as get_rect(), render_to() will use the layout calculated by get_rect(). Otherwise, render_to() will recalculate the layout if called with a text string or one of the above properties has changed after the get_rect() call. If text is a char (byte) string, then its encoding is assumed to be LATIN1. \n   render_raw() \n Return rendered text as a string of bytes render_raw(text, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -> (bytes, (int, int))  Like render() but with the pixels returned as a byte string of 8-bit gray-scale values. The foreground color is 255, the background 0, useful as an alpha mask for a foreground pattern. \n   render_raw_to() \n Render text into an array of ints render_raw_to(array, text, dest=None, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -> Rect  Render to an array object exposing an array struct interface. The array must be two dimensional with integer items. The default dest value, None, is equivalent to position (0, 0). See render_to(). As with the other render methods, text can be None to render a text string passed previously to another method. The return value is a pygame.Rect() giving the size and position of the rendered text. \n   style \n The font's style flags style -> int  Gets or sets the default style of the Font. This default style will be used for all text rendering and size calculations unless overridden specifically a render or get_rect() call. The style value may be a bit-wise OR of one or more of the following constants: STYLE_NORMAL\nSTYLE_UNDERLINE\nSTYLE_OBLIQUE\nSTYLE_STRONG\nSTYLE_WIDE\nSTYLE_DEFAULT These constants may be found on the FreeType constants module. Optionally, the default style can be modified or obtained accessing the individual style attributes (underline, oblique, strong). The STYLE_OBLIQUE and STYLE_STRONG styles are for scalable fonts only. An attempt to set either for a bitmap font raises an AttributeError. An attempt to set either for an inactive font, as returned by Font.__new__(), raises a RuntimeError. Assigning STYLE_DEFAULT to the style property leaves the property unchanged, as this property defines the default. The style property will never return STYLE_DEFAULT. \n   underline \n The state of the font's underline style flag underline -> bool  Gets or sets whether the font will be underlined when drawing text. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the 'style' parameter. \n   strong \n The state of the font's strong style flag strong -> bool  Gets or sets whether the font will be bold when drawing text. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the 'style' parameter. \n   oblique \n The state of the font's oblique style flag oblique -> bool  Gets or sets whether the font will be rendered as oblique. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the style parameter. The oblique style is only supported for scalable (outline) fonts. An attempt to set this style on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by Font.__new__(), setting this property raises a RuntimeError. \n   wide \n The state of the font's wide style flag wide -> bool  Gets or sets whether the font will be stretched horizontally when drawing text. It produces a result similar to pygame.font.Font's bold. This style not available for rotated text. \n   strength \n The strength associated with the strong or wide font styles strength -> float  The amount by which a font glyph's size is enlarged for the strong or wide transformations, as a fraction of the untransformed size. For the wide style only the horizontal dimension is increased. For strong text both the horizontal and vertical dimensions are enlarged. A wide style of strength 0.08333 ( 1/12 ) is equivalent to the pygame.font.Font bold style. The default is 0.02778 ( 1/36 ). The strength style is only supported for scalable (outline) fonts. An attempt to set this property on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by Font.__new__(), assignment to this property raises a RuntimeError. \n   underline_adjustment \n Adjustment factor for the underline position underline_adjustment -> float  Gets or sets a factor which, when positive, is multiplied with the font's underline offset to adjust the underline position. A negative value turns an underline into a strike-through or overline. It is multiplied with the ascender. Accepted values range between -2.0 and 2.0 inclusive. A value of 0.5 closely matches Tango underlining. A value of 1.0 mimics pygame.font.Font underlining. \n   fixed_width \n Gets whether the font is fixed-width fixed_width -> bool  Read only. Returns True if the font contains fixed-width characters (for example Courier, Bitstream Vera Sans Mono, Andale Mono). \n   fixed_sizes \n the number of available bitmap sizes for the font fixed_sizes -> int  Read only. Returns the number of point sizes for which the font contains bitmap character images. If zero then the font is not a bitmap font. A scalable font may contain pre-rendered point sizes as strikes. \n   scalable \n Gets whether the font is scalable scalable -> bool  Read only. Returns True if the font contains outline glyphs. If so, the point size is not limited to available bitmap sizes. \n   use_bitmap_strikes \n allow the use of embedded bitmaps in an outline font file use_bitmap_strikes -> bool  Some scalable fonts include embedded bitmaps for particular point sizes. This property controls whether or not those bitmap strikes are used. Set it False to disable the loading of any bitmap strike. Set it True, the default, to permit bitmap strikes for a non-rotated render with no style other than wide or underline. This property is ignored for bitmap fonts. See also fixed_sizes and get_sizes(). \n   antialiased \n Font anti-aliasing mode antialiased -> bool  Gets or sets the font's anti-aliasing mode. This defaults to True on all fonts, which are rendered with full 8 bit blending. Set to False to do monochrome rendering. This should provide a small speed gain and reduce cache memory size. \n   kerning \n Character kerning mode kerning -> bool  Gets or sets the font's kerning mode. This defaults to False on all fonts, which will be rendered without kerning. Set to True to add kerning between character pairs, if supported by the font, when positioning glyphs. \n   vertical \n Font vertical mode vertical -> bool  Gets or sets whether the characters are laid out vertically rather than horizontally. May be useful when rendering Kanji or some other vertical script. Set to True to switch to a vertical text layout. The default is False, place horizontally. Note that the Font class does not automatically determine script orientation. Vertical layout must be selected explicitly. Also note that several font formats (especially bitmap based ones) don't contain the necessary metrics to draw glyphs vertically, so drawing in those cases will give unspecified results. \n   rotation \n text rotation in degrees counterclockwise rotation -> int  Gets or sets the baseline angle of the rendered text. The angle is represented as integer degrees. The default angle is 0, with horizontal text rendered along the X-axis, and vertical text along the Y-axis. A positive value rotates these axes counterclockwise that many degrees. A negative angle corresponds to a clockwise rotation. The rotation value is normalized to a value within the range 0 to 359 inclusive (eg. 390 -> 390 - 360 -> 30, -45 -> 360 + -45 -> 315, 720 -> 720 - (2 * 360) -> 0). Only scalable (outline) fonts can be rotated. An attempt to change the rotation of a bitmap font raises an AttributeError. An attempt to change the rotation of an inactive font instance, as returned by Font.__new__(), raises a RuntimeError. \n   fgcolor \n default foreground color fgcolor -> Color  Gets or sets the default glyph rendering color. It is initially opaque black \u2015 (0, 0, 0, 255). Applies to render() and render_to(). \n   bgcolor \n default background color bgcolor -> Color  Gets or sets the default background rendering color. Initially it is unset and text will render with a transparent background by default. Applies to render() and render_to(). \n  New in pygame 2.0.0.    origin \n Font render to text origin mode origin -> bool  If set True, render_to() and render_raw_to() will take the dest position to be that of the text origin, as opposed to the top-left corner of the bounding box. See get_rect() for details. \n   pad \n padded boundary mode pad -> bool  If set True, then the text boundary rectangle will be inflated to match that of font.Font. Otherwise, the boundary rectangle is just large enough for the text. \n   ucs4 \n Enable UCS-4 mode ucs4 -> bool  Gets or sets the decoding of Unicode text. By default, the freetype module performs UTF-16 surrogate pair decoding on Unicode text. This allows 32-bit escape sequences ('Uxxxxxxxx') between 0x10000 and 0x10FFFF to represent their corresponding UTF-32 code points on Python interpreters built with a UCS-2 Unicode type (on Windows, for instance). It also means character values within the UTF-16 surrogate area (0xD800 to 0xDFFF) are considered part of a surrogate pair. A malformed surrogate pair will raise a UnicodeEncodeError. Setting ucs4 True turns surrogate pair decoding off, allowing access the full UCS-4 character range to a Python interpreter built with four-byte Unicode character support. \n   resolution \n Pixel resolution in dots per inch resolution -> int  Read only. Gets pixel size used in scaling font glyphs for this Font instance. \n \n"}, {"name": "freetype.Font.antialiased", "path": "ref/freetype#pygame.freetype.Font.antialiased", "type": "pygame.freetype", "text": "  antialiased \n Font anti-aliasing mode antialiased -> bool  Gets or sets the font's anti-aliasing mode. This defaults to True on all fonts, which are rendered with full 8 bit blending. Set to False to do monochrome rendering. This should provide a small speed gain and reduce cache memory size. \n"}, {"name": "freetype.Font.ascender", "path": "ref/freetype#pygame.freetype.Font.ascender", "type": "pygame.freetype", "text": "  ascender \n The unscaled ascent of the font in font units ascender -> int  Read only. Return the number of units from the font's baseline to the top of the bounding box. \n"}, {"name": "freetype.Font.bgcolor", "path": "ref/freetype#pygame.freetype.Font.bgcolor", "type": "pygame.freetype", "text": "  bgcolor \n default background color bgcolor -> Color  Gets or sets the default background rendering color. Initially it is unset and text will render with a transparent background by default. Applies to render() and render_to(). \n"}, {"name": "freetype.Font.descender", "path": "ref/freetype#pygame.freetype.Font.descender", "type": "pygame.freetype", "text": "  descender \n The unscaled descent of the font in font units descender -> int  Read only. Return the height in font units for the font descent. The descent is the number of units from the font's baseline to the bottom of the bounding box. \n"}, {"name": "freetype.Font.fgcolor", "path": "ref/freetype#pygame.freetype.Font.fgcolor", "type": "pygame.freetype", "text": "  fgcolor \n default foreground color fgcolor -> Color  Gets or sets the default glyph rendering color. It is initially opaque black \u2015 (0, 0, 0, 255). Applies to render() and render_to(). \n"}, {"name": "freetype.Font.fixed_sizes", "path": "ref/freetype#pygame.freetype.Font.fixed_sizes", "type": "pygame.freetype", "text": "  fixed_sizes \n the number of available bitmap sizes for the font fixed_sizes -> int  Read only. Returns the number of point sizes for which the font contains bitmap character images. If zero then the font is not a bitmap font. A scalable font may contain pre-rendered point sizes as strikes. \n"}, {"name": "freetype.Font.fixed_width", "path": "ref/freetype#pygame.freetype.Font.fixed_width", "type": "pygame.freetype", "text": "  fixed_width \n Gets whether the font is fixed-width fixed_width -> bool  Read only. Returns True if the font contains fixed-width characters (for example Courier, Bitstream Vera Sans Mono, Andale Mono). \n"}, {"name": "freetype.Font.get_metrics", "path": "ref/freetype#pygame.freetype.Font.get_metrics", "type": "pygame.freetype", "text": "  get_metrics() \n Return the glyph metrics for the given text get_metrics(text, size=0) -> [(...), ...]  Returns the glyph metrics for each character in text. The glyph metrics are returned as a list of tuples. Each tuple gives metrics of a single character glyph. The glyph metrics are: (min_x, max_x, min_y, max_y, horizontal_advance_x, horizontal_advance_y) The bounding box min_x, max_x, min_y, and max_y values are returned as grid-fitted pixel coordinates of type int. The advance values are float values. The calculations are done using the font's default size in points. Optionally you may specify another point size with the size argument. The metrics are adjusted for the current rotation, strong, and oblique settings. If text is a char (byte) string, then its encoding is assumed to be LATIN1. \n"}, {"name": "freetype.Font.get_rect", "path": "ref/freetype#pygame.freetype.Font.get_rect", "type": "pygame.freetype", "text": "  get_rect() \n Return the size and offset of rendered text get_rect(text, style=STYLE_DEFAULT, rotation=0, size=0) -> rect  Gets the final dimensions and origin, in pixels, of text using the optional size in points, style, and rotation. For other relevant render properties, and for any optional argument not given, the default values set for the Font instance are used. Returns a Rect instance containing the width and height of the text's bounding box and the position of the text's origin. The origin is useful in aligning separately rendered pieces of text. It gives the baseline position and bearing at the start of the text. See the render_to() method for an example. If text is a char (byte) string, its encoding is assumed to be LATIN1. Optionally, text can be None, which will return the bounding rectangle for the text passed to a previous get_rect(), render(), render_to(), render_raw(), or render_raw_to() call. See render_to() for more details. \n"}, {"name": "freetype.Font.get_sized_ascender", "path": "ref/freetype#pygame.freetype.Font.get_sized_ascender", "type": "pygame.freetype", "text": "  get_sized_ascender() \n The scaled ascent of the font in pixels get_sized_ascender(<size>=0) -> int  Return the number of units from the font's baseline to the top of the bounding box. It is not adjusted for strong or rotation. \n"}, {"name": "freetype.Font.get_sized_descender", "path": "ref/freetype#pygame.freetype.Font.get_sized_descender", "type": "pygame.freetype", "text": "  get_sized_descender() \n The scaled descent of the font in pixels get_sized_descender(<size>=0) -> int  Return the number of pixels from the font's baseline to the top of the bounding box. It is not adjusted for strong or rotation. \n"}, {"name": "freetype.Font.get_sized_glyph_height", "path": "ref/freetype#pygame.freetype.Font.get_sized_glyph_height", "type": "pygame.freetype", "text": "  get_sized_glyph_height() \n The scaled bounding box height of the font in pixels get_sized_glyph_height(<size>=0) -> int  Return the glyph bounding box height of the font in pixels. This is the average value of all glyphs in the font. It is not adjusted for strong or rotation. \n"}, {"name": "freetype.Font.get_sized_height", "path": "ref/freetype#pygame.freetype.Font.get_sized_height", "type": "pygame.freetype", "text": "  get_sized_height() \n The scaled height of the font in pixels get_sized_height(<size>=0) -> int  Returns the height of the font. This is the average value of all glyphs in the font. It is not adjusted for strong or rotation. \n"}, {"name": "freetype.Font.get_sizes", "path": "ref/freetype#pygame.freetype.Font.get_sizes", "type": "pygame.freetype", "text": "  get_sizes() \n return the available sizes of embedded bitmaps get_sizes() -> [(int, int, int, float, float), ...] get_sizes() -> []  Returns a list of tuple records, one for each point size supported. Each tuple containing the point size, the height in pixels, width in pixels, horizontal ppem (nominal width) in fractional pixels, and vertical ppem (nominal height) in fractional pixels. \n"}, {"name": "freetype.Font.height", "path": "ref/freetype#pygame.freetype.Font.height", "type": "pygame.freetype", "text": "  height \n The unscaled height of the font in font units height -> int  Read only. Gets the height of the font. This is the average value of all glyphs in the font. \n"}, {"name": "freetype.Font.kerning", "path": "ref/freetype#pygame.freetype.Font.kerning", "type": "pygame.freetype", "text": "  kerning \n Character kerning mode kerning -> bool  Gets or sets the font's kerning mode. This defaults to False on all fonts, which will be rendered without kerning. Set to True to add kerning between character pairs, if supported by the font, when positioning glyphs. \n"}, {"name": "freetype.Font.name", "path": "ref/freetype#pygame.freetype.Font.name", "type": "pygame.freetype", "text": "  name \n Proper font name. name -> string  Read only. Returns the real (long) name of the font, as recorded in the font file. \n"}, {"name": "freetype.Font.oblique", "path": "ref/freetype#pygame.freetype.Font.oblique", "type": "pygame.freetype", "text": "  oblique \n The state of the font's oblique style flag oblique -> bool  Gets or sets whether the font will be rendered as oblique. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the style parameter. The oblique style is only supported for scalable (outline) fonts. An attempt to set this style on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by Font.__new__(), setting this property raises a RuntimeError. \n"}, {"name": "freetype.Font.origin", "path": "ref/freetype#pygame.freetype.Font.origin", "type": "pygame.freetype", "text": "  origin \n Font render to text origin mode origin -> bool  If set True, render_to() and render_raw_to() will take the dest position to be that of the text origin, as opposed to the top-left corner of the bounding box. See get_rect() for details. \n"}, {"name": "freetype.Font.pad", "path": "ref/freetype#pygame.freetype.Font.pad", "type": "pygame.freetype", "text": "  pad \n padded boundary mode pad -> bool  If set True, then the text boundary rectangle will be inflated to match that of font.Font. Otherwise, the boundary rectangle is just large enough for the text. \n"}, {"name": "freetype.Font.path", "path": "ref/freetype#pygame.freetype.Font.path", "type": "pygame.freetype", "text": "  path \n Font file path path -> unicode  Read only. Returns the path of the loaded font file \n"}, {"name": "freetype.Font.render", "path": "ref/freetype#pygame.freetype.Font.render", "type": "pygame.freetype", "text": "  render() \n Return rendered text as a surface render(text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -> (Surface, Rect)  Returns a new Surface, with the text rendered to it in the color given by 'fgcolor'. If no foreground color is given, the default foreground color, fgcolor is used. If bgcolor is given, the surface will be filled with this color. When no background color is given, the surface background is transparent, zero alpha. Normally the returned surface has a 32 bit pixel size. However, if bgcolor is None and anti-aliasing is disabled a monochrome 8 bit colorkey surface, with colorkey set for the background color, is returned. The return value is a tuple: the new surface and the bounding rectangle giving the size and origin of the rendered text. If an empty string is passed for text then the returned Rect is zero width and the height of the font. Optional fgcolor, style, rotation, and size arguments override the default values set for the Font instance. If text is a char (byte) string, then its encoding is assumed to be LATIN1. Optionally, text can be None, which will render the text passed to a previous get_rect(), render(), render_to(), render_raw(), or render_raw_to() call. See render_to() for details. \n"}, {"name": "freetype.Font.render_raw", "path": "ref/freetype#pygame.freetype.Font.render_raw", "type": "pygame.freetype", "text": "  render_raw() \n Return rendered text as a string of bytes render_raw(text, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -> (bytes, (int, int))  Like render() but with the pixels returned as a byte string of 8-bit gray-scale values. The foreground color is 255, the background 0, useful as an alpha mask for a foreground pattern. \n"}, {"name": "freetype.Font.render_raw_to", "path": "ref/freetype#pygame.freetype.Font.render_raw_to", "type": "pygame.freetype", "text": "  render_raw_to() \n Render text into an array of ints render_raw_to(array, text, dest=None, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -> Rect  Render to an array object exposing an array struct interface. The array must be two dimensional with integer items. The default dest value, None, is equivalent to position (0, 0). See render_to(). As with the other render methods, text can be None to render a text string passed previously to another method. The return value is a pygame.Rect() giving the size and position of the rendered text. \n"}, {"name": "freetype.Font.render_to", "path": "ref/freetype#pygame.freetype.Font.render_to", "type": "pygame.freetype", "text": "  render_to() \n Render text onto an existing surface render_to(surf, dest, text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -> Rect  Renders the string text to the pygame.Surface surf, at position dest, a (x, y) surface coordinate pair. If either x or y is not an integer it is converted to one if possible. Any sequence where the first two items are x and y positional elements is accepted, including a Rect instance. As with render(), optional fgcolor, style, rotation, and size argument are available. If a background color bgcolor is given, the text bounding box is first filled with that color. The text is blitted next. Both the background fill and text rendering involve full alpha blits. That is, the alpha values of the foreground, background, and destination target surface all affect the blit. The return value is a rectangle giving the size and position of the rendered text within the surface. If an empty string is passed for text then the returned Rect is zero width and the height of the font. The rect will test False. Optionally, text can be set None, which will re-render text passed to a previous render_to(), get_rect(), render(), render_raw(), or render_raw_to() call. Primarily, this feature is an aid to using render_to() in combination with get_rect(). An example: def word_wrap(surf, text, font, color=(0, 0, 0)):\n    font.origin = True\n    words = text.split(' ')\n    width, height = surf.get_size()\n    line_spacing = font.get_sized_height() + 2\n    x, y = 0, line_spacing\n    space = font.get_rect(' ')\n    for word in words:\n        bounds = font.get_rect(word)\n        if x + bounds.width + bounds.x >= width:\n            x, y = 0, y + line_spacing\n        if x + bounds.width + bounds.x >= width:\n            raise ValueError(\"word too wide for the surface\")\n        if y + bounds.height - bounds.y >= height:\n            raise ValueError(\"text to long for the surface\")\n        font.render_to(surf, (x, y), None, color)\n        x += bounds.width + space.width\n    return x, y When render_to() is called with the same font properties \u2015 size, style, strength, wide, antialiased, vertical, rotation, kerning, and use_bitmap_strikes \u2015 as get_rect(), render_to() will use the layout calculated by get_rect(). Otherwise, render_to() will recalculate the layout if called with a text string or one of the above properties has changed after the get_rect() call. If text is a char (byte) string, then its encoding is assumed to be LATIN1. \n"}, {"name": "freetype.Font.resolution", "path": "ref/freetype#pygame.freetype.Font.resolution", "type": "pygame.freetype", "text": "  resolution \n Pixel resolution in dots per inch resolution -> int  Read only. Gets pixel size used in scaling font glyphs for this Font instance. \n"}, {"name": "freetype.Font.rotation", "path": "ref/freetype#pygame.freetype.Font.rotation", "type": "pygame.freetype", "text": "  rotation \n text rotation in degrees counterclockwise rotation -> int  Gets or sets the baseline angle of the rendered text. The angle is represented as integer degrees. The default angle is 0, with horizontal text rendered along the X-axis, and vertical text along the Y-axis. A positive value rotates these axes counterclockwise that many degrees. A negative angle corresponds to a clockwise rotation. The rotation value is normalized to a value within the range 0 to 359 inclusive (eg. 390 -> 390 - 360 -> 30, -45 -> 360 + -45 -> 315, 720 -> 720 - (2 * 360) -> 0). Only scalable (outline) fonts can be rotated. An attempt to change the rotation of a bitmap font raises an AttributeError. An attempt to change the rotation of an inactive font instance, as returned by Font.__new__(), raises a RuntimeError. \n"}, {"name": "freetype.Font.scalable", "path": "ref/freetype#pygame.freetype.Font.scalable", "type": "pygame.freetype", "text": "  scalable \n Gets whether the font is scalable scalable -> bool  Read only. Returns True if the font contains outline glyphs. If so, the point size is not limited to available bitmap sizes. \n"}, {"name": "freetype.Font.size", "path": "ref/freetype#pygame.freetype.Font.size", "type": "pygame.freetype", "text": "  size \n The default point size used in rendering size -> float size -> (float, float)  Get or set the default size for text metrics and rendering. It can be a single point size, given as a Python int or float, or a font ppem (width, height) tuple. Size values are non-negative. A zero size or width represents an undefined size. In this case the size must be given as a method argument, or an exception is raised. A zero width but non-zero height is a ValueError. For a scalable font, a single number value is equivalent to a tuple with width equal height. A font can be stretched vertically with height set greater than width, or horizontally with width set greater than height. For embedded bitmaps, as listed by get_sizes(), use the nominal width and height to select an available size. Font size differs for a non-scalable, bitmap, font. During a method call it must match one of the available sizes returned by method get_sizes(). If not, an exception is raised. If the size is a single number, the size is first matched against the point size value. If no match, then the available size with the same nominal width and height is chosen. \n"}, {"name": "freetype.Font.strength", "path": "ref/freetype#pygame.freetype.Font.strength", "type": "pygame.freetype", "text": "  strength \n The strength associated with the strong or wide font styles strength -> float  The amount by which a font glyph's size is enlarged for the strong or wide transformations, as a fraction of the untransformed size. For the wide style only the horizontal dimension is increased. For strong text both the horizontal and vertical dimensions are enlarged. A wide style of strength 0.08333 ( 1/12 ) is equivalent to the pygame.font.Font bold style. The default is 0.02778 ( 1/36 ). The strength style is only supported for scalable (outline) fonts. An attempt to set this property on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by Font.__new__(), assignment to this property raises a RuntimeError. \n"}, {"name": "freetype.Font.strong", "path": "ref/freetype#pygame.freetype.Font.strong", "type": "pygame.freetype", "text": "  strong \n The state of the font's strong style flag strong -> bool  Gets or sets whether the font will be bold when drawing text. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the 'style' parameter. \n"}, {"name": "freetype.Font.style", "path": "ref/freetype#pygame.freetype.Font.style", "type": "pygame.freetype", "text": "  style \n The font's style flags style -> int  Gets or sets the default style of the Font. This default style will be used for all text rendering and size calculations unless overridden specifically a render or get_rect() call. The style value may be a bit-wise OR of one or more of the following constants: STYLE_NORMAL\nSTYLE_UNDERLINE\nSTYLE_OBLIQUE\nSTYLE_STRONG\nSTYLE_WIDE\nSTYLE_DEFAULT These constants may be found on the FreeType constants module. Optionally, the default style can be modified or obtained accessing the individual style attributes (underline, oblique, strong). The STYLE_OBLIQUE and STYLE_STRONG styles are for scalable fonts only. An attempt to set either for a bitmap font raises an AttributeError. An attempt to set either for an inactive font, as returned by Font.__new__(), raises a RuntimeError. Assigning STYLE_DEFAULT to the style property leaves the property unchanged, as this property defines the default. The style property will never return STYLE_DEFAULT. \n"}, {"name": "freetype.Font.ucs4", "path": "ref/freetype#pygame.freetype.Font.ucs4", "type": "pygame.freetype", "text": "  ucs4 \n Enable UCS-4 mode ucs4 -> bool  Gets or sets the decoding of Unicode text. By default, the freetype module performs UTF-16 surrogate pair decoding on Unicode text. This allows 32-bit escape sequences ('Uxxxxxxxx') between 0x10000 and 0x10FFFF to represent their corresponding UTF-32 code points on Python interpreters built with a UCS-2 Unicode type (on Windows, for instance). It also means character values within the UTF-16 surrogate area (0xD800 to 0xDFFF) are considered part of a surrogate pair. A malformed surrogate pair will raise a UnicodeEncodeError. Setting ucs4 True turns surrogate pair decoding off, allowing access the full UCS-4 character range to a Python interpreter built with four-byte Unicode character support. \n"}, {"name": "freetype.Font.underline", "path": "ref/freetype#pygame.freetype.Font.underline", "type": "pygame.freetype", "text": "  underline \n The state of the font's underline style flag underline -> bool  Gets or sets whether the font will be underlined when drawing text. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the 'style' parameter. \n"}, {"name": "freetype.Font.underline_adjustment", "path": "ref/freetype#pygame.freetype.Font.underline_adjustment", "type": "pygame.freetype", "text": "  underline_adjustment \n Adjustment factor for the underline position underline_adjustment -> float  Gets or sets a factor which, when positive, is multiplied with the font's underline offset to adjust the underline position. A negative value turns an underline into a strike-through or overline. It is multiplied with the ascender. Accepted values range between -2.0 and 2.0 inclusive. A value of 0.5 closely matches Tango underlining. A value of 1.0 mimics pygame.font.Font underlining. \n"}, {"name": "freetype.Font.use_bitmap_strikes", "path": "ref/freetype#pygame.freetype.Font.use_bitmap_strikes", "type": "pygame.freetype", "text": "  use_bitmap_strikes \n allow the use of embedded bitmaps in an outline font file use_bitmap_strikes -> bool  Some scalable fonts include embedded bitmaps for particular point sizes. This property controls whether or not those bitmap strikes are used. Set it False to disable the loading of any bitmap strike. Set it True, the default, to permit bitmap strikes for a non-rotated render with no style other than wide or underline. This property is ignored for bitmap fonts. See also fixed_sizes and get_sizes(). \n"}, {"name": "freetype.Font.vertical", "path": "ref/freetype#pygame.freetype.Font.vertical", "type": "pygame.freetype", "text": "  vertical \n Font vertical mode vertical -> bool  Gets or sets whether the characters are laid out vertically rather than horizontally. May be useful when rendering Kanji or some other vertical script. Set to True to switch to a vertical text layout. The default is False, place horizontally. Note that the Font class does not automatically determine script orientation. Vertical layout must be selected explicitly. Also note that several font formats (especially bitmap based ones) don't contain the necessary metrics to draw glyphs vertically, so drawing in those cases will give unspecified results. \n"}, {"name": "freetype.Font.wide", "path": "ref/freetype#pygame.freetype.Font.wide", "type": "pygame.freetype", "text": "  wide \n The state of the font's wide style flag wide -> bool  Gets or sets whether the font will be stretched horizontally when drawing text. It produces a result similar to pygame.font.Font's bold. This style not available for rotated text. \n"}, {"name": "freetype.get_cache_size", "path": "ref/freetype#pygame.freetype.get_cache_size", "type": "pygame.freetype", "text": "  pygame.freetype.get_cache_size() \n Return the glyph case size get_cache_size() -> long  See pygame.freetype.init(). \n"}, {"name": "freetype.get_default_font", "path": "ref/freetype#pygame.freetype.get_default_font", "type": "pygame.freetype", "text": "  pygame.freetype.get_default_font() \n Get the filename of the default font get_default_font() -> string  Return the filename of the default pygame font. This is not the full path to the file. The file is usually in the same directory as the font module, but can also be bundled in a separate archive. \n"}, {"name": "freetype.get_default_resolution", "path": "ref/freetype#pygame.freetype.get_default_resolution", "type": "pygame.freetype", "text": "  pygame.freetype.get_default_resolution() \n Return the default pixel size in dots per inch get_default_resolution() -> long  Returns the default pixel size, in dots per inch, for the module. The default is 72 DPI. \n"}, {"name": "freetype.get_error", "path": "ref/freetype#pygame.freetype.get_error", "type": "pygame.freetype", "text": "  pygame.freetype.get_error() \n Return the latest FreeType error get_error() -> str get_error() -> None  Return a description of the last error which occurred in the FreeType2 library, or None if no errors have occurred. \n"}, {"name": "freetype.get_init", "path": "ref/freetype#pygame.freetype.get_init", "type": "pygame.freetype", "text": "  pygame.freetype.get_init() \n Returns True if the FreeType module is currently initialized. get_init() -> bool  Returns True if the pygame.freetype module is currently initialized.  New in pygame 1.9.5.  \n"}, {"name": "freetype.get_version", "path": "ref/freetype#pygame.freetype.get_version", "type": "pygame.freetype", "text": "  pygame.freetype.get_version() \n Return the FreeType version get_version() -> (int, int, int)  Returns the version of the FreeType library in use by this module. Note that the freetype module depends on the FreeType 2 library. It will not compile with the original FreeType 1.0. Hence, the first element of the tuple will always be \"2\". \n"}, {"name": "freetype.init", "path": "ref/freetype#pygame.freetype.init", "type": "pygame.freetype", "text": "  pygame.freetype.init() \n Initialize the underlying FreeType library. init(cache_size=64, resolution=72)  This function initializes the underlying FreeType library and must be called before trying to use any of the functionality of the freetype module. However, pygame.init() will automatically call this function if the freetype module is already imported. It is safe to call this function more than once. Optionally, you may specify a default cache_size for the Glyph cache: the maximum number of glyphs that will be cached at any given time by the module. Exceedingly small values will be automatically tuned for performance. Also a default pixel resolution, in dots per inch, can be given to adjust font scaling. \n"}, {"name": "freetype.quit", "path": "ref/freetype#pygame.freetype.quit", "type": "pygame.freetype", "text": "  pygame.freetype.quit() \n Shut down the underlying FreeType library. quit()  This function closes the freetype module. After calling this function, you should not invoke any class, method or function related to the freetype module as they are likely to fail or might give unpredictable results. It is safe to call this function even if the module hasn't been initialized yet. \n"}, {"name": "freetype.set_default_resolution", "path": "ref/freetype#pygame.freetype.set_default_resolution", "type": "pygame.freetype", "text": "  pygame.freetype.set_default_resolution() \n Set the default pixel size in dots per inch for the module set_default_resolution([resolution])  Set the default pixel size, in dots per inch, for the module. If the optional argument is omitted or zero the resolution is reset to 72 DPI. \n"}, {"name": "freetype.SysFont", "path": "ref/freetype#pygame.freetype.SysFont", "type": "pygame.freetype", "text": "  pygame.freetype.SysFont() \n create a Font object from the system fonts SysFont(name, size, bold=False, italic=False) -> Font  Return a new Font object that is loaded from the system fonts. The font will match the requested bold and italic flags. Pygame uses a small set of common font aliases. If the specific font you ask for is not available, a reasonable alternative may be used. If a suitable system font is not found this will fall back on loading the default pygame font. The font name can also be an iterable of font names, a string of comma-separated font names, or a bytes of comma-separated font names, in which case the set of names will be searched in order.  New in pygame 2.0.1: Accept an iterable of font names.  \n"}, {"name": "freetype.was_init", "path": "ref/freetype#pygame.freetype.was_init", "type": "pygame.freetype", "text": "  pygame.freetype.was_init() \n DEPRECATED: Use get_init() instead. was_init() -> bool  DEPRECATED: Returns True if the pygame.freetype module is currently initialized. Use get_init() instead. \n"}, {"name": "get_error", "path": "ref/pygame#pygame.get_error", "type": "pygame", "text": "  pygame.get_error() \n get the current error message get_error() -> errorstr  SDL maintains an internal error message. This message will usually be given to you when pygame.error() is raised, so this function will rarely be needed. \n"}, {"name": "get_init", "path": "ref/pygame#pygame.get_init", "type": "pygame", "text": "  pygame.get_init() \n returns True if pygame is currently initialized get_init() -> bool  Returns True if pygame is currently initialized.  New in pygame 1.9.5.  \n"}, {"name": "get_sdl_byteorder", "path": "ref/pygame#pygame.get_sdl_byteorder", "type": "pygame", "text": "  pygame.get_sdl_byteorder() \n get the byte order of SDL get_sdl_byteorder() -> int  Returns the byte order of the SDL library. It returns 1234 for little endian byte order and 4321 for big endian byte order.  New in pygame 1.8.  \n"}, {"name": "get_sdl_version", "path": "ref/pygame#pygame.get_sdl_version", "type": "pygame", "text": "  pygame.get_sdl_version() \n get the version number of SDL get_sdl_version() -> major, minor, patch  Returns the three version numbers of the SDL library. This version is built at compile time. It can be used to detect which features may or may not be available through pygame.  New in pygame 1.7.0.  \n"}, {"name": "gfxdraw", "path": "ref/gfxdraw", "type": "pygame.gfxdraw", "text": " pygame.gfxdraw\n  \n pygame module for drawing shapes  EXPERIMENTAL!: This API may change or disappear in later pygame releases. If you use this, your code may break with the next pygame release. The pygame package does not import gfxdraw automatically when loaded, so it must imported explicitly to be used. import pygame\nimport pygame.gfxdraw For all functions the arguments are strictly positional and integers are accepted for coordinates and radii. The color argument can be one of the following formats:  \n a pygame.Color object an (RGB) triplet (tuple/list) an (RGBA) quadruplet (tuple/list)  \n The functions rectangle() and box() will accept any (x, y, w, h) sequence for their rect argument, though pygame.Rect instances are preferred. To draw a filled antialiased shape, first use the antialiased (aa*) version of the function, and then use the filled (filled_*) version. For example: col = (255, 0, 0)\nsurf.fill((255, 255, 255))\npygame.gfxdraw.aacircle(surf, x, y, 30, col)\npygame.gfxdraw.filled_circle(surf, x, y, 30, col)  Note For threading, each of the functions releases the GIL during the C part of the call.   Note See the pygame.draw module for alternative draw methods. The pygame.gfxdraw module differs from the pygame.draw module in the API it uses and the different draw functions available. pygame.gfxdraw wraps the primitives from the library called SDL_gfx, rather than using modified versions.   New in pygame 1.9.0.    pygame.gfxdraw.pixel() \n draw a pixel pixel(surface, x, y, color) -> None  Draws a single pixel, at position (x ,y), on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the pixel \ny (int) -- y coordinate of the pixel \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.hline() \n draw a horizontal line hline(surface, x1, x2, y, color) -> None  Draws a straight horizontal line ((x1, y) to (x2, y)) on the given surface. There are no endcaps.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of one end of the line \nx2 (int) -- x coordinate of the other end of the line \ny (int) -- y coordinate of the line \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.vline() \n draw a vertical line vline(surface, x, y1, y2, color) -> None  Draws a straight vertical line ((x, y1) to (x, y2)) on the given surface. There are no endcaps.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the line \ny1 (int) -- y coordinate of one end of the line \ny2 (int) -- y coordinate of the other end of the line \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.line() \n draw a line line(surface, x1, y1, x2, y2, color) -> None  Draws a straight line ((x1, y1) to (x2, y2)) on the given surface. There are no endcaps.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of one end of the line \ny1 (int) -- y coordinate of one end of the line \nx2 (int) -- x coordinate of the other end of the line \ny2 (int) -- y coordinate of the other end of the line \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.rectangle() \n draw a rectangle rectangle(surface, rect, color) -> None  Draws an unfilled rectangle on the given surface. For a filled rectangle use box().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nrect (Rect) -- rectangle to draw, position and dimensions \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType      Note The rect.bottom and rect.right attributes of a pygame.Rect always lie one pixel outside of its actual border. Therefore, these values will not be included as part of the drawing.  \n   pygame.gfxdraw.box() \n draw a filled rectangle box(surface, rect, color) -> None  Draws a filled rectangle on the given surface. For an unfilled rectangle use rectangle().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nrect (Rect) -- rectangle to draw, position and dimensions \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType      Note The rect.bottom and rect.right attributes of a pygame.Rect always lie one pixel outside of its actual border. Therefore, these values will not be included as part of the drawing.   Note The pygame.Surface.fill() method works just as well for drawing filled rectangles. In fact pygame.Surface.fill() can be hardware accelerated on some platforms with both software and hardware display modes.  \n   pygame.gfxdraw.circle() \n draw a circle circle(surface, x, y, r, color) -> None  Draws an unfilled circle on the given surface. For a filled circle use filled_circle().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the circle \ny (int) -- y coordinate of the center of the circle \nr (int) -- radius of the circle \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.aacircle() \n draw an antialiased circle aacircle(surface, x, y, r, color) -> None  Draws an unfilled antialiased circle on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the circle \ny (int) -- y coordinate of the center of the circle \nr (int) -- radius of the circle \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.filled_circle() \n draw a filled circle filled_circle(surface, x, y, r, color) -> None  Draws a filled circle on the given surface. For an unfilled circle use circle().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the circle \ny (int) -- y coordinate of the center of the circle \nr (int) -- radius of the circle \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.ellipse() \n draw an ellipse ellipse(surface, x, y, rx, ry, color) -> None  Draws an unfilled ellipse on the given surface. For a filled ellipse use filled_ellipse().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the ellipse \ny (int) -- y coordinate of the center of the ellipse \nrx (int) -- horizontal radius of the ellipse \nry (int) -- vertical radius of the ellipse \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.aaellipse() \n draw an antialiased ellipse aaellipse(surface, x, y, rx, ry, color) -> None  Draws an unfilled antialiased ellipse on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the ellipse \ny (int) -- y coordinate of the center of the ellipse \nrx (int) -- horizontal radius of the ellipse \nry (int) -- vertical radius of the ellipse \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.filled_ellipse() \n draw a filled ellipse filled_ellipse(surface, x, y, rx, ry, color) -> None  Draws a filled ellipse on the given surface. For an unfilled ellipse use ellipse().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the ellipse \ny (int) -- y coordinate of the center of the ellipse \nrx (int) -- horizontal radius of the ellipse \nry (int) -- vertical radius of the ellipse \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.arc() \n draw an arc arc(surface, x, y, r, start_angle, stop_angle, color) -> None  Draws an arc on the given surface. For an arc with its endpoints connected to its center use pie(). The two angle arguments are given in degrees and indicate the start and stop positions of the arc. The arc is drawn in a clockwise direction from the start_angle to the stop_angle. If start_angle == stop_angle, nothing will be drawn     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the arc \ny (int) -- y coordinate of the center of the arc \nr (int) -- radius of the arc \nstart_angle (int) -- start angle in degrees \nstop_angle (int) -- stop angle in degrees \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType      Note This function uses degrees while the pygame.draw.arc() function uses radians.  \n   pygame.gfxdraw.pie() \n draw a pie pie(surface, x, y, r, start_angle, stop_angle, color) -> None  Draws an unfilled pie on the given surface. A pie is an arc() with its endpoints connected to its center. The two angle arguments are given in degrees and indicate the start and stop positions of the pie. The pie is drawn in a clockwise direction from the start_angle to the stop_angle. If start_angle == stop_angle, a straight line will be drawn from the center position at the given angle, to a length of the radius.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the pie \ny (int) -- y coordinate of the center of the pie \nr (int) -- radius of the pie \nstart_angle (int) -- start angle in degrees \nstop_angle (int) -- stop angle in degrees \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.trigon() \n draw a trigon/triangle trigon(surface, x1, y1, x2, y2, x3, y3, color) -> None  Draws an unfilled trigon (triangle) on the given surface. For a filled trigon use filled_trigon(). A trigon can also be drawn using polygon() e.g. polygon(surface, ((x1, y1), (x2, y2), (x3, y3)), color)     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of the first corner of the trigon \ny1 (int) -- y coordinate of the first corner of the trigon \nx2 (int) -- x coordinate of the second corner of the trigon \ny2 (int) -- y coordinate of the second corner of the trigon \nx3 (int) -- x coordinate of the third corner of the trigon \ny3 (int) -- y coordinate of the third corner of the trigon \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.aatrigon() \n draw an antialiased trigon/triangle aatrigon(surface, x1, y1, x2, y2, x3, y3, color) -> None  Draws an unfilled antialiased trigon (triangle) on the given surface. An aatrigon can also be drawn using aapolygon() e.g. aapolygon(surface, ((x1, y1), (x2, y2), (x3, y3)), color)     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of the first corner of the trigon \ny1 (int) -- y coordinate of the first corner of the trigon \nx2 (int) -- x coordinate of the second corner of the trigon \ny2 (int) -- y coordinate of the second corner of the trigon \nx3 (int) -- x coordinate of the third corner of the trigon \ny3 (int) -- y coordinate of the third corner of the trigon \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.filled_trigon() \n draw a filled trigon/triangle filled_trigon(surface, x1, y1, x2, y2, x3, y3, color) -> None  Draws a filled trigon (triangle) on the given surface. For an unfilled trigon use trigon(). A filled_trigon can also be drawn using filled_polygon() e.g. filled_polygon(surface, ((x1, y1), (x2, y2), (x3, y3)), color)     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of the first corner of the trigon \ny1 (int) -- y coordinate of the first corner of the trigon \nx2 (int) -- x coordinate of the second corner of the trigon \ny2 (int) -- y coordinate of the second corner of the trigon \nx3 (int) -- x coordinate of the third corner of the trigon \ny3 (int) -- y coordinate of the third corner of the trigon \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.polygon() \n draw a polygon polygon(surface, points, color) -> None  Draws an unfilled polygon on the given surface. For a filled polygon use filled_polygon(). The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n   pygame.gfxdraw.aapolygon() \n draw an antialiased polygon aapolygon(surface, points, color) -> None  Draws an unfilled antialiased polygon on the given surface. The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n   pygame.gfxdraw.filled_polygon() \n draw a filled polygon filled_polygon(surface, points, color) -> None  Draws a filled polygon on the given surface. For an unfilled polygon use polygon(). The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated)` \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n   pygame.gfxdraw.textured_polygon() \n draw a textured polygon textured_polygon(surface, points, texture, tx, ty) -> None  Draws a textured polygon on the given surface. For better performance, the surface and the texture should have the same format. A per-pixel alpha texture blit to a per-pixel alpha surface will differ from a pygame.Surface.blit() blit. Also, a per-pixel alpha texture cannot be used with an 8-bit per pixel destination. The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \ntexture (Surface) -- texture to draw on the polygon \ntx (int) -- x offset of the texture \nty (int) -- y offset of the texture    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n   pygame.gfxdraw.bezier() \n draw a Bezier curve bezier(surface, points, steps, color) -> None  Draws a B\u00e9zier curve on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates used to form a curve, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \nsteps (int) -- number of steps for the interpolation, the minimum is 2 \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if steps < 2\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n \n \n"}, {"name": "gfxdraw.aacircle", "path": "ref/gfxdraw#pygame.gfxdraw.aacircle", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.aacircle() \n draw an antialiased circle aacircle(surface, x, y, r, color) -> None  Draws an unfilled antialiased circle on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the circle \ny (int) -- y coordinate of the center of the circle \nr (int) -- radius of the circle \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.aaellipse", "path": "ref/gfxdraw#pygame.gfxdraw.aaellipse", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.aaellipse() \n draw an antialiased ellipse aaellipse(surface, x, y, rx, ry, color) -> None  Draws an unfilled antialiased ellipse on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the ellipse \ny (int) -- y coordinate of the center of the ellipse \nrx (int) -- horizontal radius of the ellipse \nry (int) -- vertical radius of the ellipse \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.aapolygon", "path": "ref/gfxdraw#pygame.gfxdraw.aapolygon", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.aapolygon() \n draw an antialiased polygon aapolygon(surface, points, color) -> None  Draws an unfilled antialiased polygon on the given surface. The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n"}, {"name": "gfxdraw.aatrigon", "path": "ref/gfxdraw#pygame.gfxdraw.aatrigon", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.aatrigon() \n draw an antialiased trigon/triangle aatrigon(surface, x1, y1, x2, y2, x3, y3, color) -> None  Draws an unfilled antialiased trigon (triangle) on the given surface. An aatrigon can also be drawn using aapolygon() e.g. aapolygon(surface, ((x1, y1), (x2, y2), (x3, y3)), color)     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of the first corner of the trigon \ny1 (int) -- y coordinate of the first corner of the trigon \nx2 (int) -- x coordinate of the second corner of the trigon \ny2 (int) -- y coordinate of the second corner of the trigon \nx3 (int) -- x coordinate of the third corner of the trigon \ny3 (int) -- y coordinate of the third corner of the trigon \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.arc", "path": "ref/gfxdraw#pygame.gfxdraw.arc", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.arc() \n draw an arc arc(surface, x, y, r, start_angle, stop_angle, color) -> None  Draws an arc on the given surface. For an arc with its endpoints connected to its center use pie(). The two angle arguments are given in degrees and indicate the start and stop positions of the arc. The arc is drawn in a clockwise direction from the start_angle to the stop_angle. If start_angle == stop_angle, nothing will be drawn     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the arc \ny (int) -- y coordinate of the center of the arc \nr (int) -- radius of the arc \nstart_angle (int) -- start angle in degrees \nstop_angle (int) -- stop angle in degrees \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType      Note This function uses degrees while the pygame.draw.arc() function uses radians.  \n"}, {"name": "gfxdraw.bezier", "path": "ref/gfxdraw#pygame.gfxdraw.bezier", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.bezier() \n draw a Bezier curve bezier(surface, points, steps, color) -> None  Draws a B\u00e9zier curve on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates used to form a curve, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \nsteps (int) -- number of steps for the interpolation, the minimum is 2 \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if steps < 2\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n"}, {"name": "gfxdraw.box", "path": "ref/gfxdraw#pygame.gfxdraw.box", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.box() \n draw a filled rectangle box(surface, rect, color) -> None  Draws a filled rectangle on the given surface. For an unfilled rectangle use rectangle().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nrect (Rect) -- rectangle to draw, position and dimensions \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType      Note The rect.bottom and rect.right attributes of a pygame.Rect always lie one pixel outside of its actual border. Therefore, these values will not be included as part of the drawing.   Note The pygame.Surface.fill() method works just as well for drawing filled rectangles. In fact pygame.Surface.fill() can be hardware accelerated on some platforms with both software and hardware display modes.  \n"}, {"name": "gfxdraw.circle", "path": "ref/gfxdraw#pygame.gfxdraw.circle", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.circle() \n draw a circle circle(surface, x, y, r, color) -> None  Draws an unfilled circle on the given surface. For a filled circle use filled_circle().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the circle \ny (int) -- y coordinate of the center of the circle \nr (int) -- radius of the circle \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.ellipse", "path": "ref/gfxdraw#pygame.gfxdraw.ellipse", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.ellipse() \n draw an ellipse ellipse(surface, x, y, rx, ry, color) -> None  Draws an unfilled ellipse on the given surface. For a filled ellipse use filled_ellipse().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the ellipse \ny (int) -- y coordinate of the center of the ellipse \nrx (int) -- horizontal radius of the ellipse \nry (int) -- vertical radius of the ellipse \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.filled_circle", "path": "ref/gfxdraw#pygame.gfxdraw.filled_circle", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.filled_circle() \n draw a filled circle filled_circle(surface, x, y, r, color) -> None  Draws a filled circle on the given surface. For an unfilled circle use circle().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the circle \ny (int) -- y coordinate of the center of the circle \nr (int) -- radius of the circle \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.filled_ellipse", "path": "ref/gfxdraw#pygame.gfxdraw.filled_ellipse", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.filled_ellipse() \n draw a filled ellipse filled_ellipse(surface, x, y, rx, ry, color) -> None  Draws a filled ellipse on the given surface. For an unfilled ellipse use ellipse().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the ellipse \ny (int) -- y coordinate of the center of the ellipse \nrx (int) -- horizontal radius of the ellipse \nry (int) -- vertical radius of the ellipse \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.filled_polygon", "path": "ref/gfxdraw#pygame.gfxdraw.filled_polygon", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.filled_polygon() \n draw a filled polygon filled_polygon(surface, points, color) -> None  Draws a filled polygon on the given surface. For an unfilled polygon use polygon(). The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated)` \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n"}, {"name": "gfxdraw.filled_trigon", "path": "ref/gfxdraw#pygame.gfxdraw.filled_trigon", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.filled_trigon() \n draw a filled trigon/triangle filled_trigon(surface, x1, y1, x2, y2, x3, y3, color) -> None  Draws a filled trigon (triangle) on the given surface. For an unfilled trigon use trigon(). A filled_trigon can also be drawn using filled_polygon() e.g. filled_polygon(surface, ((x1, y1), (x2, y2), (x3, y3)), color)     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of the first corner of the trigon \ny1 (int) -- y coordinate of the first corner of the trigon \nx2 (int) -- x coordinate of the second corner of the trigon \ny2 (int) -- y coordinate of the second corner of the trigon \nx3 (int) -- x coordinate of the third corner of the trigon \ny3 (int) -- y coordinate of the third corner of the trigon \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.hline", "path": "ref/gfxdraw#pygame.gfxdraw.hline", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.hline() \n draw a horizontal line hline(surface, x1, x2, y, color) -> None  Draws a straight horizontal line ((x1, y) to (x2, y)) on the given surface. There are no endcaps.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of one end of the line \nx2 (int) -- x coordinate of the other end of the line \ny (int) -- y coordinate of the line \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.line", "path": "ref/gfxdraw#pygame.gfxdraw.line", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.line() \n draw a line line(surface, x1, y1, x2, y2, color) -> None  Draws a straight line ((x1, y1) to (x2, y2)) on the given surface. There are no endcaps.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of one end of the line \ny1 (int) -- y coordinate of one end of the line \nx2 (int) -- x coordinate of the other end of the line \ny2 (int) -- y coordinate of the other end of the line \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.pie", "path": "ref/gfxdraw#pygame.gfxdraw.pie", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.pie() \n draw a pie pie(surface, x, y, r, start_angle, stop_angle, color) -> None  Draws an unfilled pie on the given surface. A pie is an arc() with its endpoints connected to its center. The two angle arguments are given in degrees and indicate the start and stop positions of the pie. The pie is drawn in a clockwise direction from the start_angle to the stop_angle. If start_angle == stop_angle, a straight line will be drawn from the center position at the given angle, to a length of the radius.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the pie \ny (int) -- y coordinate of the center of the pie \nr (int) -- radius of the pie \nstart_angle (int) -- start angle in degrees \nstop_angle (int) -- stop angle in degrees \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.pixel", "path": "ref/gfxdraw#pygame.gfxdraw.pixel", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.pixel() \n draw a pixel pixel(surface, x, y, color) -> None  Draws a single pixel, at position (x ,y), on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the pixel \ny (int) -- y coordinate of the pixel \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.polygon", "path": "ref/gfxdraw#pygame.gfxdraw.polygon", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.polygon() \n draw a polygon polygon(surface, points, color) -> None  Draws an unfilled polygon on the given surface. For a filled polygon use filled_polygon(). The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n"}, {"name": "gfxdraw.rectangle", "path": "ref/gfxdraw#pygame.gfxdraw.rectangle", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.rectangle() \n draw a rectangle rectangle(surface, rect, color) -> None  Draws an unfilled rectangle on the given surface. For a filled rectangle use box().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nrect (Rect) -- rectangle to draw, position and dimensions \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType      Note The rect.bottom and rect.right attributes of a pygame.Rect always lie one pixel outside of its actual border. Therefore, these values will not be included as part of the drawing.  \n"}, {"name": "gfxdraw.textured_polygon", "path": "ref/gfxdraw#pygame.gfxdraw.textured_polygon", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.textured_polygon() \n draw a textured polygon textured_polygon(surface, points, texture, tx, ty) -> None  Draws a textured polygon on the given surface. For better performance, the surface and the texture should have the same format. A per-pixel alpha texture blit to a per-pixel alpha surface will differ from a pygame.Surface.blit() blit. Also, a per-pixel alpha texture cannot be used with an 8-bit per pixel destination. The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \ntexture (Surface) -- texture to draw on the polygon \ntx (int) -- x offset of the texture \nty (int) -- y offset of the texture    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n"}, {"name": "gfxdraw.trigon", "path": "ref/gfxdraw#pygame.gfxdraw.trigon", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.trigon() \n draw a trigon/triangle trigon(surface, x1, y1, x2, y2, x3, y3, color) -> None  Draws an unfilled trigon (triangle) on the given surface. For a filled trigon use filled_trigon(). A trigon can also be drawn using polygon() e.g. polygon(surface, ((x1, y1), (x2, y2), (x3, y3)), color)     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of the first corner of the trigon \ny1 (int) -- y coordinate of the first corner of the trigon \nx2 (int) -- x coordinate of the second corner of the trigon \ny2 (int) -- y coordinate of the second corner of the trigon \nx3 (int) -- x coordinate of the third corner of the trigon \ny3 (int) -- y coordinate of the third corner of the trigon \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "gfxdraw.vline", "path": "ref/gfxdraw#pygame.gfxdraw.vline", "type": "pygame.gfxdraw", "text": "  pygame.gfxdraw.vline() \n draw a vertical line vline(surface, x, y1, y2, color) -> None  Draws a straight vertical line ((x, y1) to (x, y2)) on the given surface. There are no endcaps.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the line \ny1 (int) -- y coordinate of one end of the line \ny2 (int) -- y coordinate of the other end of the line \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "image", "path": "ref/image", "type": "pygame.image", "text": " pygame.image\n  \n pygame module for image transfer  The image module contains functions for loading and saving pictures, as well as transferring Surfaces to formats usable by other packages. Note that there is no Image class; an image is loaded as a Surface object. The Surface class allows manipulation (drawing lines, setting pixels, capturing regions, etc.). The image module is a required dependency of pygame, but it only optionally supports any extended file formats. By default it can only load uncompressed BMP images. When built with full image support, the pygame.image.load() function can support the following formats.  \n JPG PNG \nGIF (non-animated) BMP PCX \nTGA (uncompressed) TIF \nLBM (and PBM) \nPBM (and PGM, PPM) XPM  \n Saving images only supports a limited set of formats. You can save to the following formats.  \n BMP TGA PNG JPEG  \n JPEG and JPG refer to the same file format  New in pygame 1.8: Saving PNG and JPEG files.    pygame.image.load_basic() \n load new BMP image from a file (or file-like object) load_basic(file) -> Surface  Load an image from a file source. You can pass either a filename or a Python file-like object. This function only supports loading \"basic\" image format, ie BMP format. This function is always available, no matter how pygame was built. \n   pygame.image.load() \n load new image from a file (or file-like object) load(filename) -> Surface load(fileobj, namehint=\"\") -> Surface  Load an image from a file source. You can pass either a filename or a Python file-like object. Pygame will automatically determine the image type (e.g., GIF or bitmap) and create a new Surface object from the data. In some cases it will need to know the file extension (e.g., GIF images should end in \".gif\"). If you pass a raw file-like object, you may also want to pass the original filename as the namehint argument. The returned Surface will contain the same color format, colorkey and alpha transparency as the file it came from. You will often want to call Surface.convert() with no arguments, to create a copy that will draw more quickly on the screen. For alpha transparency, like in .png images, use the convert_alpha() method after loading so that the image has per pixel transparency. pygame may not always be built to support all image formats. At minimum it will support uncompressed BMP. If pygame.image.get_extended() returns 'True', you should be able to load most images (including PNG, JPG and GIF). You should use os.path.join() for compatibility. eg. asurf = pygame.image.load(os.path.join('data', 'bla.png')) \n   pygame.image.load_extended() \n load an image from a file (or file-like object) load_extended(filename) -> Surface load_extended(fileobj, namehint=\"\") -> Surface  This function is similar to pygame.image.load(), except that this function can only be used if pygame was built with extended image format support. From version 2.0.1, this function is always available, but raises an error if extended image formats are not supported. Previously, this function may or may not be available, depending on the state of extended image format support.  Changed in pygame 2.0.1.  \n   pygame.image.save() \n save an image to file (or file-like object) save(Surface, filename) -> None save(Surface, fileobj, namehint=\"\") -> None  This will save your Surface as either a BMP, TGA, PNG, or JPEG image. If the filename extension is unrecognized it will default to TGA. Both TGA, and BMP file formats create uncompressed files. You can pass a filename or a Python file-like object. For file-like object, the image is saved to TGA format unless a namehint with a recognizable extension is passed in.  Note To be able to save the JPEG file format to a file-like object, SDL2_Image version 2.0.2 or newer is needed.   Note When saving to a file-like object, it seems that for most formats, the object needs to be flushed after saving to it to make loading from it possible.   Changed in pygame 1.8: Saving PNG and JPEG files.   Changed in pygame 2.0.0.dev11: The namehint parameter was added to make it possible to save other formats than TGA to a file-like object.  \n   pygame.image.save_extended() \n save a png/jpg image to file (or file-like object) save_extended(Surface, filename) -> None save_extended(Surface, fileobj, namehint=\"\") -> None  This will save your Surface as either a PNG or JPEG image. Incase the image is being saved to a file-like object, this function uses the namehint argument to determine the format of the file being saved. Saves to JPEG incase the namehint was not specified while saving to file-like object. From version 2.0.1, this function is always available, but raises an error if extended image formats are not supported. Previously, this function may or may not be available, depending on the state of extended image format support.  Changed in pygame 2.0.1.  \n   pygame.image.get_sdl_image_version() \n get version number of the SDL_Image library being used get_sdl_image_version() -> None get_sdl_image_version() -> (major, minor, patch)  If pygame is built with extended image formats, then this function will return the SDL_Image library's version number as a tuple of 3 integers (major, minor, patch). If not, then it will return None.  New in pygame 2.0.0.dev11.  \n   pygame.image.get_extended() \n test if extended image formats can be loaded get_extended() -> bool  If pygame is built with extended image formats this function will return True. It is still not possible to determine which formats will be available, but generally you will be able to load them all. \n   pygame.image.tostring() \n transfer image to string buffer tostring(Surface, format, flipped=False) -> string  Creates a string that can be transferred with the 'fromstring' method in other Python imaging packages. Some Python image packages prefer their images in bottom-to-top format (PyOpenGL for example). If you pass True for the flipped argument, the string buffer will be vertically flipped. The format argument is a string of one of the following values. Note that only 8-bit Surfaces can use the \"P\" format. The other formats will work for any Surface. Also note that other Python image packages support more formats than pygame.  \n \nP, 8-bit palettized Surfaces \nRGB, 24-bit image \nRGBX, 32-bit image with unused space \nRGBA, 32-bit image with an alpha channel \nARGB, 32-bit image with alpha channel first \nRGBA_PREMULT, 32-bit image with colors scaled by alpha channel \nARGB_PREMULT, 32-bit image with colors scaled by alpha channel, alpha channel first  \n \n   pygame.image.fromstring() \n create new Surface from a string buffer fromstring(string, size, format, flipped=False) -> Surface  This function takes arguments similar to pygame.image.tostring(). The size argument is a pair of numbers representing the width and height. Once the new Surface is created you can destroy the string buffer. The size and format image must compute the exact same size as the passed string buffer. Otherwise an exception will be raised. See the pygame.image.frombuffer() method for a potentially faster way to transfer images into pygame. \n   pygame.image.frombuffer() \n create a new Surface that shares data inside a bytes buffer frombuffer(bytes, size, format) -> Surface  Create a new Surface that shares pixel data directly from a bytes buffer. This method takes similar arguments to pygame.image.fromstring(), but is unable to vertically flip the source data. This will run much faster than pygame.image.fromstring(), since no pixel data must be allocated and copied. It accepts the following 'format' arguments:  \n \nP, 8-bit palettized Surfaces \nRGB, 24-bit image \nBGR, 24-bit image, red and blue channels swapped. \nRGBX, 32-bit image with unused space \nRGBA, 32-bit image with an alpha channel \nARGB, 32-bit image with alpha channel first  \n \n \n \n"}, {"name": "image.frombuffer", "path": "ref/image#pygame.image.frombuffer", "type": "pygame.image", "text": "  pygame.image.frombuffer() \n create a new Surface that shares data inside a bytes buffer frombuffer(bytes, size, format) -> Surface  Create a new Surface that shares pixel data directly from a bytes buffer. This method takes similar arguments to pygame.image.fromstring(), but is unable to vertically flip the source data. This will run much faster than pygame.image.fromstring(), since no pixel data must be allocated and copied. It accepts the following 'format' arguments:  \n \nP, 8-bit palettized Surfaces \nRGB, 24-bit image \nBGR, 24-bit image, red and blue channels swapped. \nRGBX, 32-bit image with unused space \nRGBA, 32-bit image with an alpha channel \nARGB, 32-bit image with alpha channel first  \n \n"}, {"name": "image.fromstring", "path": "ref/image#pygame.image.fromstring", "type": "pygame.image", "text": "  pygame.image.fromstring() \n create new Surface from a string buffer fromstring(string, size, format, flipped=False) -> Surface  This function takes arguments similar to pygame.image.tostring(). The size argument is a pair of numbers representing the width and height. Once the new Surface is created you can destroy the string buffer. The size and format image must compute the exact same size as the passed string buffer. Otherwise an exception will be raised. See the pygame.image.frombuffer() method for a potentially faster way to transfer images into pygame. \n"}, {"name": "image.get_extended", "path": "ref/image#pygame.image.get_extended", "type": "pygame.image", "text": "  pygame.image.get_extended() \n test if extended image formats can be loaded get_extended() -> bool  If pygame is built with extended image formats this function will return True. It is still not possible to determine which formats will be available, but generally you will be able to load them all. \n"}, {"name": "image.get_sdl_image_version", "path": "ref/image#pygame.image.get_sdl_image_version", "type": "pygame.image", "text": "  pygame.image.get_sdl_image_version() \n get version number of the SDL_Image library being used get_sdl_image_version() -> None get_sdl_image_version() -> (major, minor, patch)  If pygame is built with extended image formats, then this function will return the SDL_Image library's version number as a tuple of 3 integers (major, minor, patch). If not, then it will return None.  New in pygame 2.0.0.dev11.  \n"}, {"name": "image.load", "path": "ref/image#pygame.image.load", "type": "pygame.image", "text": "  pygame.image.load() \n load new image from a file (or file-like object) load(filename) -> Surface load(fileobj, namehint=\"\") -> Surface  Load an image from a file source. You can pass either a filename or a Python file-like object. Pygame will automatically determine the image type (e.g., GIF or bitmap) and create a new Surface object from the data. In some cases it will need to know the file extension (e.g., GIF images should end in \".gif\"). If you pass a raw file-like object, you may also want to pass the original filename as the namehint argument. The returned Surface will contain the same color format, colorkey and alpha transparency as the file it came from. You will often want to call Surface.convert() with no arguments, to create a copy that will draw more quickly on the screen. For alpha transparency, like in .png images, use the convert_alpha() method after loading so that the image has per pixel transparency. pygame may not always be built to support all image formats. At minimum it will support uncompressed BMP. If pygame.image.get_extended() returns 'True', you should be able to load most images (including PNG, JPG and GIF). You should use os.path.join() for compatibility. eg. asurf = pygame.image.load(os.path.join('data', 'bla.png')) \n"}, {"name": "image.load_basic", "path": "ref/image#pygame.image.load_basic", "type": "pygame.image", "text": "  pygame.image.load_basic() \n load new BMP image from a file (or file-like object) load_basic(file) -> Surface  Load an image from a file source. You can pass either a filename or a Python file-like object. This function only supports loading \"basic\" image format, ie BMP format. This function is always available, no matter how pygame was built. \n"}, {"name": "image.load_extended", "path": "ref/image#pygame.image.load_extended", "type": "pygame.image", "text": "  pygame.image.load_extended() \n load an image from a file (or file-like object) load_extended(filename) -> Surface load_extended(fileobj, namehint=\"\") -> Surface  This function is similar to pygame.image.load(), except that this function can only be used if pygame was built with extended image format support. From version 2.0.1, this function is always available, but raises an error if extended image formats are not supported. Previously, this function may or may not be available, depending on the state of extended image format support.  Changed in pygame 2.0.1.  \n"}, {"name": "image.save", "path": "ref/image#pygame.image.save", "type": "pygame.image", "text": "  pygame.image.save() \n save an image to file (or file-like object) save(Surface, filename) -> None save(Surface, fileobj, namehint=\"\") -> None  This will save your Surface as either a BMP, TGA, PNG, or JPEG image. If the filename extension is unrecognized it will default to TGA. Both TGA, and BMP file formats create uncompressed files. You can pass a filename or a Python file-like object. For file-like object, the image is saved to TGA format unless a namehint with a recognizable extension is passed in.  Note To be able to save the JPEG file format to a file-like object, SDL2_Image version 2.0.2 or newer is needed.   Note When saving to a file-like object, it seems that for most formats, the object needs to be flushed after saving to it to make loading from it possible.   Changed in pygame 1.8: Saving PNG and JPEG files.   Changed in pygame 2.0.0.dev11: The namehint parameter was added to make it possible to save other formats than TGA to a file-like object.  \n"}, {"name": "image.save_extended", "path": "ref/image#pygame.image.save_extended", "type": "pygame.image", "text": "  pygame.image.save_extended() \n save a png/jpg image to file (or file-like object) save_extended(Surface, filename) -> None save_extended(Surface, fileobj, namehint=\"\") -> None  This will save your Surface as either a PNG or JPEG image. Incase the image is being saved to a file-like object, this function uses the namehint argument to determine the format of the file being saved. Saves to JPEG incase the namehint was not specified while saving to file-like object. From version 2.0.1, this function is always available, but raises an error if extended image formats are not supported. Previously, this function may or may not be available, depending on the state of extended image format support.  Changed in pygame 2.0.1.  \n"}, {"name": "image.tostring", "path": "ref/image#pygame.image.tostring", "type": "pygame.image", "text": "  pygame.image.tostring() \n transfer image to string buffer tostring(Surface, format, flipped=False) -> string  Creates a string that can be transferred with the 'fromstring' method in other Python imaging packages. Some Python image packages prefer their images in bottom-to-top format (PyOpenGL for example). If you pass True for the flipped argument, the string buffer will be vertically flipped. The format argument is a string of one of the following values. Note that only 8-bit Surfaces can use the \"P\" format. The other formats will work for any Surface. Also note that other Python image packages support more formats than pygame.  \n \nP, 8-bit palettized Surfaces \nRGB, 24-bit image \nRGBX, 32-bit image with unused space \nRGBA, 32-bit image with an alpha channel \nARGB, 32-bit image with alpha channel first \nRGBA_PREMULT, 32-bit image with colors scaled by alpha channel \nARGB_PREMULT, 32-bit image with colors scaled by alpha channel, alpha channel first  \n \n"}, {"name": "init", "path": "ref/pygame#pygame.init", "type": "pygame", "text": "  pygame.init() \n initialize all imported pygame modules init() -> (numpass, numfail)  Initialize all imported pygame modules. No exceptions will be raised if a module fails, but the total number if successful and failed inits will be returned as a tuple. You can always initialize individual modules manually, but pygame.init() is a convenient way to get everything started. The init() functions for individual modules will raise exceptions when they fail. You may want to initialize the different modules separately to speed up your program or to not use modules your game does not require. It is safe to call this init() more than once as repeated calls will have no effect. This is true even if you have pygame.quit() all the modules. \n"}, {"name": "joystick", "path": "ref/joystick", "type": "pygame.joystick", "text": " pygame.joystick\n  \n Pygame module for interacting with joysticks, gamepads, and trackballs.  The joystick module manages the joystick devices on a computer. Joystick devices include trackballs and video-game-style gamepads, and the module allows the use of multiple buttons and \"hats\". Computers may manage multiple joysticks at a time. Each instance of the Joystick class represents one gaming device plugged into the computer. If a gaming pad has multiple joysticks on it, than the joystick object can actually represent multiple joysticks on that single game device. For a quick way to initialise the joystick module and get a list of Joystick instances use the following code: pygame.joystick.init()\njoysticks = [pygame.joystick.Joystick(x) for x in range(pygame.joystick.get_count())] The following event types will be generated by the joysticks JOYAXISMOTION JOYBALLMOTION JOYBUTTONDOWN JOYBUTTONUP JOYHATMOTION And in pygame 2, which supports hotplugging: JOYDEVICEADDED JOYDEVICEREMOVED Note that in pygame 2, joysticks events use a unique \"instance ID\". The device index passed in the constructor to a Joystick object is not unique after devices have been added and removed. You must call Joystick.get_instance_id() to find the instance ID that was assigned to a Joystick on opening. The event queue needs to be pumped frequently for some of the methods to work. So call one of pygame.event.get, pygame.event.wait, or pygame.event.pump regularly.   pygame.joystick.init() \n Initialize the joystick module. init() -> None  This function is called automatically by pygame.init(). It initializes the joystick module. The module must be initialized before any other functions will work. It is safe to call this function more than once. \n   pygame.joystick.quit() \n Uninitialize the joystick module. quit() -> None  Uninitialize the joystick module. After you call this any existing joystick objects will no longer work. It is safe to call this function more than once. \n   pygame.joystick.get_init() \n Returns True if the joystick module is initialized. get_init() -> bool  Test if the pygame.joystick.init() function has been called. \n   pygame.joystick.get_count() \n Returns the number of joysticks. get_count() -> count  Return the number of joystick devices on the system. The count will be 0 if there are no joysticks on the system. When you create Joystick objects using Joystick(id), you pass an integer that must be lower than this count. \n   pygame.joystick.Joystick \n Create a new Joystick object. Joystick(id) -> Joystick  Create a new joystick to access a physical device. The id argument must be a value from 0 to pygame.joystick.get_count() - 1. Joysticks are initialised on creation and are shut down when deallocated. Once the device is initialized the pygame event queue will start receiving events about its input.  Changed in pygame 2.0.0: Joystick objects are now opened immediately on creation.    init() \n initialize the Joystick init() -> None  Initialize the joystick, if it has been closed. It is safe to call this even if the joystick is already initialized.  Deprecated since pygame 2.0.0: In future it will not be possible to reinitialise a closed Joystick object. Will be removed in Pygame 2.1.  \n   quit() \n uninitialize the Joystick quit() -> None  Close a Joystick object. After this the pygame event queue will no longer receive events from the device. It is safe to call this more than once. \n   get_init() \n check if the Joystick is initialized get_init() -> bool  Return True if the Joystick object is currently initialised. \n   get_id() \n get the device index (deprecated) get_id() -> int  Returns the original device index for this device. This is the same value that was passed to the Joystick() constructor. This method can safely be called while the Joystick is not initialized.  Deprecated since pygame 2.0.0: The original device index is not useful in pygame 2. Use get_instance_id() instead. Will be removed in Pygame 2.1.  \n   get_instance_id() \u2192 int \n get the joystick instance id get_instance_id() -> int  Get the joystick instance ID. This matches the instance_id field that is given in joystick events.  New in pygame 2.0.0dev11.  \n   get_guid() \u2192 str \n get the joystick GUID get_guid() -> str  Get the GUID string. This identifies the exact hardware of the joystick device.  New in pygame 2.0.0dev11.  \n   get_power_level() \u2192 str \n get the approximate power status of the device get_power_level() -> str  Get a string giving the power status of the device. One of: empty, low, medium, full, wired, max, or unknown.  New in pygame 2.0.0dev11.  \n   get_name() \n get the Joystick system name get_name() -> string  Returns the system name for this joystick device. It is unknown what name the system will give to the Joystick, but it should be a unique name that identifies the device. This method can safely be called while the Joystick is not initialized. \n   get_numaxes() \n get the number of axes on a Joystick get_numaxes() -> int  Returns the number of input axes are on a Joystick. There will usually be two for the position. Controls like rudders and throttles are treated as additional axes. The pygame.JOYAXISMOTION events will be in the range from -1.0 to 1.0. A value of 0.0 means the axis is centered. Gamepad devices will usually be -1, 0, or 1 with no values in between. Older analog joystick axes will not always use the full -1 to 1 range, and the centered value will be some area around 0. Analog joysticks usually have a bit of noise in their axis, which will generate a lot of rapid small motion events. \n   get_axis() \n get the current position of an axis get_axis(axis_number) -> float  Returns the current position of a joystick axis. The value will range from -1 to 1 with a value of 0 being centered. You may want to take into account some tolerance to handle jitter, and joystick drift may keep the joystick from centering at 0 or using the full range of position values. The axis number must be an integer from 0 to get_numaxes() - 1. When using gamepads both the control sticks and the analog triggers are usually reported as axes. \n   get_numballs() \n get the number of trackballs on a Joystick get_numballs() -> int  Returns the number of trackball devices on a Joystick. These devices work similar to a mouse but they have no absolute position; they only have relative amounts of movement. The pygame.JOYBALLMOTION event will be sent when the trackball is rolled. It will report the amount of movement on the trackball. \n   get_ball() \n get the relative position of a trackball get_ball(ball_number) -> x, y  Returns the relative movement of a joystick button. The value is a x, y pair holding the relative movement since the last call to get_ball. The ball number must be an integer from 0 to get_numballs() - 1. \n   get_numbuttons() \n get the number of buttons on a Joystick get_numbuttons() -> int  Returns the number of pushable buttons on the joystick. These buttons have a boolean (on or off) state. Buttons generate a pygame.JOYBUTTONDOWN and pygame.JOYBUTTONUP event when they are pressed and released. \n   get_button() \n get the current button state get_button(button) -> bool  Returns the current state of a joystick button. \n   get_numhats() \n get the number of hat controls on a Joystick get_numhats() -> int  Returns the number of joystick hats on a Joystick. Hat devices are like miniature digital joysticks on a joystick. Each hat has two axes of input. The pygame.JOYHATMOTION event is generated when the hat changes position. The position attribute for the event contains a pair of values that are either -1, 0, or 1. A position of (0, 0) means the hat is centered. \n   get_hat() \n get the position of a joystick hat get_hat(hat_number) -> x, y  Returns the current position of a position hat. The position is given as two values representing the x and y position for the hat. (0, 0) means centered. A value of -1 means left/down and a value of 1 means right/up: so (-1, 0) means left; (1, 0) means right; (0, 1) means up; (1, 1) means upper-right; etc. This value is digital, i.e., each coordinate can be -1, 0 or 1 but never in-between. The hat number must be between 0 and get_numhats() - 1. \n \n   Example code for joystick module.  import pygame\n\n\n# Define some colors.\nBLACK = pygame.Color('black')\nWHITE = pygame.Color('white')\n\n\n# This is a simple class that will help us print to the screen.\n# It has nothing to do with the joysticks, just outputting the\n# information.\nclass TextPrint(object):\n    def __init__(self):\n        self.reset()\n        self.font = pygame.font.Font(None, 20)\n\n    def tprint(self, screen, textString):\n        textBitmap = self.font.render(textString, True, BLACK)\n        screen.blit(textBitmap, (self.x, self.y))\n        self.y += self.line_height\n\n    def reset(self):\n        self.x = 10\n        self.y = 10\n        self.line_height = 15\n\n    def indent(self):\n        self.x += 10\n\n    def unindent(self):\n        self.x -= 10\n\n\npygame.init()\n\n# Set the width and height of the screen (width, height).\nscreen = pygame.display.set_mode((500, 700))\n\npygame.display.set_caption(\"My Game\")\n\n# Loop until the user clicks the close button.\ndone = False\n\n# Used to manage how fast the screen updates.\nclock = pygame.time.Clock()\n\n# Initialize the joysticks.\npygame.joystick.init()\n\n# Get ready to print.\ntextPrint = TextPrint()\n\n# -------- Main Program Loop -----------\nwhile not done:\n    #\n    # EVENT PROCESSING STEP\n    #\n    # Possible joystick actions: JOYAXISMOTION, JOYBALLMOTION, JOYBUTTONDOWN,\n    # JOYBUTTONUP, JOYHATMOTION\n    for event in pygame.event.get(): # User did something.\n        if event.type == pygame.QUIT: # If user clicked close.\n            done = True # Flag that we are done so we exit this loop.\n        elif event.type == pygame.JOYBUTTONDOWN:\n            print(\"Joystick button pressed.\")\n        elif event.type == pygame.JOYBUTTONUP:\n            print(\"Joystick button released.\")\n\n    #\n    # DRAWING STEP\n    #\n    # First, clear the screen to white. Don't put other drawing commands\n    # above this, or they will be erased with this command.\n    screen.fill(WHITE)\n    textPrint.reset()\n\n    # Get count of joysticks.\n    joystick_count = pygame.joystick.get_count()\n\n    textPrint.tprint(screen, \"Number of joysticks: {}\".format(joystick_count))\n    textPrint.indent()\n\n    # For each joystick:\n    for i in range(joystick_count):\n        joystick = pygame.joystick.Joystick(i)\n        joystick.init()\n\n        try:\n            jid = joystick.get_instance_id()\n        except AttributeError:\n            # get_instance_id() is an SDL2 method\n            jid = joystick.get_id()\n        textPrint.tprint(screen, \"Joystick {}\".format(jid))\n        textPrint.indent()\n\n        # Get the name from the OS for the controller/joystick.\n        name = joystick.get_name()\n        textPrint.tprint(screen, \"Joystick name: {}\".format(name))\n\n        try:\n            guid = joystick.get_guid()\n        except AttributeError:\n            # get_guid() is an SDL2 method\n            pass\n        else:\n            textPrint.tprint(screen, \"GUID: {}\".format(guid))\n\n        # Usually axis run in pairs, up/down for one, and left/right for\n        # the other.\n        axes = joystick.get_numaxes()\n        textPrint.tprint(screen, \"Number of axes: {}\".format(axes))\n        textPrint.indent()\n\n        for i in range(axes):\n            axis = joystick.get_axis(i)\n            textPrint.tprint(screen, \"Axis {} value: {:>6.3f}\".format(i, axis))\n        textPrint.unindent()\n\n        buttons = joystick.get_numbuttons()\n        textPrint.tprint(screen, \"Number of buttons: {}\".format(buttons))\n        textPrint.indent()\n\n        for i in range(buttons):\n            button = joystick.get_button(i)\n            textPrint.tprint(screen,\n                             \"Button {:>2} value: {}\".format(i, button))\n        textPrint.unindent()\n\n        hats = joystick.get_numhats()\n        textPrint.tprint(screen, \"Number of hats: {}\".format(hats))\n        textPrint.indent()\n\n        # Hat position. All or nothing for direction, not a float like\n        # get_axis(). Position is a tuple of int values (x, y).\n        for i in range(hats):\n            hat = joystick.get_hat(i)\n            textPrint.tprint(screen, \"Hat {} value: {}\".format(i, str(hat)))\n        textPrint.unindent()\n\n        textPrint.unindent()\n\n    #\n    # ALL CODE TO DRAW SHOULD GO ABOVE THIS COMMENT\n    #\n\n    # Go ahead and update the screen with what we've drawn.\n    pygame.display.flip()\n\n    # Limit to 20 frames per second.\n    clock.tick(20)\n\n# Close the window and quit.\n# If you forget this line, the program will 'hang'\n# on exit if running from IDLE.\npygame.quit() Common Controller Axis Mappings Controller mappings are drawn from the underlying SDL library which pygame uses and they differ between pygame 1 and pygame 2. Below are a couple of mappings for two popular game pads. Pygame 2 Axis and hat mappings are listed from -1 to +1. X-Box 360 Controller (name: \"Xbox 360 Controller\") In pygame 2 the X360 controller mapping has 6 Axes, 11 buttons and 1 hat.  \nLeft Stick: Left -> Right   - Axis 0\nUp   -> Down    - Axis 1  \nRight Stick: Left -> Right   - Axis 3\nUp   -> Down    - Axis 4  \nLeft Trigger: Out -> In       - Axis 2  \nRight Trigger: Out -> In       - Axis 5  \nButtons: A Button        - Button 0\nB Button        - Button 1\nX Button        - Button 2\nY Button        - Button 3\nLeft Bumper     - Button 4\nRight Bumper    - Button 5\nBack Button     - Button 6\nStart Button    - Button 7\nL. Stick In     - Button 8\nR. Stick In     - Button 9\nGuide Button    - Button 10  \nHat/D-pad: Down -> Up      - Y Axis\nLeft -> Right   - X Axis   Playstation 4 Controller (name: \"PS4 Controller\") In pygame 2 the PS4 controller mapping has 6 Axes and 16 buttons.  \nLeft Stick: Left -> Right   - Axis 0\nUp   -> Down    - Axis 1  \nRight Stick: Left -> Right   - Axis 2\nUp   -> Down    - Axis 3  \nLeft Trigger: Out -> In       - Axis 4  \nRight Trigger: Out -> In       - Axis 5  \nButtons: Cross Button    - Button 0\nCircle Button   - Button 1\nSquare Button   - Button 2\nTriangle Button - Button 3\nShare Button    - Button 4\nPS Button       - Button 5\nOptions Button  - Button 6\nL. Stick In     - Button 7\nR. Stick In     - Button 8\nLeft Bumper     - Button 9\nRight Bumper    - Button 10\nD-pad Up        - Button 11\nD-pad Down      - Button 12\nD-pad Left      - Button 13\nD-pad Right     - Button 14\nTouch Pad Click - Button 15   Pygame 1 Axis and hat mappings are listed from -1 to +1. X-Box 360 Controller (name: \"Controller (XBOX 360 For Windows)\") In pygame 1 the X360 controller mapping has 5 Axes, 10 buttons and 1 hat.  \nLeft Stick: Left -> Right   - Axis 0\nUp   -> Down    - Axis 1  \nRight Stick: Left -> Right   - Axis 4\nUp   -> Down    - Axis 3  \nLeft Trigger & Right Trigger: RT -> LT        - Axis 2  \nButtons: A Button        - Button 0\nB Button        - Button 1\nX Button        - Button 2\nY Button        - Button 3\nLeft Bumper     - Button 4\nRight Bumper    - Button 5\nBack Button     - Button 6\nStart Button    - Button 7\nL. Stick In     - Button 8\nR. Stick In     - Button 9  \nHat/D-pad: Down -> Up      - Y Axis\nLeft -> Right   - X Axis   Playstation 4 Controller (name: \"Wireless Controller\") In pygame 1 the PS4 controller mapping has 6 Axes and 14 buttons and 1 hat.  \nLeft Stick: Left -> Right   - Axis 0\nUp   -> Down    - Axis 1  \nRight Stick: Left -> Right   - Axis 2\nUp   -> Down    - Axis 3  \nLeft Trigger: Out -> In       - Axis 5  \nRight Trigger: Out -> In       - Axis 4  \nButtons: Cross Button    - Button 0\nCircle Button   - Button 1\nSquare Button   - Button 2\nTriangle Button - Button 3\nLeft Bumper     - Button 4\nRight Bumper    - Button 5\nL. Trigger(Full)- Button 6\nR. Trigger(Full)- Button 7\nShare Button    - Button 8\nOptions Button  - Button 9\nL. Stick In     - Button 10\nR. Stick In     - Button 11\nPS Button       - Button 12\nTouch Pad Click - Button 13  \nHat/D-pad: Down -> Up      - Y Axis\nLeft -> Right   - X Axis   \n \n"}, {"name": "joystick.get_count", "path": "ref/joystick#pygame.joystick.get_count", "type": "pygame.joystick", "text": "  pygame.joystick.get_count() \n Returns the number of joysticks. get_count() -> count  Return the number of joystick devices on the system. The count will be 0 if there are no joysticks on the system. When you create Joystick objects using Joystick(id), you pass an integer that must be lower than this count. \n"}, {"name": "joystick.get_init", "path": "ref/joystick#pygame.joystick.get_init", "type": "pygame.joystick", "text": "  pygame.joystick.get_init() \n Returns True if the joystick module is initialized. get_init() -> bool  Test if the pygame.joystick.init() function has been called. \n"}, {"name": "joystick.init", "path": "ref/joystick#pygame.joystick.init", "type": "pygame.joystick", "text": "  pygame.joystick.init() \n Initialize the joystick module. init() -> None  This function is called automatically by pygame.init(). It initializes the joystick module. The module must be initialized before any other functions will work. It is safe to call this function more than once. \n"}, {"name": "joystick.Joystick", "path": "ref/joystick#pygame.joystick.Joystick", "type": "pygame.joystick", "text": "  pygame.joystick.Joystick \n Create a new Joystick object. Joystick(id) -> Joystick  Create a new joystick to access a physical device. The id argument must be a value from 0 to pygame.joystick.get_count() - 1. Joysticks are initialised on creation and are shut down when deallocated. Once the device is initialized the pygame event queue will start receiving events about its input.  Changed in pygame 2.0.0: Joystick objects are now opened immediately on creation.    init() \n initialize the Joystick init() -> None  Initialize the joystick, if it has been closed. It is safe to call this even if the joystick is already initialized.  Deprecated since pygame 2.0.0: In future it will not be possible to reinitialise a closed Joystick object. Will be removed in Pygame 2.1.  \n   quit() \n uninitialize the Joystick quit() -> None  Close a Joystick object. After this the pygame event queue will no longer receive events from the device. It is safe to call this more than once. \n   get_init() \n check if the Joystick is initialized get_init() -> bool  Return True if the Joystick object is currently initialised. \n   get_id() \n get the device index (deprecated) get_id() -> int  Returns the original device index for this device. This is the same value that was passed to the Joystick() constructor. This method can safely be called while the Joystick is not initialized.  Deprecated since pygame 2.0.0: The original device index is not useful in pygame 2. Use get_instance_id() instead. Will be removed in Pygame 2.1.  \n   get_instance_id() \u2192 int \n get the joystick instance id get_instance_id() -> int  Get the joystick instance ID. This matches the instance_id field that is given in joystick events.  New in pygame 2.0.0dev11.  \n   get_guid() \u2192 str \n get the joystick GUID get_guid() -> str  Get the GUID string. This identifies the exact hardware of the joystick device.  New in pygame 2.0.0dev11.  \n   get_power_level() \u2192 str \n get the approximate power status of the device get_power_level() -> str  Get a string giving the power status of the device. One of: empty, low, medium, full, wired, max, or unknown.  New in pygame 2.0.0dev11.  \n   get_name() \n get the Joystick system name get_name() -> string  Returns the system name for this joystick device. It is unknown what name the system will give to the Joystick, but it should be a unique name that identifies the device. This method can safely be called while the Joystick is not initialized. \n   get_numaxes() \n get the number of axes on a Joystick get_numaxes() -> int  Returns the number of input axes are on a Joystick. There will usually be two for the position. Controls like rudders and throttles are treated as additional axes. The pygame.JOYAXISMOTION events will be in the range from -1.0 to 1.0. A value of 0.0 means the axis is centered. Gamepad devices will usually be -1, 0, or 1 with no values in between. Older analog joystick axes will not always use the full -1 to 1 range, and the centered value will be some area around 0. Analog joysticks usually have a bit of noise in their axis, which will generate a lot of rapid small motion events. \n   get_axis() \n get the current position of an axis get_axis(axis_number) -> float  Returns the current position of a joystick axis. The value will range from -1 to 1 with a value of 0 being centered. You may want to take into account some tolerance to handle jitter, and joystick drift may keep the joystick from centering at 0 or using the full range of position values. The axis number must be an integer from 0 to get_numaxes() - 1. When using gamepads both the control sticks and the analog triggers are usually reported as axes. \n   get_numballs() \n get the number of trackballs on a Joystick get_numballs() -> int  Returns the number of trackball devices on a Joystick. These devices work similar to a mouse but they have no absolute position; they only have relative amounts of movement. The pygame.JOYBALLMOTION event will be sent when the trackball is rolled. It will report the amount of movement on the trackball. \n   get_ball() \n get the relative position of a trackball get_ball(ball_number) -> x, y  Returns the relative movement of a joystick button. The value is a x, y pair holding the relative movement since the last call to get_ball. The ball number must be an integer from 0 to get_numballs() - 1. \n   get_numbuttons() \n get the number of buttons on a Joystick get_numbuttons() -> int  Returns the number of pushable buttons on the joystick. These buttons have a boolean (on or off) state. Buttons generate a pygame.JOYBUTTONDOWN and pygame.JOYBUTTONUP event when they are pressed and released. \n   get_button() \n get the current button state get_button(button) -> bool  Returns the current state of a joystick button. \n   get_numhats() \n get the number of hat controls on a Joystick get_numhats() -> int  Returns the number of joystick hats on a Joystick. Hat devices are like miniature digital joysticks on a joystick. Each hat has two axes of input. The pygame.JOYHATMOTION event is generated when the hat changes position. The position attribute for the event contains a pair of values that are either -1, 0, or 1. A position of (0, 0) means the hat is centered. \n   get_hat() \n get the position of a joystick hat get_hat(hat_number) -> x, y  Returns the current position of a position hat. The position is given as two values representing the x and y position for the hat. (0, 0) means centered. A value of -1 means left/down and a value of 1 means right/up: so (-1, 0) means left; (1, 0) means right; (0, 1) means up; (1, 1) means upper-right; etc. This value is digital, i.e., each coordinate can be -1, 0 or 1 but never in-between. The hat number must be between 0 and get_numhats() - 1. \n \n"}, {"name": "joystick.Joystick.get_axis", "path": "ref/joystick#pygame.joystick.Joystick.get_axis", "type": "pygame.joystick", "text": "  get_axis() \n get the current position of an axis get_axis(axis_number) -> float  Returns the current position of a joystick axis. The value will range from -1 to 1 with a value of 0 being centered. You may want to take into account some tolerance to handle jitter, and joystick drift may keep the joystick from centering at 0 or using the full range of position values. The axis number must be an integer from 0 to get_numaxes() - 1. When using gamepads both the control sticks and the analog triggers are usually reported as axes. \n"}, {"name": "joystick.Joystick.get_ball", "path": "ref/joystick#pygame.joystick.Joystick.get_ball", "type": "pygame.joystick", "text": "  get_ball() \n get the relative position of a trackball get_ball(ball_number) -> x, y  Returns the relative movement of a joystick button. The value is a x, y pair holding the relative movement since the last call to get_ball. The ball number must be an integer from 0 to get_numballs() - 1. \n"}, {"name": "joystick.Joystick.get_button", "path": "ref/joystick#pygame.joystick.Joystick.get_button", "type": "pygame.joystick", "text": "  get_button() \n get the current button state get_button(button) -> bool  Returns the current state of a joystick button. \n"}, {"name": "joystick.Joystick.get_guid", "path": "ref/joystick#pygame.joystick.Joystick.get_guid", "type": "pygame.joystick", "text": "  get_guid() \u2192 str \n get the joystick GUID get_guid() -> str  Get the GUID string. This identifies the exact hardware of the joystick device.  New in pygame 2.0.0dev11.  \n"}, {"name": "joystick.Joystick.get_hat", "path": "ref/joystick#pygame.joystick.Joystick.get_hat", "type": "pygame.joystick", "text": "  get_hat() \n get the position of a joystick hat get_hat(hat_number) -> x, y  Returns the current position of a position hat. The position is given as two values representing the x and y position for the hat. (0, 0) means centered. A value of -1 means left/down and a value of 1 means right/up: so (-1, 0) means left; (1, 0) means right; (0, 1) means up; (1, 1) means upper-right; etc. This value is digital, i.e., each coordinate can be -1, 0 or 1 but never in-between. The hat number must be between 0 and get_numhats() - 1. \n"}, {"name": "joystick.Joystick.get_id", "path": "ref/joystick#pygame.joystick.Joystick.get_id", "type": "pygame.joystick", "text": "  get_id() \n get the device index (deprecated) get_id() -> int  Returns the original device index for this device. This is the same value that was passed to the Joystick() constructor. This method can safely be called while the Joystick is not initialized.  Deprecated since pygame 2.0.0: The original device index is not useful in pygame 2. Use get_instance_id() instead. Will be removed in Pygame 2.1.  \n"}, {"name": "joystick.Joystick.get_init", "path": "ref/joystick#pygame.joystick.Joystick.get_init", "type": "pygame.joystick", "text": "  get_init() \n check if the Joystick is initialized get_init() -> bool  Return True if the Joystick object is currently initialised. \n"}, {"name": "joystick.Joystick.get_instance_id", "path": "ref/joystick#pygame.joystick.Joystick.get_instance_id", "type": "pygame.joystick", "text": "  get_instance_id() \u2192 int \n get the joystick instance id get_instance_id() -> int  Get the joystick instance ID. This matches the instance_id field that is given in joystick events.  New in pygame 2.0.0dev11.  \n"}, {"name": "joystick.Joystick.get_name", "path": "ref/joystick#pygame.joystick.Joystick.get_name", "type": "pygame.joystick", "text": "  get_name() \n get the Joystick system name get_name() -> string  Returns the system name for this joystick device. It is unknown what name the system will give to the Joystick, but it should be a unique name that identifies the device. This method can safely be called while the Joystick is not initialized. \n"}, {"name": "joystick.Joystick.get_numaxes", "path": "ref/joystick#pygame.joystick.Joystick.get_numaxes", "type": "pygame.joystick", "text": "  get_numaxes() \n get the number of axes on a Joystick get_numaxes() -> int  Returns the number of input axes are on a Joystick. There will usually be two for the position. Controls like rudders and throttles are treated as additional axes. The pygame.JOYAXISMOTION events will be in the range from -1.0 to 1.0. A value of 0.0 means the axis is centered. Gamepad devices will usually be -1, 0, or 1 with no values in between. Older analog joystick axes will not always use the full -1 to 1 range, and the centered value will be some area around 0. Analog joysticks usually have a bit of noise in their axis, which will generate a lot of rapid small motion events. \n"}, {"name": "joystick.Joystick.get_numballs", "path": "ref/joystick#pygame.joystick.Joystick.get_numballs", "type": "pygame.joystick", "text": "  get_numballs() \n get the number of trackballs on a Joystick get_numballs() -> int  Returns the number of trackball devices on a Joystick. These devices work similar to a mouse but they have no absolute position; they only have relative amounts of movement. The pygame.JOYBALLMOTION event will be sent when the trackball is rolled. It will report the amount of movement on the trackball. \n"}, {"name": "joystick.Joystick.get_numbuttons", "path": "ref/joystick#pygame.joystick.Joystick.get_numbuttons", "type": "pygame.joystick", "text": "  get_numbuttons() \n get the number of buttons on a Joystick get_numbuttons() -> int  Returns the number of pushable buttons on the joystick. These buttons have a boolean (on or off) state. Buttons generate a pygame.JOYBUTTONDOWN and pygame.JOYBUTTONUP event when they are pressed and released. \n"}, {"name": "joystick.Joystick.get_numhats", "path": "ref/joystick#pygame.joystick.Joystick.get_numhats", "type": "pygame.joystick", "text": "  get_numhats() \n get the number of hat controls on a Joystick get_numhats() -> int  Returns the number of joystick hats on a Joystick. Hat devices are like miniature digital joysticks on a joystick. Each hat has two axes of input. The pygame.JOYHATMOTION event is generated when the hat changes position. The position attribute for the event contains a pair of values that are either -1, 0, or 1. A position of (0, 0) means the hat is centered. \n"}, {"name": "joystick.Joystick.get_power_level", "path": "ref/joystick#pygame.joystick.Joystick.get_power_level", "type": "pygame.joystick", "text": "  get_power_level() \u2192 str \n get the approximate power status of the device get_power_level() -> str  Get a string giving the power status of the device. One of: empty, low, medium, full, wired, max, or unknown.  New in pygame 2.0.0dev11.  \n"}, {"name": "joystick.Joystick.init", "path": "ref/joystick#pygame.joystick.Joystick.init", "type": "pygame.joystick", "text": "  init() \n initialize the Joystick init() -> None  Initialize the joystick, if it has been closed. It is safe to call this even if the joystick is already initialized.  Deprecated since pygame 2.0.0: In future it will not be possible to reinitialise a closed Joystick object. Will be removed in Pygame 2.1.  \n"}, {"name": "joystick.Joystick.quit", "path": "ref/joystick#pygame.joystick.Joystick.quit", "type": "pygame.joystick", "text": "  quit() \n uninitialize the Joystick quit() -> None  Close a Joystick object. After this the pygame event queue will no longer receive events from the device. It is safe to call this more than once. \n"}, {"name": "joystick.quit", "path": "ref/joystick#pygame.joystick.quit", "type": "pygame.joystick", "text": "  pygame.joystick.quit() \n Uninitialize the joystick module. quit() -> None  Uninitialize the joystick module. After you call this any existing joystick objects will no longer work. It is safe to call this function more than once. \n"}, {"name": "key", "path": "ref/key", "type": "pygame.key", "text": " pygame.key\n  \n pygame module to work with the keyboard  This module contains functions for dealing with the keyboard. The pygame.event queue gets pygame.KEYDOWN and pygame.KEYUP events when the keyboard buttons are pressed and released. Both events have key and mod attributes.  \n \nkey: an integer ID representing every key on the keyboard \nmod: a bitmask of all the modifier keys that were in a pressed state when the event occurred  \n The pygame.KEYDOWN event has the additional attributes unicode and scancode.  \n \nunicode: a single character string that is the fully translated character entered, this takes into account the shift and composition keys \nscancode: the platform-specific key code, which could be different from keyboard to keyboard, but is useful for key selection of weird keys like the multimedia keys  \n  New in pygame 2.0.0: The pygame.TEXTINPUT event is preferred to the unicode attribute of pygame.KEYDOWN. The attribute text contains the input.  The following is a list of all the constants (from pygame.locals) used to represent keyboard keys. Portability note: The integers for key constants differ between pygame 1 and 2. Always use key constants (K_a) rather than integers directly (97) so that your key handling code works well on both pygame 1 and pygame 2. pygame\nConstant      ASCII   Description\n---------------------------------\nK_BACKSPACE   \\b      backspace\nK_TAB         \\t      tab\nK_CLEAR               clear\nK_RETURN      \\r      return\nK_PAUSE               pause\nK_ESCAPE      ^[      escape\nK_SPACE               space\nK_EXCLAIM     !       exclaim\nK_QUOTEDBL    \"       quotedbl\nK_HASH        #       hash\nK_DOLLAR      $       dollar\nK_AMPERSAND   &       ampersand\nK_QUOTE               quote\nK_LEFTPAREN   (       left parenthesis\nK_RIGHTPAREN  )       right parenthesis\nK_ASTERISK    *       asterisk\nK_PLUS        +       plus sign\nK_COMMA       ,       comma\nK_MINUS       -       minus sign\nK_PERIOD      .       period\nK_SLASH       /       forward slash\nK_0           0       0\nK_1           1       1\nK_2           2       2\nK_3           3       3\nK_4           4       4\nK_5           5       5\nK_6           6       6\nK_7           7       7\nK_8           8       8\nK_9           9       9\nK_COLON       :       colon\nK_SEMICOLON   ;       semicolon\nK_LESS        <       less-than sign\nK_EQUALS      =       equals sign\nK_GREATER     >       greater-than sign\nK_QUESTION    ?       question mark\nK_AT          @       at\nK_LEFTBRACKET [       left bracket\nK_BACKSLASH   \\       backslash\nK_RIGHTBRACKET ]      right bracket\nK_CARET       ^       caret\nK_UNDERSCORE  _       underscore\nK_BACKQUOTE   `       grave\nK_a           a       a\nK_b           b       b\nK_c           c       c\nK_d           d       d\nK_e           e       e\nK_f           f       f\nK_g           g       g\nK_h           h       h\nK_i           i       i\nK_j           j       j\nK_k           k       k\nK_l           l       l\nK_m           m       m\nK_n           n       n\nK_o           o       o\nK_p           p       p\nK_q           q       q\nK_r           r       r\nK_s           s       s\nK_t           t       t\nK_u           u       u\nK_v           v       v\nK_w           w       w\nK_x           x       x\nK_y           y       y\nK_z           z       z\nK_DELETE              delete\nK_KP0                 keypad 0\nK_KP1                 keypad 1\nK_KP2                 keypad 2\nK_KP3                 keypad 3\nK_KP4                 keypad 4\nK_KP5                 keypad 5\nK_KP6                 keypad 6\nK_KP7                 keypad 7\nK_KP8                 keypad 8\nK_KP9                 keypad 9\nK_KP_PERIOD   .       keypad period\nK_KP_DIVIDE   /       keypad divide\nK_KP_MULTIPLY *       keypad multiply\nK_KP_MINUS    -       keypad minus\nK_KP_PLUS     +       keypad plus\nK_KP_ENTER    \\r      keypad enter\nK_KP_EQUALS   =       keypad equals\nK_UP                  up arrow\nK_DOWN                down arrow\nK_RIGHT               right arrow\nK_LEFT                left arrow\nK_INSERT              insert\nK_HOME                home\nK_END                 end\nK_PAGEUP              page up\nK_PAGEDOWN            page down\nK_F1                  F1\nK_F2                  F2\nK_F3                  F3\nK_F4                  F4\nK_F5                  F5\nK_F6                  F6\nK_F7                  F7\nK_F8                  F8\nK_F9                  F9\nK_F10                 F10\nK_F11                 F11\nK_F12                 F12\nK_F13                 F13\nK_F14                 F14\nK_F15                 F15\nK_NUMLOCK             numlock\nK_CAPSLOCK            capslock\nK_SCROLLOCK           scrollock\nK_RSHIFT              right shift\nK_LSHIFT              left shift\nK_RCTRL               right control\nK_LCTRL               left control\nK_RALT                right alt\nK_LALT                left alt\nK_RMETA               right meta\nK_LMETA               left meta\nK_LSUPER              left Windows key\nK_RSUPER              right Windows key\nK_MODE                mode shift\nK_HELP                help\nK_PRINT               print screen\nK_SYSREQ              sysrq\nK_BREAK               break\nK_MENU                menu\nK_POWER               power\nK_EURO                Euro The keyboard also has a list of modifier states (from pygame.locals) that can be assembled by bitwise-ORing them together. pygame\nConstant      Description\n-------------------------\nKMOD_NONE     no modifier keys pressed\nKMOD_LSHIFT   left shift\nKMOD_RSHIFT   right shift\nKMOD_SHIFT    left shift or right shift or both\nKMOD_LCTRL    left control\nKMOD_RCTRL    right control\nKMOD_CTRL     left control or right control or both\nKMOD_LALT     left alt\nKMOD_RALT     right alt\nKMOD_ALT      left alt or right alt or both\nKMOD_LMETA    left meta\nKMOD_RMETA    right meta\nKMOD_META     left meta or right meta or both\nKMOD_CAPS     caps lock\nKMOD_NUM      num lock\nKMOD_MODE     AltGr The modifier information is contained in the mod attribute of the pygame.KEYDOWN and pygame.KEYUP events. The mod attribute is a bitmask of all the modifier keys that were in a pressed state when the event occurred. The modifier information can be decoded using a bitwise AND (except for KMOD_NONE, which should be compared using equals ==). For example: for event in pygame.event.get():\n    if event.type == pygame.KEYDOWN or event.type == pygame.KEYUP:\n        if event.mod == pygame.KMOD_NONE:\n            print('No modifier keys were in a pressed state when this '\n                  'event occurred.')\n        else:\n            if event.mod & pygame.KMOD_LSHIFT:\n                print('Left shift was in a pressed state when this event '\n                      'occurred.')\n            if event.mod & pygame.KMOD_RSHIFT:\n                print('Right shift was in a pressed state when this event '\n                      'occurred.')\n            if event.mod & pygame.KMOD_SHIFT:\n                print('Left shift or right shift or both were in a '\n                      'pressed state when this event occurred.')   pygame.key.get_focused() \n true if the display is receiving keyboard input from the system get_focused() -> bool  Returns True when the display window has keyboard focus from the system. If the display needs to ensure it does not lose keyboard focus, it can use pygame.event.set_grab() to grab all input. \n   pygame.key.get_pressed() \n get the state of all keyboard buttons get_pressed() -> bools  Returns a sequence of boolean values representing the state of every key on the keyboard. Use the key constant values to index the array. A True value means the that button is pressed.  Note Getting the list of pushed buttons with this function is not the proper way to handle text entry from the user. There is no way to know the order of keys pressed, and rapidly pushed keys can be completely unnoticed between two calls to pygame.key.get_pressed(). There is also no way to translate these pushed keys into a fully translated character value. See the pygame.KEYDOWN events on the pygame.event queue for this functionality.  \n   pygame.key.get_mods() \n determine which modifier keys are being held get_mods() -> int  Returns a single integer representing a bitmask of all the modifier keys being held. Using bitwise operators you can test if specific modifier keys are pressed. \n   pygame.key.set_mods() \n temporarily set which modifier keys are pressed set_mods(int) -> None  Create a bitmask of the modifier key constants you want to impose on your program. \n   pygame.key.set_repeat() \n control how held keys are repeated set_repeat() -> None set_repeat(delay) -> None set_repeat(delay, interval) -> None  When the keyboard repeat is enabled, keys that are held down will generate multiple pygame.KEYDOWN events. The delay parameter is the number of milliseconds before the first repeated pygame.KEYDOWN event will be sent. After that, another pygame.KEYDOWN event will be sent every interval milliseconds. If a delay value is provided and an interval value is not provided or is 0, then the interval will be set to the same value as delay. To disable key repeat call this function with no arguments or with delay set to 0. When pygame is initialized the key repeat is disabled.     \nRaises:\n\nValueError -- if delay or interval is < 0     Changed in pygame 2.0.0: A ValueError is now raised (instead of a pygame.error) if delay or interval is < 0.  \n   pygame.key.get_repeat() \n see how held keys are repeated get_repeat() -> (delay, interval)  Get the delay and interval keyboard repeat values. Refer to pygame.key.set_repeat() for a description of these values.  New in pygame 1.8.  \n   pygame.key.name() \n get the name of a key identifier name(key) -> string  Get the descriptive name of the button from a keyboard button id constant. \n   pygame.key.key_code() \n get the key identifier from a key name key_code(name=string) -> int  Get the key identifier code from the descriptive name of the key. This returns an integer matching one of the K_* keycodes. For example: >>> pygame.key.key_code(\"return\") == pygame.K_RETURN\nTrue\n>>> pygame.key.key_code(\"0\") == pygame.K_0\nTrue\n>>> pygame.key.key_code(\"space\") == pygame.K_SPACE\nTrue     \nRaises:\n\n \nValueError -- if the key name is not known. \nNotImplementedError -- if used with SDL 1.       New in pygame 2.0.0.  \n   pygame.key.start_text_input() \n start handling Unicode text input events start_text_input() -> None  Start receiving pygame.TEXTEDITING and pygame.TEXTINPUT events. A pygame.TEXTEDITING event is received when an IME composition is started or changed. It contains the composition text, length, and editing start position within the composition (attributes text, length, and start, respectively). When the composition is committed (or non-IME input is received), a pygame.TEXTINPUT event is generated. Text input events handling is on by default.  New in pygame 2.0.0.  \n   pygame.key.stop_text_input() \n stop handling Unicode text input events stop_text_input() -> None  Stop receiving pygame.TEXTEDITING and pygame.TEXTINPUT events. Text input events handling is on by default  New in pygame 2.0.0.  \n   pygame.key.set_text_input_rect() \n controls the position of the candidate list set_text_input_rect(Rect) -> None  This sets the rectangle used for typing with an IME. It controls where the candidate list will open, if supported.  New in pygame 2.0.0.  \n \n \n"}, {"name": "key.get_focused", "path": "ref/key#pygame.key.get_focused", "type": "pygame.key", "text": "  pygame.key.get_focused() \n true if the display is receiving keyboard input from the system get_focused() -> bool  Returns True when the display window has keyboard focus from the system. If the display needs to ensure it does not lose keyboard focus, it can use pygame.event.set_grab() to grab all input. \n"}, {"name": "key.get_mods", "path": "ref/key#pygame.key.get_mods", "type": "pygame.key", "text": "  pygame.key.get_mods() \n determine which modifier keys are being held get_mods() -> int  Returns a single integer representing a bitmask of all the modifier keys being held. Using bitwise operators you can test if specific modifier keys are pressed. \n"}, {"name": "key.get_pressed", "path": "ref/key#pygame.key.get_pressed", "type": "pygame.key", "text": "  pygame.key.get_pressed() \n get the state of all keyboard buttons get_pressed() -> bools  Returns a sequence of boolean values representing the state of every key on the keyboard. Use the key constant values to index the array. A True value means the that button is pressed.  Note Getting the list of pushed buttons with this function is not the proper way to handle text entry from the user. There is no way to know the order of keys pressed, and rapidly pushed keys can be completely unnoticed between two calls to pygame.key.get_pressed(). There is also no way to translate these pushed keys into a fully translated character value. See the pygame.KEYDOWN events on the pygame.event queue for this functionality.  \n"}, {"name": "key.get_repeat", "path": "ref/key#pygame.key.get_repeat", "type": "pygame.key", "text": "  pygame.key.get_repeat() \n see how held keys are repeated get_repeat() -> (delay, interval)  Get the delay and interval keyboard repeat values. Refer to pygame.key.set_repeat() for a description of these values.  New in pygame 1.8.  \n"}, {"name": "key.key_code", "path": "ref/key#pygame.key.key_code", "type": "pygame.key", "text": "  pygame.key.key_code() \n get the key identifier from a key name key_code(name=string) -> int  Get the key identifier code from the descriptive name of the key. This returns an integer matching one of the K_* keycodes. For example: >>> pygame.key.key_code(\"return\") == pygame.K_RETURN\nTrue\n>>> pygame.key.key_code(\"0\") == pygame.K_0\nTrue\n>>> pygame.key.key_code(\"space\") == pygame.K_SPACE\nTrue     \nRaises:\n\n \nValueError -- if the key name is not known. \nNotImplementedError -- if used with SDL 1.       New in pygame 2.0.0.  \n"}, {"name": "key.name", "path": "ref/key#pygame.key.name", "type": "pygame.key", "text": "  pygame.key.name() \n get the name of a key identifier name(key) -> string  Get the descriptive name of the button from a keyboard button id constant. \n"}, {"name": "key.set_mods", "path": "ref/key#pygame.key.set_mods", "type": "pygame.key", "text": "  pygame.key.set_mods() \n temporarily set which modifier keys are pressed set_mods(int) -> None  Create a bitmask of the modifier key constants you want to impose on your program. \n"}, {"name": "key.set_repeat", "path": "ref/key#pygame.key.set_repeat", "type": "pygame.key", "text": "  pygame.key.set_repeat() \n control how held keys are repeated set_repeat() -> None set_repeat(delay) -> None set_repeat(delay, interval) -> None  When the keyboard repeat is enabled, keys that are held down will generate multiple pygame.KEYDOWN events. The delay parameter is the number of milliseconds before the first repeated pygame.KEYDOWN event will be sent. After that, another pygame.KEYDOWN event will be sent every interval milliseconds. If a delay value is provided and an interval value is not provided or is 0, then the interval will be set to the same value as delay. To disable key repeat call this function with no arguments or with delay set to 0. When pygame is initialized the key repeat is disabled.     \nRaises:\n\nValueError -- if delay or interval is < 0     Changed in pygame 2.0.0: A ValueError is now raised (instead of a pygame.error) if delay or interval is < 0.  \n"}, {"name": "key.set_text_input_rect", "path": "ref/key#pygame.key.set_text_input_rect", "type": "pygame.key", "text": "  pygame.key.set_text_input_rect() \n controls the position of the candidate list set_text_input_rect(Rect) -> None  This sets the rectangle used for typing with an IME. It controls where the candidate list will open, if supported.  New in pygame 2.0.0.  \n"}, {"name": "key.start_text_input", "path": "ref/key#pygame.key.start_text_input", "type": "pygame.key", "text": "  pygame.key.start_text_input() \n start handling Unicode text input events start_text_input() -> None  Start receiving pygame.TEXTEDITING and pygame.TEXTINPUT events. A pygame.TEXTEDITING event is received when an IME composition is started or changed. It contains the composition text, length, and editing start position within the composition (attributes text, length, and start, respectively). When the composition is committed (or non-IME input is received), a pygame.TEXTINPUT event is generated. Text input events handling is on by default.  New in pygame 2.0.0.  \n"}, {"name": "key.stop_text_input", "path": "ref/key#pygame.key.stop_text_input", "type": "pygame.key", "text": "  pygame.key.stop_text_input() \n stop handling Unicode text input events stop_text_input() -> None  Stop receiving pygame.TEXTEDITING and pygame.TEXTINPUT events. Text input events handling is on by default  New in pygame 2.0.0.  \n"}, {"name": "locals", "path": "ref/locals", "type": "pygame.locals", "text": " pygame.locals\n  \n pygame constants  This module contains various constants used by pygame. Its contents are automatically placed in the pygame module namespace. However, an application can use pygame.locals to include only the pygame constants with a from\npygame.locals import *. Detailed descriptions of the various constants can be found throughout the pygame documentation. Here are the locations of some of them.  \n The pygame.display module contains flags like HWSURFACE used by pygame.display.set_mode(). The pygame.event module contains the various event types. The pygame.key module lists the keyboard constants and modifiers (K_* and MOD_*) relating to the key and mod attributes of the KEYDOWN and KEYUP events. The pygame.time module defines TIMER_RESOLUTION.  \n \n \n"}, {"name": "mask", "path": "ref/mask", "type": "pygame.mask", "text": " pygame.mask\n  \n pygame module for image masks.  Useful for fast pixel perfect collision detection. A mask uses 1 bit per-pixel to store which parts collide.  New in pygame 1.8.    pygame.mask.from_surface() \n Creates a Mask from the given surface from_surface(Surface) -> Mask from_surface(Surface, threshold=127) -> Mask  Creates a Mask object from the given surface by setting all the opaque pixels and not setting the transparent pixels. If the surface uses a color-key, then it is used to decide which bits in the resulting mask are set. All the pixels that are not equal to the color-key are set and the pixels equal to the color-key are not set. If a color-key is not used, then the alpha value of each pixel is used to decide which bits in the resulting mask are set. All the pixels that have an alpha value greater than the threshold parameter are set and the pixels with an alpha value less than or equal to the threshold are not set.     \nParameters:\n\n \nsurface (Surface) -- the surface to create the mask from \nthreshold (int) -- (optional) the alpha threshold (default is 127) to compare with each surface pixel's alpha value, if the surface is color-keyed this parameter is ignored    \nReturns:\n\na newly created Mask object from the given surface   \nReturn type:\n\nMask      Note This function is used to create the masks for pygame.sprite.collide_mask().  \n   pygame.mask.from_threshold() \n Creates a mask by thresholding Surfaces from_threshold(Surface, color) -> Mask from_threshold(Surface, color, threshold=(0, 0, 0, 255), othersurface=None, palette_colors=1) -> Mask  This is a more featureful method of getting a Mask from a surface. If the optional othersurface is not used, all the pixels within the threshold of the color parameter are set in the resulting mask. If the optional othersurface is used, every pixel in the first surface that is within the threshold of the corresponding pixel in othersurface is set in the resulting mask.     \nParameters:\n\n \nsurface (Surface) -- the surface to create the mask from \ncolor (Color or int or tuple(int, int, int, [int]) or list[int, int, int, [int]]) -- color used to check if the surface's pixels are within the given threshold range, this parameter is ignored if the optional othersurface parameter is supplied \nthreshold (Color or int or tuple(int, int, int, [int]) or list[int, int, int, [int]]) -- (optional) the threshold range used to check the difference between two colors (default is (0, 0, 0, 255)) \nothersurface (Surface) -- (optional) used to check whether the pixels of the first surface are within the given threshold range of the pixels from this surface (default is None) \npalette_colors (int) -- (optional) indicates whether to use the palette colors or not, a nonzero value causes the palette colors to be used and a 0 causes them not to be used (default is 1)    \nReturns:\n\na newly created Mask object from the given surface   \nReturn type:\n\nMask     \n   pygame.mask.Mask \n pygame object for representing 2D bitmasks Mask(size=(width, height)) -> Mask Mask(size=(width, height), fill=False) -> Mask  A Mask object is used to represent a 2D bitmask. Each bit in the mask represents a pixel. 1 is used to indicate a set bit and 0 is used to indicate an unset bit. Set bits in a mask can be used to detect collisions with other masks and their set bits. A filled mask has all of its bits set to 1, conversely an unfilled/cleared/empty mask has all of its bits set to 0. Masks can be created unfilled (default) or filled by using the fill parameter. Masks can also be cleared or filled using the pygame.mask.Mask.clear() and pygame.mask.Mask.fill() methods respectively. A mask's coordinates start in the top left corner at (0, 0) just like pygame.Surface. Individual bits can be accessed using the pygame.mask.Mask.get_at() and pygame.mask.Mask.set_at() methods. The methods overlap(), overlap_area(), overlap_mask(), draw(), erase(), and convolve() use an offset parameter to indicate the offset of another mask's top left corner from the calling mask's top left corner. The calling mask's top left corner is considered to be the origin (0, 0). Offsets are a tuple or list of 2 integer values (x_offset, y_offset). Positive and negative offset values are supported. 0 to x (x_offset)\n           :    :\n   0 ..... +----:---------+\n   to      |    :         |\n   y .......... +-----------+\n(y_offset) |    | othermask |\n           |    +-----------+\n           | calling_mask |\n           +--------------+     \nParameters:\n\n \nsize (tuple(int, int) or list[int, int]) -- the dimensions of the mask (width and height) \nfill (bool) -- (optional) create an unfilled mask (default: False) or filled mask (True)    \nReturns:\n\na newly created Mask object   \nReturn type:\n\nMask      Changed in pygame 2.0.0: Shallow copy support added. The Mask class supports the special method __copy__() and shallow copying via copy.copy(mask).   Changed in pygame 2.0.0: Subclassing support added. The Mask class can be used as a base class.   Changed in pygame 1.9.5: Added support for keyword arguments.   Changed in pygame 1.9.5: Added the optional keyword parameter fill.   Changed in pygame 1.9.5: Added support for masks with a width and/or a height of 0.    copy() \n Returns a new copy of the mask copy() -> Mask      \nReturns:\na new copy of this mask, the new mask will have the same width, height, and set/unset bits as the original  \nReturn type:\nMask     Note If a mask subclass needs to copy any instance specific attributes then it should override the __copy__() method. The overridden __copy__() method needs to call super().__copy__() and then copy the required data as in the following example code. class SubMask(pygame.mask.Mask):\n    def __copy__(self):\n        new_mask = super().__copy__()\n        # Do any SubMask attribute copying here.\n        return new_mask   New in pygame 2.0.0.  \n   get_size() \n Returns the size of the mask get_size() -> (width, height)      \nReturns:\nthe size of the mask, (width, height)  \nReturn type:\ntuple(int, int)    \n   get_rect() \n Returns a Rect based on the size of the mask get_rect(**kwargs) -> Rect  Returns a new pygame.Rect() object based on the size of this mask. The rect's default position will be (0, 0) and its default width and height will be the same as this mask's. The rect's attributes can be altered via pygame.Rect() attribute keyword arguments/values passed into this method. As an example, a_mask.get_rect(center=(10, 5)) would create a pygame.Rect() based on the mask's size centered at the given position.     \nParameters:\n\nkwargs (dict) -- pygame.Rect() attribute keyword arguments/values that will be applied to the rect  \nReturns:\na new pygame.Rect() object based on the size of this mask with any pygame.Rect() attribute keyword arguments/values applied to it  \nReturn type:\nRect     New in pygame 2.0.0.  \n   get_at() \n Gets the bit at the given position get_at((x, y)) -> int      \nParameters:\n\npos (tuple(int, int) or list[int, int]) -- the position of the bit to get  \nReturns:\n1 if the bit is set, 0 if the bit is not set  \nReturn type:\nint  \nRaises:\n\nIndexError -- if the position is outside of the mask's bounds    \n   set_at() \n Sets the bit at the given position set_at((x, y)) -> None set_at((x, y), value=1) -> None      \nParameters:\n\n \npos (tuple(int, int) or list[int, int]) -- the position of the bit to set \nvalue (int) -- any nonzero int will set the bit to 1, 0 will set the bit to 0 (default is 1)    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\nIndexError -- if the position is outside of the mask's bounds     \n   overlap() \n Returns the point of intersection overlap(othermask, offset) -> (x, y) overlap(othermask, offset) -> None  Returns the first point of intersection encountered between this mask and othermask. A point of intersection is 2 overlapping set bits. The current algorithm searches the overlapping area in sizeof(unsigned long int) * CHAR_BIT bit wide column blocks (the value of sizeof(unsigned long int) * CHAR_BIT is platform dependent, for clarity it will be referred to as W). Starting at the top left corner it checks bits 0 to W - 1 of the first row ((0, 0) to (W - 1, 0)) then continues to the next row ((0, 1) to (W - 1, 1)). Once this entire column block is checked, it continues to the next one (W to 2 * W - 1). This is repeated until it finds a point of intersection or the entire overlapping area is checked.     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\npoint of intersection or None if no intersection   \nReturn type:\n\ntuple(int, int) or NoneType     \n   overlap_area() \n Returns the number of overlapping set bits overlap_area(othermask, offset) -> numbits  Returns the number of overlapping set bits between between this mask and othermask. This can be useful for collision detection. An approximate collision normal can be found by calculating the gradient of the overlapping area through the finite difference. dx = mask.overlap_area(othermask, (x + 1, y)) - mask.overlap_area(othermask, (x - 1, y))\ndy = mask.overlap_area(othermask, (x, y + 1)) - mask.overlap_area(othermask, (x, y - 1))     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nthe number of overlapping set bits   \nReturn type:\n\nint     \n   overlap_mask() \n Returns a mask of the overlapping set bits overlap_mask(othermask, offset) -> Mask  Returns a Mask, the same size as this mask, containing the overlapping set bits between this mask and othermask.     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\na newly created Mask with the overlapping bits set   \nReturn type:\n\nMask     \n   fill() \n Sets all bits to 1 fill() -> None  Sets all bits in the mask to 1.     \nReturns:\nNone  \nReturn type:\nNoneType    \n   clear() \n Sets all bits to 0 clear() -> None  Sets all bits in the mask to 0.     \nReturns:\nNone  \nReturn type:\nNoneType    \n   invert() \n Flips all the bits invert() -> None  Flips all of the bits in the mask. All the set bits are cleared to 0 and all the unset bits are set to 1.     \nReturns:\nNone  \nReturn type:\nNoneType    \n   scale() \n Resizes a mask scale((width, height)) -> Mask  Creates a new Mask of the requested size with its bits scaled from this mask.     \nParameters:\n\nsize (tuple(int, int) or list[int, int]) -- the width and height (size) of the mask to create  \nReturns:\na new Mask object with its bits scaled from this mask  \nReturn type:\nMask  \nRaises:\n\nValueError -- if width < 0 or height < 0\n    \n   draw() \n Draws a mask onto another draw(othermask, offset) -> None  Performs a bitwise OR, drawing othermask onto this mask.     \nParameters:\n\n \nothermask (Mask) -- the mask to draw onto this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   erase() \n Erases a mask from another erase(othermask, offset) -> None  Erases (clears) all bits set in othermask from this mask.     \nParameters:\n\n \nothermask (Mask) -- the mask to erase from this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   count() \n Returns the number of set bits count() -> bits      \nReturns:\nthe number of set bits in the mask  \nReturn type:\nint    \n   centroid() \n Returns the centroid of the set bits centroid() -> (x, y)  Finds the centroid (the center mass of the set bits) for this mask.     \nReturns:\na coordinate tuple indicating the centroid of the mask, it will return (0, 0) if the mask has no bits set  \nReturn type:\ntuple(int, int)    \n   angle() \n Returns the orientation of the set bits angle() -> theta  Finds the approximate orientation (from -90 to 90 degrees) of the set bits in the mask. This works best if performed on a mask with only one connected component.     \nReturns:\nthe orientation of the set bits in the mask, it will return 0.0 if the mask has no bits set  \nReturn type:\nfloat     Note See connected_component() for details on how a connected component is calculated.  \n   outline() \n Returns a list of points outlining an object outline() -> [(x, y), ...] outline(every=1) -> [(x, y), ...]  Returns a list of points of the outline of the first connected component encountered in the mask. To find a connected component, the mask is searched per row (left to right) starting in the top left corner. The every optional parameter skips set bits in the outline. For example, setting it to 10 would return a list of every 10th set bit in the outline.     \nParameters:\n\nevery (int) -- (optional) indicates the number of bits to skip over in the outline (default is 1)  \nReturns:\na list of points outlining the first connected component encountered, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[tuple(int, int)]     Note See connected_component() for details on how a connected component is calculated.  \n   convolve() \n Returns the convolution of this mask with another mask convolve(othermask) -> Mask convolve(othermask, outputmask=None, offset=(0, 0)) -> Mask  Convolve this mask with the given othermask.     \nParameters:\n\n \nothermask (Mask) -- mask to convolve this mask with \noutputmask (Mask or NoneType) -- (optional) mask for output (default is None) \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, (default is (0, 0))    \nReturns:\n\na Mask with the (i - offset[0], j - offset[1]) bit set, if shifting othermask (such that its bottom right corner is at (i, j)) causes it to overlap with this mask If an outputmask is specified, the output is drawn onto it and it is returned. Otherwise a mask of size (MAX(0, width + othermask's\nwidth - 1), MAX(0, height + othermask's height - 1)) is created and returned.   \nReturn type:\n\nMask     \n   connected_component() \n Returns a mask containing a connected component connected_component() -> Mask connected_component((x, y)) -> Mask  A connected component is a group (1 or more) of connected set bits (orthogonally and diagonally). The SAUF algorithm, which checks 8 point connectivity, is used to find a connected component in the mask. By default this method will return a Mask containing the largest connected component in the mask. Optionally, a bit coordinate can be specified and the connected component containing it will be returned. If the bit at the given location is not set, the returned Mask will be empty (no bits set).     \nParameters:\n\npos (tuple(int, int) or list[int, int]) -- (optional) selects the connected component that contains the bit at this position  \nReturns:\na Mask object (same size as this mask) with the largest connected component from this mask, if this mask has no bits set then an empty mask will be returnedIf the pos parameter is provided then the mask returned will have the connected component that contains this position. An empty mask will be returned if the pos parameter selects an unset bit.   \nReturn type:\nMask  \nRaises:\n\nIndexError -- if the optional pos parameter is outside of the mask's bounds    \n   connected_components() \n Returns a list of masks of connected components connected_components() -> [Mask, ...] connected_components(min=0) -> [Mask, ...]  Provides a list containing a Mask object for each connected component.     \nParameters:\n\nmin (int) -- (optional) indicates the minimum number of bits (to filter out noise) per connected component (default is 0, which equates to no minimum and is equivalent to setting it to 1, as a connected component must have at least 1 bit set)  \nReturns:\na list containing a Mask object for each connected component, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[Mask]     Note See connected_component() for details on how a connected component is calculated.  \n   get_bounding_rects() \n Returns a list of bounding rects of connected components get_bounding_rects() -> [Rect, ...]  Provides a list containing a bounding rect for each connected component.     \nReturns:\na list containing a bounding rect for each connected component, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[Rect]     Note See connected_component() for details on how a connected component is calculated.  \n   to_surface() \n Returns a surface with the mask drawn on it to_surface() -> Surface to_surface(surface=None, setsurface=None, unsetsurface=None, setcolor=(255, 255, 255, 255), unsetcolor=(0, 0, 0, 255), dest=(0, 0)) -> Surface  Draws this mask on the given surface. Set bits (bits set to 1) and unset bits (bits set to 0) can be drawn onto a surface.     \nParameters:\n\n \nsurface (Surface or None) -- (optional) Surface to draw mask onto, if no surface is provided one will be created (default is None, which will cause a surface with the parameters Surface(size=mask.get_size(), flags=SRCALPHA, depth=32) to be created, drawn on, and returned) \nsetsurface (Surface or None) -- (optional) use this surface's color values to draw set bits (default is None), if this surface is smaller than the mask any bits outside its bounds will use the setcolor value \nunsetsurface (Surface or None) -- (optional) use this surface's color values to draw unset bits (default is None), if this surface is smaller than the mask any bits outside its bounds will use the unsetcolor value \nsetcolor (Color or str or int or tuple(int, int, int, [int]) or list(int, int, int, [int]) or None) -- (optional) color to draw set bits (default is (255, 255, 255, 255), white), use None to skip drawing the set bits, the setsurface parameter (if set) will takes precedence over this parameter \nunsetcolor (Color or str or int or tuple(int, int, int, [int]) or list(int, int, int, [int]) or None) -- (optional) color to draw unset bits (default is (0, 0, 0, 255), black), use None to skip drawing the unset bits, the unsetsurface parameter (if set) will takes precedence over this parameter \ndest (Rect or tuple(int, int) or list(int, int) or Vector2(int, int)) -- (optional) surface destination of where to position the topleft corner of the mask being drawn (default is (0, 0)), if a Rect is used as the dest parameter, its x and y attributes will be used as the destination, NOTE1: rects with a negative width or height value will not be normalized before using their x and y values, NOTE2: this destination value is only used to position the mask on the surface, it does not offset the setsurface and unsetsurface from the mask, they are always aligned with the mask (i.e. position (0, 0) on the mask always corresponds to position (0, 0) on the setsurface and unsetsurface)    \nReturns:\n\nthe surface parameter (or a newly created surface if no surface parameter was provided) with this mask drawn on it   \nReturn type:\n\nSurface   \nRaises:\n\nValueError -- if the setsurface parameter or unsetsurface parameter does not have the same format (bytesize/bitsize/alpha) as the surface parameter      Note To skip drawing the set bits, both setsurface and setcolor must be None. The setsurface parameter defaults to None, but setcolor defaults to a color value and therefore must be set to None.   Note To skip drawing the unset bits, both unsetsurface and unsetcolor must be None. The unsetsurface parameter defaults to None, but unsetcolor defaults to a color value and therefore must be set to None.   New in pygame 2.0.0.  \n \n \n \n"}, {"name": "mask.from_surface", "path": "ref/mask#pygame.mask.from_surface", "type": "pygame.mask", "text": "  pygame.mask.from_surface() \n Creates a Mask from the given surface from_surface(Surface) -> Mask from_surface(Surface, threshold=127) -> Mask  Creates a Mask object from the given surface by setting all the opaque pixels and not setting the transparent pixels. If the surface uses a color-key, then it is used to decide which bits in the resulting mask are set. All the pixels that are not equal to the color-key are set and the pixels equal to the color-key are not set. If a color-key is not used, then the alpha value of each pixel is used to decide which bits in the resulting mask are set. All the pixels that have an alpha value greater than the threshold parameter are set and the pixels with an alpha value less than or equal to the threshold are not set.     \nParameters:\n\n \nsurface (Surface) -- the surface to create the mask from \nthreshold (int) -- (optional) the alpha threshold (default is 127) to compare with each surface pixel's alpha value, if the surface is color-keyed this parameter is ignored    \nReturns:\n\na newly created Mask object from the given surface   \nReturn type:\n\nMask      Note This function is used to create the masks for pygame.sprite.collide_mask().  \n"}, {"name": "mask.from_threshold", "path": "ref/mask#pygame.mask.from_threshold", "type": "pygame.mask", "text": "  pygame.mask.from_threshold() \n Creates a mask by thresholding Surfaces from_threshold(Surface, color) -> Mask from_threshold(Surface, color, threshold=(0, 0, 0, 255), othersurface=None, palette_colors=1) -> Mask  This is a more featureful method of getting a Mask from a surface. If the optional othersurface is not used, all the pixels within the threshold of the color parameter are set in the resulting mask. If the optional othersurface is used, every pixel in the first surface that is within the threshold of the corresponding pixel in othersurface is set in the resulting mask.     \nParameters:\n\n \nsurface (Surface) -- the surface to create the mask from \ncolor (Color or int or tuple(int, int, int, [int]) or list[int, int, int, [int]]) -- color used to check if the surface's pixels are within the given threshold range, this parameter is ignored if the optional othersurface parameter is supplied \nthreshold (Color or int or tuple(int, int, int, [int]) or list[int, int, int, [int]]) -- (optional) the threshold range used to check the difference between two colors (default is (0, 0, 0, 255)) \nothersurface (Surface) -- (optional) used to check whether the pixels of the first surface are within the given threshold range of the pixels from this surface (default is None) \npalette_colors (int) -- (optional) indicates whether to use the palette colors or not, a nonzero value causes the palette colors to be used and a 0 causes them not to be used (default is 1)    \nReturns:\n\na newly created Mask object from the given surface   \nReturn type:\n\nMask     \n"}, {"name": "mask.Mask", "path": "ref/mask#pygame.mask.Mask", "type": "pygame.mask", "text": "  pygame.mask.Mask \n pygame object for representing 2D bitmasks Mask(size=(width, height)) -> Mask Mask(size=(width, height), fill=False) -> Mask  A Mask object is used to represent a 2D bitmask. Each bit in the mask represents a pixel. 1 is used to indicate a set bit and 0 is used to indicate an unset bit. Set bits in a mask can be used to detect collisions with other masks and their set bits. A filled mask has all of its bits set to 1, conversely an unfilled/cleared/empty mask has all of its bits set to 0. Masks can be created unfilled (default) or filled by using the fill parameter. Masks can also be cleared or filled using the pygame.mask.Mask.clear() and pygame.mask.Mask.fill() methods respectively. A mask's coordinates start in the top left corner at (0, 0) just like pygame.Surface. Individual bits can be accessed using the pygame.mask.Mask.get_at() and pygame.mask.Mask.set_at() methods. The methods overlap(), overlap_area(), overlap_mask(), draw(), erase(), and convolve() use an offset parameter to indicate the offset of another mask's top left corner from the calling mask's top left corner. The calling mask's top left corner is considered to be the origin (0, 0). Offsets are a tuple or list of 2 integer values (x_offset, y_offset). Positive and negative offset values are supported. 0 to x (x_offset)\n           :    :\n   0 ..... +----:---------+\n   to      |    :         |\n   y .......... +-----------+\n(y_offset) |    | othermask |\n           |    +-----------+\n           | calling_mask |\n           +--------------+     \nParameters:\n\n \nsize (tuple(int, int) or list[int, int]) -- the dimensions of the mask (width and height) \nfill (bool) -- (optional) create an unfilled mask (default: False) or filled mask (True)    \nReturns:\n\na newly created Mask object   \nReturn type:\n\nMask      Changed in pygame 2.0.0: Shallow copy support added. The Mask class supports the special method __copy__() and shallow copying via copy.copy(mask).   Changed in pygame 2.0.0: Subclassing support added. The Mask class can be used as a base class.   Changed in pygame 1.9.5: Added support for keyword arguments.   Changed in pygame 1.9.5: Added the optional keyword parameter fill.   Changed in pygame 1.9.5: Added support for masks with a width and/or a height of 0.    copy() \n Returns a new copy of the mask copy() -> Mask      \nReturns:\na new copy of this mask, the new mask will have the same width, height, and set/unset bits as the original  \nReturn type:\nMask     Note If a mask subclass needs to copy any instance specific attributes then it should override the __copy__() method. The overridden __copy__() method needs to call super().__copy__() and then copy the required data as in the following example code. class SubMask(pygame.mask.Mask):\n    def __copy__(self):\n        new_mask = super().__copy__()\n        # Do any SubMask attribute copying here.\n        return new_mask   New in pygame 2.0.0.  \n   get_size() \n Returns the size of the mask get_size() -> (width, height)      \nReturns:\nthe size of the mask, (width, height)  \nReturn type:\ntuple(int, int)    \n   get_rect() \n Returns a Rect based on the size of the mask get_rect(**kwargs) -> Rect  Returns a new pygame.Rect() object based on the size of this mask. The rect's default position will be (0, 0) and its default width and height will be the same as this mask's. The rect's attributes can be altered via pygame.Rect() attribute keyword arguments/values passed into this method. As an example, a_mask.get_rect(center=(10, 5)) would create a pygame.Rect() based on the mask's size centered at the given position.     \nParameters:\n\nkwargs (dict) -- pygame.Rect() attribute keyword arguments/values that will be applied to the rect  \nReturns:\na new pygame.Rect() object based on the size of this mask with any pygame.Rect() attribute keyword arguments/values applied to it  \nReturn type:\nRect     New in pygame 2.0.0.  \n   get_at() \n Gets the bit at the given position get_at((x, y)) -> int      \nParameters:\n\npos (tuple(int, int) or list[int, int]) -- the position of the bit to get  \nReturns:\n1 if the bit is set, 0 if the bit is not set  \nReturn type:\nint  \nRaises:\n\nIndexError -- if the position is outside of the mask's bounds    \n   set_at() \n Sets the bit at the given position set_at((x, y)) -> None set_at((x, y), value=1) -> None      \nParameters:\n\n \npos (tuple(int, int) or list[int, int]) -- the position of the bit to set \nvalue (int) -- any nonzero int will set the bit to 1, 0 will set the bit to 0 (default is 1)    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\nIndexError -- if the position is outside of the mask's bounds     \n   overlap() \n Returns the point of intersection overlap(othermask, offset) -> (x, y) overlap(othermask, offset) -> None  Returns the first point of intersection encountered between this mask and othermask. A point of intersection is 2 overlapping set bits. The current algorithm searches the overlapping area in sizeof(unsigned long int) * CHAR_BIT bit wide column blocks (the value of sizeof(unsigned long int) * CHAR_BIT is platform dependent, for clarity it will be referred to as W). Starting at the top left corner it checks bits 0 to W - 1 of the first row ((0, 0) to (W - 1, 0)) then continues to the next row ((0, 1) to (W - 1, 1)). Once this entire column block is checked, it continues to the next one (W to 2 * W - 1). This is repeated until it finds a point of intersection or the entire overlapping area is checked.     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\npoint of intersection or None if no intersection   \nReturn type:\n\ntuple(int, int) or NoneType     \n   overlap_area() \n Returns the number of overlapping set bits overlap_area(othermask, offset) -> numbits  Returns the number of overlapping set bits between between this mask and othermask. This can be useful for collision detection. An approximate collision normal can be found by calculating the gradient of the overlapping area through the finite difference. dx = mask.overlap_area(othermask, (x + 1, y)) - mask.overlap_area(othermask, (x - 1, y))\ndy = mask.overlap_area(othermask, (x, y + 1)) - mask.overlap_area(othermask, (x, y - 1))     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nthe number of overlapping set bits   \nReturn type:\n\nint     \n   overlap_mask() \n Returns a mask of the overlapping set bits overlap_mask(othermask, offset) -> Mask  Returns a Mask, the same size as this mask, containing the overlapping set bits between this mask and othermask.     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\na newly created Mask with the overlapping bits set   \nReturn type:\n\nMask     \n   fill() \n Sets all bits to 1 fill() -> None  Sets all bits in the mask to 1.     \nReturns:\nNone  \nReturn type:\nNoneType    \n   clear() \n Sets all bits to 0 clear() -> None  Sets all bits in the mask to 0.     \nReturns:\nNone  \nReturn type:\nNoneType    \n   invert() \n Flips all the bits invert() -> None  Flips all of the bits in the mask. All the set bits are cleared to 0 and all the unset bits are set to 1.     \nReturns:\nNone  \nReturn type:\nNoneType    \n   scale() \n Resizes a mask scale((width, height)) -> Mask  Creates a new Mask of the requested size with its bits scaled from this mask.     \nParameters:\n\nsize (tuple(int, int) or list[int, int]) -- the width and height (size) of the mask to create  \nReturns:\na new Mask object with its bits scaled from this mask  \nReturn type:\nMask  \nRaises:\n\nValueError -- if width < 0 or height < 0\n    \n   draw() \n Draws a mask onto another draw(othermask, offset) -> None  Performs a bitwise OR, drawing othermask onto this mask.     \nParameters:\n\n \nothermask (Mask) -- the mask to draw onto this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   erase() \n Erases a mask from another erase(othermask, offset) -> None  Erases (clears) all bits set in othermask from this mask.     \nParameters:\n\n \nothermask (Mask) -- the mask to erase from this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   count() \n Returns the number of set bits count() -> bits      \nReturns:\nthe number of set bits in the mask  \nReturn type:\nint    \n   centroid() \n Returns the centroid of the set bits centroid() -> (x, y)  Finds the centroid (the center mass of the set bits) for this mask.     \nReturns:\na coordinate tuple indicating the centroid of the mask, it will return (0, 0) if the mask has no bits set  \nReturn type:\ntuple(int, int)    \n   angle() \n Returns the orientation of the set bits angle() -> theta  Finds the approximate orientation (from -90 to 90 degrees) of the set bits in the mask. This works best if performed on a mask with only one connected component.     \nReturns:\nthe orientation of the set bits in the mask, it will return 0.0 if the mask has no bits set  \nReturn type:\nfloat     Note See connected_component() for details on how a connected component is calculated.  \n   outline() \n Returns a list of points outlining an object outline() -> [(x, y), ...] outline(every=1) -> [(x, y), ...]  Returns a list of points of the outline of the first connected component encountered in the mask. To find a connected component, the mask is searched per row (left to right) starting in the top left corner. The every optional parameter skips set bits in the outline. For example, setting it to 10 would return a list of every 10th set bit in the outline.     \nParameters:\n\nevery (int) -- (optional) indicates the number of bits to skip over in the outline (default is 1)  \nReturns:\na list of points outlining the first connected component encountered, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[tuple(int, int)]     Note See connected_component() for details on how a connected component is calculated.  \n   convolve() \n Returns the convolution of this mask with another mask convolve(othermask) -> Mask convolve(othermask, outputmask=None, offset=(0, 0)) -> Mask  Convolve this mask with the given othermask.     \nParameters:\n\n \nothermask (Mask) -- mask to convolve this mask with \noutputmask (Mask or NoneType) -- (optional) mask for output (default is None) \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, (default is (0, 0))    \nReturns:\n\na Mask with the (i - offset[0], j - offset[1]) bit set, if shifting othermask (such that its bottom right corner is at (i, j)) causes it to overlap with this mask If an outputmask is specified, the output is drawn onto it and it is returned. Otherwise a mask of size (MAX(0, width + othermask's\nwidth - 1), MAX(0, height + othermask's height - 1)) is created and returned.   \nReturn type:\n\nMask     \n   connected_component() \n Returns a mask containing a connected component connected_component() -> Mask connected_component((x, y)) -> Mask  A connected component is a group (1 or more) of connected set bits (orthogonally and diagonally). The SAUF algorithm, which checks 8 point connectivity, is used to find a connected component in the mask. By default this method will return a Mask containing the largest connected component in the mask. Optionally, a bit coordinate can be specified and the connected component containing it will be returned. If the bit at the given location is not set, the returned Mask will be empty (no bits set).     \nParameters:\n\npos (tuple(int, int) or list[int, int]) -- (optional) selects the connected component that contains the bit at this position  \nReturns:\na Mask object (same size as this mask) with the largest connected component from this mask, if this mask has no bits set then an empty mask will be returnedIf the pos parameter is provided then the mask returned will have the connected component that contains this position. An empty mask will be returned if the pos parameter selects an unset bit.   \nReturn type:\nMask  \nRaises:\n\nIndexError -- if the optional pos parameter is outside of the mask's bounds    \n   connected_components() \n Returns a list of masks of connected components connected_components() -> [Mask, ...] connected_components(min=0) -> [Mask, ...]  Provides a list containing a Mask object for each connected component.     \nParameters:\n\nmin (int) -- (optional) indicates the minimum number of bits (to filter out noise) per connected component (default is 0, which equates to no minimum and is equivalent to setting it to 1, as a connected component must have at least 1 bit set)  \nReturns:\na list containing a Mask object for each connected component, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[Mask]     Note See connected_component() for details on how a connected component is calculated.  \n   get_bounding_rects() \n Returns a list of bounding rects of connected components get_bounding_rects() -> [Rect, ...]  Provides a list containing a bounding rect for each connected component.     \nReturns:\na list containing a bounding rect for each connected component, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[Rect]     Note See connected_component() for details on how a connected component is calculated.  \n   to_surface() \n Returns a surface with the mask drawn on it to_surface() -> Surface to_surface(surface=None, setsurface=None, unsetsurface=None, setcolor=(255, 255, 255, 255), unsetcolor=(0, 0, 0, 255), dest=(0, 0)) -> Surface  Draws this mask on the given surface. Set bits (bits set to 1) and unset bits (bits set to 0) can be drawn onto a surface.     \nParameters:\n\n \nsurface (Surface or None) -- (optional) Surface to draw mask onto, if no surface is provided one will be created (default is None, which will cause a surface with the parameters Surface(size=mask.get_size(), flags=SRCALPHA, depth=32) to be created, drawn on, and returned) \nsetsurface (Surface or None) -- (optional) use this surface's color values to draw set bits (default is None), if this surface is smaller than the mask any bits outside its bounds will use the setcolor value \nunsetsurface (Surface or None) -- (optional) use this surface's color values to draw unset bits (default is None), if this surface is smaller than the mask any bits outside its bounds will use the unsetcolor value \nsetcolor (Color or str or int or tuple(int, int, int, [int]) or list(int, int, int, [int]) or None) -- (optional) color to draw set bits (default is (255, 255, 255, 255), white), use None to skip drawing the set bits, the setsurface parameter (if set) will takes precedence over this parameter \nunsetcolor (Color or str or int or tuple(int, int, int, [int]) or list(int, int, int, [int]) or None) -- (optional) color to draw unset bits (default is (0, 0, 0, 255), black), use None to skip drawing the unset bits, the unsetsurface parameter (if set) will takes precedence over this parameter \ndest (Rect or tuple(int, int) or list(int, int) or Vector2(int, int)) -- (optional) surface destination of where to position the topleft corner of the mask being drawn (default is (0, 0)), if a Rect is used as the dest parameter, its x and y attributes will be used as the destination, NOTE1: rects with a negative width or height value will not be normalized before using their x and y values, NOTE2: this destination value is only used to position the mask on the surface, it does not offset the setsurface and unsetsurface from the mask, they are always aligned with the mask (i.e. position (0, 0) on the mask always corresponds to position (0, 0) on the setsurface and unsetsurface)    \nReturns:\n\nthe surface parameter (or a newly created surface if no surface parameter was provided) with this mask drawn on it   \nReturn type:\n\nSurface   \nRaises:\n\nValueError -- if the setsurface parameter or unsetsurface parameter does not have the same format (bytesize/bitsize/alpha) as the surface parameter      Note To skip drawing the set bits, both setsurface and setcolor must be None. The setsurface parameter defaults to None, but setcolor defaults to a color value and therefore must be set to None.   Note To skip drawing the unset bits, both unsetsurface and unsetcolor must be None. The unsetsurface parameter defaults to None, but unsetcolor defaults to a color value and therefore must be set to None.   New in pygame 2.0.0.  \n \n"}, {"name": "mask.Mask.angle", "path": "ref/mask#pygame.mask.Mask.angle", "type": "pygame.mask", "text": "  angle() \n Returns the orientation of the set bits angle() -> theta  Finds the approximate orientation (from -90 to 90 degrees) of the set bits in the mask. This works best if performed on a mask with only one connected component.     \nReturns:\nthe orientation of the set bits in the mask, it will return 0.0 if the mask has no bits set  \nReturn type:\nfloat     Note See connected_component() for details on how a connected component is calculated.  \n"}, {"name": "mask.Mask.centroid", "path": "ref/mask#pygame.mask.Mask.centroid", "type": "pygame.mask", "text": "  centroid() \n Returns the centroid of the set bits centroid() -> (x, y)  Finds the centroid (the center mass of the set bits) for this mask.     \nReturns:\na coordinate tuple indicating the centroid of the mask, it will return (0, 0) if the mask has no bits set  \nReturn type:\ntuple(int, int)    \n"}, {"name": "mask.Mask.clear", "path": "ref/mask#pygame.mask.Mask.clear", "type": "pygame.mask", "text": "  clear() \n Sets all bits to 0 clear() -> None  Sets all bits in the mask to 0.     \nReturns:\nNone  \nReturn type:\nNoneType    \n"}, {"name": "mask.Mask.connected_component", "path": "ref/mask#pygame.mask.Mask.connected_component", "type": "pygame.mask", "text": "  connected_component() \n Returns a mask containing a connected component connected_component() -> Mask connected_component((x, y)) -> Mask  A connected component is a group (1 or more) of connected set bits (orthogonally and diagonally). The SAUF algorithm, which checks 8 point connectivity, is used to find a connected component in the mask. By default this method will return a Mask containing the largest connected component in the mask. Optionally, a bit coordinate can be specified and the connected component containing it will be returned. If the bit at the given location is not set, the returned Mask will be empty (no bits set).     \nParameters:\n\npos (tuple(int, int) or list[int, int]) -- (optional) selects the connected component that contains the bit at this position  \nReturns:\na Mask object (same size as this mask) with the largest connected component from this mask, if this mask has no bits set then an empty mask will be returnedIf the pos parameter is provided then the mask returned will have the connected component that contains this position. An empty mask will be returned if the pos parameter selects an unset bit.   \nReturn type:\nMask  \nRaises:\n\nIndexError -- if the optional pos parameter is outside of the mask's bounds    \n"}, {"name": "mask.Mask.connected_components", "path": "ref/mask#pygame.mask.Mask.connected_components", "type": "pygame.mask", "text": "  connected_components() \n Returns a list of masks of connected components connected_components() -> [Mask, ...] connected_components(min=0) -> [Mask, ...]  Provides a list containing a Mask object for each connected component.     \nParameters:\n\nmin (int) -- (optional) indicates the minimum number of bits (to filter out noise) per connected component (default is 0, which equates to no minimum and is equivalent to setting it to 1, as a connected component must have at least 1 bit set)  \nReturns:\na list containing a Mask object for each connected component, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[Mask]     Note See connected_component() for details on how a connected component is calculated.  \n"}, {"name": "mask.Mask.convolve", "path": "ref/mask#pygame.mask.Mask.convolve", "type": "pygame.mask", "text": "  convolve() \n Returns the convolution of this mask with another mask convolve(othermask) -> Mask convolve(othermask, outputmask=None, offset=(0, 0)) -> Mask  Convolve this mask with the given othermask.     \nParameters:\n\n \nothermask (Mask) -- mask to convolve this mask with \noutputmask (Mask or NoneType) -- (optional) mask for output (default is None) \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, (default is (0, 0))    \nReturns:\n\na Mask with the (i - offset[0], j - offset[1]) bit set, if shifting othermask (such that its bottom right corner is at (i, j)) causes it to overlap with this mask If an outputmask is specified, the output is drawn onto it and it is returned. Otherwise a mask of size (MAX(0, width + othermask's\nwidth - 1), MAX(0, height + othermask's height - 1)) is created and returned.   \nReturn type:\n\nMask     \n"}, {"name": "mask.Mask.copy", "path": "ref/mask#pygame.mask.Mask.copy", "type": "pygame.mask", "text": "  copy() \n Returns a new copy of the mask copy() -> Mask      \nReturns:\na new copy of this mask, the new mask will have the same width, height, and set/unset bits as the original  \nReturn type:\nMask     Note If a mask subclass needs to copy any instance specific attributes then it should override the __copy__() method. The overridden __copy__() method needs to call super().__copy__() and then copy the required data as in the following example code. class SubMask(pygame.mask.Mask):\n    def __copy__(self):\n        new_mask = super().__copy__()\n        # Do any SubMask attribute copying here.\n        return new_mask   New in pygame 2.0.0.  \n"}, {"name": "mask.Mask.count", "path": "ref/mask#pygame.mask.Mask.count", "type": "pygame.mask", "text": "  count() \n Returns the number of set bits count() -> bits      \nReturns:\nthe number of set bits in the mask  \nReturn type:\nint    \n"}, {"name": "mask.Mask.draw", "path": "ref/mask#pygame.mask.Mask.draw", "type": "pygame.mask", "text": "  draw() \n Draws a mask onto another draw(othermask, offset) -> None  Performs a bitwise OR, drawing othermask onto this mask.     \nParameters:\n\n \nothermask (Mask) -- the mask to draw onto this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "mask.Mask.erase", "path": "ref/mask#pygame.mask.Mask.erase", "type": "pygame.mask", "text": "  erase() \n Erases a mask from another erase(othermask, offset) -> None  Erases (clears) all bits set in othermask from this mask.     \nParameters:\n\n \nothermask (Mask) -- the mask to erase from this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n"}, {"name": "mask.Mask.fill", "path": "ref/mask#pygame.mask.Mask.fill", "type": "pygame.mask", "text": "  fill() \n Sets all bits to 1 fill() -> None  Sets all bits in the mask to 1.     \nReturns:\nNone  \nReturn type:\nNoneType    \n"}, {"name": "mask.Mask.get_at", "path": "ref/mask#pygame.mask.Mask.get_at", "type": "pygame.mask", "text": "  get_at() \n Gets the bit at the given position get_at((x, y)) -> int      \nParameters:\n\npos (tuple(int, int) or list[int, int]) -- the position of the bit to get  \nReturns:\n1 if the bit is set, 0 if the bit is not set  \nReturn type:\nint  \nRaises:\n\nIndexError -- if the position is outside of the mask's bounds    \n"}, {"name": "mask.Mask.get_bounding_rects", "path": "ref/mask#pygame.mask.Mask.get_bounding_rects", "type": "pygame.mask", "text": "  get_bounding_rects() \n Returns a list of bounding rects of connected components get_bounding_rects() -> [Rect, ...]  Provides a list containing a bounding rect for each connected component.     \nReturns:\na list containing a bounding rect for each connected component, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[Rect]     Note See connected_component() for details on how a connected component is calculated.  \n"}, {"name": "mask.Mask.get_rect", "path": "ref/mask#pygame.mask.Mask.get_rect", "type": "pygame.mask", "text": "  get_rect() \n Returns a Rect based on the size of the mask get_rect(**kwargs) -> Rect  Returns a new pygame.Rect() object based on the size of this mask. The rect's default position will be (0, 0) and its default width and height will be the same as this mask's. The rect's attributes can be altered via pygame.Rect() attribute keyword arguments/values passed into this method. As an example, a_mask.get_rect(center=(10, 5)) would create a pygame.Rect() based on the mask's size centered at the given position.     \nParameters:\n\nkwargs (dict) -- pygame.Rect() attribute keyword arguments/values that will be applied to the rect  \nReturns:\na new pygame.Rect() object based on the size of this mask with any pygame.Rect() attribute keyword arguments/values applied to it  \nReturn type:\nRect     New in pygame 2.0.0.  \n"}, {"name": "mask.Mask.get_size", "path": "ref/mask#pygame.mask.Mask.get_size", "type": "pygame.mask", "text": "  get_size() \n Returns the size of the mask get_size() -> (width, height)      \nReturns:\nthe size of the mask, (width, height)  \nReturn type:\ntuple(int, int)    \n"}, {"name": "mask.Mask.invert", "path": "ref/mask#pygame.mask.Mask.invert", "type": "pygame.mask", "text": "  invert() \n Flips all the bits invert() -> None  Flips all of the bits in the mask. All the set bits are cleared to 0 and all the unset bits are set to 1.     \nReturns:\nNone  \nReturn type:\nNoneType    \n"}, {"name": "mask.Mask.outline", "path": "ref/mask#pygame.mask.Mask.outline", "type": "pygame.mask", "text": "  outline() \n Returns a list of points outlining an object outline() -> [(x, y), ...] outline(every=1) -> [(x, y), ...]  Returns a list of points of the outline of the first connected component encountered in the mask. To find a connected component, the mask is searched per row (left to right) starting in the top left corner. The every optional parameter skips set bits in the outline. For example, setting it to 10 would return a list of every 10th set bit in the outline.     \nParameters:\n\nevery (int) -- (optional) indicates the number of bits to skip over in the outline (default is 1)  \nReturns:\na list of points outlining the first connected component encountered, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[tuple(int, int)]     Note See connected_component() for details on how a connected component is calculated.  \n"}, {"name": "mask.Mask.overlap", "path": "ref/mask#pygame.mask.Mask.overlap", "type": "pygame.mask", "text": "  overlap() \n Returns the point of intersection overlap(othermask, offset) -> (x, y) overlap(othermask, offset) -> None  Returns the first point of intersection encountered between this mask and othermask. A point of intersection is 2 overlapping set bits. The current algorithm searches the overlapping area in sizeof(unsigned long int) * CHAR_BIT bit wide column blocks (the value of sizeof(unsigned long int) * CHAR_BIT is platform dependent, for clarity it will be referred to as W). Starting at the top left corner it checks bits 0 to W - 1 of the first row ((0, 0) to (W - 1, 0)) then continues to the next row ((0, 1) to (W - 1, 1)). Once this entire column block is checked, it continues to the next one (W to 2 * W - 1). This is repeated until it finds a point of intersection or the entire overlapping area is checked.     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\npoint of intersection or None if no intersection   \nReturn type:\n\ntuple(int, int) or NoneType     \n"}, {"name": "mask.Mask.overlap_area", "path": "ref/mask#pygame.mask.Mask.overlap_area", "type": "pygame.mask", "text": "  overlap_area() \n Returns the number of overlapping set bits overlap_area(othermask, offset) -> numbits  Returns the number of overlapping set bits between between this mask and othermask. This can be useful for collision detection. An approximate collision normal can be found by calculating the gradient of the overlapping area through the finite difference. dx = mask.overlap_area(othermask, (x + 1, y)) - mask.overlap_area(othermask, (x - 1, y))\ndy = mask.overlap_area(othermask, (x, y + 1)) - mask.overlap_area(othermask, (x, y - 1))     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nthe number of overlapping set bits   \nReturn type:\n\nint     \n"}, {"name": "mask.Mask.overlap_mask", "path": "ref/mask#pygame.mask.Mask.overlap_mask", "type": "pygame.mask", "text": "  overlap_mask() \n Returns a mask of the overlapping set bits overlap_mask(othermask, offset) -> Mask  Returns a Mask, the same size as this mask, containing the overlapping set bits between this mask and othermask.     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\na newly created Mask with the overlapping bits set   \nReturn type:\n\nMask     \n"}, {"name": "mask.Mask.scale", "path": "ref/mask#pygame.mask.Mask.scale", "type": "pygame.mask", "text": "  scale() \n Resizes a mask scale((width, height)) -> Mask  Creates a new Mask of the requested size with its bits scaled from this mask.     \nParameters:\n\nsize (tuple(int, int) or list[int, int]) -- the width and height (size) of the mask to create  \nReturns:\na new Mask object with its bits scaled from this mask  \nReturn type:\nMask  \nRaises:\n\nValueError -- if width < 0 or height < 0\n    \n"}, {"name": "mask.Mask.set_at", "path": "ref/mask#pygame.mask.Mask.set_at", "type": "pygame.mask", "text": "  set_at() \n Sets the bit at the given position set_at((x, y)) -> None set_at((x, y), value=1) -> None      \nParameters:\n\n \npos (tuple(int, int) or list[int, int]) -- the position of the bit to set \nvalue (int) -- any nonzero int will set the bit to 1, 0 will set the bit to 0 (default is 1)    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\nIndexError -- if the position is outside of the mask's bounds     \n"}, {"name": "mask.Mask.to_surface", "path": "ref/mask#pygame.mask.Mask.to_surface", "type": "pygame.mask", "text": "  to_surface() \n Returns a surface with the mask drawn on it to_surface() -> Surface to_surface(surface=None, setsurface=None, unsetsurface=None, setcolor=(255, 255, 255, 255), unsetcolor=(0, 0, 0, 255), dest=(0, 0)) -> Surface  Draws this mask on the given surface. Set bits (bits set to 1) and unset bits (bits set to 0) can be drawn onto a surface.     \nParameters:\n\n \nsurface (Surface or None) -- (optional) Surface to draw mask onto, if no surface is provided one will be created (default is None, which will cause a surface with the parameters Surface(size=mask.get_size(), flags=SRCALPHA, depth=32) to be created, drawn on, and returned) \nsetsurface (Surface or None) -- (optional) use this surface's color values to draw set bits (default is None), if this surface is smaller than the mask any bits outside its bounds will use the setcolor value \nunsetsurface (Surface or None) -- (optional) use this surface's color values to draw unset bits (default is None), if this surface is smaller than the mask any bits outside its bounds will use the unsetcolor value \nsetcolor (Color or str or int or tuple(int, int, int, [int]) or list(int, int, int, [int]) or None) -- (optional) color to draw set bits (default is (255, 255, 255, 255), white), use None to skip drawing the set bits, the setsurface parameter (if set) will takes precedence over this parameter \nunsetcolor (Color or str or int or tuple(int, int, int, [int]) or list(int, int, int, [int]) or None) -- (optional) color to draw unset bits (default is (0, 0, 0, 255), black), use None to skip drawing the unset bits, the unsetsurface parameter (if set) will takes precedence over this parameter \ndest (Rect or tuple(int, int) or list(int, int) or Vector2(int, int)) -- (optional) surface destination of where to position the topleft corner of the mask being drawn (default is (0, 0)), if a Rect is used as the dest parameter, its x and y attributes will be used as the destination, NOTE1: rects with a negative width or height value will not be normalized before using their x and y values, NOTE2: this destination value is only used to position the mask on the surface, it does not offset the setsurface and unsetsurface from the mask, they are always aligned with the mask (i.e. position (0, 0) on the mask always corresponds to position (0, 0) on the setsurface and unsetsurface)    \nReturns:\n\nthe surface parameter (or a newly created surface if no surface parameter was provided) with this mask drawn on it   \nReturn type:\n\nSurface   \nRaises:\n\nValueError -- if the setsurface parameter or unsetsurface parameter does not have the same format (bytesize/bitsize/alpha) as the surface parameter      Note To skip drawing the set bits, both setsurface and setcolor must be None. The setsurface parameter defaults to None, but setcolor defaults to a color value and therefore must be set to None.   Note To skip drawing the unset bits, both unsetsurface and unsetcolor must be None. The unsetsurface parameter defaults to None, but unsetcolor defaults to a color value and therefore must be set to None.   New in pygame 2.0.0.  \n"}, {"name": "math", "path": "ref/math", "type": "pygame.math", "text": " pygame.math\n  \n pygame module for vector classes  The pygame math module currently provides Vector classes in two and three dimensions, Vector2 and Vector3 respectively. They support the following numerical operations: vec+vec, vec-vec, vec*number, number*vec, vec/number, vec//number, vec+=vec, vec-=vec, vec*=number, vec/=number, vec//=number. All these operations will be performed elementwise. In addition vec*vec will perform a scalar-product (a.k.a. dot-product). If you want to multiply every element from vector v with every element from vector w you can use the elementwise method: v.elementwise() * w The coordinates of a vector can be retrieved or set using attributes or subscripts v = pygame.Vector3()\n\nv.x = 5\nv[1] = 2 * v.x\nprint(v[1]) # 10\n\nv.x == v[0]\nv.y == v[1]\nv.z == v[2] Multiple coordinates can be set using slices or swizzling v = pygame.Vector2()\nv.xy = 1, 2\nv[:] = 1, 2  New in pygame 1.9.2pre.   Changed in pygame 1.9.4: Removed experimental notice.   Changed in pygame 1.9.4: Allow scalar construction like GLSL Vector2(2) == Vector2(2.0, 2.0)   Changed in pygame 1.9.4: pygame.math required import. More convenient pygame.Vector2 and pygame.Vector3.    pygame.math.Vector2 \n a 2-Dimensional Vector Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2  Some general information about the Vector2 class.   dot() \n calculates the dot- or scalar-product with the other vector dot(Vector2) -> float  \n   cross() \n calculates the cross- or vector-product cross(Vector2) -> Vector2  calculates the third component of the cross-product. \n   magnitude() \n returns the Euclidean magnitude of the vector. magnitude() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2) \n   magnitude_squared() \n returns the squared magnitude of the vector. magnitude_squared() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude_squared() == vec.x**2 + vec.y**2. This is faster than vec.magnitude() because it avoids the square root. \n   length() \n returns the Euclidean length of the vector. length() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2) \n   length_squared() \n returns the squared Euclidean length of the vector. length_squared() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2. This is faster than vec.length() because it avoids the square root. \n   normalize() \n returns a vector with the same direction but length 1. normalize() -> Vector2  Returns a new vector that has length equal to 1 and the same direction as self. \n   normalize_ip() \n normalizes the vector in place so that its length is 1. normalize_ip() -> None  Normalizes the vector so that it has length equal to 1. The direction of the vector is not changed. \n   is_normalized() \n tests if the vector is normalized i.e. has length == 1. is_normalized() -> Bool  Returns True if the vector has length equal to 1. Otherwise it returns False. \n   scale_to_length() \n scales the vector to a given length. scale_to_length(float) -> None  Scales the vector so that it has the given length. The direction of the vector is not changed. You can also scale to length 0. If the vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. \n   reflect() \n returns a vector reflected of a given normal. reflect(Vector2) -> Vector2  Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. \n   reflect_ip() \n reflect the vector of a given normal in place. reflect_ip(Vector2) -> None  Changes the direction of self as if it would have been reflected of a surface with the given surface normal. \n   distance_to() \n calculates the Euclidean distance to a given vector. distance_to(Vector2) -> float  \n   distance_squared_to() \n calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector2) -> float  \n   lerp() \n returns a linear interpolation to the given vector. lerp(Vector2, float) -> Vector2  Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned. \n   slerp() \n returns a spherical interpolation to the given vector. slerp(Vector2, float) -> Vector2  Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. \n   elementwise() \n The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy  Applies the following operation to each element of the vector. \n   rotate() \n rotates a vector by a given angle in degrees. rotate(angle) -> Vector2  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees. \n   rotate_rad() \n rotates a vector by a given angle in radians. rotate_rad(angle) -> Vector2  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_ip() \n rotates the vector by a given angle in degrees in place. rotate_ip(angle) -> None  Rotates the vector counterclockwise by the given angle in degrees. The length of the vector is not changed. \n   rotate_ip_rad() \n rotates the vector by a given angle in radians in place. rotate_ip_rad(angle) -> None  Rotates the vector counterclockwise by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   angle_to() \n calculates the angle to a given vector in degrees. angle_to(Vector2) -> float  Returns the angle between self and the given vector. \n   as_polar() \n returns a tuple with radial distance and azimuthal angle. as_polar() -> (r, phi)  Returns a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. \n   from_polar() \n Sets x and y from a polar coordinates tuple. from_polar((r, phi)) -> None  Sets x and y from a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. \n   update() \n Sets the coordinates of the vector. update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None  Sets coordinates x and y in place.  New in pygame 1.9.5.  \n \n   pygame.math.Vector3 \n a 3-Dimensional Vector Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3  Some general information about the Vector3 class.   dot() \n calculates the dot- or scalar-product with the other vector dot(Vector3) -> float  \n   cross() \n calculates the cross- or vector-product cross(Vector3) -> Vector3  calculates the cross-product. \n   magnitude() \n returns the Euclidean magnitude of the vector. magnitude() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2) \n   magnitude_squared() \n returns the squared Euclidean magnitude of the vector. magnitude_squared() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude_squared() == vec.x**2 + vec.y**2 + vec.z**2. This is faster than vec.magnitude() because it avoids the square root. \n   length() \n returns the Euclidean length of the vector. length() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2) \n   length_squared() \n returns the squared Euclidean length of the vector. length_squared() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2 + vec.z**2. This is faster than vec.length() because it avoids the square root. \n   normalize() \n returns a vector with the same direction but length 1. normalize() -> Vector3  Returns a new vector that has length equal to 1 and the same direction as self. \n   normalize_ip() \n normalizes the vector in place so that its length is 1. normalize_ip() -> None  Normalizes the vector so that it has length equal to 1. The direction of the vector is not changed. \n   is_normalized() \n tests if the vector is normalized i.e. has length == 1. is_normalized() -> Bool  Returns True if the vector has length equal to 1. Otherwise it returns False. \n   scale_to_length() \n scales the vector to a given length. scale_to_length(float) -> None  Scales the vector so that it has the given length. The direction of the vector is not changed. You can also scale to length 0. If the vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. \n   reflect() \n returns a vector reflected of a given normal. reflect(Vector3) -> Vector3  Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. \n   reflect_ip() \n reflect the vector of a given normal in place. reflect_ip(Vector3) -> None  Changes the direction of self as if it would have been reflected of a surface with the given surface normal. \n   distance_to() \n calculates the Euclidean distance to a given vector. distance_to(Vector3) -> float  \n   distance_squared_to() \n calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector3) -> float  \n   lerp() \n returns a linear interpolation to the given vector. lerp(Vector3, float) -> Vector3  Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self an other the result is going to be. It must be a value between 0 and 1, where 0 means self and 1 means other will be returned. \n   slerp() \n returns a spherical interpolation to the given vector. slerp(Vector3, float) -> Vector3  Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. \n   elementwise() \n The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy  Applies the following operation to each element of the vector. \n   rotate() \n rotates a vector by a given angle in degrees. rotate(angle, Vector3) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees around the given axis. \n   rotate_rad() \n rotates a vector by a given angle in radians. rotate_rad(angle, Vector3) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians around the given axis.  New in pygame 2.0.0.  \n   rotate_ip() \n rotates the vector by a given angle in degrees in place. rotate_ip(angle, Vector3) -> None  Rotates the vector counterclockwise around the given axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_ip_rad() \n rotates the vector by a given angle in radians in place. rotate_ip_rad(angle, Vector3) -> None  Rotates the vector counterclockwise around the given axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   rotate_x() \n rotates a vector around the x-axis by the angle in degrees. rotate_x(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in degrees. \n   rotate_x_rad() \n rotates a vector around the x-axis by the angle in radians. rotate_x_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_x_ip() \n rotates the vector around the x-axis by the angle in degrees in place. rotate_x_ip(angle) -> None  Rotates the vector counterclockwise around the x-axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_x_ip_rad() \n rotates the vector around the x-axis by the angle in radians in place. rotate_x_ip_rad(angle) -> None  Rotates the vector counterclockwise around the x-axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   rotate_y() \n rotates a vector around the y-axis by the angle in degrees. rotate_y(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in degrees. \n   rotate_y_rad() \n rotates a vector around the y-axis by the angle in radians. rotate_y_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_y_ip() \n rotates the vector around the y-axis by the angle in degrees in place. rotate_y_ip(angle) -> None  Rotates the vector counterclockwise around the y-axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_y_ip_rad() \n rotates the vector around the y-axis by the angle in radians in place. rotate_y_ip_rad(angle) -> None  Rotates the vector counterclockwise around the y-axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   rotate_z() \n rotates a vector around the z-axis by the angle in degrees. rotate_z(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in degrees. \n   rotate_z_rad() \n rotates a vector around the z-axis by the angle in radians. rotate_z_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_z_ip() \n rotates the vector around the z-axis by the angle in degrees in place. rotate_z_ip(angle) -> None  Rotates the vector counterclockwise around the z-axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_z_ip_rad() \n rotates the vector around the z-axis by the angle in radians in place. rotate_z_ip_rad(angle) -> None  Rotates the vector counterclockwise around the z-axis by the given angle in radians. The length of the vector is not changed. \n   angle_to() \n calculates the angle to a given vector in degrees. angle_to(Vector3) -> float  Returns the angle between self and the given vector. \n   as_spherical() \n returns a tuple with radial distance, inclination and azimuthal angle. as_spherical() -> (r, theta, phi)  Returns a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle. \n   from_spherical() \n Sets x, y and z from a spherical coordinates 3-tuple. from_spherical((r, theta, phi)) -> None  Sets x, y and z from a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle. \n   update() \n Sets the coordinates of the vector. update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None  Sets coordinates x, y, and z in place.  New in pygame 1.9.5.  \n \n   pygame.math.enable_swizzling() \n globally enables swizzling for vectors. enable_swizzling() -> None  DEPRECATED: Not needed anymore. Will be removed in a later version. Enables swizzling for all vectors until disable_swizzling() is called. By default swizzling is disabled. Lets you get or set multiple coordinates as one attribute, eg vec.xyz = 1, 2, 3. \n   pygame.math.disable_swizzling() \n globally disables swizzling for vectors. disable_swizzling() -> None  DEPRECATED: Not needed anymore. Will be removed in a later version. Disables swizzling for all vectors until enable_swizzling() is called. By default swizzling is disabled. \n \n \n"}, {"name": "math.disable_swizzling", "path": "ref/math#pygame.math.disable_swizzling", "type": "pygame.math", "text": "  pygame.math.disable_swizzling() \n globally disables swizzling for vectors. disable_swizzling() -> None  DEPRECATED: Not needed anymore. Will be removed in a later version. Disables swizzling for all vectors until enable_swizzling() is called. By default swizzling is disabled. \n"}, {"name": "math.enable_swizzling", "path": "ref/math#pygame.math.enable_swizzling", "type": "pygame.math", "text": "  pygame.math.enable_swizzling() \n globally enables swizzling for vectors. enable_swizzling() -> None  DEPRECATED: Not needed anymore. Will be removed in a later version. Enables swizzling for all vectors until disable_swizzling() is called. By default swizzling is disabled. Lets you get or set multiple coordinates as one attribute, eg vec.xyz = 1, 2, 3. \n"}, {"name": "math.Vector2", "path": "ref/math#pygame.math.Vector2", "type": "pygame.math", "text": "  pygame.math.Vector2 \n a 2-Dimensional Vector Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2  Some general information about the Vector2 class.   dot() \n calculates the dot- or scalar-product with the other vector dot(Vector2) -> float  \n   cross() \n calculates the cross- or vector-product cross(Vector2) -> Vector2  calculates the third component of the cross-product. \n   magnitude() \n returns the Euclidean magnitude of the vector. magnitude() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2) \n   magnitude_squared() \n returns the squared magnitude of the vector. magnitude_squared() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude_squared() == vec.x**2 + vec.y**2. This is faster than vec.magnitude() because it avoids the square root. \n   length() \n returns the Euclidean length of the vector. length() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2) \n   length_squared() \n returns the squared Euclidean length of the vector. length_squared() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2. This is faster than vec.length() because it avoids the square root. \n   normalize() \n returns a vector with the same direction but length 1. normalize() -> Vector2  Returns a new vector that has length equal to 1 and the same direction as self. \n   normalize_ip() \n normalizes the vector in place so that its length is 1. normalize_ip() -> None  Normalizes the vector so that it has length equal to 1. The direction of the vector is not changed. \n   is_normalized() \n tests if the vector is normalized i.e. has length == 1. is_normalized() -> Bool  Returns True if the vector has length equal to 1. Otherwise it returns False. \n   scale_to_length() \n scales the vector to a given length. scale_to_length(float) -> None  Scales the vector so that it has the given length. The direction of the vector is not changed. You can also scale to length 0. If the vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. \n   reflect() \n returns a vector reflected of a given normal. reflect(Vector2) -> Vector2  Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. \n   reflect_ip() \n reflect the vector of a given normal in place. reflect_ip(Vector2) -> None  Changes the direction of self as if it would have been reflected of a surface with the given surface normal. \n   distance_to() \n calculates the Euclidean distance to a given vector. distance_to(Vector2) -> float  \n   distance_squared_to() \n calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector2) -> float  \n   lerp() \n returns a linear interpolation to the given vector. lerp(Vector2, float) -> Vector2  Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned. \n   slerp() \n returns a spherical interpolation to the given vector. slerp(Vector2, float) -> Vector2  Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. \n   elementwise() \n The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy  Applies the following operation to each element of the vector. \n   rotate() \n rotates a vector by a given angle in degrees. rotate(angle) -> Vector2  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees. \n   rotate_rad() \n rotates a vector by a given angle in radians. rotate_rad(angle) -> Vector2  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_ip() \n rotates the vector by a given angle in degrees in place. rotate_ip(angle) -> None  Rotates the vector counterclockwise by the given angle in degrees. The length of the vector is not changed. \n   rotate_ip_rad() \n rotates the vector by a given angle in radians in place. rotate_ip_rad(angle) -> None  Rotates the vector counterclockwise by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   angle_to() \n calculates the angle to a given vector in degrees. angle_to(Vector2) -> float  Returns the angle between self and the given vector. \n   as_polar() \n returns a tuple with radial distance and azimuthal angle. as_polar() -> (r, phi)  Returns a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. \n   from_polar() \n Sets x and y from a polar coordinates tuple. from_polar((r, phi)) -> None  Sets x and y from a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. \n   update() \n Sets the coordinates of the vector. update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None  Sets coordinates x and y in place.  New in pygame 1.9.5.  \n \n"}, {"name": "math.Vector2.angle_to", "path": "ref/math#pygame.math.Vector2.angle_to", "type": "pygame.math", "text": "  angle_to() \n calculates the angle to a given vector in degrees. angle_to(Vector2) -> float  Returns the angle between self and the given vector. \n"}, {"name": "math.Vector2.as_polar", "path": "ref/math#pygame.math.Vector2.as_polar", "type": "pygame.math", "text": "  as_polar() \n returns a tuple with radial distance and azimuthal angle. as_polar() -> (r, phi)  Returns a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. \n"}, {"name": "math.Vector2.cross", "path": "ref/math#pygame.math.Vector2.cross", "type": "pygame.math", "text": "  cross() \n calculates the cross- or vector-product cross(Vector2) -> Vector2  calculates the third component of the cross-product. \n"}, {"name": "math.Vector2.distance_squared_to", "path": "ref/math#pygame.math.Vector2.distance_squared_to", "type": "pygame.math", "text": "  distance_squared_to() \n calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector2) -> float  \n"}, {"name": "math.Vector2.distance_to", "path": "ref/math#pygame.math.Vector2.distance_to", "type": "pygame.math", "text": "  distance_to() \n calculates the Euclidean distance to a given vector. distance_to(Vector2) -> float  \n"}, {"name": "math.Vector2.dot", "path": "ref/math#pygame.math.Vector2.dot", "type": "pygame.math", "text": "  dot() \n calculates the dot- or scalar-product with the other vector dot(Vector2) -> float  \n"}, {"name": "math.Vector2.elementwise", "path": "ref/math#pygame.math.Vector2.elementwise", "type": "pygame.math", "text": "  elementwise() \n The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy  Applies the following operation to each element of the vector. \n"}, {"name": "math.Vector2.from_polar", "path": "ref/math#pygame.math.Vector2.from_polar", "type": "pygame.math", "text": "  from_polar() \n Sets x and y from a polar coordinates tuple. from_polar((r, phi)) -> None  Sets x and y from a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. \n"}, {"name": "math.Vector2.is_normalized", "path": "ref/math#pygame.math.Vector2.is_normalized", "type": "pygame.math", "text": "  is_normalized() \n tests if the vector is normalized i.e. has length == 1. is_normalized() -> Bool  Returns True if the vector has length equal to 1. Otherwise it returns False. \n"}, {"name": "math.Vector2.length", "path": "ref/math#pygame.math.Vector2.length", "type": "pygame.math", "text": "  length() \n returns the Euclidean length of the vector. length() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2) \n"}, {"name": "math.Vector2.length_squared", "path": "ref/math#pygame.math.Vector2.length_squared", "type": "pygame.math", "text": "  length_squared() \n returns the squared Euclidean length of the vector. length_squared() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2. This is faster than vec.length() because it avoids the square root. \n"}, {"name": "math.Vector2.lerp", "path": "ref/math#pygame.math.Vector2.lerp", "type": "pygame.math", "text": "  lerp() \n returns a linear interpolation to the given vector. lerp(Vector2, float) -> Vector2  Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned. \n"}, {"name": "math.Vector2.magnitude", "path": "ref/math#pygame.math.Vector2.magnitude", "type": "pygame.math", "text": "  magnitude() \n returns the Euclidean magnitude of the vector. magnitude() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2) \n"}, {"name": "math.Vector2.magnitude_squared", "path": "ref/math#pygame.math.Vector2.magnitude_squared", "type": "pygame.math", "text": "  magnitude_squared() \n returns the squared magnitude of the vector. magnitude_squared() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude_squared() == vec.x**2 + vec.y**2. This is faster than vec.magnitude() because it avoids the square root. \n"}, {"name": "math.Vector2.normalize", "path": "ref/math#pygame.math.Vector2.normalize", "type": "pygame.math", "text": "  normalize() \n returns a vector with the same direction but length 1. normalize() -> Vector2  Returns a new vector that has length equal to 1 and the same direction as self. \n"}, {"name": "math.Vector2.normalize_ip", "path": "ref/math#pygame.math.Vector2.normalize_ip", "type": "pygame.math", "text": "  normalize_ip() \n normalizes the vector in place so that its length is 1. normalize_ip() -> None  Normalizes the vector so that it has length equal to 1. The direction of the vector is not changed. \n"}, {"name": "math.Vector2.reflect", "path": "ref/math#pygame.math.Vector2.reflect", "type": "pygame.math", "text": "  reflect() \n returns a vector reflected of a given normal. reflect(Vector2) -> Vector2  Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. \n"}, {"name": "math.Vector2.reflect_ip", "path": "ref/math#pygame.math.Vector2.reflect_ip", "type": "pygame.math", "text": "  reflect_ip() \n reflect the vector of a given normal in place. reflect_ip(Vector2) -> None  Changes the direction of self as if it would have been reflected of a surface with the given surface normal. \n"}, {"name": "math.Vector2.rotate", "path": "ref/math#pygame.math.Vector2.rotate", "type": "pygame.math", "text": "  rotate() \n rotates a vector by a given angle in degrees. rotate(angle) -> Vector2  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees. \n"}, {"name": "math.Vector2.rotate_ip", "path": "ref/math#pygame.math.Vector2.rotate_ip", "type": "pygame.math", "text": "  rotate_ip() \n rotates the vector by a given angle in degrees in place. rotate_ip(angle) -> None  Rotates the vector counterclockwise by the given angle in degrees. The length of the vector is not changed. \n"}, {"name": "math.Vector2.rotate_ip_rad", "path": "ref/math#pygame.math.Vector2.rotate_ip_rad", "type": "pygame.math", "text": "  rotate_ip_rad() \n rotates the vector by a given angle in radians in place. rotate_ip_rad(angle) -> None  Rotates the vector counterclockwise by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n"}, {"name": "math.Vector2.rotate_rad", "path": "ref/math#pygame.math.Vector2.rotate_rad", "type": "pygame.math", "text": "  rotate_rad() \n rotates a vector by a given angle in radians. rotate_rad(angle) -> Vector2  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians.  New in pygame 2.0.0.  \n"}, {"name": "math.Vector2.scale_to_length", "path": "ref/math#pygame.math.Vector2.scale_to_length", "type": "pygame.math", "text": "  scale_to_length() \n scales the vector to a given length. scale_to_length(float) -> None  Scales the vector so that it has the given length. The direction of the vector is not changed. You can also scale to length 0. If the vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. \n"}, {"name": "math.Vector2.slerp", "path": "ref/math#pygame.math.Vector2.slerp", "type": "pygame.math", "text": "  slerp() \n returns a spherical interpolation to the given vector. slerp(Vector2, float) -> Vector2  Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. \n"}, {"name": "math.Vector2.update", "path": "ref/math#pygame.math.Vector2.update", "type": "pygame.math", "text": "  update() \n Sets the coordinates of the vector. update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None  Sets coordinates x and y in place.  New in pygame 1.9.5.  \n"}, {"name": "math.Vector3", "path": "ref/math#pygame.math.Vector3", "type": "pygame.math", "text": "  pygame.math.Vector3 \n a 3-Dimensional Vector Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3  Some general information about the Vector3 class.   dot() \n calculates the dot- or scalar-product with the other vector dot(Vector3) -> float  \n   cross() \n calculates the cross- or vector-product cross(Vector3) -> Vector3  calculates the cross-product. \n   magnitude() \n returns the Euclidean magnitude of the vector. magnitude() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2) \n   magnitude_squared() \n returns the squared Euclidean magnitude of the vector. magnitude_squared() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude_squared() == vec.x**2 + vec.y**2 + vec.z**2. This is faster than vec.magnitude() because it avoids the square root. \n   length() \n returns the Euclidean length of the vector. length() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2) \n   length_squared() \n returns the squared Euclidean length of the vector. length_squared() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2 + vec.z**2. This is faster than vec.length() because it avoids the square root. \n   normalize() \n returns a vector with the same direction but length 1. normalize() -> Vector3  Returns a new vector that has length equal to 1 and the same direction as self. \n   normalize_ip() \n normalizes the vector in place so that its length is 1. normalize_ip() -> None  Normalizes the vector so that it has length equal to 1. The direction of the vector is not changed. \n   is_normalized() \n tests if the vector is normalized i.e. has length == 1. is_normalized() -> Bool  Returns True if the vector has length equal to 1. Otherwise it returns False. \n   scale_to_length() \n scales the vector to a given length. scale_to_length(float) -> None  Scales the vector so that it has the given length. The direction of the vector is not changed. You can also scale to length 0. If the vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. \n   reflect() \n returns a vector reflected of a given normal. reflect(Vector3) -> Vector3  Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. \n   reflect_ip() \n reflect the vector of a given normal in place. reflect_ip(Vector3) -> None  Changes the direction of self as if it would have been reflected of a surface with the given surface normal. \n   distance_to() \n calculates the Euclidean distance to a given vector. distance_to(Vector3) -> float  \n   distance_squared_to() \n calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector3) -> float  \n   lerp() \n returns a linear interpolation to the given vector. lerp(Vector3, float) -> Vector3  Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self an other the result is going to be. It must be a value between 0 and 1, where 0 means self and 1 means other will be returned. \n   slerp() \n returns a spherical interpolation to the given vector. slerp(Vector3, float) -> Vector3  Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. \n   elementwise() \n The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy  Applies the following operation to each element of the vector. \n   rotate() \n rotates a vector by a given angle in degrees. rotate(angle, Vector3) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees around the given axis. \n   rotate_rad() \n rotates a vector by a given angle in radians. rotate_rad(angle, Vector3) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians around the given axis.  New in pygame 2.0.0.  \n   rotate_ip() \n rotates the vector by a given angle in degrees in place. rotate_ip(angle, Vector3) -> None  Rotates the vector counterclockwise around the given axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_ip_rad() \n rotates the vector by a given angle in radians in place. rotate_ip_rad(angle, Vector3) -> None  Rotates the vector counterclockwise around the given axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   rotate_x() \n rotates a vector around the x-axis by the angle in degrees. rotate_x(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in degrees. \n   rotate_x_rad() \n rotates a vector around the x-axis by the angle in radians. rotate_x_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_x_ip() \n rotates the vector around the x-axis by the angle in degrees in place. rotate_x_ip(angle) -> None  Rotates the vector counterclockwise around the x-axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_x_ip_rad() \n rotates the vector around the x-axis by the angle in radians in place. rotate_x_ip_rad(angle) -> None  Rotates the vector counterclockwise around the x-axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   rotate_y() \n rotates a vector around the y-axis by the angle in degrees. rotate_y(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in degrees. \n   rotate_y_rad() \n rotates a vector around the y-axis by the angle in radians. rotate_y_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_y_ip() \n rotates the vector around the y-axis by the angle in degrees in place. rotate_y_ip(angle) -> None  Rotates the vector counterclockwise around the y-axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_y_ip_rad() \n rotates the vector around the y-axis by the angle in radians in place. rotate_y_ip_rad(angle) -> None  Rotates the vector counterclockwise around the y-axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   rotate_z() \n rotates a vector around the z-axis by the angle in degrees. rotate_z(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in degrees. \n   rotate_z_rad() \n rotates a vector around the z-axis by the angle in radians. rotate_z_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_z_ip() \n rotates the vector around the z-axis by the angle in degrees in place. rotate_z_ip(angle) -> None  Rotates the vector counterclockwise around the z-axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_z_ip_rad() \n rotates the vector around the z-axis by the angle in radians in place. rotate_z_ip_rad(angle) -> None  Rotates the vector counterclockwise around the z-axis by the given angle in radians. The length of the vector is not changed. \n   angle_to() \n calculates the angle to a given vector in degrees. angle_to(Vector3) -> float  Returns the angle between self and the given vector. \n   as_spherical() \n returns a tuple with radial distance, inclination and azimuthal angle. as_spherical() -> (r, theta, phi)  Returns a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle. \n   from_spherical() \n Sets x, y and z from a spherical coordinates 3-tuple. from_spherical((r, theta, phi)) -> None  Sets x, y and z from a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle. \n   update() \n Sets the coordinates of the vector. update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None  Sets coordinates x, y, and z in place.  New in pygame 1.9.5.  \n \n"}, {"name": "math.Vector3.angle_to", "path": "ref/math#pygame.math.Vector3.angle_to", "type": "pygame.math", "text": "  angle_to() \n calculates the angle to a given vector in degrees. angle_to(Vector3) -> float  Returns the angle between self and the given vector. \n"}, {"name": "math.Vector3.as_spherical", "path": "ref/math#pygame.math.Vector3.as_spherical", "type": "pygame.math", "text": "  as_spherical() \n returns a tuple with radial distance, inclination and azimuthal angle. as_spherical() -> (r, theta, phi)  Returns a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle. \n"}, {"name": "math.Vector3.cross", "path": "ref/math#pygame.math.Vector3.cross", "type": "pygame.math", "text": "  cross() \n calculates the cross- or vector-product cross(Vector3) -> Vector3  calculates the cross-product. \n"}, {"name": "math.Vector3.distance_squared_to", "path": "ref/math#pygame.math.Vector3.distance_squared_to", "type": "pygame.math", "text": "  distance_squared_to() \n calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector3) -> float  \n"}, {"name": "math.Vector3.distance_to", "path": "ref/math#pygame.math.Vector3.distance_to", "type": "pygame.math", "text": "  distance_to() \n calculates the Euclidean distance to a given vector. distance_to(Vector3) -> float  \n"}, {"name": "math.Vector3.dot", "path": "ref/math#pygame.math.Vector3.dot", "type": "pygame.math", "text": "  dot() \n calculates the dot- or scalar-product with the other vector dot(Vector3) -> float  \n"}, {"name": "math.Vector3.elementwise", "path": "ref/math#pygame.math.Vector3.elementwise", "type": "pygame.math", "text": "  elementwise() \n The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy  Applies the following operation to each element of the vector. \n"}, {"name": "math.Vector3.from_spherical", "path": "ref/math#pygame.math.Vector3.from_spherical", "type": "pygame.math", "text": "  from_spherical() \n Sets x, y and z from a spherical coordinates 3-tuple. from_spherical((r, theta, phi)) -> None  Sets x, y and z from a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle. \n"}, {"name": "math.Vector3.is_normalized", "path": "ref/math#pygame.math.Vector3.is_normalized", "type": "pygame.math", "text": "  is_normalized() \n tests if the vector is normalized i.e. has length == 1. is_normalized() -> Bool  Returns True if the vector has length equal to 1. Otherwise it returns False. \n"}, {"name": "math.Vector3.length", "path": "ref/math#pygame.math.Vector3.length", "type": "pygame.math", "text": "  length() \n returns the Euclidean length of the vector. length() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2) \n"}, {"name": "math.Vector3.length_squared", "path": "ref/math#pygame.math.Vector3.length_squared", "type": "pygame.math", "text": "  length_squared() \n returns the squared Euclidean length of the vector. length_squared() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2 + vec.z**2. This is faster than vec.length() because it avoids the square root. \n"}, {"name": "math.Vector3.lerp", "path": "ref/math#pygame.math.Vector3.lerp", "type": "pygame.math", "text": "  lerp() \n returns a linear interpolation to the given vector. lerp(Vector3, float) -> Vector3  Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self an other the result is going to be. It must be a value between 0 and 1, where 0 means self and 1 means other will be returned. \n"}, {"name": "math.Vector3.magnitude", "path": "ref/math#pygame.math.Vector3.magnitude", "type": "pygame.math", "text": "  magnitude() \n returns the Euclidean magnitude of the vector. magnitude() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2) \n"}, {"name": "math.Vector3.magnitude_squared", "path": "ref/math#pygame.math.Vector3.magnitude_squared", "type": "pygame.math", "text": "  magnitude_squared() \n returns the squared Euclidean magnitude of the vector. magnitude_squared() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude_squared() == vec.x**2 + vec.y**2 + vec.z**2. This is faster than vec.magnitude() because it avoids the square root. \n"}, {"name": "math.Vector3.normalize", "path": "ref/math#pygame.math.Vector3.normalize", "type": "pygame.math", "text": "  normalize() \n returns a vector with the same direction but length 1. normalize() -> Vector3  Returns a new vector that has length equal to 1 and the same direction as self. \n"}, {"name": "math.Vector3.normalize_ip", "path": "ref/math#pygame.math.Vector3.normalize_ip", "type": "pygame.math", "text": "  normalize_ip() \n normalizes the vector in place so that its length is 1. normalize_ip() -> None  Normalizes the vector so that it has length equal to 1. The direction of the vector is not changed. \n"}, {"name": "math.Vector3.reflect", "path": "ref/math#pygame.math.Vector3.reflect", "type": "pygame.math", "text": "  reflect() \n returns a vector reflected of a given normal. reflect(Vector3) -> Vector3  Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. \n"}, {"name": "math.Vector3.reflect_ip", "path": "ref/math#pygame.math.Vector3.reflect_ip", "type": "pygame.math", "text": "  reflect_ip() \n reflect the vector of a given normal in place. reflect_ip(Vector3) -> None  Changes the direction of self as if it would have been reflected of a surface with the given surface normal. \n"}, {"name": "math.Vector3.rotate", "path": "ref/math#pygame.math.Vector3.rotate", "type": "pygame.math", "text": "  rotate() \n rotates a vector by a given angle in degrees. rotate(angle, Vector3) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees around the given axis. \n"}, {"name": "math.Vector3.rotate_ip", "path": "ref/math#pygame.math.Vector3.rotate_ip", "type": "pygame.math", "text": "  rotate_ip() \n rotates the vector by a given angle in degrees in place. rotate_ip(angle, Vector3) -> None  Rotates the vector counterclockwise around the given axis by the given angle in degrees. The length of the vector is not changed. \n"}, {"name": "math.Vector3.rotate_ip_rad", "path": "ref/math#pygame.math.Vector3.rotate_ip_rad", "type": "pygame.math", "text": "  rotate_ip_rad() \n rotates the vector by a given angle in radians in place. rotate_ip_rad(angle, Vector3) -> None  Rotates the vector counterclockwise around the given axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n"}, {"name": "math.Vector3.rotate_rad", "path": "ref/math#pygame.math.Vector3.rotate_rad", "type": "pygame.math", "text": "  rotate_rad() \n rotates a vector by a given angle in radians. rotate_rad(angle, Vector3) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians around the given axis.  New in pygame 2.0.0.  \n"}, {"name": "math.Vector3.rotate_x", "path": "ref/math#pygame.math.Vector3.rotate_x", "type": "pygame.math", "text": "  rotate_x() \n rotates a vector around the x-axis by the angle in degrees. rotate_x(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in degrees. \n"}, {"name": "math.Vector3.rotate_x_ip", "path": "ref/math#pygame.math.Vector3.rotate_x_ip", "type": "pygame.math", "text": "  rotate_x_ip() \n rotates the vector around the x-axis by the angle in degrees in place. rotate_x_ip(angle) -> None  Rotates the vector counterclockwise around the x-axis by the given angle in degrees. The length of the vector is not changed. \n"}, {"name": "math.Vector3.rotate_x_ip_rad", "path": "ref/math#pygame.math.Vector3.rotate_x_ip_rad", "type": "pygame.math", "text": "  rotate_x_ip_rad() \n rotates the vector around the x-axis by the angle in radians in place. rotate_x_ip_rad(angle) -> None  Rotates the vector counterclockwise around the x-axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n"}, {"name": "math.Vector3.rotate_x_rad", "path": "ref/math#pygame.math.Vector3.rotate_x_rad", "type": "pygame.math", "text": "  rotate_x_rad() \n rotates a vector around the x-axis by the angle in radians. rotate_x_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in radians.  New in pygame 2.0.0.  \n"}, {"name": "math.Vector3.rotate_y", "path": "ref/math#pygame.math.Vector3.rotate_y", "type": "pygame.math", "text": "  rotate_y() \n rotates a vector around the y-axis by the angle in degrees. rotate_y(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in degrees. \n"}, {"name": "math.Vector3.rotate_y_ip", "path": "ref/math#pygame.math.Vector3.rotate_y_ip", "type": "pygame.math", "text": "  rotate_y_ip() \n rotates the vector around the y-axis by the angle in degrees in place. rotate_y_ip(angle) -> None  Rotates the vector counterclockwise around the y-axis by the given angle in degrees. The length of the vector is not changed. \n"}, {"name": "math.Vector3.rotate_y_ip_rad", "path": "ref/math#pygame.math.Vector3.rotate_y_ip_rad", "type": "pygame.math", "text": "  rotate_y_ip_rad() \n rotates the vector around the y-axis by the angle in radians in place. rotate_y_ip_rad(angle) -> None  Rotates the vector counterclockwise around the y-axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n"}, {"name": "math.Vector3.rotate_y_rad", "path": "ref/math#pygame.math.Vector3.rotate_y_rad", "type": "pygame.math", "text": "  rotate_y_rad() \n rotates a vector around the y-axis by the angle in radians. rotate_y_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in radians.  New in pygame 2.0.0.  \n"}, {"name": "math.Vector3.rotate_z", "path": "ref/math#pygame.math.Vector3.rotate_z", "type": "pygame.math", "text": "  rotate_z() \n rotates a vector around the z-axis by the angle in degrees. rotate_z(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in degrees. \n"}, {"name": "math.Vector3.rotate_z_ip", "path": "ref/math#pygame.math.Vector3.rotate_z_ip", "type": "pygame.math", "text": "  rotate_z_ip() \n rotates the vector around the z-axis by the angle in degrees in place. rotate_z_ip(angle) -> None  Rotates the vector counterclockwise around the z-axis by the given angle in degrees. The length of the vector is not changed. \n"}, {"name": "math.Vector3.rotate_z_ip_rad", "path": "ref/math#pygame.math.Vector3.rotate_z_ip_rad", "type": "pygame.math", "text": "  rotate_z_ip_rad() \n rotates the vector around the z-axis by the angle in radians in place. rotate_z_ip_rad(angle) -> None  Rotates the vector counterclockwise around the z-axis by the given angle in radians. The length of the vector is not changed. \n"}, {"name": "math.Vector3.rotate_z_rad", "path": "ref/math#pygame.math.Vector3.rotate_z_rad", "type": "pygame.math", "text": "  rotate_z_rad() \n rotates a vector around the z-axis by the angle in radians. rotate_z_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in radians.  New in pygame 2.0.0.  \n"}, {"name": "math.Vector3.scale_to_length", "path": "ref/math#pygame.math.Vector3.scale_to_length", "type": "pygame.math", "text": "  scale_to_length() \n scales the vector to a given length. scale_to_length(float) -> None  Scales the vector so that it has the given length. The direction of the vector is not changed. You can also scale to length 0. If the vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. \n"}, {"name": "math.Vector3.slerp", "path": "ref/math#pygame.math.Vector3.slerp", "type": "pygame.math", "text": "  slerp() \n returns a spherical interpolation to the given vector. slerp(Vector3, float) -> Vector3  Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. \n"}, {"name": "math.Vector3.update", "path": "ref/math#pygame.math.Vector3.update", "type": "pygame.math", "text": "  update() \n Sets the coordinates of the vector. update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None  Sets coordinates x, y, and z in place.  New in pygame 1.9.5.  \n"}, {"name": "midi", "path": "ref/midi", "type": "pygame.midi", "text": " pygame.midi\n  \n pygame module for interacting with midi input and output.   New in pygame 1.9.0.  The midi module can send output to midi devices and get input from midi devices. It can also list midi devices on the system. The midi module supports real and virtual midi devices. It uses the portmidi library. Is portable to which ever platforms portmidi supports (currently Windows, Mac OS X, and Linux). This uses pyportmidi for now, but may use its own bindings at some point in the future. The pyportmidi bindings are included with pygame.     New in pygame 2.0.0.  These are pygame events (pygame.event) reserved for midi use. The MIDIIN event is used by pygame.midi.midis2events() when converting midi events to pygame events. MIDIIN\nMIDIOUT      pygame.midi.init() \n initialize the midi module init() -> None  Initializes the pygame.midi module. Must be called before using the pygame.midi module. It is safe to call this more than once. \n   pygame.midi.quit() \n uninitialize the midi module quit() -> None  Uninitializes the pygame.midi module. If pygame.midi.init() was called to initialize the pygame.midi module, then this function will be called automatically when your program exits. It is safe to call this function more than once. \n   pygame.midi.get_init() \n returns True if the midi module is currently initialized get_init() -> bool  Gets the initialization state of the pygame.midi module.     \nReturns:\n\nTrue if the pygame.midi module is currently initialized.  \nReturn type:\nbool     New in pygame 1.9.5.  \n   pygame.midi.Input \n Input is used to get midi input from midi devices. Input(device_id) -> None Input(device_id, buffer_size) -> None      \nParameters:\n\n \ndevice_id (int) -- midi device id \nbuffer_size (int) -- (optional) the number of input events to be buffered        close() \n closes a midi stream, flushing any pending buffers. close() -> None  PortMidi attempts to close open streams when the application exits.  Note This is particularly difficult under Windows.  \n   poll() \n returns True if there's data, or False if not. poll() -> bool  Used to indicate if any data exists.     \nReturns:\n\nTrue if there is data, False otherwise  \nReturn type:\nbool  \nRaises:\n\nMidiException -- on error    \n   read() \n reads num_events midi events from the buffer. read(num_events) -> midi_event_list  Reads from the input buffer and gives back midi events.     \nParameters:\n\nnum_events (int) -- number of input events to read  \nReturns:\nthe format for midi_event_list is [[[status, data1, data2, data3], timestamp], ...]\n  \nReturn type:\nlist    \n \n   pygame.midi.Output \n Output is used to send midi to an output device Output(device_id) -> None Output(device_id, latency=0) -> None Output(device_id, buffer_size=256) -> None Output(device_id, latency, buffer_size) -> None  The buffer_size specifies the number of output events to be buffered waiting for output. In some cases (see below) PortMidi does not buffer output at all and merely passes data to a lower-level API, in which case buffersize is ignored. latency is the delay in milliseconds applied to timestamps to determine when the output should actually occur. If latency is <<0, 0 is assumed. If latency is zero, timestamps are ignored and all output is delivered immediately. If latency is greater than zero, output is delayed until the message timestamp plus the latency. In some cases, PortMidi can obtain better timing than your application by passing timestamps along to the device driver or hardware. Latency may also help you to synchronize midi data to audio data by matching midi latency to the audio buffer latency.  Note Time is measured relative to the time source indicated by time_proc. Timestamps are absolute, not relative delays or offsets.    abort() \n terminates outgoing messages immediately abort() -> None  The caller should immediately close the output port; this call may result in transmission of a partial midi message. There is no abort for Midi input because the user can simply ignore messages in the buffer and close an input device at any time. \n   close() \n closes a midi stream, flushing any pending buffers. close() -> None  PortMidi attempts to close open streams when the application exits.  Note This is particularly difficult under Windows.  \n   note_off() \n turns a midi note off (note must be on) note_off(note, velocity=None, channel=0) -> None  Turn a note off in the output stream. The note must already be on for this to work correctly. \n   note_on() \n turns a midi note on (note must be off) note_on(note, velocity=None, channel=0) -> None  Turn a note on in the output stream. The note must already be off for this to work correctly. \n   set_instrument() \n select an instrument, with a value between 0 and 127 set_instrument(instrument_id, channel=0) -> None  Select an instrument. \n   pitch_bend() \n modify the pitch of a channel. set_instrument(value=0, channel=0) -> None  Adjust the pitch of a channel. The value is a signed integer from -8192 to +8191. For example, 0 means \"no change\", +4096 is typically a semitone higher, and -8192 is 1 whole tone lower (though the musical range corresponding to the pitch bend range can also be changed in some synthesizers). If no value is given, the pitch bend is returned to \"no change\".  New in pygame 1.9.4.  \n   write() \n writes a list of midi data to the Output write(data) -> None  Writes series of MIDI information in the form of a list.     \nParameters:\n\ndata (list) -- data to write, the expected format is [[[status, data1=0, data2=0, ...], timestamp], ...] with the data# fields being optional  \nRaises:\n\nIndexError -- if more than 1024 elements in the data list    Example: # Program change at time 20000 and 500ms later send note 65 with\n# velocity 100.\nwrite([[[0xc0, 0, 0], 20000], [[0x90, 60, 100], 20500]])  Note  Timestamps will be ignored if latency = 0 To get a note to play immediately, send MIDI info with timestamp read from function Time Optional data fields: write([[[0xc0, 0, 0], 20000]]) is equivalent to write([[[0xc0], 20000]])\n   \n   write_short() \n writes up to 3 bytes of midi data to the Output write_short(status) -> None write_short(status, data1=0, data2=0) -> None  Output MIDI information of 3 bytes or less. The data fields are optional and assumed to be 0 if omitted. Examples of status byte values: 0xc0  # program change\n0x90  # note on\n# etc. Example: # note 65 on with velocity 100\nwrite_short(0x90, 65, 100) \n   write_sys_ex() \n writes a timestamped system-exclusive midi message. write_sys_ex(when, msg) -> None  Writes a timestamped system-exclusive midi message.     \nParameters:\n\n \nmsg (list[int] or str) -- midi message \nwhen -- timestamp in milliseconds      Example: midi_output.write_sys_ex(0, '\\xF0\\x7D\\x10\\x11\\x12\\x13\\xF7')\n\n# is equivalent to\n\nmidi_output.write_sys_ex(pygame.midi.time(),\n                         [0xF0, 0x7D, 0x10, 0x11, 0x12, 0x13, 0xF7]) \n \n   pygame.midi.get_count() \n gets the number of devices. get_count() -> num_devices  Device ids range from 0 to get_count() - 1 \n   pygame.midi.get_default_input_id() \n gets default input device number get_default_input_id() -> default_id  The following describes the usage details for this function and the get_default_output_id() function. Return the default device ID or -1 if there are no devices. The result can be passed to the Input/Output class. On a PC the user can specify a default device by setting an environment variable. To use device #1, for example: set PM_RECOMMENDED_INPUT_DEVICE=1\nor\nset PM_RECOMMENDED_OUTPUT_DEVICE=1 The user should first determine the available device ID by using the supplied application \"testin\" or \"testout\". In general, the registry is a better place for this kind of info. With USB devices that can come and go, using integers is not very reliable for device identification. Under Windows, if PM_RECOMMENDED_INPUT_DEVICE (or PM_RECOMMENDED_OUTPUT_DEVICE) is NOT found in the environment, then the default device is obtained by looking for a string in the registry under: HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Input_Device\nor\nHKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Output_Device The number of the first device with a substring that matches the string exactly is returned. For example, if the string in the registry is \"USB\" and device 1 is named \"In USB MidiSport 1x1\", then that will be the default input because it contains the string \"USB\". In addition to the name, get_device_info() returns \"interf\", which is the interface name. The \"interface\" is the underlying software system or API used by PortMidi to access devices. Supported interfaces: MMSystem   # the only Win32 interface currently supported\nALSA       # the only Linux interface currently supported\nCoreMIDI   # the only Mac OS X interface currently supported\n# DirectX - not implemented\n# OSS     - not implemented To specify both the interface and the device name in the registry, separate the two with a comma and a space. The string before the comma must be a substring of the \"interf\" string and the string after the space must be a substring of the \"name\" name string in order to match the device. e.g.: MMSystem, In USB MidiSport 1x1  Note In the current release, the default is simply the first device (the input or output device with the lowest PmDeviceID).  \n   pygame.midi.get_default_output_id() \n gets default output device number get_default_output_id() -> default_id  See get_default_input_id() for usage details. \n   pygame.midi.get_device_info() \n returns information about a midi device get_device_info(an_id) -> (interf, name, input, output, opened) get_device_info(an_id) -> None  Gets the device info for a given id.     \nParameters:\n\nan_id (int) -- id of the midi device being queried  \nReturns:\nif the id is out of range None is returned, otherwise a tuple of (interf, name, input, output, opened) is returned. \n interf: string describing the device interface (e.g. 'ALSA') name: string name of the device (e.g. 'Midi Through Port-0') input: 1 if the device is an input device, otherwise 0 output: 1 if the device is an output device, otherwise 0 opened: 1 if the device is opened, otherwise 0  \n   \nReturn type:\ntuple or None    \n   pygame.midi.midis2events() \n converts midi events to pygame events midis2events(midi_events, device_id) -> [Event, ...]  Takes a sequence of midi events and returns list of pygame events. The midi_events data is expected to be a sequence of ((status, data1, data2, data3), timestamp) midi events (all values required).     \nReturns:\na list of pygame events of event type MIDIIN\n  \nReturn type:\nlist    \n   pygame.midi.time() \n returns the current time in ms of the PortMidi timer time() -> time  The time is reset to 0 when the pygame.midi module is initialized. \n   pygame.midi.frequency_to_midi() \n Converts a frequency into a MIDI note. Rounds to the closest midi note. frequency_to_midi(midi_note) -> midi_note  example: frequency_to_midi(27.5) == 21  New in pygame 1.9.5.  \n   pygame.midi.midi_to_frequency() \n Converts a midi note to a frequency. midi_to_frequency(midi_note) -> frequency  example: midi_to_frequency(21) == 27.5  New in pygame 1.9.5.  \n   pygame.midi.midi_to_ansi_note() \n Returns the Ansi Note name for a midi number. midi_to_ansi_note(midi_note) -> ansi_note  example: midi_to_ansi_note(21) == 'A0'  New in pygame 1.9.5.  \n   exception pygame.midi.MidiException \n exception that pygame.midi functions and classes can raise MidiException(errno) -> None  \n \n \n"}, {"name": "midi.frequency_to_midi", "path": "ref/midi#pygame.midi.frequency_to_midi", "type": "pygame.midi", "text": "  pygame.midi.frequency_to_midi() \n Converts a frequency into a MIDI note. Rounds to the closest midi note. frequency_to_midi(midi_note) -> midi_note  example: frequency_to_midi(27.5) == 21  New in pygame 1.9.5.  \n"}, {"name": "midi.get_count", "path": "ref/midi#pygame.midi.get_count", "type": "pygame.midi", "text": "  pygame.midi.get_count() \n gets the number of devices. get_count() -> num_devices  Device ids range from 0 to get_count() - 1 \n"}, {"name": "midi.get_default_input_id", "path": "ref/midi#pygame.midi.get_default_input_id", "type": "pygame.midi", "text": "  pygame.midi.get_default_input_id() \n gets default input device number get_default_input_id() -> default_id  The following describes the usage details for this function and the get_default_output_id() function. Return the default device ID or -1 if there are no devices. The result can be passed to the Input/Output class. On a PC the user can specify a default device by setting an environment variable. To use device #1, for example: set PM_RECOMMENDED_INPUT_DEVICE=1\nor\nset PM_RECOMMENDED_OUTPUT_DEVICE=1 The user should first determine the available device ID by using the supplied application \"testin\" or \"testout\". In general, the registry is a better place for this kind of info. With USB devices that can come and go, using integers is not very reliable for device identification. Under Windows, if PM_RECOMMENDED_INPUT_DEVICE (or PM_RECOMMENDED_OUTPUT_DEVICE) is NOT found in the environment, then the default device is obtained by looking for a string in the registry under: HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Input_Device\nor\nHKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Output_Device The number of the first device with a substring that matches the string exactly is returned. For example, if the string in the registry is \"USB\" and device 1 is named \"In USB MidiSport 1x1\", then that will be the default input because it contains the string \"USB\". In addition to the name, get_device_info() returns \"interf\", which is the interface name. The \"interface\" is the underlying software system or API used by PortMidi to access devices. Supported interfaces: MMSystem   # the only Win32 interface currently supported\nALSA       # the only Linux interface currently supported\nCoreMIDI   # the only Mac OS X interface currently supported\n# DirectX - not implemented\n# OSS     - not implemented To specify both the interface and the device name in the registry, separate the two with a comma and a space. The string before the comma must be a substring of the \"interf\" string and the string after the space must be a substring of the \"name\" name string in order to match the device. e.g.: MMSystem, In USB MidiSport 1x1  Note In the current release, the default is simply the first device (the input or output device with the lowest PmDeviceID).  \n"}, {"name": "midi.get_default_output_id", "path": "ref/midi#pygame.midi.get_default_output_id", "type": "pygame.midi", "text": "  pygame.midi.get_default_output_id() \n gets default output device number get_default_output_id() -> default_id  See get_default_input_id() for usage details. \n"}, {"name": "midi.get_device_info", "path": "ref/midi#pygame.midi.get_device_info", "type": "pygame.midi", "text": "  pygame.midi.get_device_info() \n returns information about a midi device get_device_info(an_id) -> (interf, name, input, output, opened) get_device_info(an_id) -> None  Gets the device info for a given id.     \nParameters:\n\nan_id (int) -- id of the midi device being queried  \nReturns:\nif the id is out of range None is returned, otherwise a tuple of (interf, name, input, output, opened) is returned. \n interf: string describing the device interface (e.g. 'ALSA') name: string name of the device (e.g. 'Midi Through Port-0') input: 1 if the device is an input device, otherwise 0 output: 1 if the device is an output device, otherwise 0 opened: 1 if the device is opened, otherwise 0  \n   \nReturn type:\ntuple or None    \n"}, {"name": "midi.get_init", "path": "ref/midi#pygame.midi.get_init", "type": "pygame.midi", "text": "  pygame.midi.get_init() \n returns True if the midi module is currently initialized get_init() -> bool  Gets the initialization state of the pygame.midi module.     \nReturns:\n\nTrue if the pygame.midi module is currently initialized.  \nReturn type:\nbool     New in pygame 1.9.5.  \n"}, {"name": "midi.init", "path": "ref/midi#pygame.midi.init", "type": "pygame.midi", "text": "  pygame.midi.init() \n initialize the midi module init() -> None  Initializes the pygame.midi module. Must be called before using the pygame.midi module. It is safe to call this more than once. \n"}, {"name": "midi.Input", "path": "ref/midi#pygame.midi.Input", "type": "pygame.midi", "text": "  pygame.midi.Input \n Input is used to get midi input from midi devices. Input(device_id) -> None Input(device_id, buffer_size) -> None      \nParameters:\n\n \ndevice_id (int) -- midi device id \nbuffer_size (int) -- (optional) the number of input events to be buffered        close() \n closes a midi stream, flushing any pending buffers. close() -> None  PortMidi attempts to close open streams when the application exits.  Note This is particularly difficult under Windows.  \n   poll() \n returns True if there's data, or False if not. poll() -> bool  Used to indicate if any data exists.     \nReturns:\n\nTrue if there is data, False otherwise  \nReturn type:\nbool  \nRaises:\n\nMidiException -- on error    \n   read() \n reads num_events midi events from the buffer. read(num_events) -> midi_event_list  Reads from the input buffer and gives back midi events.     \nParameters:\n\nnum_events (int) -- number of input events to read  \nReturns:\nthe format for midi_event_list is [[[status, data1, data2, data3], timestamp], ...]\n  \nReturn type:\nlist    \n \n"}, {"name": "midi.Input.close", "path": "ref/midi#pygame.midi.Input.close", "type": "pygame.midi", "text": "  close() \n closes a midi stream, flushing any pending buffers. close() -> None  PortMidi attempts to close open streams when the application exits.  Note This is particularly difficult under Windows.  \n"}, {"name": "midi.Input.poll", "path": "ref/midi#pygame.midi.Input.poll", "type": "pygame.midi", "text": "  poll() \n returns True if there's data, or False if not. poll() -> bool  Used to indicate if any data exists.     \nReturns:\n\nTrue if there is data, False otherwise  \nReturn type:\nbool  \nRaises:\n\nMidiException -- on error    \n"}, {"name": "midi.Input.read", "path": "ref/midi#pygame.midi.Input.read", "type": "pygame.midi", "text": "  read() \n reads num_events midi events from the buffer. read(num_events) -> midi_event_list  Reads from the input buffer and gives back midi events.     \nParameters:\n\nnum_events (int) -- number of input events to read  \nReturns:\nthe format for midi_event_list is [[[status, data1, data2, data3], timestamp], ...]\n  \nReturn type:\nlist    \n"}, {"name": "midi.midi_to_ansi_note", "path": "ref/midi#pygame.midi.midi_to_ansi_note", "type": "pygame.midi", "text": "  pygame.midi.midi_to_ansi_note() \n Returns the Ansi Note name for a midi number. midi_to_ansi_note(midi_note) -> ansi_note  example: midi_to_ansi_note(21) == 'A0'  New in pygame 1.9.5.  \n"}, {"name": "midi.midi_to_frequency", "path": "ref/midi#pygame.midi.midi_to_frequency", "type": "pygame.midi", "text": "  pygame.midi.midi_to_frequency() \n Converts a midi note to a frequency. midi_to_frequency(midi_note) -> frequency  example: midi_to_frequency(21) == 27.5  New in pygame 1.9.5.  \n"}, {"name": "midi.MidiException", "path": "ref/midi#pygame.midi.MidiException", "type": "pygame.midi", "text": "  exception pygame.midi.MidiException \n exception that pygame.midi functions and classes can raise MidiException(errno) -> None  \n"}, {"name": "midi.midis2events", "path": "ref/midi#pygame.midi.midis2events", "type": "pygame.midi", "text": "  pygame.midi.midis2events() \n converts midi events to pygame events midis2events(midi_events, device_id) -> [Event, ...]  Takes a sequence of midi events and returns list of pygame events. The midi_events data is expected to be a sequence of ((status, data1, data2, data3), timestamp) midi events (all values required).     \nReturns:\na list of pygame events of event type MIDIIN\n  \nReturn type:\nlist    \n"}, {"name": "midi.Output", "path": "ref/midi#pygame.midi.Output", "type": "pygame.midi", "text": "  pygame.midi.Output \n Output is used to send midi to an output device Output(device_id) -> None Output(device_id, latency=0) -> None Output(device_id, buffer_size=256) -> None Output(device_id, latency, buffer_size) -> None  The buffer_size specifies the number of output events to be buffered waiting for output. In some cases (see below) PortMidi does not buffer output at all and merely passes data to a lower-level API, in which case buffersize is ignored. latency is the delay in milliseconds applied to timestamps to determine when the output should actually occur. If latency is <<0, 0 is assumed. If latency is zero, timestamps are ignored and all output is delivered immediately. If latency is greater than zero, output is delayed until the message timestamp plus the latency. In some cases, PortMidi can obtain better timing than your application by passing timestamps along to the device driver or hardware. Latency may also help you to synchronize midi data to audio data by matching midi latency to the audio buffer latency.  Note Time is measured relative to the time source indicated by time_proc. Timestamps are absolute, not relative delays or offsets.    abort() \n terminates outgoing messages immediately abort() -> None  The caller should immediately close the output port; this call may result in transmission of a partial midi message. There is no abort for Midi input because the user can simply ignore messages in the buffer and close an input device at any time. \n   close() \n closes a midi stream, flushing any pending buffers. close() -> None  PortMidi attempts to close open streams when the application exits.  Note This is particularly difficult under Windows.  \n   note_off() \n turns a midi note off (note must be on) note_off(note, velocity=None, channel=0) -> None  Turn a note off in the output stream. The note must already be on for this to work correctly. \n   note_on() \n turns a midi note on (note must be off) note_on(note, velocity=None, channel=0) -> None  Turn a note on in the output stream. The note must already be off for this to work correctly. \n   set_instrument() \n select an instrument, with a value between 0 and 127 set_instrument(instrument_id, channel=0) -> None  Select an instrument. \n   pitch_bend() \n modify the pitch of a channel. set_instrument(value=0, channel=0) -> None  Adjust the pitch of a channel. The value is a signed integer from -8192 to +8191. For example, 0 means \"no change\", +4096 is typically a semitone higher, and -8192 is 1 whole tone lower (though the musical range corresponding to the pitch bend range can also be changed in some synthesizers). If no value is given, the pitch bend is returned to \"no change\".  New in pygame 1.9.4.  \n   write() \n writes a list of midi data to the Output write(data) -> None  Writes series of MIDI information in the form of a list.     \nParameters:\n\ndata (list) -- data to write, the expected format is [[[status, data1=0, data2=0, ...], timestamp], ...] with the data# fields being optional  \nRaises:\n\nIndexError -- if more than 1024 elements in the data list    Example: # Program change at time 20000 and 500ms later send note 65 with\n# velocity 100.\nwrite([[[0xc0, 0, 0], 20000], [[0x90, 60, 100], 20500]])  Note  Timestamps will be ignored if latency = 0 To get a note to play immediately, send MIDI info with timestamp read from function Time Optional data fields: write([[[0xc0, 0, 0], 20000]]) is equivalent to write([[[0xc0], 20000]])\n   \n   write_short() \n writes up to 3 bytes of midi data to the Output write_short(status) -> None write_short(status, data1=0, data2=0) -> None  Output MIDI information of 3 bytes or less. The data fields are optional and assumed to be 0 if omitted. Examples of status byte values: 0xc0  # program change\n0x90  # note on\n# etc. Example: # note 65 on with velocity 100\nwrite_short(0x90, 65, 100) \n   write_sys_ex() \n writes a timestamped system-exclusive midi message. write_sys_ex(when, msg) -> None  Writes a timestamped system-exclusive midi message.     \nParameters:\n\n \nmsg (list[int] or str) -- midi message \nwhen -- timestamp in milliseconds      Example: midi_output.write_sys_ex(0, '\\xF0\\x7D\\x10\\x11\\x12\\x13\\xF7')\n\n# is equivalent to\n\nmidi_output.write_sys_ex(pygame.midi.time(),\n                         [0xF0, 0x7D, 0x10, 0x11, 0x12, 0x13, 0xF7]) \n \n"}, {"name": "midi.Output.abort", "path": "ref/midi#pygame.midi.Output.abort", "type": "pygame.midi", "text": "  abort() \n terminates outgoing messages immediately abort() -> None  The caller should immediately close the output port; this call may result in transmission of a partial midi message. There is no abort for Midi input because the user can simply ignore messages in the buffer and close an input device at any time. \n"}, {"name": "midi.Output.close", "path": "ref/midi#pygame.midi.Output.close", "type": "pygame.midi", "text": "  close() \n closes a midi stream, flushing any pending buffers. close() -> None  PortMidi attempts to close open streams when the application exits.  Note This is particularly difficult under Windows.  \n"}, {"name": "midi.Output.note_off", "path": "ref/midi#pygame.midi.Output.note_off", "type": "pygame.midi", "text": "  note_off() \n turns a midi note off (note must be on) note_off(note, velocity=None, channel=0) -> None  Turn a note off in the output stream. The note must already be on for this to work correctly. \n"}, {"name": "midi.Output.note_on", "path": "ref/midi#pygame.midi.Output.note_on", "type": "pygame.midi", "text": "  note_on() \n turns a midi note on (note must be off) note_on(note, velocity=None, channel=0) -> None  Turn a note on in the output stream. The note must already be off for this to work correctly. \n"}, {"name": "midi.Output.pitch_bend", "path": "ref/midi#pygame.midi.Output.pitch_bend", "type": "pygame.midi", "text": "  pitch_bend() \n modify the pitch of a channel. set_instrument(value=0, channel=0) -> None  Adjust the pitch of a channel. The value is a signed integer from -8192 to +8191. For example, 0 means \"no change\", +4096 is typically a semitone higher, and -8192 is 1 whole tone lower (though the musical range corresponding to the pitch bend range can also be changed in some synthesizers). If no value is given, the pitch bend is returned to \"no change\".  New in pygame 1.9.4.  \n"}, {"name": "midi.Output.set_instrument", "path": "ref/midi#pygame.midi.Output.set_instrument", "type": "pygame.midi", "text": "  set_instrument() \n select an instrument, with a value between 0 and 127 set_instrument(instrument_id, channel=0) -> None  Select an instrument. \n"}, {"name": "midi.Output.write", "path": "ref/midi#pygame.midi.Output.write", "type": "pygame.midi", "text": "  write() \n writes a list of midi data to the Output write(data) -> None  Writes series of MIDI information in the form of a list.     \nParameters:\n\ndata (list) -- data to write, the expected format is [[[status, data1=0, data2=0, ...], timestamp], ...] with the data# fields being optional  \nRaises:\n\nIndexError -- if more than 1024 elements in the data list    Example: # Program change at time 20000 and 500ms later send note 65 with\n# velocity 100.\nwrite([[[0xc0, 0, 0], 20000], [[0x90, 60, 100], 20500]])  Note  Timestamps will be ignored if latency = 0 To get a note to play immediately, send MIDI info with timestamp read from function Time Optional data fields: write([[[0xc0, 0, 0], 20000]]) is equivalent to write([[[0xc0], 20000]])\n   \n"}, {"name": "midi.Output.write_short", "path": "ref/midi#pygame.midi.Output.write_short", "type": "pygame.midi", "text": "  write_short() \n writes up to 3 bytes of midi data to the Output write_short(status) -> None write_short(status, data1=0, data2=0) -> None  Output MIDI information of 3 bytes or less. The data fields are optional and assumed to be 0 if omitted. Examples of status byte values: 0xc0  # program change\n0x90  # note on\n# etc. Example: # note 65 on with velocity 100\nwrite_short(0x90, 65, 100) \n"}, {"name": "midi.Output.write_sys_ex", "path": "ref/midi#pygame.midi.Output.write_sys_ex", "type": "pygame.midi", "text": "  write_sys_ex() \n writes a timestamped system-exclusive midi message. write_sys_ex(when, msg) -> None  Writes a timestamped system-exclusive midi message.     \nParameters:\n\n \nmsg (list[int] or str) -- midi message \nwhen -- timestamp in milliseconds      Example: midi_output.write_sys_ex(0, '\\xF0\\x7D\\x10\\x11\\x12\\x13\\xF7')\n\n# is equivalent to\n\nmidi_output.write_sys_ex(pygame.midi.time(),\n                         [0xF0, 0x7D, 0x10, 0x11, 0x12, 0x13, 0xF7]) \n"}, {"name": "midi.quit", "path": "ref/midi#pygame.midi.quit", "type": "pygame.midi", "text": "  pygame.midi.quit() \n uninitialize the midi module quit() -> None  Uninitializes the pygame.midi module. If pygame.midi.init() was called to initialize the pygame.midi module, then this function will be called automatically when your program exits. It is safe to call this function more than once. \n"}, {"name": "midi.time", "path": "ref/midi#pygame.midi.time", "type": "pygame.midi", "text": "  pygame.midi.time() \n returns the current time in ms of the PortMidi timer time() -> time  The time is reset to 0 when the pygame.midi module is initialized. \n"}, {"name": "mixer", "path": "ref/mixer", "type": "pygame.mixer", "text": " pygame.mixer\n  \n pygame module for loading and playing sounds  This module contains classes for loading Sound objects and controlling playback. The mixer module is optional and depends on SDL_mixer. Your program should test that pygame.mixer is available and initialized before using it. The mixer module has a limited number of channels for playback of sounds. Usually programs tell pygame to start playing audio and it selects an available channel automatically. The default is 8 simultaneous channels, but complex programs can get more precise control over the number of channels and their use. All sound playback is mixed in background threads. When you begin to play a Sound object, it will return immediately while the sound continues to play. A single Sound object can also be actively played back multiple times. The mixer also has a special streaming channel. This is for music playback and is accessed through the pygame.mixer.music module. The mixer module must be initialized like other pygame modules, but it has some extra conditions. The pygame.mixer.init() function takes several optional arguments to control the playback rate and sample size. Pygame will default to reasonable values, but pygame cannot perform Sound resampling, so the mixer should be initialized to match the values of your audio resources. NOTE: For less laggy sound use a smaller buffer size. The default is set to reduce the chance of scratchy sounds on some computers. You can change the default buffer by calling pygame.mixer.pre_init() before pygame.mixer.init() or pygame.init() is called. For example: pygame.mixer.pre_init(44100,-16,2, 1024)   pygame.mixer.init() \n initialize the mixer module init(frequency=44100, size=-16, channels=2, buffer=512, devicename=None, allowedchanges=AUDIO_ALLOW_FREQUENCY_CHANGE | AUDIO_ALLOW_CHANNELS_CHANGE) -> None  Initialize the mixer module for Sound loading and playback. The default arguments can be overridden to provide specific audio mixing. Keyword arguments are accepted. For backward compatibility where an argument is set zero the default value is used (possible changed by a pre_init call). The size argument represents how many bits are used for each audio sample. If the value is negative then signed sample values will be used. Positive values mean unsigned audio samples will be used. An invalid value raises an exception. The channels argument is used to specify whether to use mono or stereo. 1 for mono and 2 for stereo. The buffer argument controls the number of internal samples used in the sound mixer. The default value should work for most cases. It can be lowered to reduce latency, but sound dropout may occur. It can be raised to larger values to ensure playback never skips, but it will impose latency on sound playback. The buffer size must be a power of two (if not it is rounded up to the next nearest power of 2). Some platforms require the pygame.mixer module to be initialized after the display modules have initialized. The top level pygame.init() takes care of this automatically, but cannot pass any arguments to the mixer init. To solve this, mixer has a function pygame.mixer.pre_init() to set the proper defaults before the toplevel init is used. When using allowedchanges=0 it will convert the samples at runtime to match what the hardware supports. For example a sound card may not support 16bit sound samples, so instead it will use 8bit samples internally. If AUDIO_ALLOW_FORMAT_CHANGE is supplied, then the requested format will change to the closest that SDL2 supports. Apart from 0, allowedchanged accepts the following constants ORed together:  \n AUDIO_ALLOW_FREQUENCY_CHANGE AUDIO_ALLOW_FORMAT_CHANGE AUDIO_ALLOW_CHANNELS_CHANGE AUDIO_ALLOW_ANY_CHANGE  \n It is safe to call this more than once, but after the mixer is initialized you cannot change the playback arguments without first calling pygame.mixer.quit().  Changed in pygame 1.8: The default buffersize was changed from 1024 to 3072.   Changed in pygame 1.9.1: The default buffersize was changed from 3072 to 4096.   Changed in pygame 2.0.0: The default buffersize was changed from 4096 to 512. The default frequency changed to 44100 from 22050.   Changed in pygame 2.0.0: size can be 32 (32bit floats).   Changed in pygame 2.0.0: channels can also be 4 or 6.   New in pygame 2.0.0: allowedchanges argument added  \n   pygame.mixer.pre_init() \n preset the mixer init arguments pre_init(frequency=44100, size=-16, channels=2, buffer=512, devicename=None) -> None  Call pre_init to change the defaults used when the real pygame.mixer.init() is called. Keyword arguments are accepted. The best way to set custom mixer playback values is to call pygame.mixer.pre_init() before calling the top level pygame.init(). For backward compatibility argument values of zero are replaced with the startup defaults.  Changed in pygame 1.8: The default buffersize was changed from 1024 to 3072.   Changed in pygame 1.9.1: The default buffersize was changed from 3072 to 4096.   Changed in pygame 2.0.0: The default buffersize was changed from 4096 to 512. The default frequency changed to 44100 from 22050.  \n   pygame.mixer.quit() \n uninitialize the mixer quit() -> None  This will uninitialize pygame.mixer. All playback will stop and any loaded Sound objects may not be compatible with the mixer if it is reinitialized later. \n   pygame.mixer.get_init() \n test if the mixer is initialized get_init() -> (frequency, format, channels)  If the mixer is initialized, this returns the playback arguments it is using. If the mixer has not been initialized this returns None. \n   pygame.mixer.stop() \n stop playback of all sound channels stop() -> None  This will stop all playback of all active mixer channels. \n   pygame.mixer.pause() \n temporarily stop playback of all sound channels pause() -> None  This will temporarily stop all playback on the active mixer channels. The playback can later be resumed with pygame.mixer.unpause() \n   pygame.mixer.unpause() \n resume paused playback of sound channels unpause() -> None  This will resume all active sound channels after they have been paused. \n   pygame.mixer.fadeout() \n fade out the volume on all sounds before stopping fadeout(time) -> None  This will fade out the volume on all active channels over the time argument in milliseconds. After the sound is muted the playback will stop. \n   pygame.mixer.set_num_channels() \n set the total number of playback channels set_num_channels(count) -> None  Sets the number of available channels for the mixer. The default value is 8. The value can be increased or decreased. If the value is decreased, sounds playing on the truncated channels are stopped. \n   pygame.mixer.get_num_channels() \n get the total number of playback channels get_num_channels() -> count  Returns the number of currently active playback channels. \n   pygame.mixer.set_reserved() \n reserve channels from being automatically used set_reserved(count) -> None  The mixer can reserve any number of channels that will not be automatically selected for playback by Sounds. If sounds are currently playing on the reserved channels they will not be stopped. This allows the application to reserve a specific number of channels for important sounds that must not be dropped or have a guaranteed channel to play on. \n   pygame.mixer.find_channel() \n find an unused channel find_channel(force=False) -> Channel  This will find and return an inactive Channel object. If there are no inactive Channels this function will return None. If there are no inactive channels and the force argument is True, this will find the Channel with the longest running Sound and return it. If the mixer has reserved channels from pygame.mixer.set_reserved() then those channels will not be returned here. \n   pygame.mixer.get_busy() \n test if any sound is being mixed get_busy() -> bool  Returns True if the mixer is busy mixing any channels. If the mixer is idle then this return False. \n   pygame.mixer.get_sdl_mixer_version() \n get the mixer's SDL version get_sdl_mixer_version() -> (major, minor, patch) get_sdl_mixer_version(linked=True) -> (major, minor, patch)      \nParameters:\n\nlinked (bool) -- if True (default) the linked version number is returned, otherwise the compiled version number is returned  \nReturns:\nthe mixer's SDL library version number (linked or compiled depending on the linked parameter) as a tuple of 3 integers (major, minor, patch)\n  \nReturn type:\ntuple     Note The linked and compile version numbers should be the same.   New in pygame 2.0.0.  \n   pygame.mixer.Sound \n Create a new Sound object from a file or buffer object Sound(filename) -> Sound Sound(file=filename) -> Sound Sound(buffer) -> Sound Sound(buffer=buffer) -> Sound Sound(object) -> Sound Sound(file=object) -> Sound Sound(array=object) -> Sound  Load a new sound buffer from a filename, a python file object or a readable buffer object. Limited resampling will be performed to help the sample match the initialize arguments for the mixer. A Unicode string can only be a file pathname. A Python 2.x string or a Python 3.x bytes object can be either a pathname or a buffer object. Use the 'file' or 'buffer' keywords to avoid ambiguity; otherwise Sound may guess wrong. If the array keyword is used, the object is expected to export a version 3, C level array interface or, for Python 2.6 or later, a new buffer interface (The object is checked for a buffer interface first.) The Sound object represents actual sound sample data. Methods that change the state of the Sound object will the all instances of the Sound playback. A Sound object also exports an array interface, and, for Python 2.6 or later, a new buffer interface. The Sound can be loaded from an OGG audio file or from an uncompressed WAV. Note: The buffer will be copied internally, no data will be shared between it and the Sound object. For now buffer and array support is consistent with sndarray.make_sound for Numeric arrays, in that sample sign and byte order are ignored. This will change, either by correctly handling sign and byte order, or by raising an exception when different. Also, source samples are truncated to fit the audio sample size. This will not change.  New in pygame 1.8: pygame.mixer.Sound(buffer)   New in pygame 1.9.2: pygame.mixer.Sound keyword arguments and array interface support    play() \n begin sound playback play(loops=0, maxtime=0, fade_ms=0) -> Channel  Begin playback of the Sound (i.e., on the computer's speakers) on an available Channel. This will forcibly select a Channel, so playback may cut off a currently playing sound if necessary. The loops argument controls how many times the sample will be repeated after being played the first time. A value of 5 means that the sound will be played once, then repeated five times, and so is played a total of six times. The default value (zero) means the Sound is not repeated, and so is only played once. If loops is set to -1 the Sound will loop indefinitely (though you can still call stop() to stop it). The maxtime argument can be used to stop playback after a given number of milliseconds. The fade_ms argument will make the sound start playing at 0 volume and fade up to full volume over the time given. The sample may end before the fade-in is complete. This returns the Channel object for the channel that was selected. \n   stop() \n stop sound playback stop() -> None  This will stop the playback of this Sound on any active Channels. \n   fadeout() \n stop sound playback after fading out fadeout(time) -> None  This will stop playback of the sound after fading it out over the time argument in milliseconds. The Sound will fade and stop on all actively playing channels. \n   set_volume() \n set the playback volume for this Sound set_volume(value) -> None  This will set the playback volume (loudness) for this Sound. This will immediately affect the Sound if it is playing. It will also affect any future playback of this Sound.     \nParameters:\n\nvalue (float) -- volume in the range of 0.0 to 1.0 (inclusive)  If value < 0.0, the volume will not be changed If value > 1.0, the volume will be set to 1.0      \n   get_volume() \n get the playback volume get_volume() -> value  Return a value from 0.0 to 1.0 representing the volume for this Sound. \n   get_num_channels() \n count how many times this Sound is playing get_num_channels() -> count  Return the number of active channels this sound is playing on. \n   get_length() \n get the length of the Sound get_length() -> seconds  Return the length of this Sound in seconds. \n   get_raw() \n return a bytestring copy of the Sound samples. get_raw() -> bytes  Return a copy of the Sound object buffer as a bytes (for Python 3.x) or str (for Python 2.x) object.  New in pygame 1.9.2.  \n \n   pygame.mixer.Channel \n Create a Channel object for controlling playback Channel(id) -> Channel  Return a Channel object for one of the current channels. The id must be a value from 0 to the value of pygame.mixer.get_num_channels(). The Channel object can be used to get fine control over the playback of Sounds. A channel can only playback a single Sound at time. Using channels is entirely optional since pygame can manage them by default.   play() \n play a Sound on a specific Channel play(Sound, loops=0, maxtime=0, fade_ms=0) -> None  This will begin playback of a Sound on a specific Channel. If the Channel is currently playing any other Sound it will be stopped. The loops argument has the same meaning as in Sound.play(): it is the number of times to repeat the sound after the first time. If it is 3, the sound will be played 4 times (the first time, then three more). If loops is -1 then the playback will repeat indefinitely. As in Sound.play(), the maxtime argument can be used to stop playback of the Sound after a given number of milliseconds. As in Sound.play(), the fade_ms argument can be used fade in the sound. \n   stop() \n stop playback on a Channel stop() -> None  Stop sound playback on a channel. After playback is stopped the channel becomes available for new Sounds to play on it. \n   pause() \n temporarily stop playback of a channel pause() -> None  Temporarily stop the playback of sound on a channel. It can be resumed at a later time with Channel.unpause() \n   unpause() \n resume pause playback of a channel unpause() -> None  Resume the playback on a paused channel. \n   fadeout() \n stop playback after fading channel out fadeout(time) -> None  Stop playback of a channel after fading out the sound over the given time argument in milliseconds. \n   set_volume() \n set the volume of a playing channel set_volume(value) -> None set_volume(left, right) -> None  Set the volume (loudness) of a playing sound. When a channel starts to play its volume value is reset. This only affects the current sound. The value argument is between 0.0 and 1.0. If one argument is passed, it will be the volume of both speakers. If two arguments are passed and the mixer is in stereo mode, the first argument will be the volume of the left speaker and the second will be the volume of the right speaker. (If the second argument is None, the first argument will be the volume of both speakers.) If the channel is playing a Sound on which set_volume() has also been called, both calls are taken into account. For example: sound = pygame.mixer.Sound(\"s.wav\")\nchannel = s.play()      # Sound plays at full volume by default\nsound.set_volume(0.9)   # Now plays at 90% of full volume.\nsound.set_volume(0.6)   # Now plays at 60% (previous value replaced).\nchannel.set_volume(0.5) # Now plays at 30% (0.6 * 0.5). \n   get_volume() \n get the volume of the playing channel get_volume() -> value  Return the volume of the channel for the current playing sound. This does not take into account stereo separation used by Channel.set_volume(). The Sound object also has its own volume which is mixed with the channel. \n   get_busy() \n check if the channel is active get_busy() -> bool  Returns True if the channel is actively mixing sound. If the channel is idle this returns False. \n   get_sound() \n get the currently playing Sound get_sound() -> Sound  Return the actual Sound object currently playing on this channel. If the channel is idle None is returned. \n   queue() \n queue a Sound object to follow the current queue(Sound) -> None  When a Sound is queued on a Channel, it will begin playing immediately after the current Sound is finished. Each channel can only have a single Sound queued at a time. The queued Sound will only play if the current playback finished automatically. It is cleared on any other call to Channel.stop() or Channel.play(). If there is no sound actively playing on the Channel then the Sound will begin playing immediately. \n   get_queue() \n return any Sound that is queued get_queue() -> Sound  If a Sound is already queued on this channel it will be returned. Once the queued sound begins playback it will no longer be on the queue. \n   set_endevent() \n have the channel send an event when playback stops set_endevent() -> None set_endevent(type) -> None  When an endevent is set for a channel, it will send an event to the pygame queue every time a sound finishes playing on that channel (not just the first time). Use pygame.event.get() to retrieve the endevent once it's sent. Note that if you called Sound.play(n) or Channel.play(sound,n), the end event is sent only once: after the sound has been played \"n+1\" times (see the documentation of Sound.play). If Channel.stop() or Channel.play() is called while the sound was still playing, the event will be posted immediately. The type argument will be the event id sent to the queue. This can be any valid event type, but a good choice would be a value between pygame.locals.USEREVENT and pygame.locals.NUMEVENTS. If no type argument is given then the Channel will stop sending endevents. \n   get_endevent() \n get the event a channel sends when playback stops get_endevent() -> type  Returns the event type to be sent every time the Channel finishes playback of a Sound. If there is no endevent the function returns pygame.NOEVENT. \n \n \n \n"}, {"name": "mixer.Channel", "path": "ref/mixer#pygame.mixer.Channel", "type": "pygame.mixer", "text": "  pygame.mixer.Channel \n Create a Channel object for controlling playback Channel(id) -> Channel  Return a Channel object for one of the current channels. The id must be a value from 0 to the value of pygame.mixer.get_num_channels(). The Channel object can be used to get fine control over the playback of Sounds. A channel can only playback a single Sound at time. Using channels is entirely optional since pygame can manage them by default.   play() \n play a Sound on a specific Channel play(Sound, loops=0, maxtime=0, fade_ms=0) -> None  This will begin playback of a Sound on a specific Channel. If the Channel is currently playing any other Sound it will be stopped. The loops argument has the same meaning as in Sound.play(): it is the number of times to repeat the sound after the first time. If it is 3, the sound will be played 4 times (the first time, then three more). If loops is -1 then the playback will repeat indefinitely. As in Sound.play(), the maxtime argument can be used to stop playback of the Sound after a given number of milliseconds. As in Sound.play(), the fade_ms argument can be used fade in the sound. \n   stop() \n stop playback on a Channel stop() -> None  Stop sound playback on a channel. After playback is stopped the channel becomes available for new Sounds to play on it. \n   pause() \n temporarily stop playback of a channel pause() -> None  Temporarily stop the playback of sound on a channel. It can be resumed at a later time with Channel.unpause() \n   unpause() \n resume pause playback of a channel unpause() -> None  Resume the playback on a paused channel. \n   fadeout() \n stop playback after fading channel out fadeout(time) -> None  Stop playback of a channel after fading out the sound over the given time argument in milliseconds. \n   set_volume() \n set the volume of a playing channel set_volume(value) -> None set_volume(left, right) -> None  Set the volume (loudness) of a playing sound. When a channel starts to play its volume value is reset. This only affects the current sound. The value argument is between 0.0 and 1.0. If one argument is passed, it will be the volume of both speakers. If two arguments are passed and the mixer is in stereo mode, the first argument will be the volume of the left speaker and the second will be the volume of the right speaker. (If the second argument is None, the first argument will be the volume of both speakers.) If the channel is playing a Sound on which set_volume() has also been called, both calls are taken into account. For example: sound = pygame.mixer.Sound(\"s.wav\")\nchannel = s.play()      # Sound plays at full volume by default\nsound.set_volume(0.9)   # Now plays at 90% of full volume.\nsound.set_volume(0.6)   # Now plays at 60% (previous value replaced).\nchannel.set_volume(0.5) # Now plays at 30% (0.6 * 0.5). \n   get_volume() \n get the volume of the playing channel get_volume() -> value  Return the volume of the channel for the current playing sound. This does not take into account stereo separation used by Channel.set_volume(). The Sound object also has its own volume which is mixed with the channel. \n   get_busy() \n check if the channel is active get_busy() -> bool  Returns True if the channel is actively mixing sound. If the channel is idle this returns False. \n   get_sound() \n get the currently playing Sound get_sound() -> Sound  Return the actual Sound object currently playing on this channel. If the channel is idle None is returned. \n   queue() \n queue a Sound object to follow the current queue(Sound) -> None  When a Sound is queued on a Channel, it will begin playing immediately after the current Sound is finished. Each channel can only have a single Sound queued at a time. The queued Sound will only play if the current playback finished automatically. It is cleared on any other call to Channel.stop() or Channel.play(). If there is no sound actively playing on the Channel then the Sound will begin playing immediately. \n   get_queue() \n return any Sound that is queued get_queue() -> Sound  If a Sound is already queued on this channel it will be returned. Once the queued sound begins playback it will no longer be on the queue. \n   set_endevent() \n have the channel send an event when playback stops set_endevent() -> None set_endevent(type) -> None  When an endevent is set for a channel, it will send an event to the pygame queue every time a sound finishes playing on that channel (not just the first time). Use pygame.event.get() to retrieve the endevent once it's sent. Note that if you called Sound.play(n) or Channel.play(sound,n), the end event is sent only once: after the sound has been played \"n+1\" times (see the documentation of Sound.play). If Channel.stop() or Channel.play() is called while the sound was still playing, the event will be posted immediately. The type argument will be the event id sent to the queue. This can be any valid event type, but a good choice would be a value between pygame.locals.USEREVENT and pygame.locals.NUMEVENTS. If no type argument is given then the Channel will stop sending endevents. \n   get_endevent() \n get the event a channel sends when playback stops get_endevent() -> type  Returns the event type to be sent every time the Channel finishes playback of a Sound. If there is no endevent the function returns pygame.NOEVENT. \n \n"}, {"name": "mixer.Channel.fadeout", "path": "ref/mixer#pygame.mixer.Channel.fadeout", "type": "pygame.mixer", "text": "  fadeout() \n stop playback after fading channel out fadeout(time) -> None  Stop playback of a channel after fading out the sound over the given time argument in milliseconds. \n"}, {"name": "mixer.Channel.get_busy", "path": "ref/mixer#pygame.mixer.Channel.get_busy", "type": "pygame.mixer", "text": "  get_busy() \n check if the channel is active get_busy() -> bool  Returns True if the channel is actively mixing sound. If the channel is idle this returns False. \n"}, {"name": "mixer.Channel.get_endevent", "path": "ref/mixer#pygame.mixer.Channel.get_endevent", "type": "pygame.mixer", "text": "  get_endevent() \n get the event a channel sends when playback stops get_endevent() -> type  Returns the event type to be sent every time the Channel finishes playback of a Sound. If there is no endevent the function returns pygame.NOEVENT. \n"}, {"name": "mixer.Channel.get_queue", "path": "ref/mixer#pygame.mixer.Channel.get_queue", "type": "pygame.mixer", "text": "  get_queue() \n return any Sound that is queued get_queue() -> Sound  If a Sound is already queued on this channel it will be returned. Once the queued sound begins playback it will no longer be on the queue. \n"}, {"name": "mixer.Channel.get_sound", "path": "ref/mixer#pygame.mixer.Channel.get_sound", "type": "pygame.mixer", "text": "  get_sound() \n get the currently playing Sound get_sound() -> Sound  Return the actual Sound object currently playing on this channel. If the channel is idle None is returned. \n"}, {"name": "mixer.Channel.get_volume", "path": "ref/mixer#pygame.mixer.Channel.get_volume", "type": "pygame.mixer", "text": "  get_volume() \n get the volume of the playing channel get_volume() -> value  Return the volume of the channel for the current playing sound. This does not take into account stereo separation used by Channel.set_volume(). The Sound object also has its own volume which is mixed with the channel. \n"}, {"name": "mixer.Channel.pause", "path": "ref/mixer#pygame.mixer.Channel.pause", "type": "pygame.mixer", "text": "  pause() \n temporarily stop playback of a channel pause() -> None  Temporarily stop the playback of sound on a channel. It can be resumed at a later time with Channel.unpause() \n"}, {"name": "mixer.Channel.play", "path": "ref/mixer#pygame.mixer.Channel.play", "type": "pygame.mixer", "text": "  play() \n play a Sound on a specific Channel play(Sound, loops=0, maxtime=0, fade_ms=0) -> None  This will begin playback of a Sound on a specific Channel. If the Channel is currently playing any other Sound it will be stopped. The loops argument has the same meaning as in Sound.play(): it is the number of times to repeat the sound after the first time. If it is 3, the sound will be played 4 times (the first time, then three more). If loops is -1 then the playback will repeat indefinitely. As in Sound.play(), the maxtime argument can be used to stop playback of the Sound after a given number of milliseconds. As in Sound.play(), the fade_ms argument can be used fade in the sound. \n"}, {"name": "mixer.Channel.queue", "path": "ref/mixer#pygame.mixer.Channel.queue", "type": "pygame.mixer", "text": "  queue() \n queue a Sound object to follow the current queue(Sound) -> None  When a Sound is queued on a Channel, it will begin playing immediately after the current Sound is finished. Each channel can only have a single Sound queued at a time. The queued Sound will only play if the current playback finished automatically. It is cleared on any other call to Channel.stop() or Channel.play(). If there is no sound actively playing on the Channel then the Sound will begin playing immediately. \n"}, {"name": "mixer.Channel.set_endevent", "path": "ref/mixer#pygame.mixer.Channel.set_endevent", "type": "pygame.mixer", "text": "  set_endevent() \n have the channel send an event when playback stops set_endevent() -> None set_endevent(type) -> None  When an endevent is set for a channel, it will send an event to the pygame queue every time a sound finishes playing on that channel (not just the first time). Use pygame.event.get() to retrieve the endevent once it's sent. Note that if you called Sound.play(n) or Channel.play(sound,n), the end event is sent only once: after the sound has been played \"n+1\" times (see the documentation of Sound.play). If Channel.stop() or Channel.play() is called while the sound was still playing, the event will be posted immediately. The type argument will be the event id sent to the queue. This can be any valid event type, but a good choice would be a value between pygame.locals.USEREVENT and pygame.locals.NUMEVENTS. If no type argument is given then the Channel will stop sending endevents. \n"}, {"name": "mixer.Channel.set_volume", "path": "ref/mixer#pygame.mixer.Channel.set_volume", "type": "pygame.mixer", "text": "  set_volume() \n set the volume of a playing channel set_volume(value) -> None set_volume(left, right) -> None  Set the volume (loudness) of a playing sound. When a channel starts to play its volume value is reset. This only affects the current sound. The value argument is between 0.0 and 1.0. If one argument is passed, it will be the volume of both speakers. If two arguments are passed and the mixer is in stereo mode, the first argument will be the volume of the left speaker and the second will be the volume of the right speaker. (If the second argument is None, the first argument will be the volume of both speakers.) If the channel is playing a Sound on which set_volume() has also been called, both calls are taken into account. For example: sound = pygame.mixer.Sound(\"s.wav\")\nchannel = s.play()      # Sound plays at full volume by default\nsound.set_volume(0.9)   # Now plays at 90% of full volume.\nsound.set_volume(0.6)   # Now plays at 60% (previous value replaced).\nchannel.set_volume(0.5) # Now plays at 30% (0.6 * 0.5). \n"}, {"name": "mixer.Channel.stop", "path": "ref/mixer#pygame.mixer.Channel.stop", "type": "pygame.mixer", "text": "  stop() \n stop playback on a Channel stop() -> None  Stop sound playback on a channel. After playback is stopped the channel becomes available for new Sounds to play on it. \n"}, {"name": "mixer.Channel.unpause", "path": "ref/mixer#pygame.mixer.Channel.unpause", "type": "pygame.mixer", "text": "  unpause() \n resume pause playback of a channel unpause() -> None  Resume the playback on a paused channel. \n"}, {"name": "mixer.fadeout", "path": "ref/mixer#pygame.mixer.fadeout", "type": "pygame.mixer", "text": "  pygame.mixer.fadeout() \n fade out the volume on all sounds before stopping fadeout(time) -> None  This will fade out the volume on all active channels over the time argument in milliseconds. After the sound is muted the playback will stop. \n"}, {"name": "mixer.find_channel", "path": "ref/mixer#pygame.mixer.find_channel", "type": "pygame.mixer", "text": "  pygame.mixer.find_channel() \n find an unused channel find_channel(force=False) -> Channel  This will find and return an inactive Channel object. If there are no inactive Channels this function will return None. If there are no inactive channels and the force argument is True, this will find the Channel with the longest running Sound and return it. If the mixer has reserved channels from pygame.mixer.set_reserved() then those channels will not be returned here. \n"}, {"name": "mixer.get_busy", "path": "ref/mixer#pygame.mixer.get_busy", "type": "pygame.mixer", "text": "  pygame.mixer.get_busy() \n test if any sound is being mixed get_busy() -> bool  Returns True if the mixer is busy mixing any channels. If the mixer is idle then this return False. \n"}, {"name": "mixer.get_init", "path": "ref/mixer#pygame.mixer.get_init", "type": "pygame.mixer", "text": "  pygame.mixer.get_init() \n test if the mixer is initialized get_init() -> (frequency, format, channels)  If the mixer is initialized, this returns the playback arguments it is using. If the mixer has not been initialized this returns None. \n"}, {"name": "mixer.get_num_channels", "path": "ref/mixer#pygame.mixer.get_num_channels", "type": "pygame.mixer", "text": "  pygame.mixer.get_num_channels() \n get the total number of playback channels get_num_channels() -> count  Returns the number of currently active playback channels. \n"}, {"name": "mixer.get_sdl_mixer_version", "path": "ref/mixer#pygame.mixer.get_sdl_mixer_version", "type": "pygame.mixer", "text": "  pygame.mixer.get_sdl_mixer_version() \n get the mixer's SDL version get_sdl_mixer_version() -> (major, minor, patch) get_sdl_mixer_version(linked=True) -> (major, minor, patch)      \nParameters:\n\nlinked (bool) -- if True (default) the linked version number is returned, otherwise the compiled version number is returned  \nReturns:\nthe mixer's SDL library version number (linked or compiled depending on the linked parameter) as a tuple of 3 integers (major, minor, patch)\n  \nReturn type:\ntuple     Note The linked and compile version numbers should be the same.   New in pygame 2.0.0.  \n"}, {"name": "mixer.init", "path": "ref/mixer#pygame.mixer.init", "type": "pygame.mixer", "text": "  pygame.mixer.init() \n initialize the mixer module init(frequency=44100, size=-16, channels=2, buffer=512, devicename=None, allowedchanges=AUDIO_ALLOW_FREQUENCY_CHANGE | AUDIO_ALLOW_CHANNELS_CHANGE) -> None  Initialize the mixer module for Sound loading and playback. The default arguments can be overridden to provide specific audio mixing. Keyword arguments are accepted. For backward compatibility where an argument is set zero the default value is used (possible changed by a pre_init call). The size argument represents how many bits are used for each audio sample. If the value is negative then signed sample values will be used. Positive values mean unsigned audio samples will be used. An invalid value raises an exception. The channels argument is used to specify whether to use mono or stereo. 1 for mono and 2 for stereo. The buffer argument controls the number of internal samples used in the sound mixer. The default value should work for most cases. It can be lowered to reduce latency, but sound dropout may occur. It can be raised to larger values to ensure playback never skips, but it will impose latency on sound playback. The buffer size must be a power of two (if not it is rounded up to the next nearest power of 2). Some platforms require the pygame.mixer module to be initialized after the display modules have initialized. The top level pygame.init() takes care of this automatically, but cannot pass any arguments to the mixer init. To solve this, mixer has a function pygame.mixer.pre_init() to set the proper defaults before the toplevel init is used. When using allowedchanges=0 it will convert the samples at runtime to match what the hardware supports. For example a sound card may not support 16bit sound samples, so instead it will use 8bit samples internally. If AUDIO_ALLOW_FORMAT_CHANGE is supplied, then the requested format will change to the closest that SDL2 supports. Apart from 0, allowedchanged accepts the following constants ORed together:  \n AUDIO_ALLOW_FREQUENCY_CHANGE AUDIO_ALLOW_FORMAT_CHANGE AUDIO_ALLOW_CHANNELS_CHANGE AUDIO_ALLOW_ANY_CHANGE  \n It is safe to call this more than once, but after the mixer is initialized you cannot change the playback arguments without first calling pygame.mixer.quit().  Changed in pygame 1.8: The default buffersize was changed from 1024 to 3072.   Changed in pygame 1.9.1: The default buffersize was changed from 3072 to 4096.   Changed in pygame 2.0.0: The default buffersize was changed from 4096 to 512. The default frequency changed to 44100 from 22050.   Changed in pygame 2.0.0: size can be 32 (32bit floats).   Changed in pygame 2.0.0: channels can also be 4 or 6.   New in pygame 2.0.0: allowedchanges argument added  \n"}, {"name": "mixer.music", "path": "ref/music", "type": "pygame.mixer.music", "text": " pygame.mixer.music\n  \n pygame module for controlling streamed audio  The music module is closely tied to pygame.mixer. Use the music module to control the playback of music in the sound mixer. The difference between the music playback and regular Sound playback is that the music is streamed, and never actually loaded all at once. The mixer system only supports a single music stream at once. Be aware that MP3 support is limited. On some systems an unsupported format can crash the program, e.g. Debian Linux. Consider using OGG instead.   pygame.mixer.music.load() \n Load a music file for playback load(filename) -> None load(object) -> None  This will load a music filename/file object and prepare it for playback. If a music stream is already playing it will be stopped. This does not start the music playing. \n   pygame.mixer.music.unload() \n Unload the currently loaded music to free up resources unload() -> None  This closes resources like files for any music that may be loaded.  New in pygame 2.0.0.  \n   pygame.mixer.music.play() \n Start the playback of the music stream play(loops=0, start=0.0, fade_ms = 0) -> None  This will play the loaded music stream. If the music is already playing it will be restarted. loops is an optional integer argument, which is 0 by default, it tells how many times to repeat the music. The music repeats indefinately if this argument is set to -1. start is an optional float argument, which is 0.0 by default, which denotes the position in time, the music starts playing from. The starting position depends on the format of the music played. MP3 and OGG use the position as time in seconds. For mp3s the start time position selected may not be accurate as things like variable bit rate encoding and ID3 tags can throw off the timing calculations. For MOD music it is the pattern order number. Passing a start position will raise a NotImplementedError if the start position cannot be set. fade_ms is an optional integer argument, which is 0 by default, makes the music start playing at 0 volume and fade up to full volume over the given time. The sample may end before the fade-in is complete.  Changed in pygame 2.0.0: Added optional fade_ms argument  \n   pygame.mixer.music.rewind() \n restart music rewind() -> None  Resets playback of the current music to the beginning. \n   pygame.mixer.music.stop() \n stop the music playback stop() -> None  Stops the music playback if it is currently playing. It Won't Unload the music. \n   pygame.mixer.music.pause() \n temporarily stop music playback pause() -> None  Temporarily stop playback of the music stream. It can be resumed with the pygame.mixer.music.unpause() function. \n   pygame.mixer.music.unpause() \n resume paused music unpause() -> None  This will resume the playback of a music stream after it has been paused. \n   pygame.mixer.music.fadeout() \n stop music playback after fading out fadeout(time) -> None  Fade out and stop the currently playing music. The time argument denotes the integer milliseconds for which the fading effect is generated. Note, that this function blocks until the music has faded out. Calls to fadeout() and set_volume() will have no effect during this time. If an event was set using set_endevent() it will be called after the music has faded. \n   pygame.mixer.music.set_volume() \n set the music volume set_volume(volume) -> None  Set the volume of the music playback. The volume argument is a float between 0.0 and 1.0 that sets volume. When new music is loaded the volume is reset to full volume. \n   pygame.mixer.music.get_volume() \n get the music volume get_volume() -> value  Returns the current volume for the mixer. The value will be between 0.0 and 1.0. \n   pygame.mixer.music.get_busy() \n check if the music stream is playing get_busy() -> bool  Returns True when the music stream is actively playing. When the music is idle this returns False. In pygame 2.0.1 and above this function returns False when the music is paused. In pygame 1 it returns True when the music is paused.  Changed in pygame 2.0.1: Returns False when music paused.  \n   pygame.mixer.music.set_pos() \n set position to play from set_pos(pos) -> None  This sets the position in the music file where playback will start. The meaning of \"pos\", a float (or a number that can be converted to a float), depends on the music format. For MOD files, pos is the integer pattern number in the module. For OGG it is the absolute position, in seconds, from the beginning of the sound. For MP3 files, it is the relative position, in seconds, from the current position. For absolute positioning in an MP3 file, first call rewind(). Other file formats are unsupported. Newer versions of SDL_mixer have better positioning support than earlier ones. An SDLError is raised if a particular format does not support positioning. Function set_pos() calls underlining SDL_mixer function Mix_SetMusicPosition.  New in pygame 1.9.2.  \n   pygame.mixer.music.get_pos() \n get the music play time get_pos() -> time  This gets the number of milliseconds that the music has been playing for. The returned time only represents how long the music has been playing; it does not take into account any starting position offsets. \n   pygame.mixer.music.queue() \n queue a sound file to follow the current queue(filename) -> None  This will load a sound file and queue it. A queued sound file will begin as soon as the current sound naturally ends. Only one sound can be queued at a time. Queuing a new sound while another sound is queued will result in the new sound becoming the queued sound. Also, if the current sound is ever stopped or changed, the queued sound will be lost. The following example will play music by Bach six times, then play music by Mozart once: pygame.mixer.music.load('bach.ogg')\npygame.mixer.music.play(5)        # Plays six times, not five!\npygame.mixer.music.queue('mozart.ogg') \n   pygame.mixer.music.set_endevent() \n have the music send an event when playback stops set_endevent() -> None set_endevent(type) -> None  This causes pygame to signal (by means of the event queue) when the music is done playing. The argument determines the type of event that will be queued. The event will be queued every time the music finishes, not just the first time. To stop the event from being queued, call this method with no argument. \n   pygame.mixer.music.get_endevent() \n get the event a channel sends when playback stops get_endevent() -> type  Returns the event type to be sent every time the music finishes playback. If there is no endevent the function returns pygame.NOEVENT. \n \n \n"}, {"name": "mixer.music.fadeout", "path": "ref/music#pygame.mixer.music.fadeout", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.fadeout() \n stop music playback after fading out fadeout(time) -> None  Fade out and stop the currently playing music. The time argument denotes the integer milliseconds for which the fading effect is generated. Note, that this function blocks until the music has faded out. Calls to fadeout() and set_volume() will have no effect during this time. If an event was set using set_endevent() it will be called after the music has faded. \n"}, {"name": "mixer.music.get_busy", "path": "ref/music#pygame.mixer.music.get_busy", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.get_busy() \n check if the music stream is playing get_busy() -> bool  Returns True when the music stream is actively playing. When the music is idle this returns False. In pygame 2.0.1 and above this function returns False when the music is paused. In pygame 1 it returns True when the music is paused.  Changed in pygame 2.0.1: Returns False when music paused.  \n"}, {"name": "mixer.music.get_endevent", "path": "ref/music#pygame.mixer.music.get_endevent", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.get_endevent() \n get the event a channel sends when playback stops get_endevent() -> type  Returns the event type to be sent every time the music finishes playback. If there is no endevent the function returns pygame.NOEVENT. \n"}, {"name": "mixer.music.get_pos", "path": "ref/music#pygame.mixer.music.get_pos", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.get_pos() \n get the music play time get_pos() -> time  This gets the number of milliseconds that the music has been playing for. The returned time only represents how long the music has been playing; it does not take into account any starting position offsets. \n"}, {"name": "mixer.music.get_volume", "path": "ref/music#pygame.mixer.music.get_volume", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.get_volume() \n get the music volume get_volume() -> value  Returns the current volume for the mixer. The value will be between 0.0 and 1.0. \n"}, {"name": "mixer.music.load", "path": "ref/music#pygame.mixer.music.load", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.load() \n Load a music file for playback load(filename) -> None load(object) -> None  This will load a music filename/file object and prepare it for playback. If a music stream is already playing it will be stopped. This does not start the music playing. \n"}, {"name": "mixer.music.pause", "path": "ref/music#pygame.mixer.music.pause", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.pause() \n temporarily stop music playback pause() -> None  Temporarily stop playback of the music stream. It can be resumed with the pygame.mixer.music.unpause() function. \n"}, {"name": "mixer.music.play", "path": "ref/music#pygame.mixer.music.play", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.play() \n Start the playback of the music stream play(loops=0, start=0.0, fade_ms = 0) -> None  This will play the loaded music stream. If the music is already playing it will be restarted. loops is an optional integer argument, which is 0 by default, it tells how many times to repeat the music. The music repeats indefinately if this argument is set to -1. start is an optional float argument, which is 0.0 by default, which denotes the position in time, the music starts playing from. The starting position depends on the format of the music played. MP3 and OGG use the position as time in seconds. For mp3s the start time position selected may not be accurate as things like variable bit rate encoding and ID3 tags can throw off the timing calculations. For MOD music it is the pattern order number. Passing a start position will raise a NotImplementedError if the start position cannot be set. fade_ms is an optional integer argument, which is 0 by default, makes the music start playing at 0 volume and fade up to full volume over the given time. The sample may end before the fade-in is complete.  Changed in pygame 2.0.0: Added optional fade_ms argument  \n"}, {"name": "mixer.music.queue", "path": "ref/music#pygame.mixer.music.queue", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.queue() \n queue a sound file to follow the current queue(filename) -> None  This will load a sound file and queue it. A queued sound file will begin as soon as the current sound naturally ends. Only one sound can be queued at a time. Queuing a new sound while another sound is queued will result in the new sound becoming the queued sound. Also, if the current sound is ever stopped or changed, the queued sound will be lost. The following example will play music by Bach six times, then play music by Mozart once: pygame.mixer.music.load('bach.ogg')\npygame.mixer.music.play(5)        # Plays six times, not five!\npygame.mixer.music.queue('mozart.ogg') \n"}, {"name": "mixer.music.rewind", "path": "ref/music#pygame.mixer.music.rewind", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.rewind() \n restart music rewind() -> None  Resets playback of the current music to the beginning. \n"}, {"name": "mixer.music.set_endevent", "path": "ref/music#pygame.mixer.music.set_endevent", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.set_endevent() \n have the music send an event when playback stops set_endevent() -> None set_endevent(type) -> None  This causes pygame to signal (by means of the event queue) when the music is done playing. The argument determines the type of event that will be queued. The event will be queued every time the music finishes, not just the first time. To stop the event from being queued, call this method with no argument. \n"}, {"name": "mixer.music.set_pos", "path": "ref/music#pygame.mixer.music.set_pos", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.set_pos() \n set position to play from set_pos(pos) -> None  This sets the position in the music file where playback will start. The meaning of \"pos\", a float (or a number that can be converted to a float), depends on the music format. For MOD files, pos is the integer pattern number in the module. For OGG it is the absolute position, in seconds, from the beginning of the sound. For MP3 files, it is the relative position, in seconds, from the current position. For absolute positioning in an MP3 file, first call rewind(). Other file formats are unsupported. Newer versions of SDL_mixer have better positioning support than earlier ones. An SDLError is raised if a particular format does not support positioning. Function set_pos() calls underlining SDL_mixer function Mix_SetMusicPosition.  New in pygame 1.9.2.  \n"}, {"name": "mixer.music.set_volume", "path": "ref/music#pygame.mixer.music.set_volume", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.set_volume() \n set the music volume set_volume(volume) -> None  Set the volume of the music playback. The volume argument is a float between 0.0 and 1.0 that sets volume. When new music is loaded the volume is reset to full volume. \n"}, {"name": "mixer.music.stop", "path": "ref/music#pygame.mixer.music.stop", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.stop() \n stop the music playback stop() -> None  Stops the music playback if it is currently playing. It Won't Unload the music. \n"}, {"name": "mixer.music.unload", "path": "ref/music#pygame.mixer.music.unload", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.unload() \n Unload the currently loaded music to free up resources unload() -> None  This closes resources like files for any music that may be loaded.  New in pygame 2.0.0.  \n"}, {"name": "mixer.music.unpause", "path": "ref/music#pygame.mixer.music.unpause", "type": "pygame.mixer.music", "text": "  pygame.mixer.music.unpause() \n resume paused music unpause() -> None  This will resume the playback of a music stream after it has been paused. \n"}, {"name": "mixer.pause", "path": "ref/mixer#pygame.mixer.pause", "type": "pygame.mixer", "text": "  pygame.mixer.pause() \n temporarily stop playback of all sound channels pause() -> None  This will temporarily stop all playback on the active mixer channels. The playback can later be resumed with pygame.mixer.unpause() \n"}, {"name": "mixer.pre_init", "path": "ref/mixer#pygame.mixer.pre_init", "type": "pygame.mixer", "text": "  pygame.mixer.pre_init() \n preset the mixer init arguments pre_init(frequency=44100, size=-16, channels=2, buffer=512, devicename=None) -> None  Call pre_init to change the defaults used when the real pygame.mixer.init() is called. Keyword arguments are accepted. The best way to set custom mixer playback values is to call pygame.mixer.pre_init() before calling the top level pygame.init(). For backward compatibility argument values of zero are replaced with the startup defaults.  Changed in pygame 1.8: The default buffersize was changed from 1024 to 3072.   Changed in pygame 1.9.1: The default buffersize was changed from 3072 to 4096.   Changed in pygame 2.0.0: The default buffersize was changed from 4096 to 512. The default frequency changed to 44100 from 22050.  \n"}, {"name": "mixer.quit", "path": "ref/mixer#pygame.mixer.quit", "type": "pygame.mixer", "text": "  pygame.mixer.quit() \n uninitialize the mixer quit() -> None  This will uninitialize pygame.mixer. All playback will stop and any loaded Sound objects may not be compatible with the mixer if it is reinitialized later. \n"}, {"name": "mixer.set_num_channels", "path": "ref/mixer#pygame.mixer.set_num_channels", "type": "pygame.mixer", "text": "  pygame.mixer.set_num_channels() \n set the total number of playback channels set_num_channels(count) -> None  Sets the number of available channels for the mixer. The default value is 8. The value can be increased or decreased. If the value is decreased, sounds playing on the truncated channels are stopped. \n"}, {"name": "mixer.set_reserved", "path": "ref/mixer#pygame.mixer.set_reserved", "type": "pygame.mixer", "text": "  pygame.mixer.set_reserved() \n reserve channels from being automatically used set_reserved(count) -> None  The mixer can reserve any number of channels that will not be automatically selected for playback by Sounds. If sounds are currently playing on the reserved channels they will not be stopped. This allows the application to reserve a specific number of channels for important sounds that must not be dropped or have a guaranteed channel to play on. \n"}, {"name": "mixer.Sound", "path": "ref/mixer#pygame.mixer.Sound", "type": "pygame.mixer", "text": "  pygame.mixer.Sound \n Create a new Sound object from a file or buffer object Sound(filename) -> Sound Sound(file=filename) -> Sound Sound(buffer) -> Sound Sound(buffer=buffer) -> Sound Sound(object) -> Sound Sound(file=object) -> Sound Sound(array=object) -> Sound  Load a new sound buffer from a filename, a python file object or a readable buffer object. Limited resampling will be performed to help the sample match the initialize arguments for the mixer. A Unicode string can only be a file pathname. A Python 2.x string or a Python 3.x bytes object can be either a pathname or a buffer object. Use the 'file' or 'buffer' keywords to avoid ambiguity; otherwise Sound may guess wrong. If the array keyword is used, the object is expected to export a version 3, C level array interface or, for Python 2.6 or later, a new buffer interface (The object is checked for a buffer interface first.) The Sound object represents actual sound sample data. Methods that change the state of the Sound object will the all instances of the Sound playback. A Sound object also exports an array interface, and, for Python 2.6 or later, a new buffer interface. The Sound can be loaded from an OGG audio file or from an uncompressed WAV. Note: The buffer will be copied internally, no data will be shared between it and the Sound object. For now buffer and array support is consistent with sndarray.make_sound for Numeric arrays, in that sample sign and byte order are ignored. This will change, either by correctly handling sign and byte order, or by raising an exception when different. Also, source samples are truncated to fit the audio sample size. This will not change.  New in pygame 1.8: pygame.mixer.Sound(buffer)   New in pygame 1.9.2: pygame.mixer.Sound keyword arguments and array interface support    play() \n begin sound playback play(loops=0, maxtime=0, fade_ms=0) -> Channel  Begin playback of the Sound (i.e., on the computer's speakers) on an available Channel. This will forcibly select a Channel, so playback may cut off a currently playing sound if necessary. The loops argument controls how many times the sample will be repeated after being played the first time. A value of 5 means that the sound will be played once, then repeated five times, and so is played a total of six times. The default value (zero) means the Sound is not repeated, and so is only played once. If loops is set to -1 the Sound will loop indefinitely (though you can still call stop() to stop it). The maxtime argument can be used to stop playback after a given number of milliseconds. The fade_ms argument will make the sound start playing at 0 volume and fade up to full volume over the time given. The sample may end before the fade-in is complete. This returns the Channel object for the channel that was selected. \n   stop() \n stop sound playback stop() -> None  This will stop the playback of this Sound on any active Channels. \n   fadeout() \n stop sound playback after fading out fadeout(time) -> None  This will stop playback of the sound after fading it out over the time argument in milliseconds. The Sound will fade and stop on all actively playing channels. \n   set_volume() \n set the playback volume for this Sound set_volume(value) -> None  This will set the playback volume (loudness) for this Sound. This will immediately affect the Sound if it is playing. It will also affect any future playback of this Sound.     \nParameters:\n\nvalue (float) -- volume in the range of 0.0 to 1.0 (inclusive)  If value < 0.0, the volume will not be changed If value > 1.0, the volume will be set to 1.0      \n   get_volume() \n get the playback volume get_volume() -> value  Return a value from 0.0 to 1.0 representing the volume for this Sound. \n   get_num_channels() \n count how many times this Sound is playing get_num_channels() -> count  Return the number of active channels this sound is playing on. \n   get_length() \n get the length of the Sound get_length() -> seconds  Return the length of this Sound in seconds. \n   get_raw() \n return a bytestring copy of the Sound samples. get_raw() -> bytes  Return a copy of the Sound object buffer as a bytes (for Python 3.x) or str (for Python 2.x) object.  New in pygame 1.9.2.  \n \n"}, {"name": "mixer.Sound.fadeout", "path": "ref/mixer#pygame.mixer.Sound.fadeout", "type": "pygame.mixer", "text": "  fadeout() \n stop sound playback after fading out fadeout(time) -> None  This will stop playback of the sound after fading it out over the time argument in milliseconds. The Sound will fade and stop on all actively playing channels. \n"}, {"name": "mixer.Sound.get_length", "path": "ref/mixer#pygame.mixer.Sound.get_length", "type": "pygame.mixer", "text": "  get_length() \n get the length of the Sound get_length() -> seconds  Return the length of this Sound in seconds. \n"}, {"name": "mixer.Sound.get_num_channels", "path": "ref/mixer#pygame.mixer.Sound.get_num_channels", "type": "pygame.mixer", "text": "  get_num_channels() \n count how many times this Sound is playing get_num_channels() -> count  Return the number of active channels this sound is playing on. \n"}, {"name": "mixer.Sound.get_raw", "path": "ref/mixer#pygame.mixer.Sound.get_raw", "type": "pygame.mixer", "text": "  get_raw() \n return a bytestring copy of the Sound samples. get_raw() -> bytes  Return a copy of the Sound object buffer as a bytes (for Python 3.x) or str (for Python 2.x) object.  New in pygame 1.9.2.  \n"}, {"name": "mixer.Sound.get_volume", "path": "ref/mixer#pygame.mixer.Sound.get_volume", "type": "pygame.mixer", "text": "  get_volume() \n get the playback volume get_volume() -> value  Return a value from 0.0 to 1.0 representing the volume for this Sound. \n"}, {"name": "mixer.Sound.play", "path": "ref/mixer#pygame.mixer.Sound.play", "type": "pygame.mixer", "text": "  play() \n begin sound playback play(loops=0, maxtime=0, fade_ms=0) -> Channel  Begin playback of the Sound (i.e., on the computer's speakers) on an available Channel. This will forcibly select a Channel, so playback may cut off a currently playing sound if necessary. The loops argument controls how many times the sample will be repeated after being played the first time. A value of 5 means that the sound will be played once, then repeated five times, and so is played a total of six times. The default value (zero) means the Sound is not repeated, and so is only played once. If loops is set to -1 the Sound will loop indefinitely (though you can still call stop() to stop it). The maxtime argument can be used to stop playback after a given number of milliseconds. The fade_ms argument will make the sound start playing at 0 volume and fade up to full volume over the time given. The sample may end before the fade-in is complete. This returns the Channel object for the channel that was selected. \n"}, {"name": "mixer.Sound.set_volume", "path": "ref/mixer#pygame.mixer.Sound.set_volume", "type": "pygame.mixer", "text": "  set_volume() \n set the playback volume for this Sound set_volume(value) -> None  This will set the playback volume (loudness) for this Sound. This will immediately affect the Sound if it is playing. It will also affect any future playback of this Sound.     \nParameters:\n\nvalue (float) -- volume in the range of 0.0 to 1.0 (inclusive)  If value < 0.0, the volume will not be changed If value > 1.0, the volume will be set to 1.0      \n"}, {"name": "mixer.Sound.stop", "path": "ref/mixer#pygame.mixer.Sound.stop", "type": "pygame.mixer", "text": "  stop() \n stop sound playback stop() -> None  This will stop the playback of this Sound on any active Channels. \n"}, {"name": "mixer.stop", "path": "ref/mixer#pygame.mixer.stop", "type": "pygame.mixer", "text": "  pygame.mixer.stop() \n stop playback of all sound channels stop() -> None  This will stop all playback of all active mixer channels. \n"}, {"name": "mixer.unpause", "path": "ref/mixer#pygame.mixer.unpause", "type": "pygame.mixer", "text": "  pygame.mixer.unpause() \n resume paused playback of sound channels unpause() -> None  This will resume all active sound channels after they have been paused. \n"}, {"name": "module-_sdl2.touch", "path": "ref/touch", "type": "pygame._sdl2.touch", "text": " pygame._sdl2.touch\n  \n pygame module to work with touch input   New in pygame 2: This module requires SDL2.    pygame._sdl2.touch.get_num_devices() \n get the number of touch devices get_num_devices() -> int  Return the number of available touch devices. \n   pygame._sdl2.touch.get_device() \n get the a touch device id for a given index get_device(index) -> touchid      \nParameters:\n\nindex (int) -- This number is at least 0 and less than the number of devices.    Return an integer id associated with the given index. \n   pygame._sdl2.touch.get_num_fingers() \n the number of active fingers for a given touch device get_num_fingers(touchid) -> int  Return the number of fingers active for the touch device whose id is touchid. \n   pygame._sdl2.touch.get_finger() \n get information about an active finger get_finger(touchid, index) -> int      \nParameters:\n\n \ntouchid (int) -- The touch device id. \nindex (int) -- The index of the finger to return information about, between 0 and the number of active fingers.      Return a dict for the finger index active on touchid. The dict contains these keys: id         the id of the finger (an integer).\nx          the normalized x position of the finger, between 0 and 1.\ny          the normalized y position of the finger, between 0 and 1.\npressure   the amount of pressure applied by the finger, between 0 and 1. \n \n \n"}, {"name": "module-camera", "path": "ref/camera", "type": "pygame.camera", "text": " pygame.camera\n  \n pygame module for camera use  Pygame currently supports only Linux and v4l2 cameras. EXPERIMENTAL!: This API may change or disappear in later pygame releases. If you use this, your code will very likely break with the next pygame release. The Bayer to RGB function is based on: Sonix SN9C101 based webcam basic I/F routines\nCopyright (C) 2004 Takafumi Mizuno <taka-qce@ls-a.jp>\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\nOR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\nOUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE. New in pygame 1.9.0.   pygame.camera.colorspace() \n Surface colorspace conversion colorspace(Surface, format, DestSurface = None) -> Surface  Allows for conversion from \"RGB\" to a destination colorspace of \"HSV\" or \"YUV\". The source and destination surfaces must be the same size and pixel depth. This is useful for computer vision on devices with limited processing power. Capture as small of an image as possible, transform.scale() it even smaller, and then convert the colorspace to YUV or HSV before doing any processing on it. \n   pygame.camera.list_cameras() \n returns a list of available cameras list_cameras() -> [cameras]  Checks the computer for available cameras and returns a list of strings of camera names, ready to be fed into pygame.camera.Camera. \n   pygame.camera.Camera \n load a camera Camera(device, (width, height), format) -> Camera  Loads a v4l2 camera. The device is typically something like \"/dev/video0\". Default width and height are 640 by 480. Format is the desired colorspace of the output. This is useful for computer vision purposes. The default is RGB. The following are supported:  \n \nRGB - Red, Green, Blue \nYUV - Luma, Blue Chrominance, Red Chrominance \nHSV - Hue, Saturation, Value  \n   start() \n opens, initializes, and starts capturing start() -> None  Opens the camera device, attempts to initialize it, and begins recording images to a buffer. The camera must be started before any of the below functions can be used. \n   stop() \n stops, uninitializes, and closes the camera stop() -> None  Stops recording, uninitializes the camera, and closes it. Once a camera is stopped, the below functions cannot be used until it is started again. \n   get_controls() \n gets current values of user controls get_controls() -> (hflip = bool, vflip = bool, brightness)  If the camera supports it, get_controls will return the current settings for horizontal and vertical image flip as bools and brightness as an int. If unsupported, it will return the default values of (0, 0, 0). Note that the return values here may be different than those returned by set_controls, though these are more likely to be correct. \n   set_controls() \n changes camera settings if supported by the camera set_controls(hflip = bool, vflip = bool, brightness) -> (hflip = bool, vflip = bool, brightness)  Allows you to change camera settings if the camera supports it. The return values will be the input values if the camera claims it succeeded or the values previously in use if not. Each argument is optional, and the desired one can be chosen by supplying the keyword, like hflip. Note that the actual settings being used by the camera may not be the same as those returned by set_controls. \n   get_size() \n returns the dimensions of the images being recorded get_size() -> (width, height)  Returns the current dimensions of the images being captured by the camera. This will return the actual size, which may be different than the one specified during initialization if the camera did not support that size. \n   query_image() \n checks if a frame is ready query_image() -> bool  If an image is ready to get, it returns true. Otherwise it returns false. Note that some webcams will always return False and will only queue a frame when called with a blocking function like get_image(). This is useful to separate the framerate of the game from that of the camera without having to use threading. \n   get_image() \n captures an image as a Surface get_image(Surface = None) -> Surface  Pulls an image off of the buffer as an RGB Surface. It can optionally reuse an existing Surface to save time. The bit-depth of the surface is either 24 bits or the same as the optionally supplied Surface. \n   get_raw() \n returns an unmodified image as a string get_raw() -> string  Gets an image from a camera as a string in the native pixelformat of the camera. Useful for integration with other libraries. \n \n \n \n"}, {"name": "module-cdrom", "path": "ref/cdrom", "type": "pygame.cdrom", "text": " pygame.cdrom\n  \n pygame module for audio cdrom control  The cdrom module manages the CD and DVD drives on a computer. It can also control the playback of audio CDs. This module needs to be initialized before it can do anything. Each CD object you create represents a cdrom drive and must also be initialized individually before it can do most things.   pygame.cdrom.init() \n initialize the cdrom module init() -> None  Initialize the cdrom module. This will scan the system for all CD devices. The module must be initialized before any other functions will work. This automatically happens when you call pygame.init(). It is safe to call this function more than once. \n   pygame.cdrom.quit() \n uninitialize the cdrom module quit() -> None  Uninitialize the cdrom module. After you call this any existing CD objects will no longer work. It is safe to call this function more than once. \n   pygame.cdrom.get_init() \n true if the cdrom module is initialized get_init() -> bool  Test if the cdrom module is initialized or not. This is different than the CD.init() since each drive must also be initialized individually. \n   pygame.cdrom.get_count() \n number of cd drives on the system get_count() -> count  Return the number of cd drives on the system. When you create CD objects you need to pass an integer id that must be lower than this count. The count will be 0 if there are no drives on the system. \n   pygame.cdrom.CD \n class to manage a cdrom drive CD(id) -> CD  You can create a CD object for each cdrom on the system. Use pygame.cdrom.get_count() to determine how many drives actually exist. The id argument is an integer of the drive, starting at zero. The CD object is not initialized, you can only call CD.get_id() and CD.get_name() on an uninitialized drive. It is safe to create multiple CD objects for the same drive, they will all cooperate normally.   init() \n initialize a cdrom drive for use init() -> None  Initialize the cdrom drive for use. The drive must be initialized for most CD methods to work. Even if the rest of pygame has been initialized. There may be a brief pause while the drive is initialized. Avoid CD.init() if the program should not stop for a second or two. \n   quit() \n uninitialize a cdrom drive for use quit() -> None  Uninitialize a drive for use. Call this when your program will not be accessing the drive for awhile. \n   get_init() \n true if this cd device initialized get_init() -> bool  Test if this CDROM device is initialized. This is different than the pygame.cdrom.init() since each drive must also be initialized individually. \n   play() \n start playing audio play(track, start=None, end=None) -> None  Playback audio from an audio cdrom in the drive. Besides the track number argument, you can also pass a starting and ending time for playback. The start and end time are in seconds, and can limit the section of an audio track played. If you pass a start time but no end, the audio will play to the end of the track. If you pass a start time and 'None' for the end time, the audio will play to the end of the entire disc. See the CD.get_numtracks() and CD.get_track_audio() to find tracks to playback. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   stop() \n stop audio playback stop() -> None  Stops playback of audio from the cdrom. This will also lose the current playback position. This method does nothing if the drive isn't already playing audio. \n   pause() \n temporarily stop audio playback pause() -> None  Temporarily stop audio playback on the CD. The playback can be resumed at the same point with the CD.resume() method. If the CD is not playing this method does nothing. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   resume() \n unpause audio playback resume() -> None  Unpause a paused CD. If the CD is not paused or already playing, this method does nothing. \n   eject() \n eject or open the cdrom drive eject() -> None  This will open the cdrom drive and eject the cdrom. If the drive is playing or paused it will be stopped. \n   get_id() \n the index of the cdrom drive get_id() -> id  Returns the integer id that was used to create the CD instance. This method can work on an uninitialized CD. \n   get_name() \n the system name of the cdrom drive get_name() -> name  Return the string name of the drive. This is the system name used to represent the drive. It is often the drive letter or device name. This method can work on an uninitialized CD. \n   get_busy() \n true if the drive is playing audio get_busy() -> bool  Returns True if the drive busy playing back audio. \n   get_paused() \n true if the drive is paused get_paused() -> bool  Returns True if the drive is currently paused. \n   get_current() \n the current audio playback position get_current() -> track, seconds  Returns both the current track and time of that track. This method works when the drive is either playing or paused. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   get_empty() \n False if a cdrom is in the drive get_empty() -> bool  Return False if there is a cdrom currently in the drive. If the drive is empty this will return True. \n   get_numtracks() \n the number of tracks on the cdrom get_numtracks() -> count  Return the number of tracks on the cdrom in the drive. This will return zero of the drive is empty or has no tracks. \n   get_track_audio() \n true if the cdrom track has audio data get_track_audio(track) -> bool  Determine if a track on a cdrom contains audio data. You can also call CD.num_tracks() and CD.get_all() to determine more information about the cdrom. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   get_all() \n get all track information get_all() -> [(audio, start, end, length), ...]  Return a list with information for every track on the cdrom. The information consists of a tuple with four values. The audio value is True if the track contains audio data. The start, end, and length values are floating point numbers in seconds. Start and end represent absolute times on the entire disc. \n   get_track_start() \n start time of a cdrom track get_track_start(track) -> seconds  Return the absolute time in seconds where at start of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero. \n   get_track_length() \n length of a cdrom track get_track_length(track) -> seconds  Return a floating point value in seconds of the length of the cdrom track. Note, track 0 is the first track on the CD. Track numbers start at zero. \n \n \n \n"}, {"name": "module-cursors", "path": "ref/cursors", "type": "pygame.cursors", "text": " pygame.cursors\n  \n pygame module for cursor resources  Pygame offers control over the system hardware cursor. Pygame only supports black and white cursors for the system. You control the cursor with functions inside pygame.mouse. This cursors module contains functions for loading and decoding various cursor formats. These allow you to easily store your cursors in external files or directly as encoded python strings. The module includes several standard cursors. The pygame.mouse.set_cursor() function takes several arguments. All those arguments have been stored in a single tuple you can call like this: >>> pygame.mouse.set_cursor(*pygame.cursors.arrow) The following variables can be passed to pygame.mouse.set_cursor function:  \n pygame.cursors.arrow pygame.cursors.diamond pygame.cursors.broken_x pygame.cursors.tri_left pygame.cursors.tri_right  \n This module also contains a few cursors as formatted strings. You'll need to pass these to pygame.cursors.compile() function before you can use them. The example call would look like this: >>> cursor = pygame.cursors.compile(pygame.cursors.textmarker_strings)\n>>> pygame.mouse.set_cursor((8, 16), (0, 0), *cursor) The following strings can be converted into cursor bitmaps with pygame.cursors.compile() :  \n pygame.cursors.thickarrow_strings pygame.cursors.sizer_x_strings pygame.cursors.sizer_y_strings pygame.cursors.sizer_xy_strings pygame.cursor.textmarker_strings  \n   pygame.cursors.compile() \n create binary cursor data from simple strings compile(strings, black='X', white='.', xor='o') -> data, mask  A sequence of strings can be used to create binary cursor data for the system cursor. This returns the binary data in the form of two tuples. Those can be passed as the third and fourth arguments respectively of the pygame.mouse.set_cursor() function. If you are creating your own cursor strings, you can use any value represent the black and white pixels. Some system allow you to set a special toggle color for the system color, this is also called the xor color. If the system does not support xor cursors, that color will simply be black. The height must be divisible by 8. The width of the strings must all be equal and be divisible by 8. If these two conditions are not met, ValueError is raised. An example set of cursor strings looks like this thickarrow_strings = (               #sized 24x24\n  \"XX                      \",\n  \"XXX                     \",\n  \"XXXX                    \",\n  \"XX.XX                   \",\n  \"XX..XX                  \",\n  \"XX...XX                 \",\n  \"XX....XX                \",\n  \"XX.....XX               \",\n  \"XX......XX              \",\n  \"XX.......XX             \",\n  \"XX........XX            \",\n  \"XX........XXX           \",\n  \"XX......XXXXX           \",\n  \"XX.XXX..XX              \",\n  \"XXXX XX..XX             \",\n  \"XX   XX..XX             \",\n  \"     XX..XX             \",\n  \"      XX..XX            \",\n  \"      XX..XX            \",\n  \"       XXXX             \",\n  \"       XX               \",\n  \"                        \",\n  \"                        \",\n  \"                        \") \n   pygame.cursors.load_xbm() \n load cursor data from an XBM file load_xbm(cursorfile) -> cursor_args load_xbm(cursorfile, maskfile) -> cursor_args  This loads cursors for a simple subset of XBM files. XBM files are traditionally used to store cursors on UNIX systems, they are an ASCII format used to represent simple images. Sometimes the black and white color values will be split into two separate XBM files. You can pass a second maskfile argument to load the two images into a single cursor. The cursorfile and maskfile arguments can either be filenames or file-like object with the readlines method. The return value cursor_args can be passed directly to the pygame.mouse.set_cursor() function. \n \n \n"}, {"name": "module-display", "path": "ref/display", "type": "pygame.display", "text": " pygame.display\n  \n pygame module to control the display window and screen  This module offers control over the pygame display. Pygame has a single display Surface that is either contained in a window or runs full screen. Once you create the display you treat it as a regular Surface. Changes are not immediately visible onscreen; you must choose one of the two flipping functions to update the actual display. The origin of the display, where x = 0 and y = 0, is the top left of the screen. Both axes increase positively towards the bottom right of the screen. The pygame display can actually be initialized in one of several modes. By default, the display is a basic software driven framebuffer. You can request special modules like hardware acceleration and OpenGL support. These are controlled by flags passed to pygame.display.set_mode(). Pygame can only have a single display active at any time. Creating a new one with pygame.display.set_mode() will close the previous display. If precise control is needed over the pixel format or display resolutions, use the functions pygame.display.mode_ok(), pygame.display.list_modes(), and pygame.display.Info() to query information about the display. Once the display Surface is created, the functions from this module affect the single existing display. The Surface becomes invalid if the module is uninitialized. If a new display mode is set, the existing Surface will automatically switch to operate on the new display. When the display mode is set, several events are placed on the pygame event queue. pygame.QUIT is sent when the user has requested the program to shut down. The window will receive pygame.ACTIVEEVENT events as the display gains and loses input focus. If the display is set with the pygame.RESIZABLE flag, pygame.VIDEORESIZE events will be sent when the user adjusts the window dimensions. Hardware displays that draw direct to the screen will get pygame.VIDEOEXPOSE events when portions of the window must be redrawn. In pygame 2, there is a new type of event called pygame.WINDOWEVENT that is meant to replace all window related events like pygame.VIDEORESIZE, pygame.VIDEOEXPOSE and pygame.ACTIVEEVENT. Note that the WINDOWEVENT API is considered experimental, and may change in future releases. The new events of type pygame.WINDOWEVENT have an event attribute that can take the following values. Value of event attribute      Short description\n\nWINDOWEVENT_SHOWN            Window became shown\nWINDOWEVENT_HIDDEN           Window became hidden\nWINDOWEVENT_EXPOSED          Window got updated by some external event\nWINDOWEVENT_MOVED            Window got moved\nWINDOWEVENT_RESIZED          Window got resized\nWINDOWEVENT_SIZE_CHANGED     Window changed it's size\nWINDOWEVENT_MINIMIZED        Window was minimised\nWINDOWEVENT_MAXIMIZED        Window was maximised\nWINDOWEVENT_RESTORED         Window was restored\nWINDOWEVENT_ENTER            Mouse entered the window\nWINDOWEVENT_LEAVE            Mouse left the window\nWINDOWEVENT_FOCUS_GAINED     Window gained focus\nWINDOWEVENT_FOCUS_LOST       Window lost focus\nWINDOWEVENT_CLOSE            Window was closed\nWINDOWEVENT_TAKE_FOCUS       Window was offered focus\nWINDOWEVENT_HIT_TEST         Window has a special hit test If SDL version used is less than 2.0.5, the last two values WINDOWEVENT_TAKE_FOCUS and WINDOWEVENT_HIT_TEST will not work. See the SDL implementation (in C programming) of the same over here. Some display environments have an option for automatically stretching all windows. When this option is enabled, this automatic stretching distorts the appearance of the pygame window. In the pygame examples directory, there is example code (prevent_display_stretching.py) which shows how to disable this automatic stretching of the pygame display on Microsoft Windows (Vista or newer required).   pygame.display.init() \n Initialize the display module init() -> None  Initializes the pygame display module. The display module cannot do anything until it is initialized. This is usually handled for you automatically when you call the higher level pygame.init(). Pygame will select from one of several internal display backends when it is initialized. The display mode will be chosen depending on the platform and permissions of current user. Before the display module is initialized the environment variable SDL_VIDEODRIVER can be set to control which backend is used. The systems with multiple choices are listed here. Windows : windib, directx\nUnix    : x11, dga, fbcon, directfb, ggi, vgl, svgalib, aalib On some platforms it is possible to embed the pygame display into an already existing window. To do this, the environment variable SDL_WINDOWID must be set to a string containing the window id or handle. The environment variable is checked when the pygame display is initialized. Be aware that there can be many strange side effects when running in an embedded display. It is harmless to call this more than once, repeated calls have no effect. \n   pygame.display.quit() \n Uninitialize the display module quit() -> None  This will shut down the entire display module. This means any active displays will be closed. This will also be handled automatically when the program exits. It is harmless to call this more than once, repeated calls have no effect. \n   pygame.display.get_init() \n Returns True if the display module has been initialized get_init() -> bool  Returns True if the pygame.display module is currently initialized. \n   pygame.display.set_mode() \n Initialize a window or screen for display set_mode(size=(0, 0), flags=0, depth=0, display=0, vsync=0) -> Surface  This function will create a display Surface. The arguments passed in are requests for a display type. The actual created display will be the best possible match supported by the system. The size argument is a pair of numbers representing the width and height. The flags argument is a collection of additional options. The depth argument represents the number of bits to use for color. The Surface that gets returned can be drawn to like a regular Surface but changes will eventually be seen on the monitor. If no size is passed or is set to (0, 0) and pygame uses SDL version 1.2.10 or above, the created Surface will have the same size as the current screen resolution. If only the width or height are set to 0, the Surface will have the same width or height as the screen resolution. Using a SDL version prior to 1.2.10 will raise an exception. It is usually best to not pass the depth argument. It will default to the best and fastest color depth for the system. If your game requires a specific color format you can control the depth with this argument. Pygame will emulate an unavailable color depth which can be slow. When requesting fullscreen display modes, sometimes an exact match for the requested size cannot be made. In these situations pygame will select the closest compatible match. The returned surface will still always match the requested size. On high resolution displays(4k, 1080p) and tiny graphics games (640x480) show up very small so that they are unplayable. SCALED scales up the window for you. The game thinks it's a 640x480 window, but really it can be bigger. Mouse events are scaled for you, so your game doesn't need to do it. Note that SCALED is considered an experimental API and may change in future releases. The flags argument controls which type of display you want. There are several to choose from, and you can even combine multiple types using the bitwise or operator, (the pipe \"|\" character). If you pass 0 or no flags argument it will default to a software driven window. Here are the display flags you will want to choose from: pygame.FULLSCREEN    create a fullscreen display\npygame.DOUBLEBUF     recommended for HWSURFACE or OPENGL\npygame.HWSURFACE     hardware accelerated, only in FULLSCREEN\npygame.OPENGL        create an OpenGL-renderable display\npygame.RESIZABLE     display window should be sizeable\npygame.NOFRAME       display window will have no border or controls Pygame 2 has the following additional flags available. pygame.SCALED        resolution depends on desktop size and scale\n                     graphics\npygame.SHOWN         window is opened in visible mode (default)\npygame.HIDDEN        window is opened in hidden mode  New in pygame 2.0.0: SCALED, SHOWN and HIDDEN  By setting the vsync parameter to 1, it is possible to get a display with vertical sync, but you are not guaranteed to get one. The request only works at all for calls to set_mode() with the pygame.OPENGL or pygame.SCALED flags set, and is still not guaranteed even with one of those set. What you get depends on the hardware and driver configuration of the system pygame is running on. Here is an example usage of a call to set_mode() that may give you a display with vsync: flags = pygame.OPENGL | pygame.FULLSCREEN\nwindow_surface = pygame.display.set_mode((1920, 1080), flags, vsync=1) Vsync behaviour is considered experimental, and may change in future releases.  New in pygame 2.0.0: vsync  Basic example: # Open a window on the screen\nscreen_width=700\nscreen_height=400\nscreen=pygame.display.set_mode([screen_width, screen_height]) The display index 0 means the default display is used.  Changed in pygame 1.9.5: display argument added  \n   pygame.display.get_surface() \n Get a reference to the currently set display surface get_surface() -> Surface  Return a reference to the currently set display Surface. If no display mode has been set this will return None. \n   pygame.display.flip() \n Update the full display Surface to the screen flip() -> None  This will update the contents of the entire display. If your display mode is using the flags pygame.HWSURFACE and pygame.DOUBLEBUF, this will wait for a vertical retrace and swap the surfaces. If you are using a different type of display mode, it will simply update the entire contents of the surface. When using an pygame.OPENGL display mode this will perform a gl buffer swap. \n   pygame.display.update() \n Update portions of the screen for software displays update(rectangle=None) -> None update(rectangle_list) -> None  This function is like an optimized version of pygame.display.flip() for software displays. It allows only a portion of the screen to updated, instead of the entire area. If no argument is passed it updates the entire Surface area like pygame.display.flip(). You can pass the function a single rectangle, or a sequence of rectangles. It is more efficient to pass many rectangles at once than to call update multiple times with single or a partial list of rectangles. If passing a sequence of rectangles it is safe to include None values in the list, which will be skipped. This call cannot be used on pygame.OPENGL displays and will generate an exception. \n   pygame.display.get_driver() \n Get the name of the pygame display backend get_driver() -> name  Pygame chooses one of many available display backends when it is initialized. This returns the internal name used for the display backend. This can be used to provide limited information about what display capabilities might be accelerated. See the SDL_VIDEODRIVER flags in pygame.display.set_mode() to see some of the common options. \n   pygame.display.Info() \n Create a video display information object Info() -> VideoInfo  Creates a simple object containing several attributes to describe the current graphics environment. If this is called before pygame.display.set_mode() some platforms can provide information about the default display mode. This can also be called after setting the display mode to verify specific display options were satisfied. The VidInfo object has several attributes: hw:         1 if the display is hardware accelerated\nwm:         1 if windowed display modes can be used\nvideo_mem:  The megabytes of video memory on the display. This is 0 if\n            unknown\nbitsize:    Number of bits used to store each pixel\nbytesize:   Number of bytes used to store each pixel\nmasks:      Four values used to pack RGBA values into pixels\nshifts:     Four values used to pack RGBA values into pixels\nlosses:     Four values used to pack RGBA values into pixels\nblit_hw:    1 if hardware Surface blitting is accelerated\nblit_hw_CC: 1 if hardware Surface colorkey blitting is accelerated\nblit_hw_A:  1 if hardware Surface pixel alpha blitting is accelerated\nblit_sw:    1 if software Surface blitting is accelerated\nblit_sw_CC: 1 if software Surface colorkey blitting is accelerated\nblit_sw_A:  1 if software Surface pixel alpha blitting is accelerated\ncurrent_h, current_w:  Height and width of the current video mode, or\n            of the desktop mode if called before the display.set_mode\n            is called. (current_h, current_w are available since\n            SDL 1.2.10, and pygame 1.8.0). They are -1 on error, or if\n            an old SDL is being used. \n   pygame.display.get_wm_info() \n Get information about the current windowing system get_wm_info() -> dict  Creates a dictionary filled with string keys. The strings and values are arbitrarily created by the system. Some systems may have no information and an empty dictionary will be returned. Most platforms will return a \"window\" key with the value set to the system id for the current display.  New in pygame 1.7.1.  \n   pygame.display.list_modes() \n Get list of available fullscreen modes list_modes(depth=0, flags=pygame.FULLSCREEN, display=0) -> list  This function returns a list of possible sizes for a specified color depth. The return value will be an empty list if no display modes are available with the given arguments. A return value of -1 means that any requested size should work (this is likely the case for windowed modes). Mode sizes are sorted from biggest to smallest. If depth is 0, the current/best color depth for the display is used. The flags defaults to pygame.FULLSCREEN, but you may need to add additional flags for specific fullscreen modes. The display index 0 means the default display is used.  Changed in pygame 1.9.5: display argument added  \n   pygame.display.mode_ok() \n Pick the best color depth for a display mode mode_ok(size, flags=0, depth=0, display=0) -> depth  This function uses the same arguments as pygame.display.set_mode(). It is used to determine if a requested display mode is available. It will return 0 if the display mode cannot be set. Otherwise it will return a pixel depth that best matches the display asked for. Usually the depth argument is not passed, but some platforms can support multiple display depths. If passed it will hint to which depth is a better match. The most useful flags to pass will be pygame.HWSURFACE, pygame.DOUBLEBUF, and maybe pygame.FULLSCREEN. The function will return 0 if these display flags cannot be set. The display index 0 means the default display is used.  Changed in pygame 1.9.5: display argument added  \n   pygame.display.gl_get_attribute() \n Get the value for an OpenGL flag for the current display gl_get_attribute(flag) -> value  After calling pygame.display.set_mode() with the pygame.OPENGL flag, it is a good idea to check the value of any requested OpenGL attributes. See pygame.display.gl_set_attribute() for a list of valid flags. \n   pygame.display.gl_set_attribute() \n Request an OpenGL display attribute for the display mode gl_set_attribute(flag, value) -> None  When calling pygame.display.set_mode() with the pygame.OPENGL flag, Pygame automatically handles setting the OpenGL attributes like color and double-buffering. OpenGL offers several other attributes you may want control over. Pass one of these attributes as the flag, and its appropriate value. This must be called before pygame.display.set_mode(). Many settings are the requested minimum. Creating a window with an OpenGL context will fail if OpenGL cannot provide the requested attribute, but it may for example give you a stencil buffer even if you request none, or it may give you a larger one than requested. The OPENGL flags are: GL_ALPHA_SIZE, GL_DEPTH_SIZE, GL_STENCIL_SIZE, GL_ACCUM_RED_SIZE,\nGL_ACCUM_GREEN_SIZE,  GL_ACCUM_BLUE_SIZE, GL_ACCUM_ALPHA_SIZE,\nGL_MULTISAMPLEBUFFERS, GL_MULTISAMPLESAMPLES, GL_STEREO GL_MULTISAMPLEBUFFERS  \nWhether to enable multisampling anti-aliasing. Defaults to 0 (disabled). Set GL_MULTISAMPLESAMPLES to a value above 0 to control the amount of anti-aliasing. A typical value is 2 or 3. \n GL_STENCIL_SIZE  Minimum bit size of the stencil buffer. Defaults to 0.\n GL_DEPTH_SIZE  Minimum bit size of the depth buffer. Defaults to 16.\n GL_STEREO  1 enables stereo 3D. Defaults to 0.\n GL_BUFFER_SIZE  Minimum bit size of the frame buffer. Defaults to 0.\n  New in pygame 2.0.0: Additional attributes:  GL_ACCELERATED_VISUAL,\nGL_CONTEXT_MAJOR_VERSION, GL_CONTEXT_MINOR_VERSION,\nGL_CONTEXT_FLAGS, GL_CONTEXT_PROFILE_MASK,\nGL_SHARE_WITH_CURRENT_CONTEXT,\nGL_CONTEXT_RELEASE_BEHAVIOR,\nGL_FRAMEBUFFER_SRGB_CAPABLE GL_CONTEXT_PROFILE_MASK  \nSets the OpenGL profile to one of these values: GL_CONTEXT_PROFILE_CORE             disable deprecated features\nGL_CONTEXT_PROFILE_COMPATIBILITY    allow deprecated features\nGL_CONTEXT_PROFILE_ES               allow only the ES feature\n                                    subset of OpenGL \n GL_ACCELERATED_VISUAL  Set to 1 to require hardware acceleration, or 0 to force software render. By default, both are allowed.\n \n   pygame.display.get_active() \n Returns True when the display is active on the screen get_active() -> bool  Returns True when the display Surface is considered actively renderable on the screen and may be visible to the user. This is the default state immediately after pygame.display.set_mode(). This method may return True even if the application is fully hidden behind another application window. This will return False if the display Surface has been iconified or minimized (either via pygame.display.iconify() or via an OS specific method such as the minimize-icon available on most desktops). The method can also return False for other reasons without the application being explicitly iconified or minimized by the user. A notable example being if the user has multiple virtual desktops and the display Surface is not on the active virtual desktop.  Note This function returning True is unrelated to whether the application has input focus. Please see pygame.key.get_focused() and pygame.mouse.get_focused() for APIs related to input focus.  \n   pygame.display.iconify() \n Iconify the display surface iconify() -> bool  Request the window for the display surface be iconified or hidden. Not all systems and displays support an iconified display. The function will return True if successful. When the display is iconified pygame.display.get_active() will return False. The event queue should receive an ACTIVEEVENT event when the window has been iconified. Additionally, the event queue also recieves a WINDOWEVENT_MINIMIZED event when the window has been iconified on pygame 2. \n   pygame.display.toggle_fullscreen() \n Switch between fullscreen and windowed displays toggle_fullscreen() -> int  Switches the display window between windowed and fullscreen modes. Display driver support is not great when using pygame 1, but with pygame 2 it is the most reliable method to switch to and from fullscreen. Supported display drivers in pygame 1:  \n x11 (Linux/Unix) wayland (Linux/Unix)  \n Supported display drivers in pygame 2:  \n windows (Windows) x11 (Linux/Unix) wayland (Linux/Unix) cocoa (OSX/Mac)  \n \n   pygame.display.set_gamma() \n Change the hardware gamma ramps set_gamma(red, green=None, blue=None) -> bool  Set the red, green, and blue gamma values on the display hardware. If the green and blue arguments are not passed, they will both be the same as red. Not all systems and hardware support gamma ramps, if the function succeeds it will return True. A gamma value of 1.0 creates a linear color table. Lower values will darken the display and higher values will brighten. \n   pygame.display.set_gamma_ramp() \n Change the hardware gamma ramps with a custom lookup set_gamma_ramp(red, green, blue) -> bool  Set the red, green, and blue gamma ramps with an explicit lookup table. Each argument should be sequence of 256 integers. The integers should range between 0 and 0xffff. Not all systems and hardware support gamma ramps, if the function succeeds it will return True. \n   pygame.display.set_icon() \n Change the system image for the display window set_icon(Surface) -> None  Sets the runtime icon the system will use to represent the display window. All windows default to a simple pygame logo for the window icon. You can pass any surface, but most systems want a smaller image around 32x32. The image can have colorkey transparency which will be passed to the system. Some systems do not allow the window icon to change after it has been shown. This function can be called before pygame.display.set_mode() to create the icon before the display mode is set. \n   pygame.display.set_caption() \n Set the current window caption set_caption(title, icontitle=None) -> None  If the display has a window title, this function will change the name on the window. Some systems support an alternate shorter title to be used for minimized displays. \n   pygame.display.get_caption() \n Get the current window caption get_caption() -> (title, icontitle)  Returns the title and icontitle for the display Surface. These will often be the same value. \n   pygame.display.set_palette() \n Set the display color palette for indexed displays set_palette(palette=None) -> None  This will change the video display color palette for 8-bit displays. This does not change the palette for the actual display Surface, only the palette that is used to display the Surface. If no palette argument is passed, the system default palette will be restored. The palette is a sequence of RGB triplets. \n   pygame.display.get_num_displays() \n Return the number of displays get_num_displays() -> int  Returns the number of available displays. This is always 1 if pygame.get_sdl_version() returns a major version number below 2.  New in pygame 1.9.5.  \n   pygame.display.get_window_size() \n Return the size of the window or screen get_window_size() -> tuple  Returns the size of the window initialized with pygame.display.set_mode(). This may differ from the size of the display surface if SCALED is used.  New in pygame 2.0.0.  \n   pygame.display.get_allow_screensaver() \n Return whether the screensaver is allowed to run. get_allow_screensaver() -> bool  Return whether screensaver is allowed to run whilst the app is running. Default is False. By default pygame does not allow the screensaver during game play.  Note Some platforms do not have a screensaver or support disabling the screensaver. Please see pygame.display.set_allow_screensaver() for caveats with screensaver support.   New in pygame 2.0.0.  \n   pygame.display.set_allow_screensaver() \n Set whether the screensaver may run set_allow_screensaver(bool) -> None  Change whether screensavers should be allowed whilst the app is running. The default is False. By default pygame does not allow the screensaver during game play. If the screensaver has been disallowed due to this function, it will automatically be allowed to run when pygame.quit() is called. It is possible to influence the default value via the environment variable SDL_HINT_VIDEO_ALLOW_SCREENSAVER, which can be set to either 0 (disable) or 1 (enable).  Note Disabling screensaver is subject to platform support. When platform support is absent, this function will silently appear to work even though the screensaver state is unchanged. The lack of feedback is due to SDL not providing any supported method for determining whether it supports changing the screensaver state. SDL_HINT_VIDEO_ALLOW_SCREENSAVER is available in SDL 2.0.2 or later. SDL1.2 does not implement this.   New in pygame 2.0.0.  \n \n \n"}, {"name": "module-draw", "path": "ref/draw", "type": "pygame.draw", "text": " pygame.draw\n  \n pygame module for drawing shapes  Draw several simple shapes to a surface. These functions will work for rendering to any format of surface. Rendering to hardware surfaces will be slower than regular software surfaces. Most of the functions take a width argument to represent the size of stroke (thickness) around the edge of the shape. If a width of 0 is passed the shape will be filled (solid). All the drawing functions respect the clip area for the surface and will be constrained to that area. The functions return a rectangle representing the bounding area of changed pixels. This bounding rectangle is the 'minimum' bounding box that encloses the affected area. All the drawing functions accept a color argument that can be one of the following formats:  \n a pygame.Color object an (RGB) triplet (tuple/list) an (RGBA) quadruplet (tuple/list) an integer value that has been mapped to the surface's pixel format (see pygame.Surface.map_rgb() and pygame.Surface.unmap_rgb())  \n A color's alpha value will be written directly into the surface (if the surface contains pixel alphas), but the draw function will not draw transparently. These functions temporarily lock the surface they are operating on. Many sequential drawing calls can be sped up by locking and unlocking the surface object around the draw calls (see pygame.Surface.lock() and pygame.Surface.unlock()).  Note See the pygame.gfxdraw module for alternative draw methods.    pygame.draw.rect() \n draw a rectangle rect(surface, color, rect) -> Rect rect(surface, color, rect, width=0, border_radius=0, border_top_left_radius=-1, border_top_right_radius=-1, border_bottom_left_radius=-1, border_bottom_right_radius=-1) -> Rect  Draws a rectangle on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nrect (Rect) -- rectangle to draw, position and dimensions \nwidth (int) -- (optional) used for line thickness or to indicate that the rectangle is to be filled (not to be confused with the width value of the rect parameter)  \n if width == 0, (default) fill the rectangle if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will grow outside the original boundary of the rect. For more details on how the thickness for edge lines grow, refer to the width notes of the pygame.draw.line() function.  \n  \nborder_radius (int) -- (optional) used for drawing rectangle with rounded corners. The supported range is [0, min(height, width) / 2], with 0 representing a rectangle without rounded corners. \nborder_top_left_radius (int) -- (optional) used for setting the value of top left border. If you don't set this value, it will use the border_radius value. \nborder_top_right_radius (int) -- (optional) used for setting the value of top right border. If you don't set this value, it will use the border_radius value. \nborder_bottom_left_radius (int) -- (optional) used for setting the value of bottom left border. If you don't set this value, it will use the border_radius value. \nborder_bottom_right_radius (int) -- (optional) used for setting the value of bottom right border. If you don't set this value, it will use the border_radius value.  \n if border_radius < 1 it will draw rectangle without rounded corners if any of border radii has the value < 0 it will use value of the border_radius If sum of radii on the same side of the rectangle is greater than the rect size the radii will get scaled  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given rect parameter and its width and height will be 0   \nReturn type:\n\nRect      Note The pygame.Surface.fill() method works just as well for drawing filled rectangles and can be hardware accelerated on some platforms with both software and hardware display modes.   Changed in pygame 2.0.0: Added support for keyword arguments.   Changed in pygame 2.0.0.dev8: Added support for border radius.  \n   pygame.draw.polygon() \n draw a polygon polygon(surface, color, points) -> Rect polygon(surface, color, points, width=0) -> Rect  Draws a polygon on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates that make up the vertices of the polygon, each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats, e.g. [(x1, y1), (x2, y2), (x3, y3)]\n \nwidth (int) -- (optional) used for line thickness or to indicate that the polygon is to be filled  \n if width == 0, (default) fill the polygon if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will grow outside the original boundary of the polygon. For more details on how the thickness for edge lines grow, refer to the width notes of the pygame.draw.line() function.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the points parameter (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nTypeError -- if points is not a sequence or points does not contain number pairs       Note For an aapolygon, use aalines() with closed=True.   Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.circle() \n draw a circle circle(surface, color, center, radius) -> Rect circle(surface, color, center, radius, width=0, draw_top_right=None, draw_top_left=None, draw_bottom_left=None, draw_bottom_right=None) -> Rect  Draws a circle on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \ncenter (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- center point of the circle as a sequence of 2 ints/floats, e.g. (x, y)\n \nradius (int or float) -- radius of the circle, measured from the center parameter, nothing will be drawn if the radius is less than 1 \nwidth (int) -- (optional) used for line thickness or to indicate that the circle is to be filled  \n if width == 0, (default) fill the circle if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will only grow inward.  \n  \ndraw_top_right (bool) -- (optional) if this is set to True then the top right corner of the circle will be drawn \ndraw_top_left (bool) -- (optional) if this is set to True then the top left corner of the circle will be drawn \ndraw_bottom_left (bool) -- (optional) if this is set to True then the bottom left corner of the circle will be drawn \ndraw_bottom_right (bool) -- (optional) if this is set to True then the bottom right corner of the circle will be drawn  \n if any of the draw_circle_part is True then it will draw all circle parts that have the True value, otherwise it will draw the entire circle.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the center parameter value (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nTypeError -- if center is not a sequence of two numbers \nTypeError -- if radius is not a number       Changed in pygame 2.0.0: Added support for keyword arguments. Nothing is drawn when the radius is 0 (a pixel at the center coordinates used to be drawn when the radius equaled 0). Floats, and Vector2 are accepted for the center param. The drawing algorithm was improved to look more like a circle.   Changed in pygame 2.0.0.dev8: Added support for drawing circle quadrants.  \n   pygame.draw.ellipse() \n draw an ellipse ellipse(surface, color, rect) -> Rect ellipse(surface, color, rect, width=0) -> Rect  Draws an ellipse on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nrect (Rect) -- rectangle to indicate the position and dimensions of the ellipse, the ellipse will be centered inside the rectangle and bounded by it \nwidth (int) -- (optional) used for line thickness or to indicate that the ellipse is to be filled (not to be confused with the width value of the rect parameter)  \n if width == 0, (default) fill the ellipse if width > 0, used for line thickness if width < 0, nothing will be drawn    Note When using width values > 1, the edge lines will only grow inward from the original boundary of the rect parameter.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given rect parameter and its width and height will be 0   \nReturn type:\n\nRect      Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.arc() \n draw an elliptical arc arc(surface, color, rect, start_angle, stop_angle) -> Rect arc(surface, color, rect, start_angle, stop_angle, width=1) -> Rect  Draws an elliptical arc on the given surface. The two angle arguments are given in radians and indicate the start and stop positions of the arc. The arc is drawn in a counterclockwise direction from the start_angle to the stop_angle.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nrect (Rect) -- rectangle to indicate the position and dimensions of the ellipse which the arc will be based on, the ellipse will be centered inside the rectangle \nstart_angle (float) -- start angle of the arc in radians \nstop_angle (float) -- stop angle of the arc in radians  \n if start_angle < stop_angle, the arc is drawn in a counterclockwise direction from the start_angle to the stop_angle\n if start_angle > stop_angle, tau (tau == 2 * pi) will be added to the stop_angle, if the resulting stop angle value is greater than the start_angle the above start_angle < stop_angle case applies, otherwise nothing will be drawn if start_angle == stop_angle, nothing will be drawn   \n  \nwidth (int) -- (optional) used for line thickness (not to be confused with the width value of the rect parameter)  \n if width == 0, nothing will be drawn if width > 0, (default is 1) used for line thickness if width < 0, same as width == 0\n   Note When using width values > 1, the edge lines will only grow inward from the original boundary of the rect parameter.  \n     \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given rect parameter and its width and height will be 0   \nReturn type:\n\nRect      Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.line() \n draw a straight line line(surface, color, start_pos, end_pos, width) -> Rect line(surface, color, start_pos, end_pos, width=1) -> Rect  Draws a straight line on the given surface. There are no endcaps. For thick lines the ends are squared off.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nstart_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- start position of the line, (x, y) \nend_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- end position of the line, (x, y) \nwidth (int) -- (optional) used for line thickness  if width >= 1, used for line thickness (default is 1) if width < 1, nothing will be drawn    Note When using width values > 1, lines will grow as follows. For odd width values, the thickness of each line grows with the original line being in the center. For even width values, the thickness of each line grows with the original line being offset from the center (as there is no exact center line drawn). As a result, lines with a slope < 1 (horizontal-ish) will have 1 more pixel of thickness below the original line (in the y direction). Lines with a slope >= 1 (vertical-ish) will have 1 more pixel of thickness to the right of the original line (in the x direction).      \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the start_pos parameter value (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\nTypeError -- if start_pos or end_pos is not a sequence of two numbers      Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.lines() \n draw multiple contiguous straight line segments lines(surface, color, closed, points) -> Rect lines(surface, color, closed, points, width=1) -> Rect  Draws a sequence of contiguous straight lines on the given surface. There are no endcaps or miter joints. For thick lines the ends are squared off. Drawing thick lines with sharp corners can have undesired looking results.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nclosed (bool) -- if True an additional line segment is drawn between the first and last points in the points sequence \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 2 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats and adjacent coordinates will be connected by a line segment, e.g. for the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2) and from (x2, y2) to (x3, y3), additionally if the closed parameter is True another line segment will be drawn from (x3, y3) to (x1, y1)\n \nwidth (int) -- (optional) used for line thickness  if width >= 1, used for line thickness (default is 1) if width < 1, nothing will be drawn    Note When using width values > 1 refer to the width notes of line() for details on how thick lines grow.      \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the points parameter (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nValueError -- if len(points) < 2 (must have at least 2 points) \nTypeError -- if points is not a sequence or points does not contain number pairs       Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.aaline() \n draw a straight antialiased line aaline(surface, color, start_pos, end_pos) -> Rect aaline(surface, color, start_pos, end_pos, blend=1) -> Rect  Draws a straight antialiased line on the given surface. The line has a thickness of one pixel and the endpoints have a height and width of one pixel each.  The way a line and it's endpoints are drawn: \nIf both endpoints are equal, only a single pixel is drawn (after rounding floats to nearest integer). Otherwise if the line is not steep (i.e. if the length along the x-axis is greater than the height along the y-axis):  \nFor each endpoint:  \nIf x, the endpoint's x-coordinate, is a whole number find which pixels would be covered by it and draw them. Otherwise:  \nCalculate the position of the nearest point with a whole number for it's x-coordinate, when extending the line past the endpoint. Find which pixels would be covered and how much by that point. If the endpoint is the left one, multiply the coverage by (1 - the decimal part of x). Otherwise multiply the coverage by the decimal part of x. Then draw those pixels.  e.g.: \n The left endpoint of the line ((1, 1.3), (5, 3)) would cover 70% of the pixel (1, 1) and 30% of the pixel (1, 2) while the right one would cover 100% of the pixel (5, 3). The left endpoint of the line ((1.2, 1.4), (4.6, 3.1)) would cover 56% (i.e. 0.8 * 70%) of the pixel (1, 1) and 24% (i.e. 0.8 * 30%) of the pixel (1, 2) while the right one would cover 42% (i.e. 0.6 * 70%) of the pixel (5, 3) and 18% (i.e. 0.6 * 30%) of the pixel (5, 4) while the right    \n \n Then for each point between the endpoints, along the line, whose x-coordinate is a whole number:  \nFind which pixels would be covered and how much by that point and draw them.  e.g.: \n The points along the line ((1, 1), (4, 2.5)) would be (2, 1.5) and (3, 2) and would cover 50% of the pixel (2, 1), 50% of the pixel (2, 2) and 100% of the pixel (3, 2). The points along the line ((1.2, 1.4), (4.6, 3.1)) would be (2, 1.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2)), (3, 2.3) (covering 70% of the pixel (3, 2) and 30% of the pixel (3, 3)) and (4,\n2.8) (covering 20% of the pixel (2, 1) and 80% of the pixel (2, 2))    \n \n Otherwise do the same for steep lines as for non-steep lines except along the y-axis instead of the x-axis (using y instead of x, top instead of left and bottom instead of right).    Note Regarding float values for coordinates, a point with coordinate consisting of two whole numbers is considered being right in the center of said pixel (and having a height and width of 1 pixel would therefore completely cover it), while a point with coordinate where one (or both) of the numbers have non-zero decimal parts would be partially covering two (or four if both numbers have decimal parts) adjacent pixels, e.g. the point (1.4, 2) covers 60% of the pixel (1, 2) and 40% of the pixel (2,2).      \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nstart_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- start position of the line, (x, y) \nend_pos (tuple(int or float, int or float) or list(int or float, int or float) or Vector2(int or float, int or float)) -- end position of the line, (x, y) \nblend (int) -- (optional) if non-zero (default) the line will be blended with the surface's existing pixel shades, otherwise it will overwrite them    \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the start_pos parameter value (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\nTypeError -- if start_pos or end_pos is not a sequence of two numbers      Changed in pygame 2.0.0: Added support for keyword arguments.  \n   pygame.draw.aalines() \n draw multiple contiguous straight antialiased line segments aalines(surface, color, closed, points) -> Rect aalines(surface, color, closed, points, blend=1) -> Rect  Draws a sequence of contiguous straight antialiased lines on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \ncolor (Color or int or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n \nclosed (bool) -- if True an additional line segment is drawn between the first and last points in the points sequence \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 2 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats and adjacent coordinates will be connected by a line segment, e.g. for the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2) and from (x2, y2) to (x3, y3), additionally if the closed parameter is True another line segment will be drawn from (x3, y3) to (x1, y1)\n \nblend (int) -- (optional) if non-zero (default) each line will be blended with the surface's existing pixel shades, otherwise the pixels will be overwritten    \nReturns:\n\na rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the points parameter (float values will be truncated) and its width and height will be 0   \nReturn type:\n\nRect   \nRaises:\n\n \nValueError -- if len(points) < 2 (must have at least 2 points) \nTypeError -- if points is not a sequence or points does not contain number pairs       Changed in pygame 2.0.0: Added support for keyword arguments.  \n   Example code for draw module.  # Import a library of functions called 'pygame'\nimport pygame\nfrom math import pi\n \n# Initialize the game engine\npygame.init()\n \n# Define the colors we will use in RGB format\nBLACK = (  0,   0,   0)\nWHITE = (255, 255, 255)\nBLUE =  (  0,   0, 255)\nGREEN = (  0, 255,   0)\nRED =   (255,   0,   0)\n \n# Set the height and width of the screen\nsize = [400, 300]\nscreen = pygame.display.set_mode(size)\n \npygame.display.set_caption(\"Example code for the draw module\")\n \n#Loop until the user clicks the close button.\ndone = False\nclock = pygame.time.Clock()\n \nwhile not done:\n \n    # This limits the while loop to a max of 10 times per second.\n    # Leave this out and we will use all CPU we can.\n    clock.tick(10)\n     \n    for event in pygame.event.get(): # User did something\n        if event.type == pygame.QUIT: # If user clicked close\n            done=True # Flag that we are done so we exit this loop\n \n    # All drawing code happens after the for loop and but\n    # inside the main while done==False loop.\n     \n    # Clear the screen and set the screen background\n    screen.fill(WHITE)\n \n    # Draw on the screen a GREEN line from (0, 0) to (50, 30) \n    # 5 pixels wide.\n    pygame.draw.line(screen, GREEN, [0, 0], [50,30], 5)\n \n    # Draw on the screen 3 BLACK lines, each 5 pixels wide.\n    # The 'False' means the first and last points are not connected.\n    pygame.draw.lines(screen, BLACK, False, [[0, 80], [50, 90], [200, 80], [220, 30]], 5)\n    \n    # Draw on the screen a GREEN line from (0, 50) to (50, 80) \n    # Because it is an antialiased line, it is 1 pixel wide.\n    pygame.draw.aaline(screen, GREEN, [0, 50],[50, 80], True)\n\n    # Draw a rectangle outline\n    pygame.draw.rect(screen, BLACK, [75, 10, 50, 20], 2)\n     \n    # Draw a solid rectangle\n    pygame.draw.rect(screen, BLACK, [150, 10, 50, 20])\n\n    # Draw a rectangle with rounded corners\n    pygame.draw.rect(screen, GREEN, [115, 210, 70, 40], 10, border_radius=15)\n    pygame.draw.rect(screen, RED, [135, 260, 50, 30], 0, border_radius=10, border_top_left_radius=0,\n                     border_bottom_right_radius=15)\n\n    # Draw an ellipse outline, using a rectangle as the outside boundaries\n    pygame.draw.ellipse(screen, RED, [225, 10, 50, 20], 2) \n\n    # Draw an solid ellipse, using a rectangle as the outside boundaries\n    pygame.draw.ellipse(screen, RED, [300, 10, 50, 20]) \n \n    # This draws a triangle using the polygon command\n    pygame.draw.polygon(screen, BLACK, [[100, 100], [0, 200], [200, 200]], 5)\n  \n    # Draw an arc as part of an ellipse. \n    # Use radians to determine what angle to draw.\n    pygame.draw.arc(screen, BLACK,[210, 75, 150, 125], 0, pi/2, 2)\n    pygame.draw.arc(screen, GREEN,[210, 75, 150, 125], pi/2, pi, 2)\n    pygame.draw.arc(screen, BLUE, [210, 75, 150, 125], pi,3*pi/2, 2)\n    pygame.draw.arc(screen, RED,  [210, 75, 150, 125], 3*pi/2, 2*pi, 2)\n    \n    # Draw a circle\n    pygame.draw.circle(screen, BLUE, [60, 250], 40)\n\n    # Draw only one circle quadrant\n    pygame.draw.circle(screen, BLUE, [250, 250], 40, 0, draw_top_right=True)\n    pygame.draw.circle(screen, RED, [250, 250], 40, 30, draw_top_left=True)\n    pygame.draw.circle(screen, GREEN, [250, 250], 40, 20, draw_bottom_left=True)\n    pygame.draw.circle(screen, BLACK, [250, 250], 40, 10, draw_bottom_right=True)\n\n    # Go ahead and update the screen with what we've drawn.\n    # This MUST happen after all the other drawing commands.\n    pygame.display.flip()\n \n# Be IDLE friendly\npygame.quit() \n \n"}, {"name": "module-event", "path": "ref/event", "type": "pygame.event", "text": " pygame.event\n  \n pygame module for interacting with events and queues  Pygame handles all its event messaging through an event queue. The routines in this module help you manage that event queue. The input queue is heavily dependent on the pygame.display module. If the display has not been initialized and a video mode not set, the event queue may not work properly. The event subsystem should be called from the main thread. If you want to post events into the queue from other threads, please use the pygame.fastevent module. The event queue has an upper limit on the number of events it can hold (128 for standard SDL 1.2). When the queue becomes full new events are quietly dropped. To prevent lost events, especially input events which signal a quit command, your program must handle events every frame (with pygame.event.get(), pygame.event.pump(), pygame.event.wait(), pygame.event.peek() or pygame.event.clear()) and process them. Not handling events may cause your system to decide your program has locked up. To speed up queue processing use pygame.event.set_blocked() to limit which events get queued. To get the state of various input devices, you can forego the event queue and access the input devices directly with their appropriate modules: pygame.mouse, pygame.key, and pygame.joystick. If you use this method, remember that pygame requires some form of communication with the system window manager and other parts of the platform. To keep pygame in sync with the system, you will need to call pygame.event.pump() to keep everything current. Usually, this should be called once per game loop. Note: Joysticks will not send any events until the device has been initialized. The event queue contains pygame.event.EventType event objects. There are a variety of ways to access the queued events, from simply checking for the existence of events, to grabbing them directly off the stack. The event queue also offers some simple filtering which can slightly help performance by blocking certain event types from the queue. Use pygame.event.set_allowed() and pygame.event.set_blocked() to change this filtering. By default, all event types can be placed on the queue. All pygame.event.EventType instances contain an event type identifier and attributes specific to that event type. The event type identifier is accessible as the pygame.event.EventType.type property. Any of the event specific attributes can be accessed through the pygame.event.EventType.__dict__ attribute or directly as an attribute of the event object (as member lookups are passed through to the object's dictionary values). The event object has no method functions. Users can create their own new events with the pygame.event.Event() function. The event type identifier is in between the values of NOEVENT and NUMEVENTS. User defined events should have a value in the inclusive range of USEREVENT to NUMEVENTS - 1. It is recommended all user events follow this system. Events support equality and inequality comparisons. Two events are equal if they are the same type and have identical attribute values. While debugging and experimenting, you can print an event object for a quick display of its type and members. The function pygame.event.event_name() can be used to get a string representing the name of the event type. Events that come from the system will have a guaranteed set of member attributes based on the type. The following is a list event types with their specific attributes. QUIT              none\nACTIVEEVENT       gain, state\nKEYDOWN           key, mod, unicode, scancode\nKEYUP             key, mod\nMOUSEMOTION       pos, rel, buttons\nMOUSEBUTTONUP     pos, button\nMOUSEBUTTONDOWN   pos, button\nJOYAXISMOTION     joy (deprecated), instance_id, axis, value\nJOYBALLMOTION     joy (deprecated), instance_id, ball, rel\nJOYHATMOTION      joy (deprecated), instance_id, hat, value\nJOYBUTTONUP       joy (deprecated), instance_id, button\nJOYBUTTONDOWN     joy (deprecated), instance_id, button\nVIDEORESIZE       size, w, h\nVIDEOEXPOSE       none\nUSEREVENT         code  Changed in pygame 2.0.0: The joy attribute was deprecated, instance_id was added.  You can also find a list of constants for keyboard keys here.    On MacOSX when a file is opened using a pygame application, a USEREVENT with its code attribute set to pygame.USEREVENT_DROPFILE is generated. There is an additional attribute called filename where the name of the file being accessed is stored. USEREVENT         code=pygame.USEREVENT_DROPFILE, filename  New in pygame 1.9.2.     When compiled with SDL2, pygame has these additional events and their attributes. AUDIODEVICEADDED   which, iscapture\nAUDIODEVICEREMOVED which, iscapture\nFINGERMOTION       touch_id, finger_id, x, y, dx, dy\nFINGERDOWN         touch_id, finger_id, x, y, dx, dy\nFINGERUP           touch_id, finger_id, x, y, dx, dy\nMOUSEWHEEL         which, flipped, x, y\nMULTIGESTURE       touch_id, x, y, pinched, rotated, num_fingers\nTEXTEDITING        text, start, length\nTEXTINPUT          text\nWINDOWEVENT        event  New in pygame 1.9.5.     pygame can recognize text or files dropped in its window. If a file is dropped, file will be its path. The DROPTEXT event is only supported on X11. DROPBEGIN\nDROPCOMPLETE\nDROPFILE        file\nDROPTEXT        text  New in pygame 2.0.0.     Events reserved for pygame.midi use. MIDIIN\nMIDIOUT  New in pygame 2.0.0.     SDL2 supports controller hotplugging: CONTROLLERDEVICEADDED    device_index\nJOYDEVICEADDED           device_index\nCONTROLLERDEVICEREMOVED  instance_id\nJOYDEVICEREMOVED         instance_id\nCONTROLLERDEVICEREMAPPED instance_id Also in this version, instance_id attributes were added to joystick events, and the joy attribute was deprecated.  New in pygame 2.0.0.       pygame.event.pump() \n internally process pygame event handlers pump() -> None  For each frame of your game, you will need to make some sort of call to the event queue. This ensures your program can internally interact with the rest of the operating system. If you are not using other event functions in your game, you should call pygame.event.pump() to allow pygame to handle internal actions. This function is not necessary if your program is consistently processing events on the queue through the other pygame.event functions. There are important things that must be dealt with internally in the event queue. The main window may need to be repainted or respond to the system. If you fail to make a call to the event queue for too long, the system may decide your program has locked up.  Caution This function should only be called in the thread that initialized pygame.display.  \n   pygame.event.get() \n get events from the queue get(eventtype=None) -> Eventlist get(eventtype=None, pump=True) -> Eventlist  This will get all the messages and remove them from the queue. If a type or sequence of types is given only those messages will be removed from the queue. If you are only taking specific events from the queue, be aware that the queue could eventually fill up with the events you are not interested. If pump is True (the default), then pygame.event.pump() will be called.  Changed in pygame 1.9.5: Added pump argument  \n   pygame.event.poll() \n get a single event from the queue poll() -> EventType instance  Returns a single event from the queue. If the event queue is empty an event of type pygame.NOEVENT will be returned immediately. The returned event is removed from the queue.  Caution This function should only be called in the thread that initialized pygame.display.  \n   pygame.event.wait() \n wait for a single event from the queue wait() -> EventType instance wait(timeout) -> EventType instance  Returns a single event from the queue. If the queue is empty this function will wait until one is created. From pygame 2.0.0, if a timeout argument is given, the function will return an event of type pygame.NOEVENT if no events enter the queue in timeout milliseconds. The event is removed from the queue once it has been returned. While the program is waiting it will sleep in an idle state. This is important for programs that want to share the system with other applications.  Changed in pygame 2.0.0.dev13: Added timeout argument   Caution This function should only be called in the thread that initialized pygame.display.  \n   pygame.event.peek() \n test if event types are waiting on the queue peek(eventtype=None) -> bool peek(eventtype=None, pump=True) -> bool  Returns True if there are any events of the given type waiting on the queue. If a sequence of event types is passed, this will return True if any of those events are on the queue. If pump is True (the default), then pygame.event.pump() will be called.  Changed in pygame 1.9.5: Added pump argument  \n   pygame.event.clear() \n remove all events from the queue clear(eventtype=None) -> None clear(eventtype=None, pump=True) -> None  Removes all events from the queue. If eventtype is given, removes the given event or sequence of events. This has the same effect as pygame.event.get() except None is returned. It can be slightly more efficient when clearing a full event queue. If pump is True (the default), then pygame.event.pump() will be called.  Changed in pygame 1.9.5: Added pump argument  \n   pygame.event.event_name() \n get the string name from an event id event_name(type) -> string  Returns a string representing the name (in CapWords style) of the given event type. \"UserEvent\" is returned for all values in the user event id range. \"Unknown\" is returned when the event type does not exist. \n   pygame.event.set_blocked() \n control which events are allowed on the queue set_blocked(type) -> None set_blocked(typelist) -> None set_blocked(None) -> None  The given event types are not allowed to appear on the event queue. By default all events can be placed on the queue. It is safe to disable an event type multiple times. If None is passed as the argument, ALL of the event types are blocked from being placed on the queue. \n   pygame.event.set_allowed() \n control which events are allowed on the queue set_allowed(type) -> None set_allowed(typelist) -> None set_allowed(None) -> None  The given event types are allowed to appear on the event queue. By default, all event types can be placed on the queue. It is safe to enable an event type multiple times. If None is passed as the argument, ALL of the event types are allowed to be placed on the queue. \n   pygame.event.get_blocked() \n test if a type of event is blocked from the queue get_blocked(type) -> bool get_blocked(typelist) -> bool  Returns True if the given event type is blocked from the queue. If a sequence of event types is passed, this will return True if any of those event types are blocked. \n   pygame.event.set_grab() \n control the sharing of input devices with other applications set_grab(bool) -> None  When your program runs in a windowed environment, it will share the mouse and keyboard devices with other applications that have focus. If your program sets the event grab to True, it will lock all input into your program. It is best to not always grab the input, since it prevents the user from doing other things on their system. \n   pygame.event.get_grab() \n test if the program is sharing input devices get_grab() -> bool  Returns True when the input events are grabbed for this application. \n   pygame.event.post() \n place a new event on the queue post(Event) -> None  Places the given event at the end of the event queue. This is usually used for placing pygame.USEREVENT events on the queue. Although any type of event can be placed, if using the system event types your program should be sure to create the standard attributes with appropriate values. If the event queue is full a pygame.error is raised. Caution: In pygame 2.0, calling this function with event types defined by pygame (such as pygame.KEYDOWN) may put events into the SDL2 event queue. In this case, an error may be raised if standard attributes of that event are missing or have incompatible values, and unexpected properties may be silently omitted. In order to avoid this behaviour, custom event properties should be used with custom event types. This behaviour is not guaranteed. \n   pygame.event.custom_type() \n make custom user event type custom_type() -> int  Reserves a pygame.USEREVENT for a custom use. If too many events are made a pygame.error is raised.  New in pygame 2.0.0.dev3.  \n   pygame.event.Event() \n create a new event object Event(type, dict) -> EventType instance Event(type, **attributes) -> EventType instance  Creates a new event with the given type and attributes. The attributes can come from a dictionary argument with string keys or from keyword arguments. \n   pygame.event.EventType \n pygame object for representing events  A pygame object that represents an event. User event instances are created with an pygame.event.Event() function call. The EventType type is not directly callable. EventType instances support attribute assignment and deletion.   type \n event type identifier. type -> int  Read-only. The event type identifier. For user created event objects, this is the type argument passed to pygame.event.Event(). For example, some predefined event identifiers are QUIT and MOUSEMOTION. \n   __dict__ \n event attribute dictionary __dict__ -> dict  Read-only. The event type specific attributes of an event. The dict attribute is a synonym for backward compatibility. For example, the attributes of a KEYDOWN event would be unicode, key, and mod \n  New in pygame 1.9.2: Mutable attributes.  \n \n \n"}, {"name": "module-examples", "path": "ref/examples", "type": "pygame.examples", "text": " pygame.examples\n  \n module of example programs  These examples should help get you started with pygame. Here is a brief rundown of what you get. The source code for these examples is in the public domain. Feel free to use for your own projects. There are several ways to run the examples. First they can be run as stand-alone programs. Second they can be imported and their main() methods called (see below). Finally, the easiest way is to use the python -m option: python -m pygame.examples.<example name> <example arguments> eg: python -m pygame.examples.scaletest someimage.png Resources such as images and sounds for the examples are found in the pygame/examples/data subdirectory. You can find where the example files are installed by using the following commands inside the python interpreter. >>> import pygame.examples.scaletest\n>>> pygame.examples.scaletest.__file__\n'/usr/lib/python2.6/site-packages/pygame/examples/scaletest.py' On each OS and version of Python the location will be slightly different. For example on Windows it might be in 'C:/Python26/Lib/site-packages/pygame/examples/' On Mac OS X it might be in '/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/site-packages/pygame/examples/' You can also run the examples in the python interpreter by calling each modules main() function. >>> import pygame.examples.scaletest\n>>> pygame.examples.scaletest.main() We're always on the lookout for more examples and/or example requests. Code like this is probably the best way to start getting involved with python gaming. examples as a package is new to pygame 1.9.0. But most of the examples came with pygame much earlier.   aliens.main() \n play the full aliens example aliens.main() -> None  This started off as a port of the SDL demonstration, Aliens. Now it has evolved into something sort of resembling fun. This demonstrates a lot of different uses of sprites and optimized blitting. Also transparency, colorkeys, fonts, sound, music, joystick, and more. (PS, my high score is 117! goodluck) \n   oldalien.main() \n play the original aliens example oldalien.main() -> None  This more closely resembles a port of the SDL Aliens demo. The code is a lot simpler, so it makes a better starting point for people looking at code for the first times. These blitting routines are not as optimized as they should/could be, but the code is easier to follow, and it plays quick enough. \n   stars.main() \n run a simple starfield example stars.main() -> None  A simple starfield example. You can change the center of perspective by leftclicking the mouse on the screen. \n   chimp.main() \n hit the moving chimp chimp.main() -> None  This simple example is derived from the line-by-line tutorial that comes with pygame. It is based on a 'popular' web banner. Note there are comments here, but for the full explanation, follow along in the tutorial. \n   moveit.main() \n display animated objects on the screen moveit.main() -> None  This is the full and final example from the Pygame Tutorial, \"How Do I Make It Move\". It creates 10 objects and animates them on the screen. Note it's a bit scant on error checking, but it's easy to read. :] Fortunately, this is python, and we needn't wrestle with a pile of error codes. \n   fonty.main() \n run a font rendering example fonty.main() -> None  Super quick, super simple application demonstrating the different ways to render fonts with the font module \n   freetype_misc.main() \n run a FreeType rendering example freetype_misc.main() -> None  A showcase of rendering features the pygame.freetype.Font class provides in addition to those available with pygame.font.Font. It is a demonstration of direct to surface rendering, with vertical text and rotated text, opaque text and semi transparent text, horizontally stretched text and vertically stretched text. \n   vgrade.main() \n display a vertical gradient vgrade.main() -> None  Demonstrates creating a vertical gradient with pixelcopy and NumPy python. The app will create a new gradient every half second and report the time needed to create and display the image. If you're not prepared to start working with the NumPy arrays, don't worry about the source for this one :] \n   eventlist.main() \n display pygame events eventlist.main() -> None  Eventlist is a sloppy style of pygame, but is a handy tool for learning about pygame events and input. At the top of the screen are the state of several device values, and a scrolling list of events are displayed on the bottom. This is not quality 'ui' code at all, but you can see how to implement very non-interactive status displays, or even a crude text output control. \n   arraydemo.main() \n show various surfarray effects arraydemo.main(arraytype=None) -> None  Another example filled with various surfarray effects. It requires the surfarray and image modules to be installed. This little demo can also make a good starting point for any of your own tests with surfarray The arraytype parameter is deprecated; passing any value besides 'numpy' will raise ValueError. \n   sound.main() \n load and play a sound sound.main(file_path=None) -> None  Extremely basic testing of the mixer module. Load a sound and play it. All from the command shell, no graphics. If provided, use the audio file 'file_path', otherwise use a default file. sound.py optional command line argument: an audio file \n   sound_array_demos.main() \n play various sndarray effects sound_array_demos.main(arraytype=None) -> None  Uses sndarray and NumPy to create offset faded copies of the original sound. Currently it just uses hardcoded values for the number of echoes and the delay. Easy for you to recreate as needed. The arraytype parameter is deprecated; passing any value besides 'numpy' will raise ValueError. \n   liquid.main() \n display an animated liquid effect liquid.main() -> None  This example was created in a quick comparison with the BlitzBasic gaming language. Nonetheless, it demonstrates a quick 8-bit setup (with colormap). \n   glcube.main() \n display an animated 3D cube using OpenGL glcube.main() -> None  Using PyOpenGL and pygame, this creates a spinning 3D multicolored cube. \n   scrap_clipboard.main() \n access the clipboard scrap_clipboard.main() -> None  A simple demonstration example for the clipboard support. \n   mask.main() \n display multiple images bounce off each other using collision detection mask.main(*args) -> None  Positional arguments: one or more image file names. This pygame.masks demo will display multiple moving sprites bouncing off each other. More than one sprite image can be provided. If run as a program then mask.py takes one or more image files as command line arguments. \n   testsprite.main() \n show lots of sprites moving around testsprite.main(update_rects = True, use_static = False, use_FastRenderGroup = False, screen_dims = [640, 480], use_alpha = False, flags = 0) -> None  Optional keyword arguments: update_rects - use the RenderUpdate sprite group class\nuse_static - include non-moving images\nuse_FastRenderGroup - Use the FastRenderGroup sprite group\nscreen_dims - pygame window dimensions\nuse_alpha - use alpha blending\nflags - additional display mode flags Like the testsprite.c that comes with SDL, this pygame version shows lots of sprites moving around. If run as a stand-alone program then no command line arguments are taken. \n   headless_no_windows_needed.main() \n write an image file that is smoothscaled copy of an input file headless_no_windows_needed.main(fin, fout, w, h) -> None  arguments: fin - name of an input image file\nfout - name of the output file to create/overwrite\nw, h - size of the rescaled image, as integer width and height How to use pygame with no windowing system, like on headless servers. Thumbnail generation with scaling is an example of what you can do with pygame. NOTE: the pygame scale function uses MMX/SSE if available, and can be run in multiple threads. If headless_no_windows_needed.py is run as a program it takes the following command line arguments: -scale inputimage outputimage new_width new_height\neg. -scale in.png outpng 50 50 \n   fastevents.main() \n stress test the fastevents module fastevents.main() -> None  This is a stress test for the fastevents module.  \n Fast events does not appear faster!   \n So far it looks like normal pygame.event is faster by up to two times. So maybe fastevent isn't fast at all. Tested on Windows XP SP2 Athlon, and FreeBSD. However... on my Debian Duron 850 machine fastevents is faster. \n   overlay.main() \n play a .pgm video using overlays overlay.main(fname) -> None  Play the .pgm video file given by a path fname. If run as a program overlay.py takes the file name as a command line argument. \n   blend_fill.main() \n demonstrate the various surface.fill method blend options blend_fill.main() -> None  A interactive demo that lets one choose which BLEND_xxx option to apply to a surface. \n   blit_blends.main() \n uses alternative additive fill to that of surface.fill blit_blends.main() -> None  Fake additive blending. Using NumPy. it doesn't clamp. Press r,g,b Somewhat like blend_fill. \n   cursors.main() \n display two different custom cursors cursors.main() -> None  Display an arrow or circle with crossbar cursor. \n   pixelarray.main() \n display various pixelarray generated effects pixelarray.main() -> None  Display various pixelarray generated effects. \n   scaletest.main() \n interactively scale an image using smoothscale scaletest.main(imagefile, convert_alpha=False, run_speed_test=True) -> None  arguments: imagefile - file name of source image (required)\nconvert_alpha - use convert_alpha() on the surf (default False)\nrun_speed_test - (default False) A smoothscale example that resized an image on the screen. Vertical and horizontal arrow keys are used to change the width and height of the displayed image. If the convert_alpha option is True then the source image is forced to have source alpha, whether or not the original images does. If run_speed_test is True then a background timing test is performed instead of the interactive scaler. If scaletest.py is run as a program then the command line options are: ImageFile [-t] [-convert_alpha]\n[-t] = Run Speed Test\n[-convert_alpha] = Use convert_alpha() on the surf. \n   midi.main() \n run a midi example midi.main(mode='output', device_id=None) -> None  Arguments: mode - if 'output' run a midi keyboard output example\n          'input' run a midi event logger input example\n          'list' list available midi devices\n       (default 'output')\ndevice_id - midi device number; if None then use the default midi input or\n            output device for the system The output example shows how to translate mouse clicks or computer keyboard events into midi notes. It implements a rudimentary button widget and state machine. The input example shows how to translate midi input to pygame events. With the use of a virtual midi patch cord the output and input examples can be run as separate processes and connected so the keyboard output is displayed on a console. new to pygame 1.9.0 \n   scroll.main() \n run a Surface.scroll example that shows a magnified image scroll.main(image_file=None) -> None  This example shows a scrollable image that has a zoom factor of eight. It uses the Surface.scroll() function to shift the image on the display surface. A clip rectangle protects a margin area. If called as a function, the example accepts an optional image file path. If run as a program it takes an optional file path command line argument. If no file is provided a default image file is used. When running click on a black triangle to move one pixel in the direction the triangle points. Or use the arrow keys. Close the window or press ESC to quit. \n   camera.main() \n display video captured live from an attached camera camera.main() -> None  A simple live video player, it uses the first available camera it finds on the system. \n   playmus.main() \n play an audio file playmus.main(file_path) -> None  A simple music player with window and keyboard playback control. Playback can be paused and rewound to the beginning. \n \n \n"}, {"name": "module-fastevent", "path": "ref/fastevent", "type": "pygame.fastevent", "text": " pygame.fastevent\n  \n pygame module for interacting with events and queues  pygame.fastevent is a wrapper for Bob Pendleton's fastevent library. It provides fast events for use in multithreaded environments. When using pygame.fastevent, you can not use any of the pump, wait, poll, post, get, peek, etc. functions from pygame.event, but you should use the Event objects.   pygame.fastevent.init() \n initialize pygame.fastevent init() -> None  Initialize the pygame.fastevent module. \n   pygame.fastevent.get_init() \n returns True if the fastevent module is currently initialized get_init() -> bool  Returns True if the pygame.fastevent module is currently initialized. \n   pygame.fastevent.pump() \n internally process pygame event handlers pump() -> None  For each frame of your game, you will need to make some sort of call to the event queue. This ensures your program can internally interact with the rest of the operating system. This function is not necessary if your program is consistently processing events on the queue through the other pygame.fastevent functions. There are important things that must be dealt with internally in the event queue. The main window may need to be repainted or respond to the system. If you fail to make a call to the event queue for too long, the system may decide your program has locked up. \n   pygame.fastevent.wait() \n wait for an event wait() -> Event  Returns the current event on the queue. If there are no messages waiting on the queue, this will not return until one is available. Sometimes it is important to use this wait to get events from the queue, it will allow your application to idle when the user isn't doing anything with it. \n   pygame.fastevent.poll() \n get an available event poll() -> Event  Returns next event on queue. If there is no event waiting on the queue, this will return an event with type NOEVENT. \n   pygame.fastevent.get() \n get all events from the queue get() -> list of Events  This will get all the messages and remove them from the queue. \n   pygame.fastevent.post() \n place an event on the queue post(Event) -> None  This will post your own event objects onto the event queue. You can post any event type you want, but some care must be taken. For example, if you post a MOUSEBUTTONDOWN event to the queue, it is likely any code receiving the event will expect the standard MOUSEBUTTONDOWN attributes to be available, like 'pos' and 'button'. Because pygame.fastevent.post() may have to wait for the queue to empty, you can get into a dead lock if you try to append an event on to a full queue from the thread that processes events. For that reason I do not recommend using this function in the main thread of an SDL program. \n \n \n"}, {"name": "module-font", "path": "ref/font", "type": "pygame.font", "text": " pygame.font\n  \n pygame module for loading and rendering fonts  The font module allows for rendering TrueType fonts into a new Surface object. It accepts any UCS-2 character ('u0001' to 'uFFFF'). This module is optional and requires SDL_ttf as a dependency. You should test that pygame.font is available and initialized before attempting to use the module. Most of the work done with fonts are done by using the actual Font objects. The module by itself only has routines to initialize the module and create Font objects with pygame.font.Font(). You can load fonts from the system by using the pygame.font.SysFont() function. There are a few other functions to help lookup the system fonts. Pygame comes with a builtin default font. This can always be accessed by passing None as the font name. To use the pygame.freetype based pygame.ftfont as pygame.font define the environment variable PYGAME_FREETYPE before the first import of pygame. Module pygame.ftfont is a pygame.font compatible module that passes all but one of the font module unit tests: it does not have the UCS-2 limitation of the SDL_ttf based font module, so fails to raise an exception for a code point greater than 'uFFFF'. If pygame.freetype is unavailable then the SDL_ttf font module will be loaded instead.   pygame.font.init() \n initialize the font module init() -> None  This method is called automatically by pygame.init(). It initializes the font module. The module must be initialized before any other functions will work. It is safe to call this function more than once. \n   pygame.font.quit() \n uninitialize the font module quit() -> None  Manually uninitialize SDL_ttf's font system. This is called automatically by pygame.quit(). It is safe to call this function even if font is currently not initialized. \n   pygame.font.get_init() \n true if the font module is initialized get_init() -> bool  Test if the font module is initialized or not. \n   pygame.font.get_default_font() \n get the filename of the default font get_default_font() -> string  Return the filename of the system font. This is not the full path to the file. This file can usually be found in the same directory as the font module, but it can also be bundled in separate archives. \n   pygame.font.get_fonts() \n get all available fonts get_fonts() -> list of strings  Returns a list of all the fonts available on the system. The names of the fonts will be set to lowercase with all spaces and punctuation removed. This works on most systems, but some will return an empty list if they cannot find fonts. \n   pygame.font.match_font() \n find a specific font on the system match_font(name, bold=False, italic=False) -> path  Returns the full path to a font file on the system. If bold or italic are set to true, this will attempt to find the correct family of font. The font name can also be an iterable of font names, a string of comma-separated font names, or a bytes of comma-separated font names, in which case the set of names will be searched in order. If none of the given names are found, None is returned.  New in pygame 2.0.1: Accept an iterable of font names.  Example: print pygame.font.match_font('bitstreamverasans')\n# output is: /usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf\n# (but only if you have Vera on your system) \n   pygame.font.SysFont() \n create a Font object from the system fonts SysFont(name, size, bold=False, italic=False) -> Font  Return a new Font object that is loaded from the system fonts. The font will match the requested bold and italic flags. Pygame uses a small set of common font aliases. If the specific font you ask for is not available, a reasonable alternative may be used. If a suitable system font is not found this will fall back on loading the default pygame font. The font name can also be an iterable of font names, a string of comma-separated font names, or a bytes of comma-separated font names, in which case the set of names will be searched in order.  New in pygame 2.0.1: Accept an iterable of font names.  \n   pygame.font.Font \n create a new Font object from a file Font(filename, size) -> Font Font(object, size) -> Font  Load a new font from a given filename or a python file object. The size is the height of the font in pixels. If the filename is None the pygame default font will be loaded. If a font cannot be loaded from the arguments given an exception will be raised. Once the font is created the size cannot be changed. Font objects are mainly used to render text into new Surface objects. The render can emulate bold or italic features, but it is better to load from a font with actual italic or bold glyphs. The rendered text can be regular strings or unicode.   bold \n Gets or sets whether the font should be rendered in (faked) bold. bold -> bool  Whether the font should be rendered in bold. When set to True, this enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic and underline modes.  New in pygame 2.0.0.  \n   italic \n Gets or sets whether the font should be rendered in (faked) italics. italic -> bool  Whether the font should be rendered in italic. When set to True, this enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold and underline modes.  New in pygame 2.0.0.  \n   underline \n Gets or sets whether the font should be rendered with an underline. underline -> bool  Whether the font should be rendered in underline. When set to True, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold and italic modes.  New in pygame 2.0.0.  \n   render() \n draw text on a new Surface render(text, antialias, color, background=None) -> Surface  This creates a new Surface with the specified text rendered on it. pygame provides no way to directly draw text on an existing Surface: instead you must use Font.render() to create an image (Surface) of the text, then blit this image onto another Surface. The text can only be a single line: newline characters are not rendered. Null characters ('x00') raise a TypeError. Both Unicode and char (byte) strings are accepted. For Unicode strings only UCS-2 characters ('u0001' to 'uFFFF') are recognized. Anything greater raises a UnicodeError. For char strings a LATIN1 encoding is assumed. The antialias argument is a boolean: if true the characters will have smooth edges. The color argument is the color of the text [e.g.: (0,0,255) for blue]. The optional background argument is a color to use for the text background. If no background is passed the area outside the text will be transparent. The Surface returned will be of the dimensions required to hold the text. (the same as those returned by Font.size()). If an empty string is passed for the text, a blank surface will be returned that is zero pixel wide and the height of the font. Depending on the type of background and antialiasing used, this returns different types of Surfaces. For performance reasons, it is good to know what type of image will be used. If antialiasing is not used, the return image will always be an 8-bit image with a two-color palette. If the background is transparent a colorkey will be set. Antialiased images are rendered to 24-bit RGB images. If the background is transparent a pixel alpha will be included. Optimization: if you know that the final destination for the text (on the screen) will always have a solid background, and the text is antialiased, you can improve performance by specifying the background color. This will cause the resulting image to maintain transparency information by colorkey rather than (much less efficient) alpha values. If you render '\\n' an unknown char will be rendered. Usually a rectangle. Instead you need to handle new lines yourself. Font rendering is not thread safe: only a single thread can render text at any time. \n   size() \n determine the amount of space needed to render text size(text) -> (width, height)  Returns the dimensions needed to render the text. This can be used to help determine the positioning needed for text before it is rendered. It can also be used for wordwrapping and other layout effects. Be aware that most fonts use kerning which adjusts the widths for specific letter pairs. For example, the width for \"ae\" will not always match the width for \"a\" + \"e\". \n   set_underline() \n control if text is rendered with an underline set_underline(bool) -> None  When enabled, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold and italic modes.  Note This is the same as the underline attribute.  \n   get_underline() \n check if text will be rendered with an underline get_underline() -> bool  Return True when the font underline is enabled.  \n Note This is the same as the underline attribute.  \n \n   set_bold() \n enable fake rendering of bold text set_bold(bool) -> None  Enables the bold rendering of text. This is a fake stretching of the font that doesn't look good on many font types. If possible load the font from a real bold font file. While bold, the font will have a different width than when normal. This can be mixed with the italic and underline modes.  Note This is the same as the bold attribute.  \n   get_bold() \n check if text will be rendered bold get_bold() -> bool  Return True when the font bold rendering mode is enabled.  Note This is the same as the bold attribute.  \n   set_italic() \n enable fake rendering of italic text set_italic(bool) -> None  Enables fake rendering of italic text. This is a fake skewing of the font that doesn't look good on many font types. If possible load the font from a real italic font file. While italic the font will have a different width than when normal. This can be mixed with the bold and underline modes.  Note This is the same as the italic attribute.  \n   metrics() \n gets the metrics for each character in the passed string metrics(text) -> list  The list contains tuples for each character, which contain the minimum X offset, the maximum X offset, the minimum Y offset, the maximum Y offset and the advance offset (bearing plus width) of the character. [(minx, maxx, miny, maxy, advance), (minx, maxx, miny, maxy, advance), ...]. None is entered in the list for each unrecognized character. \n   get_italic() \n check if the text will be rendered italic get_italic() -> bool  Return True when the font italic rendering mode is enabled.  Note This is the same as the italic attribute.  \n   get_linesize() \n get the line space of the font text get_linesize() -> int  Return the height in pixels for a line of text with the font. When rendering multiple lines of text this is the recommended amount of space between lines. \n   get_height() \n get the height of the font get_height() -> int  Return the height in pixels of the actual rendered text. This is the average size for each glyph in the font. \n   get_ascent() \n get the ascent of the font get_ascent() -> int  Return the height in pixels for the font ascent. The ascent is the number of pixels from the font baseline to the top of the font. \n   get_descent() \n get the descent of the font get_descent() -> int  Return the height in pixels for the font descent. The descent is the number of pixels from the font baseline to the bottom of the font. \n \n \n \n"}, {"name": "module-freetype", "path": "ref/freetype", "type": "pygame.freetype", "text": " pygame.freetype\n  \n Enhanced pygame module for loading and rendering computer fonts  The pygame.freetype module is a replacement for pygame.font. It has all of the functionality of the original, plus many new features. Yet is has absolutely no dependencies on the SDL_ttf library. It is implemented directly on the FreeType 2 library. The pygame.freetype module is not itself backward compatible with pygame.font. Instead, use the pygame.ftfont module as a drop-in replacement for pygame.font. All font file formats supported by FreeType can be rendered by pygame.freetype, namely TTF, Type1, CFF, OpenType, SFNT, PCF, FNT, BDF, PFR and Type42 fonts. All glyphs having UTF-32 code points are accessible (see Font.ucs4). Most work on fonts is done using Font instances. The module itself only has routines for initialization and creation of Font objects. You can load fonts from the system using the SysFont() function. Extra support of bitmap fonts is available. Available bitmap sizes can be listed (see Font.get_sizes()). For bitmap only fonts Font can set the size for you (see the Font.size property). For now undefined character codes are replaced with the .notdef (not defined) character. How undefined codes are handled may become configurable in a future release. Pygame comes with a built-in default font. This can always be accessed by passing None as the font name to the Font constructor. Extra rendering features available to pygame.freetype.Font are direct to surface rendering (see Font.render_to()), character kerning (see Font.kerning), vertical layout (see Font.vertical), rotation of rendered text (see Font.rotation), and the strong style (see Font.strong). Some properties are configurable, such as strong style strength (see Font.strength) and underline positioning (see Font.underline_adjustment). Text can be positioned by the upper right corner of the text box or by the text baseline (see Font.origin). Finally, a font's vertical and horizontal size can be adjusted separately (see Font.size). The pygame.examples.freetype_misc example shows these features in use. The pygame package does not import freetype automatically when loaded. This module must be imported explicitly to be used. import pygame\nimport pygame.freetype  New in pygame 1.9.2: freetype    pygame.freetype.get_error() \n Return the latest FreeType error get_error() -> str get_error() -> None  Return a description of the last error which occurred in the FreeType2 library, or None if no errors have occurred. \n   pygame.freetype.get_version() \n Return the FreeType version get_version() -> (int, int, int)  Returns the version of the FreeType library in use by this module. Note that the freetype module depends on the FreeType 2 library. It will not compile with the original FreeType 1.0. Hence, the first element of the tuple will always be \"2\". \n   pygame.freetype.init() \n Initialize the underlying FreeType library. init(cache_size=64, resolution=72)  This function initializes the underlying FreeType library and must be called before trying to use any of the functionality of the freetype module. However, pygame.init() will automatically call this function if the freetype module is already imported. It is safe to call this function more than once. Optionally, you may specify a default cache_size for the Glyph cache: the maximum number of glyphs that will be cached at any given time by the module. Exceedingly small values will be automatically tuned for performance. Also a default pixel resolution, in dots per inch, can be given to adjust font scaling. \n   pygame.freetype.quit() \n Shut down the underlying FreeType library. quit()  This function closes the freetype module. After calling this function, you should not invoke any class, method or function related to the freetype module as they are likely to fail or might give unpredictable results. It is safe to call this function even if the module hasn't been initialized yet. \n   pygame.freetype.get_init() \n Returns True if the FreeType module is currently initialized. get_init() -> bool  Returns True if the pygame.freetype module is currently initialized.  New in pygame 1.9.5.  \n   pygame.freetype.was_init() \n DEPRECATED: Use get_init() instead. was_init() -> bool  DEPRECATED: Returns True if the pygame.freetype module is currently initialized. Use get_init() instead. \n   pygame.freetype.get_cache_size() \n Return the glyph case size get_cache_size() -> long  See pygame.freetype.init(). \n   pygame.freetype.get_default_resolution() \n Return the default pixel size in dots per inch get_default_resolution() -> long  Returns the default pixel size, in dots per inch, for the module. The default is 72 DPI. \n   pygame.freetype.set_default_resolution() \n Set the default pixel size in dots per inch for the module set_default_resolution([resolution])  Set the default pixel size, in dots per inch, for the module. If the optional argument is omitted or zero the resolution is reset to 72 DPI. \n   pygame.freetype.SysFont() \n create a Font object from the system fonts SysFont(name, size, bold=False, italic=False) -> Font  Return a new Font object that is loaded from the system fonts. The font will match the requested bold and italic flags. Pygame uses a small set of common font aliases. If the specific font you ask for is not available, a reasonable alternative may be used. If a suitable system font is not found this will fall back on loading the default pygame font. The font name can also be an iterable of font names, a string of comma-separated font names, or a bytes of comma-separated font names, in which case the set of names will be searched in order.  New in pygame 2.0.1: Accept an iterable of font names.  \n   pygame.freetype.get_default_font() \n Get the filename of the default font get_default_font() -> string  Return the filename of the default pygame font. This is not the full path to the file. The file is usually in the same directory as the font module, but can also be bundled in a separate archive. \n   pygame.freetype.Font \n Create a new Font instance from a supported font file. Font(file, size=0, font_index=0, resolution=0, ucs4=False) -> Font  Argument file can be either a string representing the font's filename, a file-like object containing the font, or None; if None, a default, Pygame, font is used. Optionally, a size argument may be specified to set the default size in points, which determines the size of the rendered characters. The size can also be passed explicitly to each method call. Because of the way the caching system works, specifying a default size on the constructor doesn't imply a performance gain over manually passing the size on each function call. If the font is bitmap and no size is given, the default size is set to the first available size for the font. If the font file has more than one font, the font to load can be chosen with the index argument. An exception is raised for an out-of-range font index value. The optional resolution argument sets the pixel size, in dots per inch, for use in scaling glyphs for this Font instance. If 0 then the default module value, set by init(), is used. The Font object's resolution can only be changed by re-initializing the Font instance. The optional ucs4 argument, an integer, sets the default text translation mode: 0 (False) recognize UTF-16 surrogate pairs, any other value (True), to treat Unicode text as UCS-4, with no surrogate pairs. See Font.ucs4.   name \n Proper font name. name -> string  Read only. Returns the real (long) name of the font, as recorded in the font file. \n   path \n Font file path path -> unicode  Read only. Returns the path of the loaded font file \n   size \n The default point size used in rendering size -> float size -> (float, float)  Get or set the default size for text metrics and rendering. It can be a single point size, given as a Python int or float, or a font ppem (width, height) tuple. Size values are non-negative. A zero size or width represents an undefined size. In this case the size must be given as a method argument, or an exception is raised. A zero width but non-zero height is a ValueError. For a scalable font, a single number value is equivalent to a tuple with width equal height. A font can be stretched vertically with height set greater than width, or horizontally with width set greater than height. For embedded bitmaps, as listed by get_sizes(), use the nominal width and height to select an available size. Font size differs for a non-scalable, bitmap, font. During a method call it must match one of the available sizes returned by method get_sizes(). If not, an exception is raised. If the size is a single number, the size is first matched against the point size value. If no match, then the available size with the same nominal width and height is chosen. \n   get_rect() \n Return the size and offset of rendered text get_rect(text, style=STYLE_DEFAULT, rotation=0, size=0) -> rect  Gets the final dimensions and origin, in pixels, of text using the optional size in points, style, and rotation. For other relevant render properties, and for any optional argument not given, the default values set for the Font instance are used. Returns a Rect instance containing the width and height of the text's bounding box and the position of the text's origin. The origin is useful in aligning separately rendered pieces of text. It gives the baseline position and bearing at the start of the text. See the render_to() method for an example. If text is a char (byte) string, its encoding is assumed to be LATIN1. Optionally, text can be None, which will return the bounding rectangle for the text passed to a previous get_rect(), render(), render_to(), render_raw(), or render_raw_to() call. See render_to() for more details. \n   get_metrics() \n Return the glyph metrics for the given text get_metrics(text, size=0) -> [(...), ...]  Returns the glyph metrics for each character in text. The glyph metrics are returned as a list of tuples. Each tuple gives metrics of a single character glyph. The glyph metrics are: (min_x, max_x, min_y, max_y, horizontal_advance_x, horizontal_advance_y) The bounding box min_x, max_x, min_y, and max_y values are returned as grid-fitted pixel coordinates of type int. The advance values are float values. The calculations are done using the font's default size in points. Optionally you may specify another point size with the size argument. The metrics are adjusted for the current rotation, strong, and oblique settings. If text is a char (byte) string, then its encoding is assumed to be LATIN1. \n   height \n The unscaled height of the font in font units height -> int  Read only. Gets the height of the font. This is the average value of all glyphs in the font. \n   ascender \n The unscaled ascent of the font in font units ascender -> int  Read only. Return the number of units from the font's baseline to the top of the bounding box. \n   descender \n The unscaled descent of the font in font units descender -> int  Read only. Return the height in font units for the font descent. The descent is the number of units from the font's baseline to the bottom of the bounding box. \n   get_sized_ascender() \n The scaled ascent of the font in pixels get_sized_ascender(<size>=0) -> int  Return the number of units from the font's baseline to the top of the bounding box. It is not adjusted for strong or rotation. \n   get_sized_descender() \n The scaled descent of the font in pixels get_sized_descender(<size>=0) -> int  Return the number of pixels from the font's baseline to the top of the bounding box. It is not adjusted for strong or rotation. \n   get_sized_height() \n The scaled height of the font in pixels get_sized_height(<size>=0) -> int  Returns the height of the font. This is the average value of all glyphs in the font. It is not adjusted for strong or rotation. \n   get_sized_glyph_height() \n The scaled bounding box height of the font in pixels get_sized_glyph_height(<size>=0) -> int  Return the glyph bounding box height of the font in pixels. This is the average value of all glyphs in the font. It is not adjusted for strong or rotation. \n   get_sizes() \n return the available sizes of embedded bitmaps get_sizes() -> [(int, int, int, float, float), ...] get_sizes() -> []  Returns a list of tuple records, one for each point size supported. Each tuple containing the point size, the height in pixels, width in pixels, horizontal ppem (nominal width) in fractional pixels, and vertical ppem (nominal height) in fractional pixels. \n   render() \n Return rendered text as a surface render(text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -> (Surface, Rect)  Returns a new Surface, with the text rendered to it in the color given by 'fgcolor'. If no foreground color is given, the default foreground color, fgcolor is used. If bgcolor is given, the surface will be filled with this color. When no background color is given, the surface background is transparent, zero alpha. Normally the returned surface has a 32 bit pixel size. However, if bgcolor is None and anti-aliasing is disabled a monochrome 8 bit colorkey surface, with colorkey set for the background color, is returned. The return value is a tuple: the new surface and the bounding rectangle giving the size and origin of the rendered text. If an empty string is passed for text then the returned Rect is zero width and the height of the font. Optional fgcolor, style, rotation, and size arguments override the default values set for the Font instance. If text is a char (byte) string, then its encoding is assumed to be LATIN1. Optionally, text can be None, which will render the text passed to a previous get_rect(), render(), render_to(), render_raw(), or render_raw_to() call. See render_to() for details. \n   render_to() \n Render text onto an existing surface render_to(surf, dest, text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -> Rect  Renders the string text to the pygame.Surface surf, at position dest, a (x, y) surface coordinate pair. If either x or y is not an integer it is converted to one if possible. Any sequence where the first two items are x and y positional elements is accepted, including a Rect instance. As with render(), optional fgcolor, style, rotation, and size argument are available. If a background color bgcolor is given, the text bounding box is first filled with that color. The text is blitted next. Both the background fill and text rendering involve full alpha blits. That is, the alpha values of the foreground, background, and destination target surface all affect the blit. The return value is a rectangle giving the size and position of the rendered text within the surface. If an empty string is passed for text then the returned Rect is zero width and the height of the font. The rect will test False. Optionally, text can be set None, which will re-render text passed to a previous render_to(), get_rect(), render(), render_raw(), or render_raw_to() call. Primarily, this feature is an aid to using render_to() in combination with get_rect(). An example: def word_wrap(surf, text, font, color=(0, 0, 0)):\n    font.origin = True\n    words = text.split(' ')\n    width, height = surf.get_size()\n    line_spacing = font.get_sized_height() + 2\n    x, y = 0, line_spacing\n    space = font.get_rect(' ')\n    for word in words:\n        bounds = font.get_rect(word)\n        if x + bounds.width + bounds.x >= width:\n            x, y = 0, y + line_spacing\n        if x + bounds.width + bounds.x >= width:\n            raise ValueError(\"word too wide for the surface\")\n        if y + bounds.height - bounds.y >= height:\n            raise ValueError(\"text to long for the surface\")\n        font.render_to(surf, (x, y), None, color)\n        x += bounds.width + space.width\n    return x, y When render_to() is called with the same font properties \u2015 size, style, strength, wide, antialiased, vertical, rotation, kerning, and use_bitmap_strikes \u2015 as get_rect(), render_to() will use the layout calculated by get_rect(). Otherwise, render_to() will recalculate the layout if called with a text string or one of the above properties has changed after the get_rect() call. If text is a char (byte) string, then its encoding is assumed to be LATIN1. \n   render_raw() \n Return rendered text as a string of bytes render_raw(text, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -> (bytes, (int, int))  Like render() but with the pixels returned as a byte string of 8-bit gray-scale values. The foreground color is 255, the background 0, useful as an alpha mask for a foreground pattern. \n   render_raw_to() \n Render text into an array of ints render_raw_to(array, text, dest=None, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -> Rect  Render to an array object exposing an array struct interface. The array must be two dimensional with integer items. The default dest value, None, is equivalent to position (0, 0). See render_to(). As with the other render methods, text can be None to render a text string passed previously to another method. The return value is a pygame.Rect() giving the size and position of the rendered text. \n   style \n The font's style flags style -> int  Gets or sets the default style of the Font. This default style will be used for all text rendering and size calculations unless overridden specifically a render or get_rect() call. The style value may be a bit-wise OR of one or more of the following constants: STYLE_NORMAL\nSTYLE_UNDERLINE\nSTYLE_OBLIQUE\nSTYLE_STRONG\nSTYLE_WIDE\nSTYLE_DEFAULT These constants may be found on the FreeType constants module. Optionally, the default style can be modified or obtained accessing the individual style attributes (underline, oblique, strong). The STYLE_OBLIQUE and STYLE_STRONG styles are for scalable fonts only. An attempt to set either for a bitmap font raises an AttributeError. An attempt to set either for an inactive font, as returned by Font.__new__(), raises a RuntimeError. Assigning STYLE_DEFAULT to the style property leaves the property unchanged, as this property defines the default. The style property will never return STYLE_DEFAULT. \n   underline \n The state of the font's underline style flag underline -> bool  Gets or sets whether the font will be underlined when drawing text. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the 'style' parameter. \n   strong \n The state of the font's strong style flag strong -> bool  Gets or sets whether the font will be bold when drawing text. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the 'style' parameter. \n   oblique \n The state of the font's oblique style flag oblique -> bool  Gets or sets whether the font will be rendered as oblique. This default style value will be used for all text rendering and size calculations unless overridden specifically in a render or get_rect() call, via the style parameter. The oblique style is only supported for scalable (outline) fonts. An attempt to set this style on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by Font.__new__(), setting this property raises a RuntimeError. \n   wide \n The state of the font's wide style flag wide -> bool  Gets or sets whether the font will be stretched horizontally when drawing text. It produces a result similar to pygame.font.Font's bold. This style not available for rotated text. \n   strength \n The strength associated with the strong or wide font styles strength -> float  The amount by which a font glyph's size is enlarged for the strong or wide transformations, as a fraction of the untransformed size. For the wide style only the horizontal dimension is increased. For strong text both the horizontal and vertical dimensions are enlarged. A wide style of strength 0.08333 ( 1/12 ) is equivalent to the pygame.font.Font bold style. The default is 0.02778 ( 1/36 ). The strength style is only supported for scalable (outline) fonts. An attempt to set this property on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by Font.__new__(), assignment to this property raises a RuntimeError. \n   underline_adjustment \n Adjustment factor for the underline position underline_adjustment -> float  Gets or sets a factor which, when positive, is multiplied with the font's underline offset to adjust the underline position. A negative value turns an underline into a strike-through or overline. It is multiplied with the ascender. Accepted values range between -2.0 and 2.0 inclusive. A value of 0.5 closely matches Tango underlining. A value of 1.0 mimics pygame.font.Font underlining. \n   fixed_width \n Gets whether the font is fixed-width fixed_width -> bool  Read only. Returns True if the font contains fixed-width characters (for example Courier, Bitstream Vera Sans Mono, Andale Mono). \n   fixed_sizes \n the number of available bitmap sizes for the font fixed_sizes -> int  Read only. Returns the number of point sizes for which the font contains bitmap character images. If zero then the font is not a bitmap font. A scalable font may contain pre-rendered point sizes as strikes. \n   scalable \n Gets whether the font is scalable scalable -> bool  Read only. Returns True if the font contains outline glyphs. If so, the point size is not limited to available bitmap sizes. \n   use_bitmap_strikes \n allow the use of embedded bitmaps in an outline font file use_bitmap_strikes -> bool  Some scalable fonts include embedded bitmaps for particular point sizes. This property controls whether or not those bitmap strikes are used. Set it False to disable the loading of any bitmap strike. Set it True, the default, to permit bitmap strikes for a non-rotated render with no style other than wide or underline. This property is ignored for bitmap fonts. See also fixed_sizes and get_sizes(). \n   antialiased \n Font anti-aliasing mode antialiased -> bool  Gets or sets the font's anti-aliasing mode. This defaults to True on all fonts, which are rendered with full 8 bit blending. Set to False to do monochrome rendering. This should provide a small speed gain and reduce cache memory size. \n   kerning \n Character kerning mode kerning -> bool  Gets or sets the font's kerning mode. This defaults to False on all fonts, which will be rendered without kerning. Set to True to add kerning between character pairs, if supported by the font, when positioning glyphs. \n   vertical \n Font vertical mode vertical -> bool  Gets or sets whether the characters are laid out vertically rather than horizontally. May be useful when rendering Kanji or some other vertical script. Set to True to switch to a vertical text layout. The default is False, place horizontally. Note that the Font class does not automatically determine script orientation. Vertical layout must be selected explicitly. Also note that several font formats (especially bitmap based ones) don't contain the necessary metrics to draw glyphs vertically, so drawing in those cases will give unspecified results. \n   rotation \n text rotation in degrees counterclockwise rotation -> int  Gets or sets the baseline angle of the rendered text. The angle is represented as integer degrees. The default angle is 0, with horizontal text rendered along the X-axis, and vertical text along the Y-axis. A positive value rotates these axes counterclockwise that many degrees. A negative angle corresponds to a clockwise rotation. The rotation value is normalized to a value within the range 0 to 359 inclusive (eg. 390 -> 390 - 360 -> 30, -45 -> 360 + -45 -> 315, 720 -> 720 - (2 * 360) -> 0). Only scalable (outline) fonts can be rotated. An attempt to change the rotation of a bitmap font raises an AttributeError. An attempt to change the rotation of an inactive font instance, as returned by Font.__new__(), raises a RuntimeError. \n   fgcolor \n default foreground color fgcolor -> Color  Gets or sets the default glyph rendering color. It is initially opaque black \u2015 (0, 0, 0, 255). Applies to render() and render_to(). \n   bgcolor \n default background color bgcolor -> Color  Gets or sets the default background rendering color. Initially it is unset and text will render with a transparent background by default. Applies to render() and render_to(). \n  New in pygame 2.0.0.    origin \n Font render to text origin mode origin -> bool  If set True, render_to() and render_raw_to() will take the dest position to be that of the text origin, as opposed to the top-left corner of the bounding box. See get_rect() for details. \n   pad \n padded boundary mode pad -> bool  If set True, then the text boundary rectangle will be inflated to match that of font.Font. Otherwise, the boundary rectangle is just large enough for the text. \n   ucs4 \n Enable UCS-4 mode ucs4 -> bool  Gets or sets the decoding of Unicode text. By default, the freetype module performs UTF-16 surrogate pair decoding on Unicode text. This allows 32-bit escape sequences ('Uxxxxxxxx') between 0x10000 and 0x10FFFF to represent their corresponding UTF-32 code points on Python interpreters built with a UCS-2 Unicode type (on Windows, for instance). It also means character values within the UTF-16 surrogate area (0xD800 to 0xDFFF) are considered part of a surrogate pair. A malformed surrogate pair will raise a UnicodeEncodeError. Setting ucs4 True turns surrogate pair decoding off, allowing access the full UCS-4 character range to a Python interpreter built with four-byte Unicode character support. \n   resolution \n Pixel resolution in dots per inch resolution -> int  Read only. Gets pixel size used in scaling font glyphs for this Font instance. \n \n \n \n"}, {"name": "module-gfxdraw", "path": "ref/gfxdraw", "type": "pygame.gfxdraw", "text": " pygame.gfxdraw\n  \n pygame module for drawing shapes  EXPERIMENTAL!: This API may change or disappear in later pygame releases. If you use this, your code may break with the next pygame release. The pygame package does not import gfxdraw automatically when loaded, so it must imported explicitly to be used. import pygame\nimport pygame.gfxdraw For all functions the arguments are strictly positional and integers are accepted for coordinates and radii. The color argument can be one of the following formats:  \n a pygame.Color object an (RGB) triplet (tuple/list) an (RGBA) quadruplet (tuple/list)  \n The functions rectangle() and box() will accept any (x, y, w, h) sequence for their rect argument, though pygame.Rect instances are preferred. To draw a filled antialiased shape, first use the antialiased (aa*) version of the function, and then use the filled (filled_*) version. For example: col = (255, 0, 0)\nsurf.fill((255, 255, 255))\npygame.gfxdraw.aacircle(surf, x, y, 30, col)\npygame.gfxdraw.filled_circle(surf, x, y, 30, col)  Note For threading, each of the functions releases the GIL during the C part of the call.   Note See the pygame.draw module for alternative draw methods. The pygame.gfxdraw module differs from the pygame.draw module in the API it uses and the different draw functions available. pygame.gfxdraw wraps the primitives from the library called SDL_gfx, rather than using modified versions.   New in pygame 1.9.0.    pygame.gfxdraw.pixel() \n draw a pixel pixel(surface, x, y, color) -> None  Draws a single pixel, at position (x ,y), on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the pixel \ny (int) -- y coordinate of the pixel \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.hline() \n draw a horizontal line hline(surface, x1, x2, y, color) -> None  Draws a straight horizontal line ((x1, y) to (x2, y)) on the given surface. There are no endcaps.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of one end of the line \nx2 (int) -- x coordinate of the other end of the line \ny (int) -- y coordinate of the line \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.vline() \n draw a vertical line vline(surface, x, y1, y2, color) -> None  Draws a straight vertical line ((x, y1) to (x, y2)) on the given surface. There are no endcaps.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the line \ny1 (int) -- y coordinate of one end of the line \ny2 (int) -- y coordinate of the other end of the line \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.line() \n draw a line line(surface, x1, y1, x2, y2, color) -> None  Draws a straight line ((x1, y1) to (x2, y2)) on the given surface. There are no endcaps.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of one end of the line \ny1 (int) -- y coordinate of one end of the line \nx2 (int) -- x coordinate of the other end of the line \ny2 (int) -- y coordinate of the other end of the line \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.rectangle() \n draw a rectangle rectangle(surface, rect, color) -> None  Draws an unfilled rectangle on the given surface. For a filled rectangle use box().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nrect (Rect) -- rectangle to draw, position and dimensions \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType      Note The rect.bottom and rect.right attributes of a pygame.Rect always lie one pixel outside of its actual border. Therefore, these values will not be included as part of the drawing.  \n   pygame.gfxdraw.box() \n draw a filled rectangle box(surface, rect, color) -> None  Draws a filled rectangle on the given surface. For an unfilled rectangle use rectangle().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nrect (Rect) -- rectangle to draw, position and dimensions \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType      Note The rect.bottom and rect.right attributes of a pygame.Rect always lie one pixel outside of its actual border. Therefore, these values will not be included as part of the drawing.   Note The pygame.Surface.fill() method works just as well for drawing filled rectangles. In fact pygame.Surface.fill() can be hardware accelerated on some platforms with both software and hardware display modes.  \n   pygame.gfxdraw.circle() \n draw a circle circle(surface, x, y, r, color) -> None  Draws an unfilled circle on the given surface. For a filled circle use filled_circle().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the circle \ny (int) -- y coordinate of the center of the circle \nr (int) -- radius of the circle \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.aacircle() \n draw an antialiased circle aacircle(surface, x, y, r, color) -> None  Draws an unfilled antialiased circle on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the circle \ny (int) -- y coordinate of the center of the circle \nr (int) -- radius of the circle \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.filled_circle() \n draw a filled circle filled_circle(surface, x, y, r, color) -> None  Draws a filled circle on the given surface. For an unfilled circle use circle().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the circle \ny (int) -- y coordinate of the center of the circle \nr (int) -- radius of the circle \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.ellipse() \n draw an ellipse ellipse(surface, x, y, rx, ry, color) -> None  Draws an unfilled ellipse on the given surface. For a filled ellipse use filled_ellipse().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the ellipse \ny (int) -- y coordinate of the center of the ellipse \nrx (int) -- horizontal radius of the ellipse \nry (int) -- vertical radius of the ellipse \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.aaellipse() \n draw an antialiased ellipse aaellipse(surface, x, y, rx, ry, color) -> None  Draws an unfilled antialiased ellipse on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the ellipse \ny (int) -- y coordinate of the center of the ellipse \nrx (int) -- horizontal radius of the ellipse \nry (int) -- vertical radius of the ellipse \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.filled_ellipse() \n draw a filled ellipse filled_ellipse(surface, x, y, rx, ry, color) -> None  Draws a filled ellipse on the given surface. For an unfilled ellipse use ellipse().     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the ellipse \ny (int) -- y coordinate of the center of the ellipse \nrx (int) -- horizontal radius of the ellipse \nry (int) -- vertical radius of the ellipse \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.arc() \n draw an arc arc(surface, x, y, r, start_angle, stop_angle, color) -> None  Draws an arc on the given surface. For an arc with its endpoints connected to its center use pie(). The two angle arguments are given in degrees and indicate the start and stop positions of the arc. The arc is drawn in a clockwise direction from the start_angle to the stop_angle. If start_angle == stop_angle, nothing will be drawn     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the arc \ny (int) -- y coordinate of the center of the arc \nr (int) -- radius of the arc \nstart_angle (int) -- start angle in degrees \nstop_angle (int) -- stop angle in degrees \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType      Note This function uses degrees while the pygame.draw.arc() function uses radians.  \n   pygame.gfxdraw.pie() \n draw a pie pie(surface, x, y, r, start_angle, stop_angle, color) -> None  Draws an unfilled pie on the given surface. A pie is an arc() with its endpoints connected to its center. The two angle arguments are given in degrees and indicate the start and stop positions of the pie. The pie is drawn in a clockwise direction from the start_angle to the stop_angle. If start_angle == stop_angle, a straight line will be drawn from the center position at the given angle, to a length of the radius.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx (int) -- x coordinate of the center of the pie \ny (int) -- y coordinate of the center of the pie \nr (int) -- radius of the pie \nstart_angle (int) -- start angle in degrees \nstop_angle (int) -- stop angle in degrees \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.trigon() \n draw a trigon/triangle trigon(surface, x1, y1, x2, y2, x3, y3, color) -> None  Draws an unfilled trigon (triangle) on the given surface. For a filled trigon use filled_trigon(). A trigon can also be drawn using polygon() e.g. polygon(surface, ((x1, y1), (x2, y2), (x3, y3)), color)     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of the first corner of the trigon \ny1 (int) -- y coordinate of the first corner of the trigon \nx2 (int) -- x coordinate of the second corner of the trigon \ny2 (int) -- y coordinate of the second corner of the trigon \nx3 (int) -- x coordinate of the third corner of the trigon \ny3 (int) -- y coordinate of the third corner of the trigon \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.aatrigon() \n draw an antialiased trigon/triangle aatrigon(surface, x1, y1, x2, y2, x3, y3, color) -> None  Draws an unfilled antialiased trigon (triangle) on the given surface. An aatrigon can also be drawn using aapolygon() e.g. aapolygon(surface, ((x1, y1), (x2, y2), (x3, y3)), color)     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of the first corner of the trigon \ny1 (int) -- y coordinate of the first corner of the trigon \nx2 (int) -- x coordinate of the second corner of the trigon \ny2 (int) -- y coordinate of the second corner of the trigon \nx3 (int) -- x coordinate of the third corner of the trigon \ny3 (int) -- y coordinate of the third corner of the trigon \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.filled_trigon() \n draw a filled trigon/triangle filled_trigon(surface, x1, y1, x2, y2, x3, y3, color) -> None  Draws a filled trigon (triangle) on the given surface. For an unfilled trigon use trigon(). A filled_trigon can also be drawn using filled_polygon() e.g. filled_polygon(surface, ((x1, y1), (x2, y2), (x3, y3)), color)     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \nx1 (int) -- x coordinate of the first corner of the trigon \ny1 (int) -- y coordinate of the first corner of the trigon \nx2 (int) -- x coordinate of the second corner of the trigon \ny2 (int) -- y coordinate of the second corner of the trigon \nx3 (int) -- x coordinate of the third corner of the trigon \ny3 (int) -- y coordinate of the third corner of the trigon \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   pygame.gfxdraw.polygon() \n draw a polygon polygon(surface, points, color) -> None  Draws an unfilled polygon on the given surface. For a filled polygon use filled_polygon(). The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n   pygame.gfxdraw.aapolygon() \n draw an antialiased polygon aapolygon(surface, points, color) -> None  Draws an unfilled antialiased polygon on the given surface. The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n   pygame.gfxdraw.filled_polygon() \n draw a filled polygon filled_polygon(surface, points, color) -> None  Draws a filled polygon on the given surface. For an unfilled polygon use polygon(). The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated)` \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n   pygame.gfxdraw.textured_polygon() \n draw a textured polygon textured_polygon(surface, points, texture, tx, ty) -> None  Draws a textured polygon on the given surface. For better performance, the surface and the texture should have the same format. A per-pixel alpha texture blit to a per-pixel alpha surface will differ from a pygame.Surface.blit() blit. Also, a per-pixel alpha texture cannot be used with an 8-bit per pixel destination. The adjacent coordinates in the points argument, as well as the first and last points, will be connected by line segments. e.g. For the points [(x1, y1), (x2, y2), (x3, y3)] a line segment will be drawn from (x1, y1) to (x2, y2), from (x2, y2) to (x3, y3), and from (x3, y3) to (x1, y1).     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \ntexture (Surface) -- texture to draw on the polygon \ntx (int) -- x offset of the texture \nty (int) -- y offset of the texture    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n   pygame.gfxdraw.bezier() \n draw a Bezier curve bezier(surface, points, steps, color) -> None  Draws a B\u00e9zier curve on the given surface.     \nParameters:\n\n \nsurface (Surface) -- surface to draw on \npoints (tuple(coordinate) or list(coordinate)) -- a sequence of 3 or more (x, y) coordinates used to form a curve, where each coordinate in the sequence must be a tuple/list/pygame.math.Vector2 of 2 ints/floats (float values will be truncated) \nsteps (int) -- number of steps for the interpolation, the minimum is 2 \ncolor (Color or tuple(int, int, int, [int])) -- color to draw with, the alpha value is optional if using a tuple (RGB[A])\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\n \nValueError -- if steps < 2\n \nValueError -- if len(points) < 3 (must have at least 3 points) \nIndexError -- if len(coordinate) < 2 (each coordinate must have at least 2 items)      \n \n \n"}, {"name": "module-image", "path": "ref/image", "type": "pygame.image", "text": " pygame.image\n  \n pygame module for image transfer  The image module contains functions for loading and saving pictures, as well as transferring Surfaces to formats usable by other packages. Note that there is no Image class; an image is loaded as a Surface object. The Surface class allows manipulation (drawing lines, setting pixels, capturing regions, etc.). The image module is a required dependency of pygame, but it only optionally supports any extended file formats. By default it can only load uncompressed BMP images. When built with full image support, the pygame.image.load() function can support the following formats.  \n JPG PNG \nGIF (non-animated) BMP PCX \nTGA (uncompressed) TIF \nLBM (and PBM) \nPBM (and PGM, PPM) XPM  \n Saving images only supports a limited set of formats. You can save to the following formats.  \n BMP TGA PNG JPEG  \n JPEG and JPG refer to the same file format  New in pygame 1.8: Saving PNG and JPEG files.    pygame.image.load_basic() \n load new BMP image from a file (or file-like object) load_basic(file) -> Surface  Load an image from a file source. You can pass either a filename or a Python file-like object. This function only supports loading \"basic\" image format, ie BMP format. This function is always available, no matter how pygame was built. \n   pygame.image.load() \n load new image from a file (or file-like object) load(filename) -> Surface load(fileobj, namehint=\"\") -> Surface  Load an image from a file source. You can pass either a filename or a Python file-like object. Pygame will automatically determine the image type (e.g., GIF or bitmap) and create a new Surface object from the data. In some cases it will need to know the file extension (e.g., GIF images should end in \".gif\"). If you pass a raw file-like object, you may also want to pass the original filename as the namehint argument. The returned Surface will contain the same color format, colorkey and alpha transparency as the file it came from. You will often want to call Surface.convert() with no arguments, to create a copy that will draw more quickly on the screen. For alpha transparency, like in .png images, use the convert_alpha() method after loading so that the image has per pixel transparency. pygame may not always be built to support all image formats. At minimum it will support uncompressed BMP. If pygame.image.get_extended() returns 'True', you should be able to load most images (including PNG, JPG and GIF). You should use os.path.join() for compatibility. eg. asurf = pygame.image.load(os.path.join('data', 'bla.png')) \n   pygame.image.load_extended() \n load an image from a file (or file-like object) load_extended(filename) -> Surface load_extended(fileobj, namehint=\"\") -> Surface  This function is similar to pygame.image.load(), except that this function can only be used if pygame was built with extended image format support. From version 2.0.1, this function is always available, but raises an error if extended image formats are not supported. Previously, this function may or may not be available, depending on the state of extended image format support.  Changed in pygame 2.0.1.  \n   pygame.image.save() \n save an image to file (or file-like object) save(Surface, filename) -> None save(Surface, fileobj, namehint=\"\") -> None  This will save your Surface as either a BMP, TGA, PNG, or JPEG image. If the filename extension is unrecognized it will default to TGA. Both TGA, and BMP file formats create uncompressed files. You can pass a filename or a Python file-like object. For file-like object, the image is saved to TGA format unless a namehint with a recognizable extension is passed in.  Note To be able to save the JPEG file format to a file-like object, SDL2_Image version 2.0.2 or newer is needed.   Note When saving to a file-like object, it seems that for most formats, the object needs to be flushed after saving to it to make loading from it possible.   Changed in pygame 1.8: Saving PNG and JPEG files.   Changed in pygame 2.0.0.dev11: The namehint parameter was added to make it possible to save other formats than TGA to a file-like object.  \n   pygame.image.save_extended() \n save a png/jpg image to file (or file-like object) save_extended(Surface, filename) -> None save_extended(Surface, fileobj, namehint=\"\") -> None  This will save your Surface as either a PNG or JPEG image. Incase the image is being saved to a file-like object, this function uses the namehint argument to determine the format of the file being saved. Saves to JPEG incase the namehint was not specified while saving to file-like object. From version 2.0.1, this function is always available, but raises an error if extended image formats are not supported. Previously, this function may or may not be available, depending on the state of extended image format support.  Changed in pygame 2.0.1.  \n   pygame.image.get_sdl_image_version() \n get version number of the SDL_Image library being used get_sdl_image_version() -> None get_sdl_image_version() -> (major, minor, patch)  If pygame is built with extended image formats, then this function will return the SDL_Image library's version number as a tuple of 3 integers (major, minor, patch). If not, then it will return None.  New in pygame 2.0.0.dev11.  \n   pygame.image.get_extended() \n test if extended image formats can be loaded get_extended() -> bool  If pygame is built with extended image formats this function will return True. It is still not possible to determine which formats will be available, but generally you will be able to load them all. \n   pygame.image.tostring() \n transfer image to string buffer tostring(Surface, format, flipped=False) -> string  Creates a string that can be transferred with the 'fromstring' method in other Python imaging packages. Some Python image packages prefer their images in bottom-to-top format (PyOpenGL for example). If you pass True for the flipped argument, the string buffer will be vertically flipped. The format argument is a string of one of the following values. Note that only 8-bit Surfaces can use the \"P\" format. The other formats will work for any Surface. Also note that other Python image packages support more formats than pygame.  \n \nP, 8-bit palettized Surfaces \nRGB, 24-bit image \nRGBX, 32-bit image with unused space \nRGBA, 32-bit image with an alpha channel \nARGB, 32-bit image with alpha channel first \nRGBA_PREMULT, 32-bit image with colors scaled by alpha channel \nARGB_PREMULT, 32-bit image with colors scaled by alpha channel, alpha channel first  \n \n   pygame.image.fromstring() \n create new Surface from a string buffer fromstring(string, size, format, flipped=False) -> Surface  This function takes arguments similar to pygame.image.tostring(). The size argument is a pair of numbers representing the width and height. Once the new Surface is created you can destroy the string buffer. The size and format image must compute the exact same size as the passed string buffer. Otherwise an exception will be raised. See the pygame.image.frombuffer() method for a potentially faster way to transfer images into pygame. \n   pygame.image.frombuffer() \n create a new Surface that shares data inside a bytes buffer frombuffer(bytes, size, format) -> Surface  Create a new Surface that shares pixel data directly from a bytes buffer. This method takes similar arguments to pygame.image.fromstring(), but is unable to vertically flip the source data. This will run much faster than pygame.image.fromstring(), since no pixel data must be allocated and copied. It accepts the following 'format' arguments:  \n \nP, 8-bit palettized Surfaces \nRGB, 24-bit image \nBGR, 24-bit image, red and blue channels swapped. \nRGBX, 32-bit image with unused space \nRGBA, 32-bit image with an alpha channel \nARGB, 32-bit image with alpha channel first  \n \n \n \n"}, {"name": "module-joystick", "path": "ref/joystick", "type": "pygame.joystick", "text": " pygame.joystick\n  \n Pygame module for interacting with joysticks, gamepads, and trackballs.  The joystick module manages the joystick devices on a computer. Joystick devices include trackballs and video-game-style gamepads, and the module allows the use of multiple buttons and \"hats\". Computers may manage multiple joysticks at a time. Each instance of the Joystick class represents one gaming device plugged into the computer. If a gaming pad has multiple joysticks on it, than the joystick object can actually represent multiple joysticks on that single game device. For a quick way to initialise the joystick module and get a list of Joystick instances use the following code: pygame.joystick.init()\njoysticks = [pygame.joystick.Joystick(x) for x in range(pygame.joystick.get_count())] The following event types will be generated by the joysticks JOYAXISMOTION JOYBALLMOTION JOYBUTTONDOWN JOYBUTTONUP JOYHATMOTION And in pygame 2, which supports hotplugging: JOYDEVICEADDED JOYDEVICEREMOVED Note that in pygame 2, joysticks events use a unique \"instance ID\". The device index passed in the constructor to a Joystick object is not unique after devices have been added and removed. You must call Joystick.get_instance_id() to find the instance ID that was assigned to a Joystick on opening. The event queue needs to be pumped frequently for some of the methods to work. So call one of pygame.event.get, pygame.event.wait, or pygame.event.pump regularly.   pygame.joystick.init() \n Initialize the joystick module. init() -> None  This function is called automatically by pygame.init(). It initializes the joystick module. The module must be initialized before any other functions will work. It is safe to call this function more than once. \n   pygame.joystick.quit() \n Uninitialize the joystick module. quit() -> None  Uninitialize the joystick module. After you call this any existing joystick objects will no longer work. It is safe to call this function more than once. \n   pygame.joystick.get_init() \n Returns True if the joystick module is initialized. get_init() -> bool  Test if the pygame.joystick.init() function has been called. \n   pygame.joystick.get_count() \n Returns the number of joysticks. get_count() -> count  Return the number of joystick devices on the system. The count will be 0 if there are no joysticks on the system. When you create Joystick objects using Joystick(id), you pass an integer that must be lower than this count. \n   pygame.joystick.Joystick \n Create a new Joystick object. Joystick(id) -> Joystick  Create a new joystick to access a physical device. The id argument must be a value from 0 to pygame.joystick.get_count() - 1. Joysticks are initialised on creation and are shut down when deallocated. Once the device is initialized the pygame event queue will start receiving events about its input.  Changed in pygame 2.0.0: Joystick objects are now opened immediately on creation.    init() \n initialize the Joystick init() -> None  Initialize the joystick, if it has been closed. It is safe to call this even if the joystick is already initialized.  Deprecated since pygame 2.0.0: In future it will not be possible to reinitialise a closed Joystick object. Will be removed in Pygame 2.1.  \n   quit() \n uninitialize the Joystick quit() -> None  Close a Joystick object. After this the pygame event queue will no longer receive events from the device. It is safe to call this more than once. \n   get_init() \n check if the Joystick is initialized get_init() -> bool  Return True if the Joystick object is currently initialised. \n   get_id() \n get the device index (deprecated) get_id() -> int  Returns the original device index for this device. This is the same value that was passed to the Joystick() constructor. This method can safely be called while the Joystick is not initialized.  Deprecated since pygame 2.0.0: The original device index is not useful in pygame 2. Use get_instance_id() instead. Will be removed in Pygame 2.1.  \n   get_instance_id() \u2192 int \n get the joystick instance id get_instance_id() -> int  Get the joystick instance ID. This matches the instance_id field that is given in joystick events.  New in pygame 2.0.0dev11.  \n   get_guid() \u2192 str \n get the joystick GUID get_guid() -> str  Get the GUID string. This identifies the exact hardware of the joystick device.  New in pygame 2.0.0dev11.  \n   get_power_level() \u2192 str \n get the approximate power status of the device get_power_level() -> str  Get a string giving the power status of the device. One of: empty, low, medium, full, wired, max, or unknown.  New in pygame 2.0.0dev11.  \n   get_name() \n get the Joystick system name get_name() -> string  Returns the system name for this joystick device. It is unknown what name the system will give to the Joystick, but it should be a unique name that identifies the device. This method can safely be called while the Joystick is not initialized. \n   get_numaxes() \n get the number of axes on a Joystick get_numaxes() -> int  Returns the number of input axes are on a Joystick. There will usually be two for the position. Controls like rudders and throttles are treated as additional axes. The pygame.JOYAXISMOTION events will be in the range from -1.0 to 1.0. A value of 0.0 means the axis is centered. Gamepad devices will usually be -1, 0, or 1 with no values in between. Older analog joystick axes will not always use the full -1 to 1 range, and the centered value will be some area around 0. Analog joysticks usually have a bit of noise in their axis, which will generate a lot of rapid small motion events. \n   get_axis() \n get the current position of an axis get_axis(axis_number) -> float  Returns the current position of a joystick axis. The value will range from -1 to 1 with a value of 0 being centered. You may want to take into account some tolerance to handle jitter, and joystick drift may keep the joystick from centering at 0 or using the full range of position values. The axis number must be an integer from 0 to get_numaxes() - 1. When using gamepads both the control sticks and the analog triggers are usually reported as axes. \n   get_numballs() \n get the number of trackballs on a Joystick get_numballs() -> int  Returns the number of trackball devices on a Joystick. These devices work similar to a mouse but they have no absolute position; they only have relative amounts of movement. The pygame.JOYBALLMOTION event will be sent when the trackball is rolled. It will report the amount of movement on the trackball. \n   get_ball() \n get the relative position of a trackball get_ball(ball_number) -> x, y  Returns the relative movement of a joystick button. The value is a x, y pair holding the relative movement since the last call to get_ball. The ball number must be an integer from 0 to get_numballs() - 1. \n   get_numbuttons() \n get the number of buttons on a Joystick get_numbuttons() -> int  Returns the number of pushable buttons on the joystick. These buttons have a boolean (on or off) state. Buttons generate a pygame.JOYBUTTONDOWN and pygame.JOYBUTTONUP event when they are pressed and released. \n   get_button() \n get the current button state get_button(button) -> bool  Returns the current state of a joystick button. \n   get_numhats() \n get the number of hat controls on a Joystick get_numhats() -> int  Returns the number of joystick hats on a Joystick. Hat devices are like miniature digital joysticks on a joystick. Each hat has two axes of input. The pygame.JOYHATMOTION event is generated when the hat changes position. The position attribute for the event contains a pair of values that are either -1, 0, or 1. A position of (0, 0) means the hat is centered. \n   get_hat() \n get the position of a joystick hat get_hat(hat_number) -> x, y  Returns the current position of a position hat. The position is given as two values representing the x and y position for the hat. (0, 0) means centered. A value of -1 means left/down and a value of 1 means right/up: so (-1, 0) means left; (1, 0) means right; (0, 1) means up; (1, 1) means upper-right; etc. This value is digital, i.e., each coordinate can be -1, 0 or 1 but never in-between. The hat number must be between 0 and get_numhats() - 1. \n \n   Example code for joystick module.  import pygame\n\n\n# Define some colors.\nBLACK = pygame.Color('black')\nWHITE = pygame.Color('white')\n\n\n# This is a simple class that will help us print to the screen.\n# It has nothing to do with the joysticks, just outputting the\n# information.\nclass TextPrint(object):\n    def __init__(self):\n        self.reset()\n        self.font = pygame.font.Font(None, 20)\n\n    def tprint(self, screen, textString):\n        textBitmap = self.font.render(textString, True, BLACK)\n        screen.blit(textBitmap, (self.x, self.y))\n        self.y += self.line_height\n\n    def reset(self):\n        self.x = 10\n        self.y = 10\n        self.line_height = 15\n\n    def indent(self):\n        self.x += 10\n\n    def unindent(self):\n        self.x -= 10\n\n\npygame.init()\n\n# Set the width and height of the screen (width, height).\nscreen = pygame.display.set_mode((500, 700))\n\npygame.display.set_caption(\"My Game\")\n\n# Loop until the user clicks the close button.\ndone = False\n\n# Used to manage how fast the screen updates.\nclock = pygame.time.Clock()\n\n# Initialize the joysticks.\npygame.joystick.init()\n\n# Get ready to print.\ntextPrint = TextPrint()\n\n# -------- Main Program Loop -----------\nwhile not done:\n    #\n    # EVENT PROCESSING STEP\n    #\n    # Possible joystick actions: JOYAXISMOTION, JOYBALLMOTION, JOYBUTTONDOWN,\n    # JOYBUTTONUP, JOYHATMOTION\n    for event in pygame.event.get(): # User did something.\n        if event.type == pygame.QUIT: # If user clicked close.\n            done = True # Flag that we are done so we exit this loop.\n        elif event.type == pygame.JOYBUTTONDOWN:\n            print(\"Joystick button pressed.\")\n        elif event.type == pygame.JOYBUTTONUP:\n            print(\"Joystick button released.\")\n\n    #\n    # DRAWING STEP\n    #\n    # First, clear the screen to white. Don't put other drawing commands\n    # above this, or they will be erased with this command.\n    screen.fill(WHITE)\n    textPrint.reset()\n\n    # Get count of joysticks.\n    joystick_count = pygame.joystick.get_count()\n\n    textPrint.tprint(screen, \"Number of joysticks: {}\".format(joystick_count))\n    textPrint.indent()\n\n    # For each joystick:\n    for i in range(joystick_count):\n        joystick = pygame.joystick.Joystick(i)\n        joystick.init()\n\n        try:\n            jid = joystick.get_instance_id()\n        except AttributeError:\n            # get_instance_id() is an SDL2 method\n            jid = joystick.get_id()\n        textPrint.tprint(screen, \"Joystick {}\".format(jid))\n        textPrint.indent()\n\n        # Get the name from the OS for the controller/joystick.\n        name = joystick.get_name()\n        textPrint.tprint(screen, \"Joystick name: {}\".format(name))\n\n        try:\n            guid = joystick.get_guid()\n        except AttributeError:\n            # get_guid() is an SDL2 method\n            pass\n        else:\n            textPrint.tprint(screen, \"GUID: {}\".format(guid))\n\n        # Usually axis run in pairs, up/down for one, and left/right for\n        # the other.\n        axes = joystick.get_numaxes()\n        textPrint.tprint(screen, \"Number of axes: {}\".format(axes))\n        textPrint.indent()\n\n        for i in range(axes):\n            axis = joystick.get_axis(i)\n            textPrint.tprint(screen, \"Axis {} value: {:>6.3f}\".format(i, axis))\n        textPrint.unindent()\n\n        buttons = joystick.get_numbuttons()\n        textPrint.tprint(screen, \"Number of buttons: {}\".format(buttons))\n        textPrint.indent()\n\n        for i in range(buttons):\n            button = joystick.get_button(i)\n            textPrint.tprint(screen,\n                             \"Button {:>2} value: {}\".format(i, button))\n        textPrint.unindent()\n\n        hats = joystick.get_numhats()\n        textPrint.tprint(screen, \"Number of hats: {}\".format(hats))\n        textPrint.indent()\n\n        # Hat position. All or nothing for direction, not a float like\n        # get_axis(). Position is a tuple of int values (x, y).\n        for i in range(hats):\n            hat = joystick.get_hat(i)\n            textPrint.tprint(screen, \"Hat {} value: {}\".format(i, str(hat)))\n        textPrint.unindent()\n\n        textPrint.unindent()\n\n    #\n    # ALL CODE TO DRAW SHOULD GO ABOVE THIS COMMENT\n    #\n\n    # Go ahead and update the screen with what we've drawn.\n    pygame.display.flip()\n\n    # Limit to 20 frames per second.\n    clock.tick(20)\n\n# Close the window and quit.\n# If you forget this line, the program will 'hang'\n# on exit if running from IDLE.\npygame.quit() Common Controller Axis Mappings Controller mappings are drawn from the underlying SDL library which pygame uses and they differ between pygame 1 and pygame 2. Below are a couple of mappings for two popular game pads. Pygame 2 Axis and hat mappings are listed from -1 to +1. X-Box 360 Controller (name: \"Xbox 360 Controller\") In pygame 2 the X360 controller mapping has 6 Axes, 11 buttons and 1 hat.  \nLeft Stick: Left -> Right   - Axis 0\nUp   -> Down    - Axis 1  \nRight Stick: Left -> Right   - Axis 3\nUp   -> Down    - Axis 4  \nLeft Trigger: Out -> In       - Axis 2  \nRight Trigger: Out -> In       - Axis 5  \nButtons: A Button        - Button 0\nB Button        - Button 1\nX Button        - Button 2\nY Button        - Button 3\nLeft Bumper     - Button 4\nRight Bumper    - Button 5\nBack Button     - Button 6\nStart Button    - Button 7\nL. Stick In     - Button 8\nR. Stick In     - Button 9\nGuide Button    - Button 10  \nHat/D-pad: Down -> Up      - Y Axis\nLeft -> Right   - X Axis   Playstation 4 Controller (name: \"PS4 Controller\") In pygame 2 the PS4 controller mapping has 6 Axes and 16 buttons.  \nLeft Stick: Left -> Right   - Axis 0\nUp   -> Down    - Axis 1  \nRight Stick: Left -> Right   - Axis 2\nUp   -> Down    - Axis 3  \nLeft Trigger: Out -> In       - Axis 4  \nRight Trigger: Out -> In       - Axis 5  \nButtons: Cross Button    - Button 0\nCircle Button   - Button 1\nSquare Button   - Button 2\nTriangle Button - Button 3\nShare Button    - Button 4\nPS Button       - Button 5\nOptions Button  - Button 6\nL. Stick In     - Button 7\nR. Stick In     - Button 8\nLeft Bumper     - Button 9\nRight Bumper    - Button 10\nD-pad Up        - Button 11\nD-pad Down      - Button 12\nD-pad Left      - Button 13\nD-pad Right     - Button 14\nTouch Pad Click - Button 15   Pygame 1 Axis and hat mappings are listed from -1 to +1. X-Box 360 Controller (name: \"Controller (XBOX 360 For Windows)\") In pygame 1 the X360 controller mapping has 5 Axes, 10 buttons and 1 hat.  \nLeft Stick: Left -> Right   - Axis 0\nUp   -> Down    - Axis 1  \nRight Stick: Left -> Right   - Axis 4\nUp   -> Down    - Axis 3  \nLeft Trigger & Right Trigger: RT -> LT        - Axis 2  \nButtons: A Button        - Button 0\nB Button        - Button 1\nX Button        - Button 2\nY Button        - Button 3\nLeft Bumper     - Button 4\nRight Bumper    - Button 5\nBack Button     - Button 6\nStart Button    - Button 7\nL. Stick In     - Button 8\nR. Stick In     - Button 9  \nHat/D-pad: Down -> Up      - Y Axis\nLeft -> Right   - X Axis   Playstation 4 Controller (name: \"Wireless Controller\") In pygame 1 the PS4 controller mapping has 6 Axes and 14 buttons and 1 hat.  \nLeft Stick: Left -> Right   - Axis 0\nUp   -> Down    - Axis 1  \nRight Stick: Left -> Right   - Axis 2\nUp   -> Down    - Axis 3  \nLeft Trigger: Out -> In       - Axis 5  \nRight Trigger: Out -> In       - Axis 4  \nButtons: Cross Button    - Button 0\nCircle Button   - Button 1\nSquare Button   - Button 2\nTriangle Button - Button 3\nLeft Bumper     - Button 4\nRight Bumper    - Button 5\nL. Trigger(Full)- Button 6\nR. Trigger(Full)- Button 7\nShare Button    - Button 8\nOptions Button  - Button 9\nL. Stick In     - Button 10\nR. Stick In     - Button 11\nPS Button       - Button 12\nTouch Pad Click - Button 13  \nHat/D-pad: Down -> Up      - Y Axis\nLeft -> Right   - X Axis   \n \n"}, {"name": "module-key", "path": "ref/key", "type": "pygame.key", "text": " pygame.key\n  \n pygame module to work with the keyboard  This module contains functions for dealing with the keyboard. The pygame.event queue gets pygame.KEYDOWN and pygame.KEYUP events when the keyboard buttons are pressed and released. Both events have key and mod attributes.  \n \nkey: an integer ID representing every key on the keyboard \nmod: a bitmask of all the modifier keys that were in a pressed state when the event occurred  \n The pygame.KEYDOWN event has the additional attributes unicode and scancode.  \n \nunicode: a single character string that is the fully translated character entered, this takes into account the shift and composition keys \nscancode: the platform-specific key code, which could be different from keyboard to keyboard, but is useful for key selection of weird keys like the multimedia keys  \n  New in pygame 2.0.0: The pygame.TEXTINPUT event is preferred to the unicode attribute of pygame.KEYDOWN. The attribute text contains the input.  The following is a list of all the constants (from pygame.locals) used to represent keyboard keys. Portability note: The integers for key constants differ between pygame 1 and 2. Always use key constants (K_a) rather than integers directly (97) so that your key handling code works well on both pygame 1 and pygame 2. pygame\nConstant      ASCII   Description\n---------------------------------\nK_BACKSPACE   \\b      backspace\nK_TAB         \\t      tab\nK_CLEAR               clear\nK_RETURN      \\r      return\nK_PAUSE               pause\nK_ESCAPE      ^[      escape\nK_SPACE               space\nK_EXCLAIM     !       exclaim\nK_QUOTEDBL    \"       quotedbl\nK_HASH        #       hash\nK_DOLLAR      $       dollar\nK_AMPERSAND   &       ampersand\nK_QUOTE               quote\nK_LEFTPAREN   (       left parenthesis\nK_RIGHTPAREN  )       right parenthesis\nK_ASTERISK    *       asterisk\nK_PLUS        +       plus sign\nK_COMMA       ,       comma\nK_MINUS       -       minus sign\nK_PERIOD      .       period\nK_SLASH       /       forward slash\nK_0           0       0\nK_1           1       1\nK_2           2       2\nK_3           3       3\nK_4           4       4\nK_5           5       5\nK_6           6       6\nK_7           7       7\nK_8           8       8\nK_9           9       9\nK_COLON       :       colon\nK_SEMICOLON   ;       semicolon\nK_LESS        <       less-than sign\nK_EQUALS      =       equals sign\nK_GREATER     >       greater-than sign\nK_QUESTION    ?       question mark\nK_AT          @       at\nK_LEFTBRACKET [       left bracket\nK_BACKSLASH   \\       backslash\nK_RIGHTBRACKET ]      right bracket\nK_CARET       ^       caret\nK_UNDERSCORE  _       underscore\nK_BACKQUOTE   `       grave\nK_a           a       a\nK_b           b       b\nK_c           c       c\nK_d           d       d\nK_e           e       e\nK_f           f       f\nK_g           g       g\nK_h           h       h\nK_i           i       i\nK_j           j       j\nK_k           k       k\nK_l           l       l\nK_m           m       m\nK_n           n       n\nK_o           o       o\nK_p           p       p\nK_q           q       q\nK_r           r       r\nK_s           s       s\nK_t           t       t\nK_u           u       u\nK_v           v       v\nK_w           w       w\nK_x           x       x\nK_y           y       y\nK_z           z       z\nK_DELETE              delete\nK_KP0                 keypad 0\nK_KP1                 keypad 1\nK_KP2                 keypad 2\nK_KP3                 keypad 3\nK_KP4                 keypad 4\nK_KP5                 keypad 5\nK_KP6                 keypad 6\nK_KP7                 keypad 7\nK_KP8                 keypad 8\nK_KP9                 keypad 9\nK_KP_PERIOD   .       keypad period\nK_KP_DIVIDE   /       keypad divide\nK_KP_MULTIPLY *       keypad multiply\nK_KP_MINUS    -       keypad minus\nK_KP_PLUS     +       keypad plus\nK_KP_ENTER    \\r      keypad enter\nK_KP_EQUALS   =       keypad equals\nK_UP                  up arrow\nK_DOWN                down arrow\nK_RIGHT               right arrow\nK_LEFT                left arrow\nK_INSERT              insert\nK_HOME                home\nK_END                 end\nK_PAGEUP              page up\nK_PAGEDOWN            page down\nK_F1                  F1\nK_F2                  F2\nK_F3                  F3\nK_F4                  F4\nK_F5                  F5\nK_F6                  F6\nK_F7                  F7\nK_F8                  F8\nK_F9                  F9\nK_F10                 F10\nK_F11                 F11\nK_F12                 F12\nK_F13                 F13\nK_F14                 F14\nK_F15                 F15\nK_NUMLOCK             numlock\nK_CAPSLOCK            capslock\nK_SCROLLOCK           scrollock\nK_RSHIFT              right shift\nK_LSHIFT              left shift\nK_RCTRL               right control\nK_LCTRL               left control\nK_RALT                right alt\nK_LALT                left alt\nK_RMETA               right meta\nK_LMETA               left meta\nK_LSUPER              left Windows key\nK_RSUPER              right Windows key\nK_MODE                mode shift\nK_HELP                help\nK_PRINT               print screen\nK_SYSREQ              sysrq\nK_BREAK               break\nK_MENU                menu\nK_POWER               power\nK_EURO                Euro The keyboard also has a list of modifier states (from pygame.locals) that can be assembled by bitwise-ORing them together. pygame\nConstant      Description\n-------------------------\nKMOD_NONE     no modifier keys pressed\nKMOD_LSHIFT   left shift\nKMOD_RSHIFT   right shift\nKMOD_SHIFT    left shift or right shift or both\nKMOD_LCTRL    left control\nKMOD_RCTRL    right control\nKMOD_CTRL     left control or right control or both\nKMOD_LALT     left alt\nKMOD_RALT     right alt\nKMOD_ALT      left alt or right alt or both\nKMOD_LMETA    left meta\nKMOD_RMETA    right meta\nKMOD_META     left meta or right meta or both\nKMOD_CAPS     caps lock\nKMOD_NUM      num lock\nKMOD_MODE     AltGr The modifier information is contained in the mod attribute of the pygame.KEYDOWN and pygame.KEYUP events. The mod attribute is a bitmask of all the modifier keys that were in a pressed state when the event occurred. The modifier information can be decoded using a bitwise AND (except for KMOD_NONE, which should be compared using equals ==). For example: for event in pygame.event.get():\n    if event.type == pygame.KEYDOWN or event.type == pygame.KEYUP:\n        if event.mod == pygame.KMOD_NONE:\n            print('No modifier keys were in a pressed state when this '\n                  'event occurred.')\n        else:\n            if event.mod & pygame.KMOD_LSHIFT:\n                print('Left shift was in a pressed state when this event '\n                      'occurred.')\n            if event.mod & pygame.KMOD_RSHIFT:\n                print('Right shift was in a pressed state when this event '\n                      'occurred.')\n            if event.mod & pygame.KMOD_SHIFT:\n                print('Left shift or right shift or both were in a '\n                      'pressed state when this event occurred.')   pygame.key.get_focused() \n true if the display is receiving keyboard input from the system get_focused() -> bool  Returns True when the display window has keyboard focus from the system. If the display needs to ensure it does not lose keyboard focus, it can use pygame.event.set_grab() to grab all input. \n   pygame.key.get_pressed() \n get the state of all keyboard buttons get_pressed() -> bools  Returns a sequence of boolean values representing the state of every key on the keyboard. Use the key constant values to index the array. A True value means the that button is pressed.  Note Getting the list of pushed buttons with this function is not the proper way to handle text entry from the user. There is no way to know the order of keys pressed, and rapidly pushed keys can be completely unnoticed between two calls to pygame.key.get_pressed(). There is also no way to translate these pushed keys into a fully translated character value. See the pygame.KEYDOWN events on the pygame.event queue for this functionality.  \n   pygame.key.get_mods() \n determine which modifier keys are being held get_mods() -> int  Returns a single integer representing a bitmask of all the modifier keys being held. Using bitwise operators you can test if specific modifier keys are pressed. \n   pygame.key.set_mods() \n temporarily set which modifier keys are pressed set_mods(int) -> None  Create a bitmask of the modifier key constants you want to impose on your program. \n   pygame.key.set_repeat() \n control how held keys are repeated set_repeat() -> None set_repeat(delay) -> None set_repeat(delay, interval) -> None  When the keyboard repeat is enabled, keys that are held down will generate multiple pygame.KEYDOWN events. The delay parameter is the number of milliseconds before the first repeated pygame.KEYDOWN event will be sent. After that, another pygame.KEYDOWN event will be sent every interval milliseconds. If a delay value is provided and an interval value is not provided or is 0, then the interval will be set to the same value as delay. To disable key repeat call this function with no arguments or with delay set to 0. When pygame is initialized the key repeat is disabled.     \nRaises:\n\nValueError -- if delay or interval is < 0     Changed in pygame 2.0.0: A ValueError is now raised (instead of a pygame.error) if delay or interval is < 0.  \n   pygame.key.get_repeat() \n see how held keys are repeated get_repeat() -> (delay, interval)  Get the delay and interval keyboard repeat values. Refer to pygame.key.set_repeat() for a description of these values.  New in pygame 1.8.  \n   pygame.key.name() \n get the name of a key identifier name(key) -> string  Get the descriptive name of the button from a keyboard button id constant. \n   pygame.key.key_code() \n get the key identifier from a key name key_code(name=string) -> int  Get the key identifier code from the descriptive name of the key. This returns an integer matching one of the K_* keycodes. For example: >>> pygame.key.key_code(\"return\") == pygame.K_RETURN\nTrue\n>>> pygame.key.key_code(\"0\") == pygame.K_0\nTrue\n>>> pygame.key.key_code(\"space\") == pygame.K_SPACE\nTrue     \nRaises:\n\n \nValueError -- if the key name is not known. \nNotImplementedError -- if used with SDL 1.       New in pygame 2.0.0.  \n   pygame.key.start_text_input() \n start handling Unicode text input events start_text_input() -> None  Start receiving pygame.TEXTEDITING and pygame.TEXTINPUT events. A pygame.TEXTEDITING event is received when an IME composition is started or changed. It contains the composition text, length, and editing start position within the composition (attributes text, length, and start, respectively). When the composition is committed (or non-IME input is received), a pygame.TEXTINPUT event is generated. Text input events handling is on by default.  New in pygame 2.0.0.  \n   pygame.key.stop_text_input() \n stop handling Unicode text input events stop_text_input() -> None  Stop receiving pygame.TEXTEDITING and pygame.TEXTINPUT events. Text input events handling is on by default  New in pygame 2.0.0.  \n   pygame.key.set_text_input_rect() \n controls the position of the candidate list set_text_input_rect(Rect) -> None  This sets the rectangle used for typing with an IME. It controls where the candidate list will open, if supported.  New in pygame 2.0.0.  \n \n \n"}, {"name": "module-locals", "path": "ref/locals", "type": "pygame.locals", "text": " pygame.locals\n  \n pygame constants  This module contains various constants used by pygame. Its contents are automatically placed in the pygame module namespace. However, an application can use pygame.locals to include only the pygame constants with a from\npygame.locals import *. Detailed descriptions of the various constants can be found throughout the pygame documentation. Here are the locations of some of them.  \n The pygame.display module contains flags like HWSURFACE used by pygame.display.set_mode(). The pygame.event module contains the various event types. The pygame.key module lists the keyboard constants and modifiers (K_* and MOD_*) relating to the key and mod attributes of the KEYDOWN and KEYUP events. The pygame.time module defines TIMER_RESOLUTION.  \n \n \n"}, {"name": "module-mask", "path": "ref/mask", "type": "pygame.mask", "text": " pygame.mask\n  \n pygame module for image masks.  Useful for fast pixel perfect collision detection. A mask uses 1 bit per-pixel to store which parts collide.  New in pygame 1.8.    pygame.mask.from_surface() \n Creates a Mask from the given surface from_surface(Surface) -> Mask from_surface(Surface, threshold=127) -> Mask  Creates a Mask object from the given surface by setting all the opaque pixels and not setting the transparent pixels. If the surface uses a color-key, then it is used to decide which bits in the resulting mask are set. All the pixels that are not equal to the color-key are set and the pixels equal to the color-key are not set. If a color-key is not used, then the alpha value of each pixel is used to decide which bits in the resulting mask are set. All the pixels that have an alpha value greater than the threshold parameter are set and the pixels with an alpha value less than or equal to the threshold are not set.     \nParameters:\n\n \nsurface (Surface) -- the surface to create the mask from \nthreshold (int) -- (optional) the alpha threshold (default is 127) to compare with each surface pixel's alpha value, if the surface is color-keyed this parameter is ignored    \nReturns:\n\na newly created Mask object from the given surface   \nReturn type:\n\nMask      Note This function is used to create the masks for pygame.sprite.collide_mask().  \n   pygame.mask.from_threshold() \n Creates a mask by thresholding Surfaces from_threshold(Surface, color) -> Mask from_threshold(Surface, color, threshold=(0, 0, 0, 255), othersurface=None, palette_colors=1) -> Mask  This is a more featureful method of getting a Mask from a surface. If the optional othersurface is not used, all the pixels within the threshold of the color parameter are set in the resulting mask. If the optional othersurface is used, every pixel in the first surface that is within the threshold of the corresponding pixel in othersurface is set in the resulting mask.     \nParameters:\n\n \nsurface (Surface) -- the surface to create the mask from \ncolor (Color or int or tuple(int, int, int, [int]) or list[int, int, int, [int]]) -- color used to check if the surface's pixels are within the given threshold range, this parameter is ignored if the optional othersurface parameter is supplied \nthreshold (Color or int or tuple(int, int, int, [int]) or list[int, int, int, [int]]) -- (optional) the threshold range used to check the difference between two colors (default is (0, 0, 0, 255)) \nothersurface (Surface) -- (optional) used to check whether the pixels of the first surface are within the given threshold range of the pixels from this surface (default is None) \npalette_colors (int) -- (optional) indicates whether to use the palette colors or not, a nonzero value causes the palette colors to be used and a 0 causes them not to be used (default is 1)    \nReturns:\n\na newly created Mask object from the given surface   \nReturn type:\n\nMask     \n   pygame.mask.Mask \n pygame object for representing 2D bitmasks Mask(size=(width, height)) -> Mask Mask(size=(width, height), fill=False) -> Mask  A Mask object is used to represent a 2D bitmask. Each bit in the mask represents a pixel. 1 is used to indicate a set bit and 0 is used to indicate an unset bit. Set bits in a mask can be used to detect collisions with other masks and their set bits. A filled mask has all of its bits set to 1, conversely an unfilled/cleared/empty mask has all of its bits set to 0. Masks can be created unfilled (default) or filled by using the fill parameter. Masks can also be cleared or filled using the pygame.mask.Mask.clear() and pygame.mask.Mask.fill() methods respectively. A mask's coordinates start in the top left corner at (0, 0) just like pygame.Surface. Individual bits can be accessed using the pygame.mask.Mask.get_at() and pygame.mask.Mask.set_at() methods. The methods overlap(), overlap_area(), overlap_mask(), draw(), erase(), and convolve() use an offset parameter to indicate the offset of another mask's top left corner from the calling mask's top left corner. The calling mask's top left corner is considered to be the origin (0, 0). Offsets are a tuple or list of 2 integer values (x_offset, y_offset). Positive and negative offset values are supported. 0 to x (x_offset)\n           :    :\n   0 ..... +----:---------+\n   to      |    :         |\n   y .......... +-----------+\n(y_offset) |    | othermask |\n           |    +-----------+\n           | calling_mask |\n           +--------------+     \nParameters:\n\n \nsize (tuple(int, int) or list[int, int]) -- the dimensions of the mask (width and height) \nfill (bool) -- (optional) create an unfilled mask (default: False) or filled mask (True)    \nReturns:\n\na newly created Mask object   \nReturn type:\n\nMask      Changed in pygame 2.0.0: Shallow copy support added. The Mask class supports the special method __copy__() and shallow copying via copy.copy(mask).   Changed in pygame 2.0.0: Subclassing support added. The Mask class can be used as a base class.   Changed in pygame 1.9.5: Added support for keyword arguments.   Changed in pygame 1.9.5: Added the optional keyword parameter fill.   Changed in pygame 1.9.5: Added support for masks with a width and/or a height of 0.    copy() \n Returns a new copy of the mask copy() -> Mask      \nReturns:\na new copy of this mask, the new mask will have the same width, height, and set/unset bits as the original  \nReturn type:\nMask     Note If a mask subclass needs to copy any instance specific attributes then it should override the __copy__() method. The overridden __copy__() method needs to call super().__copy__() and then copy the required data as in the following example code. class SubMask(pygame.mask.Mask):\n    def __copy__(self):\n        new_mask = super().__copy__()\n        # Do any SubMask attribute copying here.\n        return new_mask   New in pygame 2.0.0.  \n   get_size() \n Returns the size of the mask get_size() -> (width, height)      \nReturns:\nthe size of the mask, (width, height)  \nReturn type:\ntuple(int, int)    \n   get_rect() \n Returns a Rect based on the size of the mask get_rect(**kwargs) -> Rect  Returns a new pygame.Rect() object based on the size of this mask. The rect's default position will be (0, 0) and its default width and height will be the same as this mask's. The rect's attributes can be altered via pygame.Rect() attribute keyword arguments/values passed into this method. As an example, a_mask.get_rect(center=(10, 5)) would create a pygame.Rect() based on the mask's size centered at the given position.     \nParameters:\n\nkwargs (dict) -- pygame.Rect() attribute keyword arguments/values that will be applied to the rect  \nReturns:\na new pygame.Rect() object based on the size of this mask with any pygame.Rect() attribute keyword arguments/values applied to it  \nReturn type:\nRect     New in pygame 2.0.0.  \n   get_at() \n Gets the bit at the given position get_at((x, y)) -> int      \nParameters:\n\npos (tuple(int, int) or list[int, int]) -- the position of the bit to get  \nReturns:\n1 if the bit is set, 0 if the bit is not set  \nReturn type:\nint  \nRaises:\n\nIndexError -- if the position is outside of the mask's bounds    \n   set_at() \n Sets the bit at the given position set_at((x, y)) -> None set_at((x, y), value=1) -> None      \nParameters:\n\n \npos (tuple(int, int) or list[int, int]) -- the position of the bit to set \nvalue (int) -- any nonzero int will set the bit to 1, 0 will set the bit to 0 (default is 1)    \nReturns:\n\nNone   \nReturn type:\n\nNoneType   \nRaises:\n\nIndexError -- if the position is outside of the mask's bounds     \n   overlap() \n Returns the point of intersection overlap(othermask, offset) -> (x, y) overlap(othermask, offset) -> None  Returns the first point of intersection encountered between this mask and othermask. A point of intersection is 2 overlapping set bits. The current algorithm searches the overlapping area in sizeof(unsigned long int) * CHAR_BIT bit wide column blocks (the value of sizeof(unsigned long int) * CHAR_BIT is platform dependent, for clarity it will be referred to as W). Starting at the top left corner it checks bits 0 to W - 1 of the first row ((0, 0) to (W - 1, 0)) then continues to the next row ((0, 1) to (W - 1, 1)). Once this entire column block is checked, it continues to the next one (W to 2 * W - 1). This is repeated until it finds a point of intersection or the entire overlapping area is checked.     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\npoint of intersection or None if no intersection   \nReturn type:\n\ntuple(int, int) or NoneType     \n   overlap_area() \n Returns the number of overlapping set bits overlap_area(othermask, offset) -> numbits  Returns the number of overlapping set bits between between this mask and othermask. This can be useful for collision detection. An approximate collision normal can be found by calculating the gradient of the overlapping area through the finite difference. dx = mask.overlap_area(othermask, (x + 1, y)) - mask.overlap_area(othermask, (x - 1, y))\ndy = mask.overlap_area(othermask, (x, y + 1)) - mask.overlap_area(othermask, (x, y - 1))     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nthe number of overlapping set bits   \nReturn type:\n\nint     \n   overlap_mask() \n Returns a mask of the overlapping set bits overlap_mask(othermask, offset) -> Mask  Returns a Mask, the same size as this mask, containing the overlapping set bits between this mask and othermask.     \nParameters:\n\n \nothermask (Mask) -- the other mask to overlap with this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\na newly created Mask with the overlapping bits set   \nReturn type:\n\nMask     \n   fill() \n Sets all bits to 1 fill() -> None  Sets all bits in the mask to 1.     \nReturns:\nNone  \nReturn type:\nNoneType    \n   clear() \n Sets all bits to 0 clear() -> None  Sets all bits in the mask to 0.     \nReturns:\nNone  \nReturn type:\nNoneType    \n   invert() \n Flips all the bits invert() -> None  Flips all of the bits in the mask. All the set bits are cleared to 0 and all the unset bits are set to 1.     \nReturns:\nNone  \nReturn type:\nNoneType    \n   scale() \n Resizes a mask scale((width, height)) -> Mask  Creates a new Mask of the requested size with its bits scaled from this mask.     \nParameters:\n\nsize (tuple(int, int) or list[int, int]) -- the width and height (size) of the mask to create  \nReturns:\na new Mask object with its bits scaled from this mask  \nReturn type:\nMask  \nRaises:\n\nValueError -- if width < 0 or height < 0\n    \n   draw() \n Draws a mask onto another draw(othermask, offset) -> None  Performs a bitwise OR, drawing othermask onto this mask.     \nParameters:\n\n \nothermask (Mask) -- the mask to draw onto this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   erase() \n Erases a mask from another erase(othermask, offset) -> None  Erases (clears) all bits set in othermask from this mask.     \nParameters:\n\n \nothermask (Mask) -- the mask to erase from this mask \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, for more details refer to the Mask offset notes\n    \nReturns:\n\nNone   \nReturn type:\n\nNoneType     \n   count() \n Returns the number of set bits count() -> bits      \nReturns:\nthe number of set bits in the mask  \nReturn type:\nint    \n   centroid() \n Returns the centroid of the set bits centroid() -> (x, y)  Finds the centroid (the center mass of the set bits) for this mask.     \nReturns:\na coordinate tuple indicating the centroid of the mask, it will return (0, 0) if the mask has no bits set  \nReturn type:\ntuple(int, int)    \n   angle() \n Returns the orientation of the set bits angle() -> theta  Finds the approximate orientation (from -90 to 90 degrees) of the set bits in the mask. This works best if performed on a mask with only one connected component.     \nReturns:\nthe orientation of the set bits in the mask, it will return 0.0 if the mask has no bits set  \nReturn type:\nfloat     Note See connected_component() for details on how a connected component is calculated.  \n   outline() \n Returns a list of points outlining an object outline() -> [(x, y), ...] outline(every=1) -> [(x, y), ...]  Returns a list of points of the outline of the first connected component encountered in the mask. To find a connected component, the mask is searched per row (left to right) starting in the top left corner. The every optional parameter skips set bits in the outline. For example, setting it to 10 would return a list of every 10th set bit in the outline.     \nParameters:\n\nevery (int) -- (optional) indicates the number of bits to skip over in the outline (default is 1)  \nReturns:\na list of points outlining the first connected component encountered, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[tuple(int, int)]     Note See connected_component() for details on how a connected component is calculated.  \n   convolve() \n Returns the convolution of this mask with another mask convolve(othermask) -> Mask convolve(othermask, outputmask=None, offset=(0, 0)) -> Mask  Convolve this mask with the given othermask.     \nParameters:\n\n \nothermask (Mask) -- mask to convolve this mask with \noutputmask (Mask or NoneType) -- (optional) mask for output (default is None) \noffset (tuple(int, int) or list[int, int]) -- the offset of othermask from this mask, (default is (0, 0))    \nReturns:\n\na Mask with the (i - offset[0], j - offset[1]) bit set, if shifting othermask (such that its bottom right corner is at (i, j)) causes it to overlap with this mask If an outputmask is specified, the output is drawn onto it and it is returned. Otherwise a mask of size (MAX(0, width + othermask's\nwidth - 1), MAX(0, height + othermask's height - 1)) is created and returned.   \nReturn type:\n\nMask     \n   connected_component() \n Returns a mask containing a connected component connected_component() -> Mask connected_component((x, y)) -> Mask  A connected component is a group (1 or more) of connected set bits (orthogonally and diagonally). The SAUF algorithm, which checks 8 point connectivity, is used to find a connected component in the mask. By default this method will return a Mask containing the largest connected component in the mask. Optionally, a bit coordinate can be specified and the connected component containing it will be returned. If the bit at the given location is not set, the returned Mask will be empty (no bits set).     \nParameters:\n\npos (tuple(int, int) or list[int, int]) -- (optional) selects the connected component that contains the bit at this position  \nReturns:\na Mask object (same size as this mask) with the largest connected component from this mask, if this mask has no bits set then an empty mask will be returnedIf the pos parameter is provided then the mask returned will have the connected component that contains this position. An empty mask will be returned if the pos parameter selects an unset bit.   \nReturn type:\nMask  \nRaises:\n\nIndexError -- if the optional pos parameter is outside of the mask's bounds    \n   connected_components() \n Returns a list of masks of connected components connected_components() -> [Mask, ...] connected_components(min=0) -> [Mask, ...]  Provides a list containing a Mask object for each connected component.     \nParameters:\n\nmin (int) -- (optional) indicates the minimum number of bits (to filter out noise) per connected component (default is 0, which equates to no minimum and is equivalent to setting it to 1, as a connected component must have at least 1 bit set)  \nReturns:\na list containing a Mask object for each connected component, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[Mask]     Note See connected_component() for details on how a connected component is calculated.  \n   get_bounding_rects() \n Returns a list of bounding rects of connected components get_bounding_rects() -> [Rect, ...]  Provides a list containing a bounding rect for each connected component.     \nReturns:\na list containing a bounding rect for each connected component, an empty list is returned if the mask has no bits set  \nReturn type:\nlist[Rect]     Note See connected_component() for details on how a connected component is calculated.  \n   to_surface() \n Returns a surface with the mask drawn on it to_surface() -> Surface to_surface(surface=None, setsurface=None, unsetsurface=None, setcolor=(255, 255, 255, 255), unsetcolor=(0, 0, 0, 255), dest=(0, 0)) -> Surface  Draws this mask on the given surface. Set bits (bits set to 1) and unset bits (bits set to 0) can be drawn onto a surface.     \nParameters:\n\n \nsurface (Surface or None) -- (optional) Surface to draw mask onto, if no surface is provided one will be created (default is None, which will cause a surface with the parameters Surface(size=mask.get_size(), flags=SRCALPHA, depth=32) to be created, drawn on, and returned) \nsetsurface (Surface or None) -- (optional) use this surface's color values to draw set bits (default is None), if this surface is smaller than the mask any bits outside its bounds will use the setcolor value \nunsetsurface (Surface or None) -- (optional) use this surface's color values to draw unset bits (default is None), if this surface is smaller than the mask any bits outside its bounds will use the unsetcolor value \nsetcolor (Color or str or int or tuple(int, int, int, [int]) or list(int, int, int, [int]) or None) -- (optional) color to draw set bits (default is (255, 255, 255, 255), white), use None to skip drawing the set bits, the setsurface parameter (if set) will takes precedence over this parameter \nunsetcolor (Color or str or int or tuple(int, int, int, [int]) or list(int, int, int, [int]) or None) -- (optional) color to draw unset bits (default is (0, 0, 0, 255), black), use None to skip drawing the unset bits, the unsetsurface parameter (if set) will takes precedence over this parameter \ndest (Rect or tuple(int, int) or list(int, int) or Vector2(int, int)) -- (optional) surface destination of where to position the topleft corner of the mask being drawn (default is (0, 0)), if a Rect is used as the dest parameter, its x and y attributes will be used as the destination, NOTE1: rects with a negative width or height value will not be normalized before using their x and y values, NOTE2: this destination value is only used to position the mask on the surface, it does not offset the setsurface and unsetsurface from the mask, they are always aligned with the mask (i.e. position (0, 0) on the mask always corresponds to position (0, 0) on the setsurface and unsetsurface)    \nReturns:\n\nthe surface parameter (or a newly created surface if no surface parameter was provided) with this mask drawn on it   \nReturn type:\n\nSurface   \nRaises:\n\nValueError -- if the setsurface parameter or unsetsurface parameter does not have the same format (bytesize/bitsize/alpha) as the surface parameter      Note To skip drawing the set bits, both setsurface and setcolor must be None. The setsurface parameter defaults to None, but setcolor defaults to a color value and therefore must be set to None.   Note To skip drawing the unset bits, both unsetsurface and unsetcolor must be None. The unsetsurface parameter defaults to None, but unsetcolor defaults to a color value and therefore must be set to None.   New in pygame 2.0.0.  \n \n \n \n"}, {"name": "module-math", "path": "ref/math", "type": "pygame.math", "text": " pygame.math\n  \n pygame module for vector classes  The pygame math module currently provides Vector classes in two and three dimensions, Vector2 and Vector3 respectively. They support the following numerical operations: vec+vec, vec-vec, vec*number, number*vec, vec/number, vec//number, vec+=vec, vec-=vec, vec*=number, vec/=number, vec//=number. All these operations will be performed elementwise. In addition vec*vec will perform a scalar-product (a.k.a. dot-product). If you want to multiply every element from vector v with every element from vector w you can use the elementwise method: v.elementwise() * w The coordinates of a vector can be retrieved or set using attributes or subscripts v = pygame.Vector3()\n\nv.x = 5\nv[1] = 2 * v.x\nprint(v[1]) # 10\n\nv.x == v[0]\nv.y == v[1]\nv.z == v[2] Multiple coordinates can be set using slices or swizzling v = pygame.Vector2()\nv.xy = 1, 2\nv[:] = 1, 2  New in pygame 1.9.2pre.   Changed in pygame 1.9.4: Removed experimental notice.   Changed in pygame 1.9.4: Allow scalar construction like GLSL Vector2(2) == Vector2(2.0, 2.0)   Changed in pygame 1.9.4: pygame.math required import. More convenient pygame.Vector2 and pygame.Vector3.    pygame.math.Vector2 \n a 2-Dimensional Vector Vector2() -> Vector2 Vector2(int) -> Vector2 Vector2(float) -> Vector2 Vector2(Vector2) -> Vector2 Vector2(x, y) -> Vector2 Vector2((x, y)) -> Vector2  Some general information about the Vector2 class.   dot() \n calculates the dot- or scalar-product with the other vector dot(Vector2) -> float  \n   cross() \n calculates the cross- or vector-product cross(Vector2) -> Vector2  calculates the third component of the cross-product. \n   magnitude() \n returns the Euclidean magnitude of the vector. magnitude() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2) \n   magnitude_squared() \n returns the squared magnitude of the vector. magnitude_squared() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude_squared() == vec.x**2 + vec.y**2. This is faster than vec.magnitude() because it avoids the square root. \n   length() \n returns the Euclidean length of the vector. length() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2) \n   length_squared() \n returns the squared Euclidean length of the vector. length_squared() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2. This is faster than vec.length() because it avoids the square root. \n   normalize() \n returns a vector with the same direction but length 1. normalize() -> Vector2  Returns a new vector that has length equal to 1 and the same direction as self. \n   normalize_ip() \n normalizes the vector in place so that its length is 1. normalize_ip() -> None  Normalizes the vector so that it has length equal to 1. The direction of the vector is not changed. \n   is_normalized() \n tests if the vector is normalized i.e. has length == 1. is_normalized() -> Bool  Returns True if the vector has length equal to 1. Otherwise it returns False. \n   scale_to_length() \n scales the vector to a given length. scale_to_length(float) -> None  Scales the vector so that it has the given length. The direction of the vector is not changed. You can also scale to length 0. If the vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. \n   reflect() \n returns a vector reflected of a given normal. reflect(Vector2) -> Vector2  Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. \n   reflect_ip() \n reflect the vector of a given normal in place. reflect_ip(Vector2) -> None  Changes the direction of self as if it would have been reflected of a surface with the given surface normal. \n   distance_to() \n calculates the Euclidean distance to a given vector. distance_to(Vector2) -> float  \n   distance_squared_to() \n calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector2) -> float  \n   lerp() \n returns a linear interpolation to the given vector. lerp(Vector2, float) -> Vector2  Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned. \n   slerp() \n returns a spherical interpolation to the given vector. slerp(Vector2, float) -> Vector2  Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. \n   elementwise() \n The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy  Applies the following operation to each element of the vector. \n   rotate() \n rotates a vector by a given angle in degrees. rotate(angle) -> Vector2  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees. \n   rotate_rad() \n rotates a vector by a given angle in radians. rotate_rad(angle) -> Vector2  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_ip() \n rotates the vector by a given angle in degrees in place. rotate_ip(angle) -> None  Rotates the vector counterclockwise by the given angle in degrees. The length of the vector is not changed. \n   rotate_ip_rad() \n rotates the vector by a given angle in radians in place. rotate_ip_rad(angle) -> None  Rotates the vector counterclockwise by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   angle_to() \n calculates the angle to a given vector in degrees. angle_to(Vector2) -> float  Returns the angle between self and the given vector. \n   as_polar() \n returns a tuple with radial distance and azimuthal angle. as_polar() -> (r, phi)  Returns a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. \n   from_polar() \n Sets x and y from a polar coordinates tuple. from_polar((r, phi)) -> None  Sets x and y from a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle. \n   update() \n Sets the coordinates of the vector. update() -> None update(int) -> None update(float) -> None update(Vector2) -> None update(x, y) -> None update((x, y)) -> None  Sets coordinates x and y in place.  New in pygame 1.9.5.  \n \n   pygame.math.Vector3 \n a 3-Dimensional Vector Vector3() -> Vector3 Vector3(int) -> Vector3 Vector3(float) -> Vector3 Vector3(Vector3) -> Vector3 Vector3(x, y, z) -> Vector3 Vector3((x, y, z)) -> Vector3  Some general information about the Vector3 class.   dot() \n calculates the dot- or scalar-product with the other vector dot(Vector3) -> float  \n   cross() \n calculates the cross- or vector-product cross(Vector3) -> Vector3  calculates the cross-product. \n   magnitude() \n returns the Euclidean magnitude of the vector. magnitude() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2) \n   magnitude_squared() \n returns the squared Euclidean magnitude of the vector. magnitude_squared() -> float  calculates the magnitude of the vector which follows from the theorem: vec.magnitude_squared() == vec.x**2 + vec.y**2 + vec.z**2. This is faster than vec.magnitude() because it avoids the square root. \n   length() \n returns the Euclidean length of the vector. length() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2) \n   length_squared() \n returns the squared Euclidean length of the vector. length_squared() -> float  calculates the Euclidean length of the vector which follows from the Pythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2 + vec.z**2. This is faster than vec.length() because it avoids the square root. \n   normalize() \n returns a vector with the same direction but length 1. normalize() -> Vector3  Returns a new vector that has length equal to 1 and the same direction as self. \n   normalize_ip() \n normalizes the vector in place so that its length is 1. normalize_ip() -> None  Normalizes the vector so that it has length equal to 1. The direction of the vector is not changed. \n   is_normalized() \n tests if the vector is normalized i.e. has length == 1. is_normalized() -> Bool  Returns True if the vector has length equal to 1. Otherwise it returns False. \n   scale_to_length() \n scales the vector to a given length. scale_to_length(float) -> None  Scales the vector so that it has the given length. The direction of the vector is not changed. You can also scale to length 0. If the vector is the zero vector (i.e. has length 0 thus no direction) a ValueError is raised. \n   reflect() \n returns a vector reflected of a given normal. reflect(Vector3) -> Vector3  Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's. \n   reflect_ip() \n reflect the vector of a given normal in place. reflect_ip(Vector3) -> None  Changes the direction of self as if it would have been reflected of a surface with the given surface normal. \n   distance_to() \n calculates the Euclidean distance to a given vector. distance_to(Vector3) -> float  \n   distance_squared_to() \n calculates the squared Euclidean distance to a given vector. distance_squared_to(Vector3) -> float  \n   lerp() \n returns a linear interpolation to the given vector. lerp(Vector3, float) -> Vector3  Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self an other the result is going to be. It must be a value between 0 and 1, where 0 means self and 1 means other will be returned. \n   slerp() \n returns a spherical interpolation to the given vector. slerp(Vector3, float) -> Vector3  Calculates the spherical interpolation from self to the given Vector. The second argument - often called t - must be in the range [-1, 1]. It parametrizes where - in between the two vectors - the result should be. If a negative value is given the interpolation will not take the complement of the shortest path. \n   elementwise() \n The next operation will be performed elementwise. elementwise() -> VectorElementwiseProxy  Applies the following operation to each element of the vector. \n   rotate() \n rotates a vector by a given angle in degrees. rotate(angle, Vector3) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees around the given axis. \n   rotate_rad() \n rotates a vector by a given angle in radians. rotate_rad(angle, Vector3) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians around the given axis.  New in pygame 2.0.0.  \n   rotate_ip() \n rotates the vector by a given angle in degrees in place. rotate_ip(angle, Vector3) -> None  Rotates the vector counterclockwise around the given axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_ip_rad() \n rotates the vector by a given angle in radians in place. rotate_ip_rad(angle, Vector3) -> None  Rotates the vector counterclockwise around the given axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   rotate_x() \n rotates a vector around the x-axis by the angle in degrees. rotate_x(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in degrees. \n   rotate_x_rad() \n rotates a vector around the x-axis by the angle in radians. rotate_x_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_x_ip() \n rotates the vector around the x-axis by the angle in degrees in place. rotate_x_ip(angle) -> None  Rotates the vector counterclockwise around the x-axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_x_ip_rad() \n rotates the vector around the x-axis by the angle in radians in place. rotate_x_ip_rad(angle) -> None  Rotates the vector counterclockwise around the x-axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   rotate_y() \n rotates a vector around the y-axis by the angle in degrees. rotate_y(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in degrees. \n   rotate_y_rad() \n rotates a vector around the y-axis by the angle in radians. rotate_y_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_y_ip() \n rotates the vector around the y-axis by the angle in degrees in place. rotate_y_ip(angle) -> None  Rotates the vector counterclockwise around the y-axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_y_ip_rad() \n rotates the vector around the y-axis by the angle in radians in place. rotate_y_ip_rad(angle) -> None  Rotates the vector counterclockwise around the y-axis by the given angle in radians. The length of the vector is not changed.  New in pygame 2.0.0.  \n   rotate_z() \n rotates a vector around the z-axis by the angle in degrees. rotate_z(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in degrees. \n   rotate_z_rad() \n rotates a vector around the z-axis by the angle in radians. rotate_z_rad(angle) -> Vector3  Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in radians.  New in pygame 2.0.0.  \n   rotate_z_ip() \n rotates the vector around the z-axis by the angle in degrees in place. rotate_z_ip(angle) -> None  Rotates the vector counterclockwise around the z-axis by the given angle in degrees. The length of the vector is not changed. \n   rotate_z_ip_rad() \n rotates the vector around the z-axis by the angle in radians in place. rotate_z_ip_rad(angle) -> None  Rotates the vector counterclockwise around the z-axis by the given angle in radians. The length of the vector is not changed. \n   angle_to() \n calculates the angle to a given vector in degrees. angle_to(Vector3) -> float  Returns the angle between self and the given vector. \n   as_spherical() \n returns a tuple with radial distance, inclination and azimuthal angle. as_spherical() -> (r, theta, phi)  Returns a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle. \n   from_spherical() \n Sets x, y and z from a spherical coordinates 3-tuple. from_spherical((r, theta, phi)) -> None  Sets x, y and z from a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle. \n   update() \n Sets the coordinates of the vector. update() -> None update(int) -> None update(float) -> None update(Vector3) -> None update(x, y, z) -> None update((x, y, z)) -> None  Sets coordinates x, y, and z in place.  New in pygame 1.9.5.  \n \n   pygame.math.enable_swizzling() \n globally enables swizzling for vectors. enable_swizzling() -> None  DEPRECATED: Not needed anymore. Will be removed in a later version. Enables swizzling for all vectors until disable_swizzling() is called. By default swizzling is disabled. Lets you get or set multiple coordinates as one attribute, eg vec.xyz = 1, 2, 3. \n   pygame.math.disable_swizzling() \n globally disables swizzling for vectors. disable_swizzling() -> None  DEPRECATED: Not needed anymore. Will be removed in a later version. Disables swizzling for all vectors until enable_swizzling() is called. By default swizzling is disabled. \n \n \n"}, {"name": "module-midi", "path": "ref/midi", "type": "pygame.midi", "text": " pygame.midi\n  \n pygame module for interacting with midi input and output.   New in pygame 1.9.0.  The midi module can send output to midi devices and get input from midi devices. It can also list midi devices on the system. The midi module supports real and virtual midi devices. It uses the portmidi library. Is portable to which ever platforms portmidi supports (currently Windows, Mac OS X, and Linux). This uses pyportmidi for now, but may use its own bindings at some point in the future. The pyportmidi bindings are included with pygame.     New in pygame 2.0.0.  These are pygame events (pygame.event) reserved for midi use. The MIDIIN event is used by pygame.midi.midis2events() when converting midi events to pygame events. MIDIIN\nMIDIOUT      pygame.midi.init() \n initialize the midi module init() -> None  Initializes the pygame.midi module. Must be called before using the pygame.midi module. It is safe to call this more than once. \n   pygame.midi.quit() \n uninitialize the midi module quit() -> None  Uninitializes the pygame.midi module. If pygame.midi.init() was called to initialize the pygame.midi module, then this function will be called automatically when your program exits. It is safe to call this function more than once. \n   pygame.midi.get_init() \n returns True if the midi module is currently initialized get_init() -> bool  Gets the initialization state of the pygame.midi module.     \nReturns:\n\nTrue if the pygame.midi module is currently initialized.  \nReturn type:\nbool     New in pygame 1.9.5.  \n   pygame.midi.Input \n Input is used to get midi input from midi devices. Input(device_id) -> None Input(device_id, buffer_size) -> None      \nParameters:\n\n \ndevice_id (int) -- midi device id \nbuffer_size (int) -- (optional) the number of input events to be buffered        close() \n closes a midi stream, flushing any pending buffers. close() -> None  PortMidi attempts to close open streams when the application exits.  Note This is particularly difficult under Windows.  \n   poll() \n returns True if there's data, or False if not. poll() -> bool  Used to indicate if any data exists.     \nReturns:\n\nTrue if there is data, False otherwise  \nReturn type:\nbool  \nRaises:\n\nMidiException -- on error    \n   read() \n reads num_events midi events from the buffer. read(num_events) -> midi_event_list  Reads from the input buffer and gives back midi events.     \nParameters:\n\nnum_events (int) -- number of input events to read  \nReturns:\nthe format for midi_event_list is [[[status, data1, data2, data3], timestamp], ...]\n  \nReturn type:\nlist    \n \n   pygame.midi.Output \n Output is used to send midi to an output device Output(device_id) -> None Output(device_id, latency=0) -> None Output(device_id, buffer_size=256) -> None Output(device_id, latency, buffer_size) -> None  The buffer_size specifies the number of output events to be buffered waiting for output. In some cases (see below) PortMidi does not buffer output at all and merely passes data to a lower-level API, in which case buffersize is ignored. latency is the delay in milliseconds applied to timestamps to determine when the output should actually occur. If latency is <<0, 0 is assumed. If latency is zero, timestamps are ignored and all output is delivered immediately. If latency is greater than zero, output is delayed until the message timestamp plus the latency. In some cases, PortMidi can obtain better timing than your application by passing timestamps along to the device driver or hardware. Latency may also help you to synchronize midi data to audio data by matching midi latency to the audio buffer latency.  Note Time is measured relative to the time source indicated by time_proc. Timestamps are absolute, not relative delays or offsets.    abort() \n terminates outgoing messages immediately abort() -> None  The caller should immediately close the output port; this call may result in transmission of a partial midi message. There is no abort for Midi input because the user can simply ignore messages in the buffer and close an input device at any time. \n   close() \n closes a midi stream, flushing any pending buffers. close() -> None  PortMidi attempts to close open streams when the application exits.  Note This is particularly difficult under Windows.  \n   note_off() \n turns a midi note off (note must be on) note_off(note, velocity=None, channel=0) -> None  Turn a note off in the output stream. The note must already be on for this to work correctly. \n   note_on() \n turns a midi note on (note must be off) note_on(note, velocity=None, channel=0) -> None  Turn a note on in the output stream. The note must already be off for this to work correctly. \n   set_instrument() \n select an instrument, with a value between 0 and 127 set_instrument(instrument_id, channel=0) -> None  Select an instrument. \n   pitch_bend() \n modify the pitch of a channel. set_instrument(value=0, channel=0) -> None  Adjust the pitch of a channel. The value is a signed integer from -8192 to +8191. For example, 0 means \"no change\", +4096 is typically a semitone higher, and -8192 is 1 whole tone lower (though the musical range corresponding to the pitch bend range can also be changed in some synthesizers). If no value is given, the pitch bend is returned to \"no change\".  New in pygame 1.9.4.  \n   write() \n writes a list of midi data to the Output write(data) -> None  Writes series of MIDI information in the form of a list.     \nParameters:\n\ndata (list) -- data to write, the expected format is [[[status, data1=0, data2=0, ...], timestamp], ...] with the data# fields being optional  \nRaises:\n\nIndexError -- if more than 1024 elements in the data list    Example: # Program change at time 20000 and 500ms later send note 65 with\n# velocity 100.\nwrite([[[0xc0, 0, 0], 20000], [[0x90, 60, 100], 20500]])  Note  Timestamps will be ignored if latency = 0 To get a note to play immediately, send MIDI info with timestamp read from function Time Optional data fields: write([[[0xc0, 0, 0], 20000]]) is equivalent to write([[[0xc0], 20000]])\n   \n   write_short() \n writes up to 3 bytes of midi data to the Output write_short(status) -> None write_short(status, data1=0, data2=0) -> None  Output MIDI information of 3 bytes or less. The data fields are optional and assumed to be 0 if omitted. Examples of status byte values: 0xc0  # program change\n0x90  # note on\n# etc. Example: # note 65 on with velocity 100\nwrite_short(0x90, 65, 100) \n   write_sys_ex() \n writes a timestamped system-exclusive midi message. write_sys_ex(when, msg) -> None  Writes a timestamped system-exclusive midi message.     \nParameters:\n\n \nmsg (list[int] or str) -- midi message \nwhen -- timestamp in milliseconds      Example: midi_output.write_sys_ex(0, '\\xF0\\x7D\\x10\\x11\\x12\\x13\\xF7')\n\n# is equivalent to\n\nmidi_output.write_sys_ex(pygame.midi.time(),\n                         [0xF0, 0x7D, 0x10, 0x11, 0x12, 0x13, 0xF7]) \n \n   pygame.midi.get_count() \n gets the number of devices. get_count() -> num_devices  Device ids range from 0 to get_count() - 1 \n   pygame.midi.get_default_input_id() \n gets default input device number get_default_input_id() -> default_id  The following describes the usage details for this function and the get_default_output_id() function. Return the default device ID or -1 if there are no devices. The result can be passed to the Input/Output class. On a PC the user can specify a default device by setting an environment variable. To use device #1, for example: set PM_RECOMMENDED_INPUT_DEVICE=1\nor\nset PM_RECOMMENDED_OUTPUT_DEVICE=1 The user should first determine the available device ID by using the supplied application \"testin\" or \"testout\". In general, the registry is a better place for this kind of info. With USB devices that can come and go, using integers is not very reliable for device identification. Under Windows, if PM_RECOMMENDED_INPUT_DEVICE (or PM_RECOMMENDED_OUTPUT_DEVICE) is NOT found in the environment, then the default device is obtained by looking for a string in the registry under: HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Input_Device\nor\nHKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Output_Device The number of the first device with a substring that matches the string exactly is returned. For example, if the string in the registry is \"USB\" and device 1 is named \"In USB MidiSport 1x1\", then that will be the default input because it contains the string \"USB\". In addition to the name, get_device_info() returns \"interf\", which is the interface name. The \"interface\" is the underlying software system or API used by PortMidi to access devices. Supported interfaces: MMSystem   # the only Win32 interface currently supported\nALSA       # the only Linux interface currently supported\nCoreMIDI   # the only Mac OS X interface currently supported\n# DirectX - not implemented\n# OSS     - not implemented To specify both the interface and the device name in the registry, separate the two with a comma and a space. The string before the comma must be a substring of the \"interf\" string and the string after the space must be a substring of the \"name\" name string in order to match the device. e.g.: MMSystem, In USB MidiSport 1x1  Note In the current release, the default is simply the first device (the input or output device with the lowest PmDeviceID).  \n   pygame.midi.get_default_output_id() \n gets default output device number get_default_output_id() -> default_id  See get_default_input_id() for usage details. \n   pygame.midi.get_device_info() \n returns information about a midi device get_device_info(an_id) -> (interf, name, input, output, opened) get_device_info(an_id) -> None  Gets the device info for a given id.     \nParameters:\n\nan_id (int) -- id of the midi device being queried  \nReturns:\nif the id is out of range None is returned, otherwise a tuple of (interf, name, input, output, opened) is returned. \n interf: string describing the device interface (e.g. 'ALSA') name: string name of the device (e.g. 'Midi Through Port-0') input: 1 if the device is an input device, otherwise 0 output: 1 if the device is an output device, otherwise 0 opened: 1 if the device is opened, otherwise 0  \n   \nReturn type:\ntuple or None    \n   pygame.midi.midis2events() \n converts midi events to pygame events midis2events(midi_events, device_id) -> [Event, ...]  Takes a sequence of midi events and returns list of pygame events. The midi_events data is expected to be a sequence of ((status, data1, data2, data3), timestamp) midi events (all values required).     \nReturns:\na list of pygame events of event type MIDIIN\n  \nReturn type:\nlist    \n   pygame.midi.time() \n returns the current time in ms of the PortMidi timer time() -> time  The time is reset to 0 when the pygame.midi module is initialized. \n   pygame.midi.frequency_to_midi() \n Converts a frequency into a MIDI note. Rounds to the closest midi note. frequency_to_midi(midi_note) -> midi_note  example: frequency_to_midi(27.5) == 21  New in pygame 1.9.5.  \n   pygame.midi.midi_to_frequency() \n Converts a midi note to a frequency. midi_to_frequency(midi_note) -> frequency  example: midi_to_frequency(21) == 27.5  New in pygame 1.9.5.  \n   pygame.midi.midi_to_ansi_note() \n Returns the Ansi Note name for a midi number. midi_to_ansi_note(midi_note) -> ansi_note  example: midi_to_ansi_note(21) == 'A0'  New in pygame 1.9.5.  \n   exception pygame.midi.MidiException \n exception that pygame.midi functions and classes can raise MidiException(errno) -> None  \n \n \n"}, {"name": "module-mixer", "path": "ref/mixer", "type": "pygame.mixer", "text": " pygame.mixer\n  \n pygame module for loading and playing sounds  This module contains classes for loading Sound objects and controlling playback. The mixer module is optional and depends on SDL_mixer. Your program should test that pygame.mixer is available and initialized before using it. The mixer module has a limited number of channels for playback of sounds. Usually programs tell pygame to start playing audio and it selects an available channel automatically. The default is 8 simultaneous channels, but complex programs can get more precise control over the number of channels and their use. All sound playback is mixed in background threads. When you begin to play a Sound object, it will return immediately while the sound continues to play. A single Sound object can also be actively played back multiple times. The mixer also has a special streaming channel. This is for music playback and is accessed through the pygame.mixer.music module. The mixer module must be initialized like other pygame modules, but it has some extra conditions. The pygame.mixer.init() function takes several optional arguments to control the playback rate and sample size. Pygame will default to reasonable values, but pygame cannot perform Sound resampling, so the mixer should be initialized to match the values of your audio resources. NOTE: For less laggy sound use a smaller buffer size. The default is set to reduce the chance of scratchy sounds on some computers. You can change the default buffer by calling pygame.mixer.pre_init() before pygame.mixer.init() or pygame.init() is called. For example: pygame.mixer.pre_init(44100,-16,2, 1024)   pygame.mixer.init() \n initialize the mixer module init(frequency=44100, size=-16, channels=2, buffer=512, devicename=None, allowedchanges=AUDIO_ALLOW_FREQUENCY_CHANGE | AUDIO_ALLOW_CHANNELS_CHANGE) -> None  Initialize the mixer module for Sound loading and playback. The default arguments can be overridden to provide specific audio mixing. Keyword arguments are accepted. For backward compatibility where an argument is set zero the default value is used (possible changed by a pre_init call). The size argument represents how many bits are used for each audio sample. If the value is negative then signed sample values will be used. Positive values mean unsigned audio samples will be used. An invalid value raises an exception. The channels argument is used to specify whether to use mono or stereo. 1 for mono and 2 for stereo. The buffer argument controls the number of internal samples used in the sound mixer. The default value should work for most cases. It can be lowered to reduce latency, but sound dropout may occur. It can be raised to larger values to ensure playback never skips, but it will impose latency on sound playback. The buffer size must be a power of two (if not it is rounded up to the next nearest power of 2). Some platforms require the pygame.mixer module to be initialized after the display modules have initialized. The top level pygame.init() takes care of this automatically, but cannot pass any arguments to the mixer init. To solve this, mixer has a function pygame.mixer.pre_init() to set the proper defaults before the toplevel init is used. When using allowedchanges=0 it will convert the samples at runtime to match what the hardware supports. For example a sound card may not support 16bit sound samples, so instead it will use 8bit samples internally. If AUDIO_ALLOW_FORMAT_CHANGE is supplied, then the requested format will change to the closest that SDL2 supports. Apart from 0, allowedchanged accepts the following constants ORed together:  \n AUDIO_ALLOW_FREQUENCY_CHANGE AUDIO_ALLOW_FORMAT_CHANGE AUDIO_ALLOW_CHANNELS_CHANGE AUDIO_ALLOW_ANY_CHANGE  \n It is safe to call this more than once, but after the mixer is initialized you cannot change the playback arguments without first calling pygame.mixer.quit().  Changed in pygame 1.8: The default buffersize was changed from 1024 to 3072.   Changed in pygame 1.9.1: The default buffersize was changed from 3072 to 4096.   Changed in pygame 2.0.0: The default buffersize was changed from 4096 to 512. The default frequency changed to 44100 from 22050.   Changed in pygame 2.0.0: size can be 32 (32bit floats).   Changed in pygame 2.0.0: channels can also be 4 or 6.   New in pygame 2.0.0: allowedchanges argument added  \n   pygame.mixer.pre_init() \n preset the mixer init arguments pre_init(frequency=44100, size=-16, channels=2, buffer=512, devicename=None) -> None  Call pre_init to change the defaults used when the real pygame.mixer.init() is called. Keyword arguments are accepted. The best way to set custom mixer playback values is to call pygame.mixer.pre_init() before calling the top level pygame.init(). For backward compatibility argument values of zero are replaced with the startup defaults.  Changed in pygame 1.8: The default buffersize was changed from 1024 to 3072.   Changed in pygame 1.9.1: The default buffersize was changed from 3072 to 4096.   Changed in pygame 2.0.0: The default buffersize was changed from 4096 to 512. The default frequency changed to 44100 from 22050.  \n   pygame.mixer.quit() \n uninitialize the mixer quit() -> None  This will uninitialize pygame.mixer. All playback will stop and any loaded Sound objects may not be compatible with the mixer if it is reinitialized later. \n   pygame.mixer.get_init() \n test if the mixer is initialized get_init() -> (frequency, format, channels)  If the mixer is initialized, this returns the playback arguments it is using. If the mixer has not been initialized this returns None. \n   pygame.mixer.stop() \n stop playback of all sound channels stop() -> None  This will stop all playback of all active mixer channels. \n   pygame.mixer.pause() \n temporarily stop playback of all sound channels pause() -> None  This will temporarily stop all playback on the active mixer channels. The playback can later be resumed with pygame.mixer.unpause() \n   pygame.mixer.unpause() \n resume paused playback of sound channels unpause() -> None  This will resume all active sound channels after they have been paused. \n   pygame.mixer.fadeout() \n fade out the volume on all sounds before stopping fadeout(time) -> None  This will fade out the volume on all active channels over the time argument in milliseconds. After the sound is muted the playback will stop. \n   pygame.mixer.set_num_channels() \n set the total number of playback channels set_num_channels(count) -> None  Sets the number of available channels for the mixer. The default value is 8. The value can be increased or decreased. If the value is decreased, sounds playing on the truncated channels are stopped. \n   pygame.mixer.get_num_channels() \n get the total number of playback channels get_num_channels() -> count  Returns the number of currently active playback channels. \n   pygame.mixer.set_reserved() \n reserve channels from being automatically used set_reserved(count) -> None  The mixer can reserve any number of channels that will not be automatically selected for playback by Sounds. If sounds are currently playing on the reserved channels they will not be stopped. This allows the application to reserve a specific number of channels for important sounds that must not be dropped or have a guaranteed channel to play on. \n   pygame.mixer.find_channel() \n find an unused channel find_channel(force=False) -> Channel  This will find and return an inactive Channel object. If there are no inactive Channels this function will return None. If there are no inactive channels and the force argument is True, this will find the Channel with the longest running Sound and return it. If the mixer has reserved channels from pygame.mixer.set_reserved() then those channels will not be returned here. \n   pygame.mixer.get_busy() \n test if any sound is being mixed get_busy() -> bool  Returns True if the mixer is busy mixing any channels. If the mixer is idle then this return False. \n   pygame.mixer.get_sdl_mixer_version() \n get the mixer's SDL version get_sdl_mixer_version() -> (major, minor, patch) get_sdl_mixer_version(linked=True) -> (major, minor, patch)      \nParameters:\n\nlinked (bool) -- if True (default) the linked version number is returned, otherwise the compiled version number is returned  \nReturns:\nthe mixer's SDL library version number (linked or compiled depending on the linked parameter) as a tuple of 3 integers (major, minor, patch)\n  \nReturn type:\ntuple     Note The linked and compile version numbers should be the same.   New in pygame 2.0.0.  \n   pygame.mixer.Sound \n Create a new Sound object from a file or buffer object Sound(filename) -> Sound Sound(file=filename) -> Sound Sound(buffer) -> Sound Sound(buffer=buffer) -> Sound Sound(object) -> Sound Sound(file=object) -> Sound Sound(array=object) -> Sound  Load a new sound buffer from a filename, a python file object or a readable buffer object. Limited resampling will be performed to help the sample match the initialize arguments for the mixer. A Unicode string can only be a file pathname. A Python 2.x string or a Python 3.x bytes object can be either a pathname or a buffer object. Use the 'file' or 'buffer' keywords to avoid ambiguity; otherwise Sound may guess wrong. If the array keyword is used, the object is expected to export a version 3, C level array interface or, for Python 2.6 or later, a new buffer interface (The object is checked for a buffer interface first.) The Sound object represents actual sound sample data. Methods that change the state of the Sound object will the all instances of the Sound playback. A Sound object also exports an array interface, and, for Python 2.6 or later, a new buffer interface. The Sound can be loaded from an OGG audio file or from an uncompressed WAV. Note: The buffer will be copied internally, no data will be shared between it and the Sound object. For now buffer and array support is consistent with sndarray.make_sound for Numeric arrays, in that sample sign and byte order are ignored. This will change, either by correctly handling sign and byte order, or by raising an exception when different. Also, source samples are truncated to fit the audio sample size. This will not change.  New in pygame 1.8: pygame.mixer.Sound(buffer)   New in pygame 1.9.2: pygame.mixer.Sound keyword arguments and array interface support    play() \n begin sound playback play(loops=0, maxtime=0, fade_ms=0) -> Channel  Begin playback of the Sound (i.e., on the computer's speakers) on an available Channel. This will forcibly select a Channel, so playback may cut off a currently playing sound if necessary. The loops argument controls how many times the sample will be repeated after being played the first time. A value of 5 means that the sound will be played once, then repeated five times, and so is played a total of six times. The default value (zero) means the Sound is not repeated, and so is only played once. If loops is set to -1 the Sound will loop indefinitely (though you can still call stop() to stop it). The maxtime argument can be used to stop playback after a given number of milliseconds. The fade_ms argument will make the sound start playing at 0 volume and fade up to full volume over the time given. The sample may end before the fade-in is complete. This returns the Channel object for the channel that was selected. \n   stop() \n stop sound playback stop() -> None  This will stop the playback of this Sound on any active Channels. \n   fadeout() \n stop sound playback after fading out fadeout(time) -> None  This will stop playback of the sound after fading it out over the time argument in milliseconds. The Sound will fade and stop on all actively playing channels. \n   set_volume() \n set the playback volume for this Sound set_volume(value) -> None  This will set the playback volume (loudness) for this Sound. This will immediately affect the Sound if it is playing. It will also affect any future playback of this Sound.     \nParameters:\n\nvalue (float) -- volume in the range of 0.0 to 1.0 (inclusive)  If value < 0.0, the volume will not be changed If value > 1.0, the volume will be set to 1.0      \n   get_volume() \n get the playback volume get_volume() -> value  Return a value from 0.0 to 1.0 representing the volume for this Sound. \n   get_num_channels() \n count how many times this Sound is playing get_num_channels() -> count  Return the number of active channels this sound is playing on. \n   get_length() \n get the length of the Sound get_length() -> seconds  Return the length of this Sound in seconds. \n   get_raw() \n return a bytestring copy of the Sound samples. get_raw() -> bytes  Return a copy of the Sound object buffer as a bytes (for Python 3.x) or str (for Python 2.x) object.  New in pygame 1.9.2.  \n \n   pygame.mixer.Channel \n Create a Channel object for controlling playback Channel(id) -> Channel  Return a Channel object for one of the current channels. The id must be a value from 0 to the value of pygame.mixer.get_num_channels(). The Channel object can be used to get fine control over the playback of Sounds. A channel can only playback a single Sound at time. Using channels is entirely optional since pygame can manage them by default.   play() \n play a Sound on a specific Channel play(Sound, loops=0, maxtime=0, fade_ms=0) -> None  This will begin playback of a Sound on a specific Channel. If the Channel is currently playing any other Sound it will be stopped. The loops argument has the same meaning as in Sound.play(): it is the number of times to repeat the sound after the first time. If it is 3, the sound will be played 4 times (the first time, then three more). If loops is -1 then the playback will repeat indefinitely. As in Sound.play(), the maxtime argument can be used to stop playback of the Sound after a given number of milliseconds. As in Sound.play(), the fade_ms argument can be used fade in the sound. \n   stop() \n stop playback on a Channel stop() -> None  Stop sound playback on a channel. After playback is stopped the channel becomes available for new Sounds to play on it. \n   pause() \n temporarily stop playback of a channel pause() -> None  Temporarily stop the playback of sound on a channel. It can be resumed at a later time with Channel.unpause() \n   unpause() \n resume pause playback of a channel unpause() -> None  Resume the playback on a paused channel. \n   fadeout() \n stop playback after fading channel out fadeout(time) -> None  Stop playback of a channel after fading out the sound over the given time argument in milliseconds. \n   set_volume() \n set the volume of a playing channel set_volume(value) -> None set_volume(left, right) -> None  Set the volume (loudness) of a playing sound. When a channel starts to play its volume value is reset. This only affects the current sound. The value argument is between 0.0 and 1.0. If one argument is passed, it will be the volume of both speakers. If two arguments are passed and the mixer is in stereo mode, the first argument will be the volume of the left speaker and the second will be the volume of the right speaker. (If the second argument is None, the first argument will be the volume of both speakers.) If the channel is playing a Sound on which set_volume() has also been called, both calls are taken into account. For example: sound = pygame.mixer.Sound(\"s.wav\")\nchannel = s.play()      # Sound plays at full volume by default\nsound.set_volume(0.9)   # Now plays at 90% of full volume.\nsound.set_volume(0.6)   # Now plays at 60% (previous value replaced).\nchannel.set_volume(0.5) # Now plays at 30% (0.6 * 0.5). \n   get_volume() \n get the volume of the playing channel get_volume() -> value  Return the volume of the channel for the current playing sound. This does not take into account stereo separation used by Channel.set_volume(). The Sound object also has its own volume which is mixed with the channel. \n   get_busy() \n check if the channel is active get_busy() -> bool  Returns True if the channel is actively mixing sound. If the channel is idle this returns False. \n   get_sound() \n get the currently playing Sound get_sound() -> Sound  Return the actual Sound object currently playing on this channel. If the channel is idle None is returned. \n   queue() \n queue a Sound object to follow the current queue(Sound) -> None  When a Sound is queued on a Channel, it will begin playing immediately after the current Sound is finished. Each channel can only have a single Sound queued at a time. The queued Sound will only play if the current playback finished automatically. It is cleared on any other call to Channel.stop() or Channel.play(). If there is no sound actively playing on the Channel then the Sound will begin playing immediately. \n   get_queue() \n return any Sound that is queued get_queue() -> Sound  If a Sound is already queued on this channel it will be returned. Once the queued sound begins playback it will no longer be on the queue. \n   set_endevent() \n have the channel send an event when playback stops set_endevent() -> None set_endevent(type) -> None  When an endevent is set for a channel, it will send an event to the pygame queue every time a sound finishes playing on that channel (not just the first time). Use pygame.event.get() to retrieve the endevent once it's sent. Note that if you called Sound.play(n) or Channel.play(sound,n), the end event is sent only once: after the sound has been played \"n+1\" times (see the documentation of Sound.play). If Channel.stop() or Channel.play() is called while the sound was still playing, the event will be posted immediately. The type argument will be the event id sent to the queue. This can be any valid event type, but a good choice would be a value between pygame.locals.USEREVENT and pygame.locals.NUMEVENTS. If no type argument is given then the Channel will stop sending endevents. \n   get_endevent() \n get the event a channel sends when playback stops get_endevent() -> type  Returns the event type to be sent every time the Channel finishes playback of a Sound. If there is no endevent the function returns pygame.NOEVENT. \n \n \n \n"}, {"name": "module-mixer.music", "path": "ref/music", "type": "pygame.mixer.music", "text": " pygame.mixer.music\n  \n pygame module for controlling streamed audio  The music module is closely tied to pygame.mixer. Use the music module to control the playback of music in the sound mixer. The difference between the music playback and regular Sound playback is that the music is streamed, and never actually loaded all at once. The mixer system only supports a single music stream at once. Be aware that MP3 support is limited. On some systems an unsupported format can crash the program, e.g. Debian Linux. Consider using OGG instead.   pygame.mixer.music.load() \n Load a music file for playback load(filename) -> None load(object) -> None  This will load a music filename/file object and prepare it for playback. If a music stream is already playing it will be stopped. This does not start the music playing. \n   pygame.mixer.music.unload() \n Unload the currently loaded music to free up resources unload() -> None  This closes resources like files for any music that may be loaded.  New in pygame 2.0.0.  \n   pygame.mixer.music.play() \n Start the playback of the music stream play(loops=0, start=0.0, fade_ms = 0) -> None  This will play the loaded music stream. If the music is already playing it will be restarted. loops is an optional integer argument, which is 0 by default, it tells how many times to repeat the music. The music repeats indefinately if this argument is set to -1. start is an optional float argument, which is 0.0 by default, which denotes the position in time, the music starts playing from. The starting position depends on the format of the music played. MP3 and OGG use the position as time in seconds. For mp3s the start time position selected may not be accurate as things like variable bit rate encoding and ID3 tags can throw off the timing calculations. For MOD music it is the pattern order number. Passing a start position will raise a NotImplementedError if the start position cannot be set. fade_ms is an optional integer argument, which is 0 by default, makes the music start playing at 0 volume and fade up to full volume over the given time. The sample may end before the fade-in is complete.  Changed in pygame 2.0.0: Added optional fade_ms argument  \n   pygame.mixer.music.rewind() \n restart music rewind() -> None  Resets playback of the current music to the beginning. \n   pygame.mixer.music.stop() \n stop the music playback stop() -> None  Stops the music playback if it is currently playing. It Won't Unload the music. \n   pygame.mixer.music.pause() \n temporarily stop music playback pause() -> None  Temporarily stop playback of the music stream. It can be resumed with the pygame.mixer.music.unpause() function. \n   pygame.mixer.music.unpause() \n resume paused music unpause() -> None  This will resume the playback of a music stream after it has been paused. \n   pygame.mixer.music.fadeout() \n stop music playback after fading out fadeout(time) -> None  Fade out and stop the currently playing music. The time argument denotes the integer milliseconds for which the fading effect is generated. Note, that this function blocks until the music has faded out. Calls to fadeout() and set_volume() will have no effect during this time. If an event was set using set_endevent() it will be called after the music has faded. \n   pygame.mixer.music.set_volume() \n set the music volume set_volume(volume) -> None  Set the volume of the music playback. The volume argument is a float between 0.0 and 1.0 that sets volume. When new music is loaded the volume is reset to full volume. \n   pygame.mixer.music.get_volume() \n get the music volume get_volume() -> value  Returns the current volume for the mixer. The value will be between 0.0 and 1.0. \n   pygame.mixer.music.get_busy() \n check if the music stream is playing get_busy() -> bool  Returns True when the music stream is actively playing. When the music is idle this returns False. In pygame 2.0.1 and above this function returns False when the music is paused. In pygame 1 it returns True when the music is paused.  Changed in pygame 2.0.1: Returns False when music paused.  \n   pygame.mixer.music.set_pos() \n set position to play from set_pos(pos) -> None  This sets the position in the music file where playback will start. The meaning of \"pos\", a float (or a number that can be converted to a float), depends on the music format. For MOD files, pos is the integer pattern number in the module. For OGG it is the absolute position, in seconds, from the beginning of the sound. For MP3 files, it is the relative position, in seconds, from the current position. For absolute positioning in an MP3 file, first call rewind(). Other file formats are unsupported. Newer versions of SDL_mixer have better positioning support than earlier ones. An SDLError is raised if a particular format does not support positioning. Function set_pos() calls underlining SDL_mixer function Mix_SetMusicPosition.  New in pygame 1.9.2.  \n   pygame.mixer.music.get_pos() \n get the music play time get_pos() -> time  This gets the number of milliseconds that the music has been playing for. The returned time only represents how long the music has been playing; it does not take into account any starting position offsets. \n   pygame.mixer.music.queue() \n queue a sound file to follow the current queue(filename) -> None  This will load a sound file and queue it. A queued sound file will begin as soon as the current sound naturally ends. Only one sound can be queued at a time. Queuing a new sound while another sound is queued will result in the new sound becoming the queued sound. Also, if the current sound is ever stopped or changed, the queued sound will be lost. The following example will play music by Bach six times, then play music by Mozart once: pygame.mixer.music.load('bach.ogg')\npygame.mixer.music.play(5)        # Plays six times, not five!\npygame.mixer.music.queue('mozart.ogg') \n   pygame.mixer.music.set_endevent() \n have the music send an event when playback stops set_endevent() -> None set_endevent(type) -> None  This causes pygame to signal (by means of the event queue) when the music is done playing. The argument determines the type of event that will be queued. The event will be queued every time the music finishes, not just the first time. To stop the event from being queued, call this method with no argument. \n   pygame.mixer.music.get_endevent() \n get the event a channel sends when playback stops get_endevent() -> type  Returns the event type to be sent every time the music finishes playback. If there is no endevent the function returns pygame.NOEVENT. \n \n \n"}, {"name": "module-mouse", "path": "ref/mouse", "type": "pygame.mouse", "text": " pygame.mouse\n  \n pygame module to work with the mouse  The mouse functions can be used to get the current state of the mouse device. These functions can also alter the system cursor for the mouse. When the display mode is set, the event queue will start receiving mouse events. The mouse buttons generate pygame.MOUSEBUTTONDOWN and pygame.MOUSEBUTTONUP events when they are pressed and released. These events contain a button attribute representing which button was pressed. The mouse wheel will generate pygame.MOUSEBUTTONDOWN and pygame.MOUSEBUTTONUP events when rolled. The button will be set to 4 when the wheel is rolled up, and to button 5 when the wheel is rolled down. Whenever the mouse is moved it generates a pygame.MOUSEMOTION event. The mouse movement is broken into small and accurate motion events. As the mouse is moving many motion events will be placed on the queue. Mouse motion events that are not properly cleaned from the event queue are the primary reason the event queue fills up. If the mouse cursor is hidden, and input is grabbed to the current display the mouse will enter a virtual input mode, where the relative movements of the mouse will never be stopped by the borders of the screen. See the functions pygame.mouse.set_visible() and pygame.event.set_grab() to get this configured. Mouse Wheel Behavior in pygame 2 There is proper functionality for mouse wheel behaviour with pygame 2 supporting pygame.MOUSEWHEEL events. The new events support horizontal and vertical scroll movements, with signed integer values representing the amount scrolled (x and y), as well as flipped direction (the set positive and negative values for each axis is flipped). Read more about SDL2 input-related changes here https://wiki.libsdl.org/MigrationGuide#Input In pygame 2, the mouse wheel functionality can be used by listening for the pygame.MOUSEWHEEL type of an event. When this event is triggered, a developer can access the appropriate Event object with pygame.event.get(). The object can be used to access data about the mouse scroll, such as which (it will tell you what exact mouse device trigger the event).  Code example of mouse scroll (tested on 2.0.0.dev7) \n# Taken from husano896's PR thread (slightly modified)\nimport pygame\nfrom pygame.locals import *\npygame.init()\nscreen = pygame.display.set_mode((640, 480))\nclock = pygame.time.Clock()\n\ndef main():\n   while True:\n      for event in pygame.event.get():\n            if event.type == QUIT:\n               pygame.quit()\n               return\n            elif event.type == MOUSEWHEEL:\n               print(event)\n               print(event.x, event.y)\n               print(event.flipped)\n               print(event.which)\n               # can access properties with\n               # proper notation(ex: event.y)\n      clock.tick(60)\n\n# Execute game:\nmain()\n     pygame.mouse.get_pressed() \n get the state of the mouse buttons get_pressed(num_buttons=3) -> (button1, button2, button3) get_pressed(num_buttons=5) -> (button1, button2, button3, button4, button5)  Returns a sequence of booleans representing the state of all the mouse buttons. A true value means the mouse is currently being pressed at the time of the call. Note, to get all of the mouse events it is better to use either pygame.event.wait() or pygame.event.get() and check all of those events to see if they are MOUSEBUTTONDOWN, MOUSEBUTTONUP, or MOUSEMOTION. Note, that on X11 some X servers use middle button emulation. When you click both buttons 1 and 3 at the same time a 2 button event can be emitted. Note, remember to call pygame.event.get() before this function. Otherwise it will not work as expected. To support five button mice, an optional parameter num_buttons has been added in pygame 2. When this is set to 5, button4 and button5 are added to the returned tuple. Only 3 and 5 are valid values for this parameter.  Changed in pygame 2.0.0: num_buttons argument added  \n   pygame.mouse.get_pos() \n get the mouse cursor position get_pos() -> (x, y)  Returns the x and y position of the mouse cursor. The position is relative to the top-left corner of the display. The cursor position can be located outside of the display window, but is always constrained to the screen. \n   pygame.mouse.get_rel() \n get the amount of mouse movement get_rel() -> (x, y)  Returns the amount of movement in x and y since the previous call to this function. The relative movement of the mouse cursor is constrained to the edges of the screen, but see the virtual input mouse mode for a way around this. Virtual input mode is described at the top of the page. \n   pygame.mouse.set_pos() \n set the mouse cursor position set_pos([x, y]) -> None  Set the current mouse position to arguments given. If the mouse cursor is visible it will jump to the new coordinates. Moving the mouse will generate a new pygame.MOUSEMOTION event. \n   pygame.mouse.set_visible() \n hide or show the mouse cursor set_visible(bool) -> bool  If the bool argument is true, the mouse cursor will be visible. This will return the previous visible state of the cursor. \n   pygame.mouse.get_visible() \n get the current visibility state of the mouse cursor get_visible() -> bool  Get the current visibility state of the mouse cursor. True if the mouse is visible, False otherwise.  New in pygame 2.0.0.  \n   pygame.mouse.get_focused() \n check if the display is receiving mouse input get_focused() -> bool  Returns true when pygame is receiving mouse input events (or, in windowing terminology, is \"active\" or has the \"focus\"). This method is most useful when working in a window. By contrast, in full-screen mode, this method always returns true. Note: under MS Windows, the window that has the mouse focus also has the keyboard focus. But under X-Windows, one window can receive mouse events and another receive keyboard events. pygame.mouse.get_focused() indicates whether the pygame window receives mouse events. \n   pygame.mouse.set_cursor() \n set the image for the mouse cursor set_cursor(size, hotspot, xormasks, andmasks) -> None  When the mouse cursor is visible, it will be displayed as a black and white bitmap using the given bitmask arrays. The size is a sequence containing the cursor width and height. hotspot is a sequence containing the cursor hotspot position. A cursor has a width and height, but a mouse position is represented by a set of point coordinates. So the value passed into the cursor hotspot variable helps pygame to actually determine at what exact point the cursor is at. xormasks is a sequence of bytes containing the cursor xor data masks. Lastly andmasks, a sequence of bytes containing the cursor bitmask data. To create these variables, we can make use of the pygame.cursors.compile() function. Width and height must be a multiple of 8, and the mask arrays must be the correct size for the given width and height. Otherwise an exception is raised. See the pygame.cursor module for help creating default and custom masks for the mouse cursor and also for more examples related to cursors. \n   pygame.mouse.set_system_cursor() \n set the mouse cursor to a system variant set_system_cursor(constant) -> None  When the mouse cursor is visible, it will displayed as a operating system specific variant of the options below. Pygame Cursor Constant           Description\n--------------------------------------------\npygame.SYSTEM_CURSOR_ARROW       arrow\npygame.SYSTEM_CURSOR_IBEAM       i-beam\npygame.SYSTEM_CURSOR_WAIT        wait\npygame.SYSTEM_CURSOR_CROSSHAIR   crosshair\npygame.SYSTEM_CURSOR_WAITARROW   small wait cursor\n                                 (or wait if not available)\npygame.SYSTEM_CURSOR_SIZENWSE    double arrow pointing\n                                 northwest and southeast\npygame.SYSTEM_CURSOR_SIZENESW    double arrow pointing\n                                 northeast and southwest\npygame.SYSTEM_CURSOR_SIZEWE      double arrow pointing\n                                 west and east\npygame.SYSTEM_CURSOR_SIZENS      double arrow pointing\n                                 north and south\npygame.SYSTEM_CURSOR_SIZEALL     four pointed arrow pointing\n                                 north, south, east, and west\npygame.SYSTEM_CURSOR_NO          slashed circle or crossbones\npygame.SYSTEM_CURSOR_HAND        hand  New in pygame 2.0.0.  \n   pygame.mouse.get_cursor() \n get the image of the mouse cursor get_cursor() -> (size, hotspot, xormasks, andmasks)  Get the information about the mouse system cursor. The return value is the same data as the arguments passed into pygame.mouse.set_cursor().  Note This method is unavailable with pygame 2, as SDL2 does not provide the underlying code to implement this method.  \n \n \n"}, {"name": "module-pixelcopy", "path": "ref/pixelcopy", "type": "pygame.pixelcopy", "text": " pygame.pixelcopy\n  \n pygame module for general pixel array copying  The pygame.pixelcopy module contains functions for copying between surfaces and objects exporting an array structure interface. It is a backend for pygame.surfarray, adding NumPy support. But pixelcopy is more general, and intended for direct use. The array struct interface exposes an array's data in a standard way. It was introduced in NumPy. In Python 2.7 and above it is replaced by the new buffer protocol, though the buffer protocol is still a work in progress. The array struct interface, on the other hand, is stable and works with earlier Python versions. So for now the array struct interface is the predominate way pygame handles array introspection. New in pygame 1.9.2.   pygame.pixelcopy.surface_to_array() \n copy surface pixels to an array object surface_to_array(array, surface, kind='P', opaque=255, clear=0) -> None  The surface_to_array function copies pixels from a Surface object to a 2D or 3D array. Depending on argument kind and the target array dimension, a copy may be raw pixel value, RGB, a color component slice, or colorkey alpha transparency value. Recognized kind values are the single character codes 'P', 'R', 'G', 'B', 'A', and 'C'. Kind codes are case insensitive, so 'p' is equivalent to 'P'. The first two dimensions of the target must be the surface size (w, h). The default 'P' kind code does a direct raw integer pixel (mapped) value copy to a 2D array and a 'RGB' pixel component (unmapped) copy to a 3D array having shape (w, h, 3). For an 8 bit colormap surface this means the table index is copied to a 2D array, not the table value itself. A 2D array's item size must be at least as large as the surface's pixel byte size. The item size of a 3D array must be at least one byte. For the 'R', 'G', 'B', and 'A' copy kinds a single color component of the unmapped surface pixels are copied to the target 2D array. For kind 'A' and surfaces with source alpha (the surface was created with the SRCALPHA flag), has a colorkey (set with Surface.set_colorkey()), or has a blanket alpha (set with Surface.set_alpha()) then the alpha values are those expected for a SDL surface. If a surface has no explicit alpha value, then the target array is filled with the value of the optional opaque surface_to_array argument (default 255: not transparent). Copy kind 'C' is a special case for alpha copy of a source surface with colorkey. Unlike the 'A' color component copy, the clear argument value is used for colorkey matches, opaque otherwise. By default, a match has alpha 0 (totally transparent), while everything else is alpha 255 (totally opaque). It is a more general implementation of pygame.surfarray.array_colorkey(). Specific to surface_to_array, a ValueError is raised for target arrays with incorrect shape or item size. A TypeError is raised for an incorrect kind code. Surface specific problems, such as locking, raise a pygame.error. \n   pygame.pixelcopy.array_to_surface() \n copy an array object to a surface array_to_surface(<surface>, <array>) -> None  See pygame.surfarray.blit_array(). \n   pygame.pixelcopy.map_array() \n copy an array to another array, using surface format map_array(<array>, <array>, <surface>) -> None  Map an array of color element values - (w, h, ..., 3) - to an array of pixels - (w, h) according to the format of <surface>. \n   pygame.pixelcopy.make_surface() \n Copy an array to a new surface pygame.pixelcopy.make_surface(array) -> Surface  Create a new Surface that best resembles the data and format of the array. The array can be 2D or 3D with any sized integer values. \n \n \n"}, {"name": "module-pygame", "path": "ref/pygame", "type": "pygame", "text": " pygame\n  \n the top level pygame package  The pygame package represents the top-level package for others to use. Pygame itself is broken into many submodules, but this does not affect programs that use pygame. As a convenience, most of the top-level variables in pygame have been placed inside a module named pygame.locals. This is meant to be used with from pygame.locals import *, in addition to import pygame. When you import pygame all available pygame submodules are automatically imported. Be aware that some of the pygame modules are considered optional, and may not be available. In that case, pygame will provide a placeholder object instead of the module, which can be used to test for availability.   pygame.init() \n initialize all imported pygame modules init() -> (numpass, numfail)  Initialize all imported pygame modules. No exceptions will be raised if a module fails, but the total number if successful and failed inits will be returned as a tuple. You can always initialize individual modules manually, but pygame.init() is a convenient way to get everything started. The init() functions for individual modules will raise exceptions when they fail. You may want to initialize the different modules separately to speed up your program or to not use modules your game does not require. It is safe to call this init() more than once as repeated calls will have no effect. This is true even if you have pygame.quit() all the modules. \n   pygame.quit() \n uninitialize all pygame modules quit() -> None  Uninitialize all pygame modules that have previously been initialized. When the Python interpreter shuts down, this method is called regardless, so your program should not need it, except when it wants to terminate its pygame resources and continue. It is safe to call this function more than once as repeated calls have no effect.  Note Calling pygame.quit() will not exit your program. Consider letting your program end in the same way a normal Python program will end.  \n   pygame.get_init() \n returns True if pygame is currently initialized get_init() -> bool  Returns True if pygame is currently initialized.  New in pygame 1.9.5.  \n   exception pygame.error \n standard pygame exception raise pygame.error(message)  This exception is raised whenever a pygame or SDL operation fails. You can catch any anticipated problems and deal with the error. The exception is always raised with a descriptive message about the problem. Derived from the RuntimeError exception, which can also be used to catch these raised errors. \n   pygame.get_error() \n get the current error message get_error() -> errorstr  SDL maintains an internal error message. This message will usually be given to you when pygame.error() is raised, so this function will rarely be needed. \n   pygame.set_error() \n set the current error message set_error(error_msg) -> None  SDL maintains an internal error message. This message will usually be given to you when pygame.error() is raised, so this function will rarely be needed. \n   pygame.get_sdl_version() \n get the version number of SDL get_sdl_version() -> major, minor, patch  Returns the three version numbers of the SDL library. This version is built at compile time. It can be used to detect which features may or may not be available through pygame.  New in pygame 1.7.0.  \n   pygame.get_sdl_byteorder() \n get the byte order of SDL get_sdl_byteorder() -> int  Returns the byte order of the SDL library. It returns 1234 for little endian byte order and 4321 for big endian byte order.  New in pygame 1.8.  \n   pygame.register_quit() \n register a function to be called when pygame quits register_quit(callable) -> None  When pygame.quit() is called, all registered quit functions are called. Pygame modules do this automatically when they are initializing, so this function will rarely be needed. \n   pygame.encode_string() \n Encode a Unicode or bytes object encode_string([obj [, encoding [, errors [, etype]]]]) -> bytes or None  obj: If Unicode, encode; if bytes, return unaltered; if anything else, return None; if not given, raise SyntaxError. encoding (string): If present, encoding to use. The default is 'unicode_escape'. errors (string): If given, how to handle unencodable characters. The default is 'backslashreplace'. etype (exception type): If given, the exception type to raise for an encoding error. The default is UnicodeEncodeError, as returned by PyUnicode_AsEncodedString(). For the default encoding and errors values there should be no encoding errors. This function is used in encoding file paths. Keyword arguments are supported.  New in pygame 1.9.2: (primarily for use in unit tests)  \n   pygame.encode_file_path() \n Encode a Unicode or bytes object as a file system path encode_file_path([obj [, etype]]) -> bytes or None  obj: If Unicode, encode; if bytes, return unaltered; if anything else, return None; if not given, raise SyntaxError. etype (exception type): If given, the exception type to raise for an encoding error. The default is UnicodeEncodeError, as returned by PyUnicode_AsEncodedString(). This function is used to encode file paths in pygame. Encoding is to the codec as returned by sys.getfilesystemencoding(). Keyword arguments are supported.  New in pygame 1.9.2: (primarily for use in unit tests)  \n \n   pygame.version\n  \n small module containing version information  This module is automatically imported into the pygame package and can be used to check which version of pygame has been imported.   pygame.version.ver \n version number as a string ver = '1.2'  This is the version represented as a string. It can contain a micro release number as well, e.g. '1.5.2' \n   pygame.version.vernum \n tupled integers of the version vernum = (1, 5, 3)  This version information can easily be compared with other version numbers of the same format. An example of checking pygame version numbers would look like this: if pygame.version.vernum < (1, 5):\n    print('Warning, older version of pygame (%s)' %  pygame.version.ver)\n    disable_advanced_features = True  New in pygame 1.9.6: Attributes major, minor, and patch.  vernum.major == vernum[0]\nvernum.minor == vernum[1]\nvernum.patch == vernum[2]  Changed in pygame 1.9.6: str(pygame.version.vernum) returns a string like \"2.0.0\" instead of \"(2, 0, 0)\".   Changed in pygame 1.9.6: repr(pygame.version.vernum) returns a string like \"PygameVersion(major=2, minor=0, patch=0)\" instead of \"(2, 0, 0)\".  \n   pygame.version.rev \n repository revision of the build rev = 'a6f89747b551+'  The Mercurial node identifier of the repository checkout from which this package was built. If the identifier ends with a plus sign '+' then the package contains uncommitted changes. Please include this revision number in bug reports, especially for non-release pygame builds. Important note: pygame development has moved to github, this variable is obsolete now. As soon as development shifted to github, this variable started returning an empty string \"\". It has always been returning an empty string since v1.9.5.  Changed in pygame 1.9.5: Always returns an empty string \"\".  \n   pygame.version.SDL \n tupled integers of the SDL library version SDL = '(2, 0, 12)'  This is the SDL library version represented as an extended tuple. It also has attributes 'major', 'minor' & 'patch' that can be accessed like this: >>> pygame.version.SDL.major\n2 printing the whole thing returns a string like this: >>> pygame.version.SDL\nSDLVersion(major=2, minor=0, patch=12)  New in pygame 2.0.0.  \n Setting Environment Variables Some aspects of pygame's behaviour can be controlled by setting environment variables, they cover a wide range of the library's functionality. Some of the variables are from pygame itself, while others come from the underlying C SDL library that pygame uses. In python, environment variables are usually set in code like this: import os\nos.environ['NAME_OF_ENVIRONMENT_VARIABLE'] = 'value_to_set' Or to preserve users ability to override the variable: import os\nos.environ['ENV_VAR'] = os.environ.get('ENV_VAR', 'value') If the variable is more useful for users of an app to set than the developer then they can set it like this: Windows: set NAME_OF_ENVIRONMENT_VARIABLE=value_to_set\npython my_application.py Linux/Mac: ENV_VAR=value python my_application.py For some variables they need to be set before initialising pygame, some must be set before even importing pygame, and others can simply be set right before the area of code they control is run. Below is a list of environment variables, their settable values, and a brief description of what they do.    Pygame Environment Variables These variables are defined by pygame itself.    PYGAME_DISPLAY - Experimental (subject to change)\nSet index of the display to use, \"0\" is the default. This sets the display where pygame will open its window or screen. The value set here will be used if set before calling pygame.display.set_mode(), and as long as no 'display' parameter is passed into pygame.display.set_mode().    PYGAME_FORCE_SCALE -\nSet to \"photo\" or \"default\". This forces set_mode() to use the SCALED display mode and, if \"photo\" is set, makes the scaling use the slowest, but highest quality anisotropic scaling algorithm, if it is available. Must be set before calling pygame.display.set_mode().    PYGAME_BLEND_ALPHA_SDL2 - New in pygame 2.0.0\nSet to \"1\" to enable the SDL2 blitter. This makes pygame use the SDL2 blitter for all alpha blending. The SDL2 blitter is sometimes faster than the default blitter but uses a different formula so the final colours may differ. Must be set before pygame.init() is called.    PYGAME_HIDE_SUPPORT_PROMPT -\nSet to \"1\" to hide the prompt. This stops the welcome message popping up in the console that tells you which version of python, pygame & SDL you are using. Must be set before importing pygame.    PYGAME_FREETYPE -\nSet to \"1\" to enable. This switches the pygame.font module to a pure freetype implementation that bypasses SDL_ttf. See the font module for why you might want to do this. Must be set before importing pygame.    PYGAME_CAMERA -\nSet to \"opencv\" or \"vidcapture\" Forces the library backend used in the camera module, overriding the platform defaults. Must be set before calling pygame.camera.init().     SDL Environment Variables These variables are defined by SDL. For documentation on the environment variables available in pygame 1 try here. For Pygame 2, some selected environment variables are listed below.    SDL_VIDEO_CENTERED -\nSet to \"1\" to enable centering the window. This will make the pygame window open in the centre of the display. Must be set before calling pygame.display.set_mode().    SDL_VIDEO_WINDOW_POS -\nSet to \"x,y\" to position the top left corner of the window. This allows control over the placement of the pygame window within the display. Must be set before calling pygame.display.set_mode().    SDL_VIDEODRIVER -\nSet to \"drivername\" to change the video driver used. On some platforms there are multiple video drivers available and this allows users to pick between them. More information is available here. Must be set before calling pygame.init() or pygame.display.init().    SDL_AUDIODRIVER -\nSet to \"drivername\" to change the audio driver used. On some platforms there are multiple audio drivers available and this allows users to pick between them. More information is available here. Must be set before calling pygame.init() or pygame.mixer.init().    SDL_VIDEO_ALLOW_SCREENSAVER\nSet to \"1\" to allow screensavers while pygame apps are running. By default pygame apps disable screensavers while they are running. Setting this environment variable allows users or developers to change that and make screensavers run again.    SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\nSet to \"0\" to re-enable the compositor. By default SDL tries to disable the X11 compositor for all pygame apps. This is usually a good thing as it's faster, however if you have an app which doesn't update every frame and are using linux you may want to disable this bypass. The bypass has reported problems on KDE linux. This variable is only used on x11/linux platforms. \n \n"}, {"name": "module-scrap", "path": "ref/scrap", "type": "pygame.scrap", "text": " pygame.scrap\n  \n pygame module for clipboard support.  EXPERIMENTAL!: This API may change or disappear in later pygame releases. If you use this, your code may break with the next pygame release. The scrap module is for transferring data to/from the clipboard. This allows for cutting and pasting data between pygame and other applications. Some basic data (MIME) types are defined and registered: pygame         string\nconstant        value        description\n--------------------------------------------------\nSCRAP_TEXT   \"text/plain\"    plain text\nSCRAP_BMP    \"image/bmp\"     BMP encoded image data\nSCRAP_PBM    \"image/pbm\"     PBM encoded image data\nSCRAP_PPM    \"image/ppm\"     PPM encoded image data pygame.SCRAP_PPM, pygame.SCRAP_PBM and pygame.SCRAP_BMP are suitable for surface buffers to be shared with other applications. pygame.SCRAP_TEXT is an alias for the plain text clipboard type. Depending on the platform, additional types are automatically registered when data is placed into the clipboard to guarantee a consistent sharing behaviour with other applications. The following listed types can be used as strings to be passed to the respective pygame.scrap module functions. For Windows platforms, these additional types are supported automatically and resolve to their internal definitions: \"text/plain;charset=utf-8\"   UTF-8 encoded text\n\"audio/wav\"                  WAV encoded audio\n\"image/tiff\"                 TIFF encoded image data For X11 platforms, these additional types are supported automatically and resolve to their internal definitions: \"text/plain;charset=utf-8\"   UTF-8 encoded text\n\"UTF8_STRING\"                UTF-8 encoded text\n\"COMPOUND_TEXT\"              COMPOUND text User defined types can be used, but the data might not be accessible by other applications unless they know what data type to look for. Example: Data placed into the clipboard by pygame.scrap.put(\"my_data_type\", byte_data) can only be accessed by applications which query the clipboard for the \"my_data_type\" data type. For an example of how the scrap module works refer to the examples page (pygame.examples.scrap_clipboard.main()) or the code directly in GitHub (pygame/examples/scrap_clipboard.py).  New in pygame 1.8.   Note The scrap module is currently only supported for Windows, X11 and Mac OS X. On Mac OS X only text works at the moment - other types may be supported in future releases.    pygame.scrap.init() \n Initializes the scrap module. init() -> None  Initialize the scrap module.     \nRaises:\n\npygame.error -- if unable to initialize scrap module        Note The scrap module requires pygame.display.set_mode() be called before being initialized.  \n   pygame.scrap.get_init() \n Returns True if the scrap module is currently initialized. get_init() -> bool  Gets the scrap module's initialization state.     \nReturns:\n\nTrue if the pygame.scrap module is currently initialized, False otherwise  \nReturn type:\nbool     New in pygame 1.9.5.  \n   pygame.scrap.get() \n Gets the data for the specified type from the clipboard. get(type) -> bytes or str or None  Retrieves the data for the specified type from the clipboard. In python 3 the data is returned as a byte string and might need further processing (such as decoding to Unicode).     \nParameters:\n\ntype (string) -- data type to retrieve from the clipboard  \nReturns:\ndata (byte string in python 3 or str in python 2) for the given type identifier or None if no data for the given type is available  \nReturn type:\nbytes or str or None    text = pygame.scrap.get(pygame.SCRAP_TEXT)\nif text:\n    print(\"There is text in the clipboard.\")\nelse:\n    print(\"There does not seem to be text in the clipboard.\") \n   pygame.scrap.get_types() \n Gets a list of the available clipboard types. get_types() -> list  Gets a list of data type string identifiers for the data currently available on the clipboard. Each identifier can be used in the pygame.scrap.get() method to get the clipboard content of the specific type.     \nReturns:\nlist of strings of the available clipboard data types, if there is no data in the clipboard an empty list is returned  \nReturn type:\nlist    for t in pygame.scrap.get_types():\n    if \"text\" in t:\n        # There is some content with the word \"text\" in its type string.\n        print(pygame.scrap.get(t)) \n   pygame.scrap.put() \n Places data into the clipboard. put(type, data) -> None  Places data for a given clipboard type into the clipboard. The data must be a string buffer. The type is a string identifying the type of data to be placed into the clipboard. This can be one of the predefined pygame.SCRAP_PBM, pygame.SCRAP_PPM, pygame.SCRAP_BMP or pygame.SCRAP_TEXT values or a user defined string identifier.     \nParameters:\n\n \ntype (string) -- type identifier of the data to be placed into the clipboard \ndata (bytes or str) -- data to be place into the clipboard (in python 3 data is a byte string and in python 2 data is a str)    \nRaises:\n\npygame.error -- if unable to put the data into the clipboard     with open(\"example.bmp\", \"rb\") as fp:\n    pygame.scrap.put(pygame.SCRAP_BMP, fp.read())\n# The image data is now on the clipboard for other applications to access\n# it.\npygame.scrap.put(pygame.SCRAP_TEXT, b\"A text to copy\")\npygame.scrap.put(\"Plain text\", b\"Data for user defined type 'Plain text'\") \n   pygame.scrap.contains() \n Checks whether data for a given type is available in the clipboard. contains(type) -> bool  Checks whether data for the given type is currently available in the clipboard.     \nParameters:\n\ntype (string) -- data type to check availability of  \nReturns:\n\nTrue if data for the passed type is available in the clipboard, False otherwise  \nReturn type:\nbool    if pygame.scrap.contains(pygame.SCRAP_TEXT):\n    print(\"There is text in the clipboard.\")\nif pygame.scrap.contains(\"own_data_type\"):\n    print(\"There is stuff in the clipboard.\") \n   pygame.scrap.lost() \n Indicates if the clipboard ownership has been lost by the pygame application. lost() -> bool  Indicates if the clipboard ownership has been lost by the pygame application.     \nReturns:\n\nTrue, if the clipboard ownership has been lost by the pygame application, False if the pygame application still owns the clipboard  \nReturn type:\nbool    if pygame.scrap.lost():\n    print(\"The clipboard is in use by another application.\") \n   pygame.scrap.set_mode() \n Sets the clipboard access mode. set_mode(mode) -> None  Sets the access mode for the clipboard. This is only of interest for X11 environments where clipboard modes pygame.SCRAP_SELECTION (for mouse selections) and pygame.SCRAP_CLIPBOARD (for the clipboard) are available. Setting the mode to pygame.SCRAP_SELECTION in other environments will not change the mode from pygame.SCRAP_CLIPBOARD.     \nParameters:\n\nmode -- access mode, supported values are pygame.SCRAP_CLIPBOARD and pygame.SCRAP_SELECTION (pygame.SCRAP_SELECTION only has an effect when used on X11 platforms)  \nRaises:\n\nValueError -- if the mode parameter is not pygame.SCRAP_CLIPBOARD or pygame.SCRAP_SELECTION\n    \n \n \n"}, {"name": "module-sndarray", "path": "ref/sndarray", "type": "pygame.sndarray", "text": " pygame.sndarray\n  \n pygame module for accessing sound sample data  Functions to convert between NumPy arrays and Sound objects. This module will only be available when pygame can use the external NumPy package. Sound data is made of thousands of samples per second, and each sample is the amplitude of the wave at a particular moment in time. For example, in 22-kHz format, element number 5 of the array is the amplitude of the wave after 5/22000 seconds. Each sample is an 8-bit or 16-bit integer, depending on the data format. A stereo sound file has two values per sample, while a mono sound file only has one.   pygame.sndarray.array() \n copy Sound samples into an array array(Sound) -> array  Creates a new array for the sound data and copies the samples. The array will always be in the format returned from pygame.mixer.get_init(). \n   pygame.sndarray.samples() \n reference Sound samples into an array samples(Sound) -> array  Creates a new array that directly references the samples in a Sound object. Modifying the array will change the Sound. The array will always be in the format returned from pygame.mixer.get_init(). \n   pygame.sndarray.make_sound() \n convert an array into a Sound object make_sound(array) -> Sound  Create a new playable Sound object from an array. The mixer module must be initialized and the array format must be similar to the mixer audio format. \n   pygame.sndarray.use_arraytype() \n Sets the array system to be used for sound arrays use_arraytype (arraytype) -> None  DEPRECATED: Uses the requested array type for the module functions. The only supported arraytype is 'numpy'. Other values will raise ValueError. \n   pygame.sndarray.get_arraytype() \n Gets the currently active array type. get_arraytype () -> str  DEPRECATED: Returns the currently active array type. This will be a value of the get_arraytypes() tuple and indicates which type of array module is used for the array creation.  New in pygame 1.8.  \n   pygame.sndarray.get_arraytypes() \n Gets the array system types currently supported. get_arraytypes () -> tuple  DEPRECATED: Checks, which array systems are available and returns them as a tuple of strings. The values of the tuple can be used directly in the pygame.sndarray.use_arraytype() () method. If no supported array system could be found, None will be returned.  New in pygame 1.8.  \n \n \n"}, {"name": "module-sprite", "path": "ref/sprite", "type": "pygame.sprite", "text": " pygame.sprite\n  \n pygame module with basic game object classes  This module contains several simple classes to be used within games. There is the main Sprite class and several Group classes that contain Sprites. The use of these classes is entirely optional when using pygame. The classes are fairly lightweight and only provide a starting place for the code that is common to most games. The Sprite class is intended to be used as a base class for the different types of objects in the game. There is also a base Group class that simply stores sprites. A game could create new types of Group classes that operate on specially customized Sprite instances they contain. The basic Sprite class can draw the Sprites it contains to a Surface. The Group.draw() method requires that each Sprite have a Surface.image attribute and a Surface.rect. The Group.clear() method requires these same attributes, and can be used to erase all the Sprites with background. There are also more advanced Groups: pygame.sprite.RenderUpdates() and pygame.sprite.OrderedUpdates(). Lastly, this module contains several collision functions. These help find sprites inside multiple groups that have intersecting bounding rectangles. To find the collisions, the Sprites are required to have a Surface.rect attribute assigned. The groups are designed for high efficiency in removing and adding Sprites to them. They also allow cheap testing to see if a Sprite already exists in a Group. A given Sprite can exist in any number of groups. A game could use some groups to control object rendering, and a completely separate set of groups to control interaction or player movement. Instead of adding type attributes or bools to a derived Sprite class, consider keeping the Sprites inside organized Groups. This will allow for easier lookup later in the game. Sprites and Groups manage their relationships with the add() and remove() methods. These methods can accept a single or multiple targets for membership. The default initializers for these classes also takes a single or list of targets for initial membership. It is safe to repeatedly add and remove the same Sprite from a Group. While it is possible to design sprite and group classes that don't derive from the Sprite and AbstractGroup classes below, it is strongly recommended that you extend those when you add a Sprite or Group class. Sprites are not thread safe. So lock them yourself if using threads.   pygame.sprite.Sprite \n Simple base class for visible game objects. Sprite(*groups) -> Sprite  The base class for visible game objects. Derived classes will want to override the Sprite.update() and assign a Sprite.image and Sprite.rect attributes. The initializer can accept any number of Group instances to be added to. When subclassing the Sprite, be sure to call the base initializer before adding the Sprite to Groups. For example: \nclass Block(pygame.sprite.Sprite):\n\n    # Constructor. Pass in the color of the block,\n    # and its x and y position\n    def __init__(self, color, width, height):\n       # Call the parent class (Sprite) constructor\n       pygame.sprite.Sprite.__init__(self)\n\n       # Create an image of the block, and fill it with a color.\n       # This could also be an image loaded from the disk.\n       self.image = pygame.Surface([width, height])\n       self.image.fill(color)\n\n       # Fetch the rectangle object that has the dimensions of the image\n       # Update the position of this object by setting the values of rect.x and rect.y\n       self.rect = self.image.get_rect()\n    update() \n method to control sprite behavior update(*args, **kwargs) -> None  The default implementation of this method does nothing; it's just a convenient \"hook\" that you can override. This method is called by Group.update() with whatever arguments you give it. There is no need to use this method if not using the convenience method by the same name in the Group class. \n   add() \n add the sprite to groups add(*groups) -> None  Any number of Group instances can be passed as arguments. The Sprite will be added to the Groups it is not already a member of. \n   remove() \n remove the sprite from groups remove(*groups) -> None  Any number of Group instances can be passed as arguments. The Sprite will be removed from the Groups it is currently a member of. \n   kill() \n remove the Sprite from all Groups kill() -> None  The Sprite is removed from all the Groups that contain it. This won't change anything about the state of the Sprite. It is possible to continue to use the Sprite after this method has been called, including adding it to Groups. \n   alive() \n does the sprite belong to any groups alive() -> bool  Returns True when the Sprite belongs to one or more Groups. \n   groups() \n list of Groups that contain this Sprite groups() -> group_list  Return a list of all the Groups that contain this Sprite. \n \n   pygame.sprite.DirtySprite \n A subclass of Sprite with more attributes and features. DirtySprite(*groups) -> DirtySprite  Extra DirtySprite attributes with their default values: dirty = 1 if set to 1, it is repainted and then set to 0 again\nif set to 2 then it is always dirty ( repainted each frame,\nflag is not reset)\n0 means that it is not dirty and therefore not repainted again blendmode = 0 its the special_flags argument of blit, blendmodes source_rect = None source rect to use, remember that it is relative to\ntopleft (0,0) of self.image visible = 1 normally 1, if set to 0 it will not be repainted\n(you must set it dirty too to be erased from screen) layer = 0 (READONLY value, it is read when adding it to the\nLayeredDirty, for details see doc of LayeredDirty) \n   pygame.sprite.Group \n A container class to hold and manage multiple Sprite objects. Group(*sprites) -> Group  A simple container for Sprite objects. This class can be inherited to create containers with more specific behaviors. The constructor takes any number of Sprite arguments to add to the Group. The group supports the following standard Python operations: in      test if a Sprite is contained\nlen     the number of Sprites contained\nbool    test if any Sprites are contained\niter    iterate through all the Sprites The Sprites in the Group are not ordered, so drawing and iterating the Sprites is in no particular order.   sprites() \n list of the Sprites this Group contains sprites() -> sprite_list  Return a list of all the Sprites this group contains. You can also get an iterator from the group, but you cannot iterate over a Group while modifying it. \n   copy() \n duplicate the Group copy() -> Group  Creates a new Group with all the same Sprites as the original. If you have subclassed Group, the new object will have the same (sub-)class as the original. This only works if the derived class's constructor takes the same arguments as the Group class's. \n   add() \n add Sprites to this Group add(*sprites) -> None  Add any number of Sprites to this Group. This will only add Sprites that are not already members of the Group. Each sprite argument can also be a iterator containing Sprites. \n   remove() \n remove Sprites from the Group remove(*sprites) -> None  Remove any number of Sprites from the Group. This will only remove Sprites that are already members of the Group. Each sprite argument can also be a iterator containing Sprites. \n   has() \n test if a Group contains Sprites has(*sprites) -> bool  Return True if the Group contains all of the given sprites. This is similar to using the \"in\" operator on the Group (\"if sprite in group: ...\"), which tests if a single Sprite belongs to a Group. Each sprite argument can also be a iterator containing Sprites. \n   update() \n call the update method on contained Sprites update(*args, **kwargs) -> None  Calls the update() method on all Sprites in the Group. The base Sprite class has an update method that takes any number of arguments and does nothing. The arguments passed to Group.update() will be passed to each Sprite. There is no way to get the return value from the Sprite.update() methods. \n   draw() \n blit the Sprite images draw(Surface) -> None  Draws the contained Sprites to the Surface argument. This uses the Sprite.image attribute for the source surface, and Sprite.rect for the position. The Group does not keep sprites in any order, so the draw order is arbitrary. \n   clear() \n draw a background over the Sprites clear(Surface_dest, background) -> None  Erases the Sprites used in the last Group.draw() call. The destination Surface is cleared by filling the drawn Sprite positions with the background. The background is usually a Surface image the same dimensions as the destination Surface. However, it can also be a callback function that takes two arguments; the destination Surface and an area to clear. The background callback function will be called several times each clear. Here is an example callback that will clear the Sprites with solid red: def clear_callback(surf, rect):\n    color = 255, 0, 0\n    surf.fill(color, rect) \n   empty() \n remove all Sprites empty() -> None  Removes all Sprites from this Group. \n \n   pygame.sprite.RenderPlain \n Same as pygame.sprite.Group  This class is an alias to pygame.sprite.Group(). It has no additional functionality. \n   pygame.sprite.RenderClear \n Same as pygame.sprite.Group  This class is an alias to pygame.sprite.Group(). It has no additional functionality. \n   pygame.sprite.RenderUpdates \n Group sub-class that tracks dirty updates. RenderUpdates(*sprites) -> RenderUpdates  This class is derived from pygame.sprite.Group(). It has an extended draw() method that tracks the changed areas of the screen.   draw() \n blit the Sprite images and track changed areas draw(surface) -> Rect_list  Draws all the Sprites to the surface, the same as Group.draw(). This method also returns a list of Rectangular areas on the screen that have been changed. The returned changes include areas of the screen that have been affected by previous Group.clear() calls. The returned Rect list should be passed to pygame.display.update(). This will help performance on software driven display modes. This type of updating is usually only helpful on destinations with non-animating backgrounds. \n \n   pygame.sprite.OrderedUpdates() \n RenderUpdates sub-class that draws Sprites in order of addition. OrderedUpdates(*spites) -> OrderedUpdates  This class derives from pygame.sprite.RenderUpdates(). It maintains the order in which the Sprites were added to the Group for rendering. This makes adding and removing Sprites from the Group a little slower than regular Groups. \n   pygame.sprite.LayeredUpdates \n LayeredUpdates is a sprite group that handles layers and draws like OrderedUpdates. LayeredUpdates(*spites, **kwargs) -> LayeredUpdates  This group is fully compatible with pygame.sprite.Sprite. You can set the default layer through kwargs using 'default_layer' and an integer for the layer. The default layer is 0. If the sprite you add has an attribute _layer then that layer will be used. If the **kwarg contains 'layer' then the sprites passed will be added to that layer (overriding the sprite.layer attribute). If neither sprite has attribute layer nor **kwarg then the default layer is used to add the sprites.  New in pygame 1.8.    add() \n add a sprite or sequence of sprites to a group add(*sprites, **kwargs) -> None  If the sprite(s) have an attribute layer then that is used for the layer. If **kwargs contains 'layer' then the sprite(s) will be added to that argument (overriding the sprite layer attribute). If neither is passed then the sprite(s) will be added to the default layer. \n   sprites() \n returns a ordered list of sprites (first back, last top). sprites() -> sprites  \n   draw() \n draw all sprites in the right order onto the passed surface. draw(surface) -> Rect_list  \n   get_sprites_at() \n returns a list with all sprites at that position. get_sprites_at(pos) -> colliding_sprites  Bottom sprites first, top last. \n   get_sprite() \n returns the sprite at the index idx from the groups sprites get_sprite(idx) -> sprite  Raises IndexOutOfBounds if the idx is not within range. \n   remove_sprites_of_layer() \n removes all sprites from a layer and returns them as a list. remove_sprites_of_layer(layer_nr) -> sprites  \n   layers() \n returns a list of layers defined (unique), sorted from bottom up. layers() -> layers  \n   change_layer() \n changes the layer of the sprite change_layer(sprite, new_layer) -> None  sprite must have been added to the renderer. It is not checked. \n   get_layer_of_sprite() \n returns the layer that sprite is currently in. get_layer_of_sprite(sprite) -> layer  If the sprite is not found then it will return the default layer. \n   get_top_layer() \n returns the top layer get_top_layer() -> layer  \n   get_bottom_layer() \n returns the bottom layer get_bottom_layer() -> layer  \n   move_to_front() \n brings the sprite to front layer move_to_front(sprite) -> None  Brings the sprite to front, changing sprite layer to topmost layer (added at the end of that layer). \n   move_to_back() \n moves the sprite to the bottom layer move_to_back(sprite) -> None  Moves the sprite to the bottom layer, moving it behind all other layers and adding one additional layer. \n   get_top_sprite() \n returns the topmost sprite get_top_sprite() -> Sprite  \n   get_sprites_from_layer() \n returns all sprites from a layer, ordered by how they where added get_sprites_from_layer(layer) -> sprites  Returns all sprites from a layer, ordered by how they where added. It uses linear search and the sprites are not removed from layer. \n   switch_layer() \n switches the sprites from layer1 to layer2 switch_layer(layer1_nr, layer2_nr) -> None  The layers number must exist, it is not checked. \n \n   pygame.sprite.LayeredDirty \n LayeredDirty group is for DirtySprite objects. Subclasses LayeredUpdates. LayeredDirty(*spites, **kwargs) -> LayeredDirty  This group requires pygame.sprite.DirtySprite or any sprite that has the following attributes: image, rect, dirty, visible, blendmode (see doc of DirtySprite). It uses the dirty flag technique and is therefore faster than the pygame.sprite.RenderUpdates if you have many static sprites. It also switches automatically between dirty rect update and full screen drawing, so you do no have to worry what would be faster. Same as for the pygame.sprite.Group. You can specify some additional attributes through kwargs: _use_update: True/False   default is False\n_default_layer: default layer where sprites without a layer are added.\n_time_threshold: threshold time for switching between dirty rect mode\n    and fullscreen mode, defaults to 1000./80  == 1000./fps  New in pygame 1.8.    draw() \n draw all sprites in the right order onto the passed surface. draw(surface, bgd=None) -> Rect_list  You can pass the background too. If a background is already set, then the bgd argument has no effect. \n   clear() \n used to set background clear(surface, bgd) -> None  \n   repaint_rect() \n repaints the given area repaint_rect(screen_rect) -> None  screen_rect is in screen coordinates. \n   set_clip() \n clip the area where to draw. Just pass None (default) to reset the clip set_clip(screen_rect=None) -> None  \n   get_clip() \n clip the area where to draw. Just pass None (default) to reset the clip get_clip() -> Rect  \n   change_layer() \n changes the layer of the sprite change_layer(sprite, new_layer) -> None  sprite must have been added to the renderer. It is not checked. \n   set_timing_treshold() \n sets the threshold in milliseconds set_timing_treshold(time_ms) -> None  Default is 1000./80 where 80 is the fps I want to switch to full screen mode. This method's name is a typo and should be fixed.     \nRaises:\n\nTypeError -- if time_ms is not int or float    \n \n   pygame.sprite.GroupSingle() \n Group container that holds a single sprite. GroupSingle(sprite=None) -> GroupSingle  The GroupSingle container only holds a single Sprite. When a new Sprite is added, the old one is removed. There is a special property, GroupSingle.sprite, that accesses the Sprite that this Group contains. It can be None when the Group is empty. The property can also be assigned to add a Sprite into the GroupSingle container. \n   pygame.sprite.spritecollide() \n Find sprites in a group that intersect another sprite. spritecollide(sprite, group, dokill, collided = None) -> Sprite_list  Return a list containing all Sprites in a Group that intersect with another Sprite. Intersection is determined by comparing the Sprite.rect attribute of each Sprite. The dokill argument is a bool. If set to True, all Sprites that collide will be removed from the Group. The collided argument is a callback function used to calculate if two sprites are colliding. it should take two sprites as values, and return a bool value indicating if they are colliding. If collided is not passed, all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. collided callables: collide_rect, collide_rect_ratio, collide_circle,\ncollide_circle_ratio, collide_mask Example: \n# See if the Sprite block has collided with anything in the Group block_list\n# The True flag will remove the sprite in block_list\nblocks_hit_list = pygame.sprite.spritecollide(player, block_list, True)\n\n# Check the list of colliding sprites, and add one to the score for each one\nfor block in blocks_hit_list:\n    score +=1\n  \n   pygame.sprite.collide_rect() \n Collision detection between two sprites, using rects. collide_rect(left, right) -> bool  Tests for collision between two sprites. Uses the pygame rect colliderect function to calculate the collision. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" attributes.  New in pygame 1.8.  \n   pygame.sprite.collide_rect_ratio() \n Collision detection between two sprites, using rects scaled to a ratio. collide_rect_ratio(ratio) -> collided_callable  A callable class that checks for collisions between two sprites, using a scaled version of the sprites rects. Is created with a ratio, the instance is then intended to be passed as a collided callback function to the *collide functions. A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size.  New in pygame 1.8.1.  \n   pygame.sprite.collide_circle() \n Collision detection between two sprites, using circles. collide_circle(left, right) -> bool  Tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap. If the sprites have a \"radius\" attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the \"rect\" attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" and an optional \"radius\" attribute.  New in pygame 1.8.1.  \n   pygame.sprite.collide_circle_ratio() \n Collision detection between two sprites, using circles scaled to a ratio. collide_circle_ratio(ratio) -> collided_callable  A callable class that checks for collisions between two sprites, using a scaled version of the sprites radius. Is created with a floating point ratio, the instance is then intended to be passed as a collided callback function to the *collide functions. A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size. The created callable tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap, after scaling the circles radius by the stored ratio. If the sprites have a \"radius\" attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the \"rect\" attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" and an optional \"radius\" attribute.  New in pygame 1.8.1.  \n   pygame.sprite.collide_mask() \n Collision detection between two sprites, using masks. collide_mask(sprite1, sprite2) -> (int, int) collide_mask(sprite1, sprite2) -> None  Tests for collision between two sprites, by testing if their bitmasks overlap (uses pygame.mask.Mask.overlap()). If the sprites have a mask attribute, it is used as the mask, otherwise a mask is created from the sprite's image (uses pygame.mask.from_surface()). Sprites must have a rect attribute; the mask attribute is optional. The first point of collision between the masks is returned. The collision point is offset from sprite1's mask's topleft corner (which is always (0, 0)). The collision point is a position within the mask and is not related to the actual screen position of sprite1. This function is intended to be passed as a collided callback function to the group collide functions (see spritecollide(), groupcollide(), spritecollideany()).  Note To increase performance, create and set a mask attibute for all sprites that will use this function to check for collisions. Otherwise, each time this function is called it will create new masks.   Note A new mask needs to be recreated each time a sprite's image is changed (e.g. if a new image is used or the existing image is rotated).  # Example of mask creation for a sprite.\nsprite.mask = pygame.mask.from_surface(sprite.image)     \nReturns:\nfirst point of collision between the masks or None if no collision  \nReturn type:\ntuple(int, int) or NoneType     New in pygame 1.8.0.  \n   pygame.sprite.groupcollide() \n Find all sprites that collide between two groups. groupcollide(group1, group2, dokill1, dokill2, collided = None) -> Sprite_dict  This will find collisions between all the Sprites in two groups. Collision is determined by comparing the Sprite.rect attribute of each Sprite or by using the collided function if it is not None. Every Sprite inside group1 is added to the return dictionary. The value for each item is the list of Sprites in group2 that intersect. If either dokill argument is True, the colliding Sprites will be removed from their respective Group. The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. \n   pygame.sprite.spritecollideany() \n Simple test if a sprite intersects anything in a group. \nspritecollideany(sprite, group, collided = None) -> Sprite Collision with the returned sprite. \nspritecollideany(sprite, group, collided = None) -> None No collision  If the sprite collides with any single sprite in the group, a single sprite from the group is returned. On no collision None is returned. If you don't need all the features of the pygame.sprite.spritecollide() function, this function will be a bit quicker. The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. \n \n \n"}, {"name": "module-surfarray", "path": "ref/surfarray", "type": "pygame.surfarray", "text": " pygame.surfarray\n  \n pygame module for accessing surface pixel data using array interfaces  Functions to convert pixel data between pygame Surfaces and arrays. This module will only be functional when pygame can use the external NumPy package. Every pixel is stored as a single integer value to represent the red, green, and blue colors. The 8-bit images use a value that looks into a colormap. Pixels with higher depth use a bit packing process to place three or four values into a single number. The arrays are indexed by the X axis first, followed by the Y axis. Arrays that treat the pixels as a single integer are referred to as 2D arrays. This module can also separate the red, green, and blue color values into separate indices. These types of arrays are referred to as 3D arrays, and the last index is 0 for red, 1 for green, and 2 for blue.   pygame.surfarray.array2d() \n Copy pixels into a 2d array array2d(Surface) -> array  Copy the mapped (raw) pixels from a Surface into a 2D array. The bit depth of the surface will control the size of the integer values, and will work for any type of pixel format. This function will temporarily lock the Surface as pixels are copied (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.pixels2d() \n Reference pixels into a 2d array pixels2d(Surface) -> array  Create a new 2D array that directly references the pixel values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. Pixels from a 24-bit Surface cannot be referenced, but all other Surface bit depths can. The Surface this references will remain locked for the lifetime of the array (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.array3d() \n Copy pixels into a 3d array array3d(Surface) -> array  Copy the pixels from a Surface into a 3D array. The bit depth of the surface will control the size of the integer values, and will work for any type of pixel format. This function will temporarily lock the Surface as pixels are copied (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.pixels3d() \n Reference pixels into a 3d array pixels3d(Surface) -> array  Create a new 3D array that directly references the pixel values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This will only work on Surfaces that have 24-bit or 32-bit formats. Lower pixel formats cannot be referenced. The Surface this references will remain locked for the lifetime of the array (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.array_alpha() \n Copy pixel alphas into a 2d array array_alpha(Surface) -> array  Copy the pixel alpha values (degree of transparency) from a Surface into a 2D array. This will work for any type of Surface format. Surfaces without a pixel alpha will return an array with all opaque values. This function will temporarily lock the Surface as pixels are copied (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.pixels_alpha() \n Reference pixel alphas into a 2d array pixels_alpha(Surface) -> array  Create a new 2D array that directly references the alpha values (degree of transparency) in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 32-bit Surfaces with a per-pixel alpha value. The Surface this array references will remain locked for the lifetime of the array. \n   pygame.surfarray.pixels_red() \n Reference pixel red into a 2d array. pixels_red (Surface) -> array  Create a new 2D array that directly references the red values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 24-bit or 32-bit Surfaces. The Surface this array references will remain locked for the lifetime of the array. \n   pygame.surfarray.pixels_green() \n Reference pixel green into a 2d array. pixels_green (Surface) -> array  Create a new 2D array that directly references the green values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 24-bit or 32-bit Surfaces. The Surface this array references will remain locked for the lifetime of the array. \n   pygame.surfarray.pixels_blue() \n Reference pixel blue into a 2d array. pixels_blue (Surface) -> array  Create a new 2D array that directly references the blue values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 24-bit or 32-bit Surfaces. The Surface this array references will remain locked for the lifetime of the array. \n   pygame.surfarray.array_colorkey() \n Copy the colorkey values into a 2d array array_colorkey(Surface) -> array  Create a new array with the colorkey transparency value from each pixel. If the pixel matches the colorkey it will be fully transparent; otherwise it will be fully opaque. This will work on any type of Surface format. If the image has no colorkey a solid opaque array will be returned. This function will temporarily lock the Surface as pixels are copied. \n   pygame.surfarray.make_surface() \n Copy an array to a new surface make_surface(array) -> Surface  Create a new Surface that best resembles the data and format on the array. The array can be 2D or 3D with any sized integer values. Function make_surface uses the array struct interface to acquire array properties, so is not limited to just NumPy arrays. See pygame.pixelcopy. New in pygame 1.9.2: array struct interface support. \n   pygame.surfarray.blit_array() \n Blit directly from a array values blit_array(Surface, array) -> None  Directly copy values from an array into a Surface. This is faster than converting the array into a Surface and blitting. The array must be the same dimensions as the Surface and will completely replace all pixel values. Only integer, ASCII character and record arrays are accepted. This function will temporarily lock the Surface as the new values are copied. \n   pygame.surfarray.map_array() \n Map a 3d array into a 2d array map_array(Surface, array3d) -> array2d  Convert a 3D array into a 2D array. This will use the given Surface format to control the conversion. Palette surface formats are supported for NumPy arrays. \n   pygame.surfarray.use_arraytype() \n Sets the array system to be used for surface arrays use_arraytype (arraytype) -> None  DEPRECATED: Uses the requested array type for the module functions. The only supported arraytype is 'numpy'. Other values will raise ValueError. \n   pygame.surfarray.get_arraytype() \n Gets the currently active array type. get_arraytype () -> str  DEPRECATED: Returns the currently active array type. This will be a value of the get_arraytypes() tuple and indicates which type of array module is used for the array creation.  New in pygame 1.8.  \n   pygame.surfarray.get_arraytypes() \n Gets the array system types currently supported. get_arraytypes () -> tuple  DEPRECATED: Checks, which array systems are available and returns them as a tuple of strings. The values of the tuple can be used directly in the pygame.surfarray.use_arraytype() () method. If no supported array system could be found, None will be returned.  New in pygame 1.8.  \n \n \n"}, {"name": "module-tests", "path": "ref/tests", "type": "pygame.tests", "text": " pygame.tests\n  \n Pygame unit test suite package  A quick way to run the test suite package from the command line is to import the go submodule with the Python -m option: python -m pygame.tests [<test options>] Command line option --help displays a usage message. Available options correspond to the pygame.tests.run() arguments. The xxxx_test submodules of the tests package are unit test suites for individual parts of pygame. Each can also be run as a main program. This is useful if the test, such as cdrom_test, is interactive. For pygame development the test suite can be run from a pygame distribution root directory. Program run_tests.py is provided for convenience, though test/go.py can be run directly. Module level tags control which modules are included in a unit test run. Tags are assigned to a unit test module with a corresponding <name>_tags.py module. The tags module has the global __tags__, a list of tag names. For example, cdrom_test.py has a tag file cdrom_tags.py containing a tags list that has the 'interactive' string. The 'interactive' tag indicates cdrom_test.py expects user input. It is excluded from a run_tests.py or pygame.tests.go run. Two other tags that are excluded are 'ignore' and 'subprocess_ignore'. These two tags indicate unit tests that will not run on a particular platform, or for which no corresponding pygame module is available. The test runner will list each excluded module along with the tag responsible.   pygame.tests.run() \n Run the pygame unit test suite run(*args, **kwds) -> tuple  Positional arguments (optional): The names of tests to include. If omitted then all tests are run. Test names\nneed not include the trailing '_test'. Keyword arguments: incomplete - fail incomplete tests (default False)\nnosubprocess - run all test suites in the current process\n               (default False, use separate subprocesses)\ndump - dump failures/errors as dict ready to eval (default False)\nfile - if provided, the name of a file into which to dump failures/errors\ntimings - if provided, the number of times to run each individual test to\n          get an average run time (default is run each test once)\nexclude - A list of TAG names to exclude from the run\nshow_output - show silenced stderr/stdout on errors (default False)\nall - dump all results, not just errors (default False)\nrandomize - randomize order of tests (default False)\nseed - if provided, a seed randomizer integer\nmulti_thread - if provided, the number of THREADS in which to run\n               subprocessed tests\ntime_out - if subprocess is True then the time limit in seconds before\n           killing a test (default 30)\nfake - if provided, the name of the fake tests package in the\n       run_tests__tests subpackage to run instead of the normal\n       pygame tests\npython - the path to a python executable to run subprocessed tests\n         (default sys.executable) Return value: A tuple of total number of tests run, dictionary of error information.\nThe dictionary is empty if no errors were recorded. By default individual test modules are run in separate subprocesses. This recreates normal pygame usage where pygame.init() and pygame.quit() are called only once per program execution, and avoids unfortunate interactions between test modules. Also, a time limit is placed on test execution, so frozen tests are killed when there time allotment expired. Use the single process option if threading is not working properly or if tests are taking too long. It is not guaranteed that all tests will pass in single process mode. Tests are run in a randomized order if the randomize argument is True or a seed argument is provided. If no seed integer is provided then the system time is used. Individual test modules may have a __tags__ attribute, a list of tag strings used to selectively omit modules from a run. By default only 'interactive' modules such as cdrom_test are ignored. An interactive module must be run from the console as a Python program. This function can only be called once per Python session. It is not reentrant. \n \n \n"}, {"name": "module-time", "path": "ref/time", "type": "pygame.time", "text": " pygame.time\n  \n pygame module for monitoring time  Times in pygame are represented in milliseconds (1/1000 seconds). Most platforms have a limited time resolution of around 10 milliseconds. This resolution, in milliseconds, is given in the TIMER_RESOLUTION constant.   pygame.time.get_ticks() \n get the time in milliseconds get_ticks() -> milliseconds  Return the number of milliseconds since pygame.init() was called. Before pygame is initialized this will always be 0. \n   pygame.time.wait() \n pause the program for an amount of time wait(milliseconds) -> time  Will pause for a given number of milliseconds. This function sleeps the process to share the processor with other programs. A program that waits for even a few milliseconds will consume very little processor time. It is slightly less accurate than the pygame.time.delay() function. This returns the actual number of milliseconds used. \n   pygame.time.delay() \n pause the program for an amount of time delay(milliseconds) -> time  Will pause for a given number of milliseconds. This function will use the processor (rather than sleeping) in order to make the delay more accurate than pygame.time.wait(). This returns the actual number of milliseconds used. \n   pygame.time.set_timer() \n repeatedly create an event on the event queue set_timer(eventid, milliseconds) -> None set_timer(eventid, milliseconds, once) -> None  Set an event type to appear on the event queue every given number of milliseconds. The first event will not appear until the amount of time has passed. Every event type can have a separate timer attached to it. It is best to use the value between pygame.USEREVENT and pygame.NUMEVENTS. To disable the timer for an event, set the milliseconds argument to 0. If the once argument is True, then only send the timer once.  New in pygame 2.0.0.dev3: once argument added.  \n   pygame.time.Clock \n create an object to help track time Clock() -> Clock  Creates a new Clock object that can be used to track an amount of time. The clock also provides several functions to help control a game's framerate.   tick() \n update the clock tick(framerate=0) -> milliseconds  This method should be called once per frame. It will compute how many milliseconds have passed since the previous call. If you pass the optional framerate argument the function will delay to keep the game running slower than the given ticks per second. This can be used to help limit the runtime speed of a game. By calling Clock.tick(40) once per frame, the program will never run at more than 40 frames per second. Note that this function uses SDL_Delay function which is not accurate on every platform, but does not use much CPU. Use tick_busy_loop if you want an accurate timer, and don't mind chewing CPU. \n   tick_busy_loop() \n update the clock tick_busy_loop(framerate=0) -> milliseconds  This method should be called once per frame. It will compute how many milliseconds have passed since the previous call. If you pass the optional framerate argument the function will delay to keep the game running slower than the given ticks per second. This can be used to help limit the runtime speed of a game. By calling Clock.tick_busy_loop(40) once per frame, the program will never run at more than 40 frames per second. Note that this function uses pygame.time.delay(), which uses lots of CPU in a busy loop to make sure that timing is more accurate.  New in pygame 1.8.  \n   get_time() \n time used in the previous tick get_time() -> milliseconds  The number of milliseconds that passed between the previous two calls to Clock.tick(). \n   get_rawtime() \n actual time used in the previous tick get_rawtime() -> milliseconds  Similar to Clock.get_time(), but does not include any time used while Clock.tick() was delaying to limit the framerate. \n   get_fps() \n compute the clock framerate get_fps() -> float  Compute your game's framerate (in frames per second). It is computed by averaging the last ten calls to Clock.tick(). \n \n \n \n"}, {"name": "module-transform", "path": "ref/transform", "type": "pygame.transform", "text": " pygame.transform\n  \n pygame module to transform surfaces  A Surface transform is an operation that moves or resizes the pixels. All these functions take a Surface to operate on and return a new Surface with the results. Some of the transforms are considered destructive. These means every time they are performed they lose pixel data. Common examples of this are resizing and rotating. For this reason, it is better to re-transform the original surface than to keep transforming an image multiple times. (For example, suppose you are animating a bouncing spring which expands and contracts. If you applied the size changes incrementally to the previous images, you would lose detail. Instead, always begin with the original image and scale to the desired size.)   pygame.transform.flip() \n flip vertically and horizontally flip(Surface, xbool, ybool) -> Surface  This can flip a Surface either vertically, horizontally, or both. Flipping a Surface is non-destructive and returns a new Surface with the same dimensions. \n   pygame.transform.scale() \n resize to new resolution scale(Surface, (width, height), DestSurface = None) -> Surface  Resizes the Surface to a new resolution. This is a fast scale operation that does not sample the results. An optional destination surface can be used, rather than have it create a new one. This is quicker if you want to repeatedly scale something. However the destination must be the same size as the (width, height) passed in. Also the destination surface must be the same format. \n   pygame.transform.rotate() \n rotate an image rotate(Surface, angle) -> Surface  Unfiltered counterclockwise rotation. The angle argument represents degrees and can be any floating point value. Negative angle amounts will rotate clockwise. Unless rotating by 90 degree increments, the image will be padded larger to hold the new size. If the image has pixel alphas, the padded area will be transparent. Otherwise pygame will pick a color that matches the Surface colorkey or the topleft pixel value. \n   pygame.transform.rotozoom() \n filtered scale and rotation rotozoom(Surface, angle, scale) -> Surface  This is a combined scale and rotation transform. The resulting Surface will be a filtered 32-bit Surface. The scale argument is a floating point value that will be multiplied by the current resolution. The angle argument is a floating point value that represents the counterclockwise degrees to rotate. A negative rotation angle will rotate clockwise. \n   pygame.transform.scale2x() \n specialized image doubler scale2x(Surface, DestSurface = None) -> Surface  This will return a new image that is double the size of the original. It uses the AdvanceMAME Scale2X algorithm which does a 'jaggie-less' scale of bitmap graphics. This really only has an effect on simple images with solid colors. On photographic and antialiased images it will look like a regular unfiltered scale. An optional destination surface can be used, rather than have it create a new one. This is quicker if you want to repeatedly scale something. However the destination must be twice the size of the source surface passed in. Also the destination surface must be the same format. \n   pygame.transform.smoothscale() \n scale a surface to an arbitrary size smoothly smoothscale(Surface, (width, height), DestSurface = None) -> Surface  Uses one of two different algorithms for scaling each dimension of the input surface as required. For shrinkage, the output pixels are area averages of the colors they cover. For expansion, a bilinear filter is used. For the x86-64 and i686 architectures, optimized MMX routines are included and will run much faster than other machine types. The size is a 2 number sequence for (width, height). This function only works for 24-bit or 32-bit surfaces. An exception will be thrown if the input surface bit depth is less than 24.  New in pygame 1.8.  \n   pygame.transform.get_smoothscale_backend() \n return smoothscale filter version in use: 'GENERIC', 'MMX', or 'SSE' get_smoothscale_backend() -> String  Shows whether or not smoothscale is using MMX or SSE acceleration. If no acceleration is available then \"GENERIC\" is returned. For a x86 processor the level of acceleration to use is determined at runtime. This function is provided for pygame testing and debugging. \n   pygame.transform.set_smoothscale_backend() \n set smoothscale filter version to one of: 'GENERIC', 'MMX', or 'SSE' set_smoothscale_backend(type) -> None  Sets smoothscale acceleration. Takes a string argument. A value of 'GENERIC' turns off acceleration. 'MMX' uses MMX instructions only. 'SSE' allows SSE extensions as well. A value error is raised if type is not recognized or not supported by the current processor. This function is provided for pygame testing and debugging. If smoothscale causes an invalid instruction error then it is a pygame/SDL bug that should be reported. Use this function as a temporary fix only. \n   pygame.transform.chop() \n gets a copy of an image with an interior area removed chop(Surface, rect) -> Surface  Extracts a portion of an image. All vertical and horizontal pixels surrounding the given rectangle area are removed. The corner areas (diagonal to the rect) are then brought together. (The original image is not altered by this operation.) NOTE: If you want a \"crop\" that returns the part of an image within a rect, you can blit with a rect to a new surface or copy a subsurface. \n   pygame.transform.laplacian() \n find edges in a surface laplacian(Surface, DestSurface = None) -> Surface  Finds the edges in a surface using the laplacian algorithm.  New in pygame 1.8.  \n   pygame.transform.average_surfaces() \n find the average surface from many surfaces. average_surfaces(Surfaces, DestSurface = None, palette_colors = 1) -> Surface  Takes a sequence of surfaces and returns a surface with average colors from each of the surfaces. palette_colors - if true we average the colors in palette, otherwise we average the pixel values. This is useful if the surface is actually greyscale colors, and not palette colors. Note, this function currently does not handle palette using surfaces correctly.  New in pygame 1.8.   New in pygame 1.9: palette_colors argument  \n   pygame.transform.average_color() \n finds the average color of a surface average_color(Surface, Rect = None) -> Color  Finds the average color of a Surface or a region of a surface specified by a Rect, and returns it as a Color. \n   pygame.transform.threshold() \n finds which, and how many pixels in a surface are within a threshold of a 'search_color' or a 'search_surf'. threshold(dest_surf, surf, search_color, threshold=(0,0,0,0), set_color=(0,0,0,0), set_behavior=1, search_surf=None, inverse_set=False) -> num_threshold_pixels  This versatile function can be used for find colors in a 'surf' close to a 'search_color' or close to colors in a separate 'search_surf'. It can also be used to transfer pixels into a 'dest_surf' that match or don't match. By default it sets pixels in the 'dest_surf' where all of the pixels NOT within the threshold are changed to set_color. If inverse_set is optionally set to True, the pixels that ARE within the threshold are changed to set_color. If the optional 'search_surf' surface is given, it is used to threshold against rather than the specified 'set_color'. That is, it will find each pixel in the 'surf' that is within the 'threshold' of the pixel at the same coordinates of the 'search_surf'.     \nParameters:\n\n \ndest_surf (pygame.Surface or None) -- Surface we are changing. See 'set_behavior'. Should be None if counting (set_behavior is 0). \nsurf (pygame.Surface) -- Surface we are looking at. \nsearch_color (pygame.Color) -- Color we are searching for. \nthreshold (pygame.Color) -- Within this distance from search_color (or search_surf). You can use a threshold of (r,g,b,a) where the r,g,b can have different thresholds. So you could use an r threshold of 40 and a blue threshold of 2 if you like. \nset_color (pygame.Color or None) -- Color we set in dest_surf. \nset_behavior (int) --  set_behavior=1 (default). Pixels in dest_surface will be changed to 'set_color'. set_behavior=0 we do not change 'dest_surf', just count. Make dest_surf=None. set_behavior=2 pixels set in 'dest_surf' will be from 'surf'.   \nsearch_surf (pygame.Surface or None) --  search_surf=None (default). Search against 'search_color' instead. search_surf=Surface. Look at the color in 'search_surf' rather than using 'search_color'.   \ninverse_set (bool) --  False, default. Pixels outside of threshold are changed. True, Pixels within threshold are changed.      \nReturn type:\n\nint   \nReturns:\n\nThe number of pixels that are within the 'threshold' in 'surf' compared to either 'search_color' or search_surf.   \nExamples:\n    See the threshold tests for a full of examples: https://github.com/pygame/pygame/blob/master/test/transform_test.py def test_threshold_dest_surf_not_change(self):\n        \"\"\" the pixels within the threshold.\n\n        All pixels not within threshold are changed to set_color.\n        So there should be none changed in this test.\n        \"\"\"\n        (w, h) = size = (32, 32)\n        threshold = (20, 20, 20, 20)\n        original_color = (25, 25, 25, 25)\n        original_dest_color = (65, 65, 65, 55)\n        threshold_color = (10, 10, 10, 10)\n        set_color = (255, 10, 10, 10)\n\n        surf = pygame.Surface(size, pygame.SRCALPHA, 32)\n        dest_surf = pygame.Surface(size, pygame.SRCALPHA, 32)\n        search_surf = pygame.Surface(size, pygame.SRCALPHA, 32)\n\n        surf.fill(original_color)\n        search_surf.fill(threshold_color)\n        dest_surf.fill(original_dest_color)\n\n        # set_behavior=1, set dest_surface from set_color.\n        # all within threshold of third_surface, so no color is set.\n\n        THRESHOLD_BEHAVIOR_FROM_SEARCH_COLOR = 1\n        pixels_within_threshold = pygame.transform.threshold(\n            dest_surf=dest_surf,\n            surf=surf,\n            search_color=None,\n            threshold=threshold,\n            set_color=set_color,\n            set_behavior=THRESHOLD_BEHAVIOR_FROM_SEARCH_COLOR,\n            search_surf=search_surf,\n        )\n\n        # # Return, of pixels within threshold is correct\n        self.assertEqual(w * h, pixels_within_threshold)\n\n        # # Size of dest surface is correct\n        dest_rect = dest_surf.get_rect()\n        dest_size = dest_rect.size\n        self.assertEqual(size, dest_size)\n\n        # The color is not the change_color specified for every pixel As all\n        # pixels are within threshold\n\n        for pt in test_utils.rect_area_pts(dest_rect):\n            self.assertNotEqual(dest_surf.get_at(pt), set_color)\n            self.assertEqual(dest_surf.get_at(pt), original_dest_color)  New in pygame 1.8.   Changed in pygame 1.9.4: Fixed a lot of bugs and added keyword arguments. Test your code.  \n \n \n"}, {"name": "module-version", "path": "ref/pygame", "type": "pygame", "text": " pygame\n  \n the top level pygame package  The pygame package represents the top-level package for others to use. Pygame itself is broken into many submodules, but this does not affect programs that use pygame. As a convenience, most of the top-level variables in pygame have been placed inside a module named pygame.locals. This is meant to be used with from pygame.locals import *, in addition to import pygame. When you import pygame all available pygame submodules are automatically imported. Be aware that some of the pygame modules are considered optional, and may not be available. In that case, pygame will provide a placeholder object instead of the module, which can be used to test for availability.   pygame.init() \n initialize all imported pygame modules init() -> (numpass, numfail)  Initialize all imported pygame modules. No exceptions will be raised if a module fails, but the total number if successful and failed inits will be returned as a tuple. You can always initialize individual modules manually, but pygame.init() is a convenient way to get everything started. The init() functions for individual modules will raise exceptions when they fail. You may want to initialize the different modules separately to speed up your program or to not use modules your game does not require. It is safe to call this init() more than once as repeated calls will have no effect. This is true even if you have pygame.quit() all the modules. \n   pygame.quit() \n uninitialize all pygame modules quit() -> None  Uninitialize all pygame modules that have previously been initialized. When the Python interpreter shuts down, this method is called regardless, so your program should not need it, except when it wants to terminate its pygame resources and continue. It is safe to call this function more than once as repeated calls have no effect.  Note Calling pygame.quit() will not exit your program. Consider letting your program end in the same way a normal Python program will end.  \n   pygame.get_init() \n returns True if pygame is currently initialized get_init() -> bool  Returns True if pygame is currently initialized.  New in pygame 1.9.5.  \n   exception pygame.error \n standard pygame exception raise pygame.error(message)  This exception is raised whenever a pygame or SDL operation fails. You can catch any anticipated problems and deal with the error. The exception is always raised with a descriptive message about the problem. Derived from the RuntimeError exception, which can also be used to catch these raised errors. \n   pygame.get_error() \n get the current error message get_error() -> errorstr  SDL maintains an internal error message. This message will usually be given to you when pygame.error() is raised, so this function will rarely be needed. \n   pygame.set_error() \n set the current error message set_error(error_msg) -> None  SDL maintains an internal error message. This message will usually be given to you when pygame.error() is raised, so this function will rarely be needed. \n   pygame.get_sdl_version() \n get the version number of SDL get_sdl_version() -> major, minor, patch  Returns the three version numbers of the SDL library. This version is built at compile time. It can be used to detect which features may or may not be available through pygame.  New in pygame 1.7.0.  \n   pygame.get_sdl_byteorder() \n get the byte order of SDL get_sdl_byteorder() -> int  Returns the byte order of the SDL library. It returns 1234 for little endian byte order and 4321 for big endian byte order.  New in pygame 1.8.  \n   pygame.register_quit() \n register a function to be called when pygame quits register_quit(callable) -> None  When pygame.quit() is called, all registered quit functions are called. Pygame modules do this automatically when they are initializing, so this function will rarely be needed. \n   pygame.encode_string() \n Encode a Unicode or bytes object encode_string([obj [, encoding [, errors [, etype]]]]) -> bytes or None  obj: If Unicode, encode; if bytes, return unaltered; if anything else, return None; if not given, raise SyntaxError. encoding (string): If present, encoding to use. The default is 'unicode_escape'. errors (string): If given, how to handle unencodable characters. The default is 'backslashreplace'. etype (exception type): If given, the exception type to raise for an encoding error. The default is UnicodeEncodeError, as returned by PyUnicode_AsEncodedString(). For the default encoding and errors values there should be no encoding errors. This function is used in encoding file paths. Keyword arguments are supported.  New in pygame 1.9.2: (primarily for use in unit tests)  \n   pygame.encode_file_path() \n Encode a Unicode or bytes object as a file system path encode_file_path([obj [, etype]]) -> bytes or None  obj: If Unicode, encode; if bytes, return unaltered; if anything else, return None; if not given, raise SyntaxError. etype (exception type): If given, the exception type to raise for an encoding error. The default is UnicodeEncodeError, as returned by PyUnicode_AsEncodedString(). This function is used to encode file paths in pygame. Encoding is to the codec as returned by sys.getfilesystemencoding(). Keyword arguments are supported.  New in pygame 1.9.2: (primarily for use in unit tests)  \n \n   pygame.version\n  \n small module containing version information  This module is automatically imported into the pygame package and can be used to check which version of pygame has been imported.   pygame.version.ver \n version number as a string ver = '1.2'  This is the version represented as a string. It can contain a micro release number as well, e.g. '1.5.2' \n   pygame.version.vernum \n tupled integers of the version vernum = (1, 5, 3)  This version information can easily be compared with other version numbers of the same format. An example of checking pygame version numbers would look like this: if pygame.version.vernum < (1, 5):\n    print('Warning, older version of pygame (%s)' %  pygame.version.ver)\n    disable_advanced_features = True  New in pygame 1.9.6: Attributes major, minor, and patch.  vernum.major == vernum[0]\nvernum.minor == vernum[1]\nvernum.patch == vernum[2]  Changed in pygame 1.9.6: str(pygame.version.vernum) returns a string like \"2.0.0\" instead of \"(2, 0, 0)\".   Changed in pygame 1.9.6: repr(pygame.version.vernum) returns a string like \"PygameVersion(major=2, minor=0, patch=0)\" instead of \"(2, 0, 0)\".  \n   pygame.version.rev \n repository revision of the build rev = 'a6f89747b551+'  The Mercurial node identifier of the repository checkout from which this package was built. If the identifier ends with a plus sign '+' then the package contains uncommitted changes. Please include this revision number in bug reports, especially for non-release pygame builds. Important note: pygame development has moved to github, this variable is obsolete now. As soon as development shifted to github, this variable started returning an empty string \"\". It has always been returning an empty string since v1.9.5.  Changed in pygame 1.9.5: Always returns an empty string \"\".  \n   pygame.version.SDL \n tupled integers of the SDL library version SDL = '(2, 0, 12)'  This is the SDL library version represented as an extended tuple. It also has attributes 'major', 'minor' & 'patch' that can be accessed like this: >>> pygame.version.SDL.major\n2 printing the whole thing returns a string like this: >>> pygame.version.SDL\nSDLVersion(major=2, minor=0, patch=12)  New in pygame 2.0.0.  \n Setting Environment Variables Some aspects of pygame's behaviour can be controlled by setting environment variables, they cover a wide range of the library's functionality. Some of the variables are from pygame itself, while others come from the underlying C SDL library that pygame uses. In python, environment variables are usually set in code like this: import os\nos.environ['NAME_OF_ENVIRONMENT_VARIABLE'] = 'value_to_set' Or to preserve users ability to override the variable: import os\nos.environ['ENV_VAR'] = os.environ.get('ENV_VAR', 'value') If the variable is more useful for users of an app to set than the developer then they can set it like this: Windows: set NAME_OF_ENVIRONMENT_VARIABLE=value_to_set\npython my_application.py Linux/Mac: ENV_VAR=value python my_application.py For some variables they need to be set before initialising pygame, some must be set before even importing pygame, and others can simply be set right before the area of code they control is run. Below is a list of environment variables, their settable values, and a brief description of what they do.    Pygame Environment Variables These variables are defined by pygame itself.    PYGAME_DISPLAY - Experimental (subject to change)\nSet index of the display to use, \"0\" is the default. This sets the display where pygame will open its window or screen. The value set here will be used if set before calling pygame.display.set_mode(), and as long as no 'display' parameter is passed into pygame.display.set_mode().    PYGAME_FORCE_SCALE -\nSet to \"photo\" or \"default\". This forces set_mode() to use the SCALED display mode and, if \"photo\" is set, makes the scaling use the slowest, but highest quality anisotropic scaling algorithm, if it is available. Must be set before calling pygame.display.set_mode().    PYGAME_BLEND_ALPHA_SDL2 - New in pygame 2.0.0\nSet to \"1\" to enable the SDL2 blitter. This makes pygame use the SDL2 blitter for all alpha blending. The SDL2 blitter is sometimes faster than the default blitter but uses a different formula so the final colours may differ. Must be set before pygame.init() is called.    PYGAME_HIDE_SUPPORT_PROMPT -\nSet to \"1\" to hide the prompt. This stops the welcome message popping up in the console that tells you which version of python, pygame & SDL you are using. Must be set before importing pygame.    PYGAME_FREETYPE -\nSet to \"1\" to enable. This switches the pygame.font module to a pure freetype implementation that bypasses SDL_ttf. See the font module for why you might want to do this. Must be set before importing pygame.    PYGAME_CAMERA -\nSet to \"opencv\" or \"vidcapture\" Forces the library backend used in the camera module, overriding the platform defaults. Must be set before calling pygame.camera.init().     SDL Environment Variables These variables are defined by SDL. For documentation on the environment variables available in pygame 1 try here. For Pygame 2, some selected environment variables are listed below.    SDL_VIDEO_CENTERED -\nSet to \"1\" to enable centering the window. This will make the pygame window open in the centre of the display. Must be set before calling pygame.display.set_mode().    SDL_VIDEO_WINDOW_POS -\nSet to \"x,y\" to position the top left corner of the window. This allows control over the placement of the pygame window within the display. Must be set before calling pygame.display.set_mode().    SDL_VIDEODRIVER -\nSet to \"drivername\" to change the video driver used. On some platforms there are multiple video drivers available and this allows users to pick between them. More information is available here. Must be set before calling pygame.init() or pygame.display.init().    SDL_AUDIODRIVER -\nSet to \"drivername\" to change the audio driver used. On some platforms there are multiple audio drivers available and this allows users to pick between them. More information is available here. Must be set before calling pygame.init() or pygame.mixer.init().    SDL_VIDEO_ALLOW_SCREENSAVER\nSet to \"1\" to allow screensavers while pygame apps are running. By default pygame apps disable screensavers while they are running. Setting this environment variable allows users or developers to change that and make screensavers run again.    SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\nSet to \"0\" to re-enable the compositor. By default SDL tries to disable the X11 compositor for all pygame apps. This is usually a good thing as it's faster, however if you have an app which doesn't update every frame and are using linux you may want to disable this bypass. The bypass has reported problems on KDE linux. This variable is only used on x11/linux platforms. \n \n"}, {"name": "mouse", "path": "ref/mouse", "type": "pygame.mouse", "text": " pygame.mouse\n  \n pygame module to work with the mouse  The mouse functions can be used to get the current state of the mouse device. These functions can also alter the system cursor for the mouse. When the display mode is set, the event queue will start receiving mouse events. The mouse buttons generate pygame.MOUSEBUTTONDOWN and pygame.MOUSEBUTTONUP events when they are pressed and released. These events contain a button attribute representing which button was pressed. The mouse wheel will generate pygame.MOUSEBUTTONDOWN and pygame.MOUSEBUTTONUP events when rolled. The button will be set to 4 when the wheel is rolled up, and to button 5 when the wheel is rolled down. Whenever the mouse is moved it generates a pygame.MOUSEMOTION event. The mouse movement is broken into small and accurate motion events. As the mouse is moving many motion events will be placed on the queue. Mouse motion events that are not properly cleaned from the event queue are the primary reason the event queue fills up. If the mouse cursor is hidden, and input is grabbed to the current display the mouse will enter a virtual input mode, where the relative movements of the mouse will never be stopped by the borders of the screen. See the functions pygame.mouse.set_visible() and pygame.event.set_grab() to get this configured. Mouse Wheel Behavior in pygame 2 There is proper functionality for mouse wheel behaviour with pygame 2 supporting pygame.MOUSEWHEEL events. The new events support horizontal and vertical scroll movements, with signed integer values representing the amount scrolled (x and y), as well as flipped direction (the set positive and negative values for each axis is flipped). Read more about SDL2 input-related changes here https://wiki.libsdl.org/MigrationGuide#Input In pygame 2, the mouse wheel functionality can be used by listening for the pygame.MOUSEWHEEL type of an event. When this event is triggered, a developer can access the appropriate Event object with pygame.event.get(). The object can be used to access data about the mouse scroll, such as which (it will tell you what exact mouse device trigger the event).  Code example of mouse scroll (tested on 2.0.0.dev7) \n# Taken from husano896's PR thread (slightly modified)\nimport pygame\nfrom pygame.locals import *\npygame.init()\nscreen = pygame.display.set_mode((640, 480))\nclock = pygame.time.Clock()\n\ndef main():\n   while True:\n      for event in pygame.event.get():\n            if event.type == QUIT:\n               pygame.quit()\n               return\n            elif event.type == MOUSEWHEEL:\n               print(event)\n               print(event.x, event.y)\n               print(event.flipped)\n               print(event.which)\n               # can access properties with\n               # proper notation(ex: event.y)\n      clock.tick(60)\n\n# Execute game:\nmain()\n     pygame.mouse.get_pressed() \n get the state of the mouse buttons get_pressed(num_buttons=3) -> (button1, button2, button3) get_pressed(num_buttons=5) -> (button1, button2, button3, button4, button5)  Returns a sequence of booleans representing the state of all the mouse buttons. A true value means the mouse is currently being pressed at the time of the call. Note, to get all of the mouse events it is better to use either pygame.event.wait() or pygame.event.get() and check all of those events to see if they are MOUSEBUTTONDOWN, MOUSEBUTTONUP, or MOUSEMOTION. Note, that on X11 some X servers use middle button emulation. When you click both buttons 1 and 3 at the same time a 2 button event can be emitted. Note, remember to call pygame.event.get() before this function. Otherwise it will not work as expected. To support five button mice, an optional parameter num_buttons has been added in pygame 2. When this is set to 5, button4 and button5 are added to the returned tuple. Only 3 and 5 are valid values for this parameter.  Changed in pygame 2.0.0: num_buttons argument added  \n   pygame.mouse.get_pos() \n get the mouse cursor position get_pos() -> (x, y)  Returns the x and y position of the mouse cursor. The position is relative to the top-left corner of the display. The cursor position can be located outside of the display window, but is always constrained to the screen. \n   pygame.mouse.get_rel() \n get the amount of mouse movement get_rel() -> (x, y)  Returns the amount of movement in x and y since the previous call to this function. The relative movement of the mouse cursor is constrained to the edges of the screen, but see the virtual input mouse mode for a way around this. Virtual input mode is described at the top of the page. \n   pygame.mouse.set_pos() \n set the mouse cursor position set_pos([x, y]) -> None  Set the current mouse position to arguments given. If the mouse cursor is visible it will jump to the new coordinates. Moving the mouse will generate a new pygame.MOUSEMOTION event. \n   pygame.mouse.set_visible() \n hide or show the mouse cursor set_visible(bool) -> bool  If the bool argument is true, the mouse cursor will be visible. This will return the previous visible state of the cursor. \n   pygame.mouse.get_visible() \n get the current visibility state of the mouse cursor get_visible() -> bool  Get the current visibility state of the mouse cursor. True if the mouse is visible, False otherwise.  New in pygame 2.0.0.  \n   pygame.mouse.get_focused() \n check if the display is receiving mouse input get_focused() -> bool  Returns true when pygame is receiving mouse input events (or, in windowing terminology, is \"active\" or has the \"focus\"). This method is most useful when working in a window. By contrast, in full-screen mode, this method always returns true. Note: under MS Windows, the window that has the mouse focus also has the keyboard focus. But under X-Windows, one window can receive mouse events and another receive keyboard events. pygame.mouse.get_focused() indicates whether the pygame window receives mouse events. \n   pygame.mouse.set_cursor() \n set the image for the mouse cursor set_cursor(size, hotspot, xormasks, andmasks) -> None  When the mouse cursor is visible, it will be displayed as a black and white bitmap using the given bitmask arrays. The size is a sequence containing the cursor width and height. hotspot is a sequence containing the cursor hotspot position. A cursor has a width and height, but a mouse position is represented by a set of point coordinates. So the value passed into the cursor hotspot variable helps pygame to actually determine at what exact point the cursor is at. xormasks is a sequence of bytes containing the cursor xor data masks. Lastly andmasks, a sequence of bytes containing the cursor bitmask data. To create these variables, we can make use of the pygame.cursors.compile() function. Width and height must be a multiple of 8, and the mask arrays must be the correct size for the given width and height. Otherwise an exception is raised. See the pygame.cursor module for help creating default and custom masks for the mouse cursor and also for more examples related to cursors. \n   pygame.mouse.set_system_cursor() \n set the mouse cursor to a system variant set_system_cursor(constant) -> None  When the mouse cursor is visible, it will displayed as a operating system specific variant of the options below. Pygame Cursor Constant           Description\n--------------------------------------------\npygame.SYSTEM_CURSOR_ARROW       arrow\npygame.SYSTEM_CURSOR_IBEAM       i-beam\npygame.SYSTEM_CURSOR_WAIT        wait\npygame.SYSTEM_CURSOR_CROSSHAIR   crosshair\npygame.SYSTEM_CURSOR_WAITARROW   small wait cursor\n                                 (or wait if not available)\npygame.SYSTEM_CURSOR_SIZENWSE    double arrow pointing\n                                 northwest and southeast\npygame.SYSTEM_CURSOR_SIZENESW    double arrow pointing\n                                 northeast and southwest\npygame.SYSTEM_CURSOR_SIZEWE      double arrow pointing\n                                 west and east\npygame.SYSTEM_CURSOR_SIZENS      double arrow pointing\n                                 north and south\npygame.SYSTEM_CURSOR_SIZEALL     four pointed arrow pointing\n                                 north, south, east, and west\npygame.SYSTEM_CURSOR_NO          slashed circle or crossbones\npygame.SYSTEM_CURSOR_HAND        hand  New in pygame 2.0.0.  \n   pygame.mouse.get_cursor() \n get the image of the mouse cursor get_cursor() -> (size, hotspot, xormasks, andmasks)  Get the information about the mouse system cursor. The return value is the same data as the arguments passed into pygame.mouse.set_cursor().  Note This method is unavailable with pygame 2, as SDL2 does not provide the underlying code to implement this method.  \n \n \n"}, {"name": "mouse.get_cursor", "path": "ref/mouse#pygame.mouse.get_cursor", "type": "pygame.mouse", "text": "  pygame.mouse.get_cursor() \n get the image of the mouse cursor get_cursor() -> (size, hotspot, xormasks, andmasks)  Get the information about the mouse system cursor. The return value is the same data as the arguments passed into pygame.mouse.set_cursor().  Note This method is unavailable with pygame 2, as SDL2 does not provide the underlying code to implement this method.  \n"}, {"name": "mouse.get_focused", "path": "ref/mouse#pygame.mouse.get_focused", "type": "pygame.mouse", "text": "  pygame.mouse.get_focused() \n check if the display is receiving mouse input get_focused() -> bool  Returns true when pygame is receiving mouse input events (or, in windowing terminology, is \"active\" or has the \"focus\"). This method is most useful when working in a window. By contrast, in full-screen mode, this method always returns true. Note: under MS Windows, the window that has the mouse focus also has the keyboard focus. But under X-Windows, one window can receive mouse events and another receive keyboard events. pygame.mouse.get_focused() indicates whether the pygame window receives mouse events. \n"}, {"name": "mouse.get_pos", "path": "ref/mouse#pygame.mouse.get_pos", "type": "pygame.mouse", "text": "  pygame.mouse.get_pos() \n get the mouse cursor position get_pos() -> (x, y)  Returns the x and y position of the mouse cursor. The position is relative to the top-left corner of the display. The cursor position can be located outside of the display window, but is always constrained to the screen. \n"}, {"name": "mouse.get_pressed", "path": "ref/mouse#pygame.mouse.get_pressed", "type": "pygame.mouse", "text": "  pygame.mouse.get_pressed() \n get the state of the mouse buttons get_pressed(num_buttons=3) -> (button1, button2, button3) get_pressed(num_buttons=5) -> (button1, button2, button3, button4, button5)  Returns a sequence of booleans representing the state of all the mouse buttons. A true value means the mouse is currently being pressed at the time of the call. Note, to get all of the mouse events it is better to use either pygame.event.wait() or pygame.event.get() and check all of those events to see if they are MOUSEBUTTONDOWN, MOUSEBUTTONUP, or MOUSEMOTION. Note, that on X11 some X servers use middle button emulation. When you click both buttons 1 and 3 at the same time a 2 button event can be emitted. Note, remember to call pygame.event.get() before this function. Otherwise it will not work as expected. To support five button mice, an optional parameter num_buttons has been added in pygame 2. When this is set to 5, button4 and button5 are added to the returned tuple. Only 3 and 5 are valid values for this parameter.  Changed in pygame 2.0.0: num_buttons argument added  \n"}, {"name": "mouse.get_rel", "path": "ref/mouse#pygame.mouse.get_rel", "type": "pygame.mouse", "text": "  pygame.mouse.get_rel() \n get the amount of mouse movement get_rel() -> (x, y)  Returns the amount of movement in x and y since the previous call to this function. The relative movement of the mouse cursor is constrained to the edges of the screen, but see the virtual input mouse mode for a way around this. Virtual input mode is described at the top of the page. \n"}, {"name": "mouse.get_visible", "path": "ref/mouse#pygame.mouse.get_visible", "type": "pygame.mouse", "text": "  pygame.mouse.get_visible() \n get the current visibility state of the mouse cursor get_visible() -> bool  Get the current visibility state of the mouse cursor. True if the mouse is visible, False otherwise.  New in pygame 2.0.0.  \n"}, {"name": "mouse.set_cursor", "path": "ref/mouse#pygame.mouse.set_cursor", "type": "pygame.mouse", "text": "  pygame.mouse.set_cursor() \n set the image for the mouse cursor set_cursor(size, hotspot, xormasks, andmasks) -> None  When the mouse cursor is visible, it will be displayed as a black and white bitmap using the given bitmask arrays. The size is a sequence containing the cursor width and height. hotspot is a sequence containing the cursor hotspot position. A cursor has a width and height, but a mouse position is represented by a set of point coordinates. So the value passed into the cursor hotspot variable helps pygame to actually determine at what exact point the cursor is at. xormasks is a sequence of bytes containing the cursor xor data masks. Lastly andmasks, a sequence of bytes containing the cursor bitmask data. To create these variables, we can make use of the pygame.cursors.compile() function. Width and height must be a multiple of 8, and the mask arrays must be the correct size for the given width and height. Otherwise an exception is raised. See the pygame.cursor module for help creating default and custom masks for the mouse cursor and also for more examples related to cursors. \n"}, {"name": "mouse.set_pos", "path": "ref/mouse#pygame.mouse.set_pos", "type": "pygame.mouse", "text": "  pygame.mouse.set_pos() \n set the mouse cursor position set_pos([x, y]) -> None  Set the current mouse position to arguments given. If the mouse cursor is visible it will jump to the new coordinates. Moving the mouse will generate a new pygame.MOUSEMOTION event. \n"}, {"name": "mouse.set_system_cursor", "path": "ref/mouse#pygame.mouse.set_system_cursor", "type": "pygame.mouse", "text": "  pygame.mouse.set_system_cursor() \n set the mouse cursor to a system variant set_system_cursor(constant) -> None  When the mouse cursor is visible, it will displayed as a operating system specific variant of the options below. Pygame Cursor Constant           Description\n--------------------------------------------\npygame.SYSTEM_CURSOR_ARROW       arrow\npygame.SYSTEM_CURSOR_IBEAM       i-beam\npygame.SYSTEM_CURSOR_WAIT        wait\npygame.SYSTEM_CURSOR_CROSSHAIR   crosshair\npygame.SYSTEM_CURSOR_WAITARROW   small wait cursor\n                                 (or wait if not available)\npygame.SYSTEM_CURSOR_SIZENWSE    double arrow pointing\n                                 northwest and southeast\npygame.SYSTEM_CURSOR_SIZENESW    double arrow pointing\n                                 northeast and southwest\npygame.SYSTEM_CURSOR_SIZEWE      double arrow pointing\n                                 west and east\npygame.SYSTEM_CURSOR_SIZENS      double arrow pointing\n                                 north and south\npygame.SYSTEM_CURSOR_SIZEALL     four pointed arrow pointing\n                                 north, south, east, and west\npygame.SYSTEM_CURSOR_NO          slashed circle or crossbones\npygame.SYSTEM_CURSOR_HAND        hand  New in pygame 2.0.0.  \n"}, {"name": "mouse.set_visible", "path": "ref/mouse#pygame.mouse.set_visible", "type": "pygame.mouse", "text": "  pygame.mouse.set_visible() \n hide or show the mouse cursor set_visible(bool) -> bool  If the bool argument is true, the mouse cursor will be visible. This will return the previous visible state of the cursor. \n"}, {"name": "Overlay", "path": "ref/overlay", "type": "pygame.Overlay", "text": " pygame.Overlay\n  \n pygame object for video overlay graphics Overlay(format, (width, height)) -> Overlay  The Overlay objects provide support for accessing hardware video overlays. Video overlays do not use standard RGB pixel formats, and can use multiple resolutions of data to create a single image. The Overlay objects represent lower level access to the display hardware. To use the object you must understand the technical details of video overlays. The Overlay format determines the type of pixel data used. Not all hardware will support all types of overlay formats. Here is a list of available format types: YV12_OVERLAY, IYUV_OVERLAY, YUY2_OVERLAY, UYVY_OVERLAY, YVYU_OVERLAY The width and height arguments control the size for the overlay image data. The overlay image can be displayed at any size, not just the resolution of the overlay. The overlay objects are always visible, and always show above the regular display contents.   display() \n set the overlay pixel data display((y, u, v)) -> None display() -> None  Display the YUV data in SDL's overlay planes. The y, u, and v arguments are strings of binary data. The data must be in the correct format used to create the Overlay. If no argument is passed in, the Overlay will simply be redrawn with the current data. This can be useful when the Overlay is not really hardware accelerated. The strings are not validated, and improperly sized strings could crash the program. \n   set_location() \n control where the overlay is displayed set_location(rect) -> None  Set the location for the overlay. The overlay will always be shown relative to the main display Surface. This does not actually redraw the overlay, it will be updated on the next call to Overlay.display(). \n   get_hardware() \n test if the Overlay is hardware accelerated get_hardware(rect) -> int  Returns a True value when the Overlay is hardware accelerated. If the platform does not support acceleration, software rendering is used. \n \n \n"}, {"name": "Overlay.display", "path": "ref/overlay#pygame.Overlay.display", "type": "pygame.Overlay", "text": "  display() \n set the overlay pixel data display((y, u, v)) -> None display() -> None  Display the YUV data in SDL's overlay planes. The y, u, and v arguments are strings of binary data. The data must be in the correct format used to create the Overlay. If no argument is passed in, the Overlay will simply be redrawn with the current data. This can be useful when the Overlay is not really hardware accelerated. The strings are not validated, and improperly sized strings could crash the program. \n"}, {"name": "Overlay.get_hardware", "path": "ref/overlay#pygame.Overlay.get_hardware", "type": "pygame.Overlay", "text": "  get_hardware() \n test if the Overlay is hardware accelerated get_hardware(rect) -> int  Returns a True value when the Overlay is hardware accelerated. If the platform does not support acceleration, software rendering is used. \n"}, {"name": "Overlay.set_location", "path": "ref/overlay#pygame.Overlay.set_location", "type": "pygame.Overlay", "text": "  set_location() \n control where the overlay is displayed set_location(rect) -> None  Set the location for the overlay. The overlay will always be shown relative to the main display Surface. This does not actually redraw the overlay, it will be updated on the next call to Overlay.display(). \n"}, {"name": "PixelArray", "path": "ref/pixelarray", "type": "pygame.PixelArray", "text": " pygame.PixelArray\n  \n pygame object for direct pixel access of surfaces PixelArray(Surface) -> PixelArray  The PixelArray wraps a Surface and provides direct access to the surface's pixels. A pixel array can be one or two dimensional. A two dimensional array, like its surface, is indexed [column, row]. Pixel arrays support slicing, both for returning a subarray or for assignment. A pixel array sliced on a single column or row returns a one dimensional pixel array. Arithmetic and other operations are not supported. A pixel array can be safely assigned to itself. Finally, pixel arrays export an array struct interface, allowing them to interact with pygame.pixelcopy methods and NumPy arrays. A PixelArray pixel item can be assigned a raw integer values, a pygame.Color instance, or a (r, g, b[, a]) tuple. pxarray[x, y] = 0xFF00FF\npxarray[x, y] = pygame.Color(255, 0, 255)\npxarray[x, y] = (255, 0, 255) However, only a pixel's integer value is returned. So, to compare a pixel to a particular color the color needs to be first mapped using the Surface.map_rgb() method of the Surface object for which the PixelArray was created. pxarray = pygame.PixelArray(surface)\n# Check, if the first pixel at the topleft corner is blue\nif pxarray[0, 0] == surface.map_rgb((0, 0, 255)):\n    ... When assigning to a range of of pixels, a non tuple sequence of colors or a PixelArray can be used as the value. For a sequence, the length must match the PixelArray width. pxarray[a:b] = 0xFF00FF                   # set all pixels to 0xFF00FF\npxarray[a:b] = (0xFF00FF, 0xAACCEE, ... ) # first pixel = 0xFF00FF,\n                                          # second pixel  = 0xAACCEE, ...\npxarray[a:b] = [(255, 0, 255), (170, 204, 238), ...] # same as above\npxarray[a:b] = [(255, 0, 255), 0xAACCEE, ...]        # same as above\npxarray[a:b] = otherarray[x:y]            # slice sizes must match For PixelArray assignment, if the right hand side array has a row length of 1, then the column is broadcast over the target array's rows. An array of height 1 is broadcast over the target's columns, and is equivalent to assigning a 1D PixelArray. Subscript slices can also be used to assign to a rectangular subview of the target PixelArray. # Create some new PixelArray objects providing a different view\n# of the original array/surface.\nnewarray = pxarray[2:4, 3:5]\notherarray = pxarray[::2, ::2] Subscript slices can also be used to do fast rectangular pixel manipulations instead of iterating over the x or y axis. The pxarray[::2, :] = (0, 0, 0)               # Make even columns black.\npxarray[::2] = (0, 0, 0)                  # Same as [::2, :] During its lifetime, the PixelArray locks the surface, thus you explicitly have to close() it once its not used any more and the surface should perform operations in the same scope. It is best to use it as a context manager using the with PixelArray(surf) as pixel_array: style. So it works on pypy too. A simple : slice index for the column can be omitted. pxarray[::2, ...] = (0, 0, 0)             # Same as pxarray[::2, :]\npxarray[...] = (255, 0, 0)                # Same as pxarray[:] A note about PixelArray to PixelArray assignment, for arrays with an item size of 3 (created from 24 bit surfaces) pixel values are translated from the source to the destinations format. The red, green, and blue color elements of each pixel are shifted to match the format of the target surface. For all other pixel sizes no such remapping occurs. This should change in later pygame releases, where format conversions are performed for all pixel sizes. To avoid code breakage when full mapped copying is implemented it is suggested PixelArray to PixelArray copies be only between surfaces of identical format.   New in pygame 1.9.4: \nclose() method was added. For explicitly cleaning up.  \nbeing able to use PixelArray as a context manager for cleanup.  \nboth of these are useful for when working without reference counting (pypy).      New in pygame 1.9.2: \narray struct interface  \ntranspose method  \nbroadcasting for a length 1 dimension      Changed in pygame 1.9.2: \nA 2D PixelArray can have a length 1 dimension. Only an integer index on a 2D PixelArray returns a 1D array.  \nFor assignment, a tuple can only be a color. Any other sequence type is a sequence of colors.      surface \n Gets the Surface the PixelArray uses. surface -> Surface  The Surface the PixelArray was created for. \n   itemsize \n Returns the byte size of a pixel array item itemsize -> int  This is the same as Surface.get_bytesize() for the pixel array's surface.  New in pygame 1.9.2.  \n   ndim \n Returns the number of dimensions. ndim -> int  A pixel array can be 1 or 2 dimensional.  New in pygame 1.9.2.  \n   shape \n Returns the array size. shape -> tuple of int's  A tuple or length ndim giving the length of each dimension. Analogous to Surface.get_size().  New in pygame 1.9.2.  \n   strides \n Returns byte offsets for each array dimension. strides -> tuple of int's  A tuple or length ndim byte counts. When a stride is multiplied by the corresponding index it gives the offset of that index from the start of the array. A stride is negative for an array that has is inverted (has a negative step).  New in pygame 1.9.2.  \n   make_surface() \n Creates a new Surface from the current PixelArray. make_surface() -> Surface  Creates a new Surface from the current PixelArray. Depending on the current PixelArray the size, pixel order etc. will be different from the original Surface. # Create a new surface flipped around the vertical axis.\nsf = pxarray[:,::-1].make_surface ()  New in pygame 1.8.1.  \n   replace() \n Replaces the passed color in the PixelArray with another one. replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None  Replaces the pixels with the passed color in the PixelArray by changing them them to the passed replacement color. It uses a simple weighted Euclidean distance formula to calculate the distance between the colors. The distance space ranges from 0.0 to 1.0 and is used as threshold for the color detection. This causes the replacement to take pixels with a similar, but not exactly identical color, into account as well. This is an in place operation that directly affects the pixels of the PixelArray.  New in pygame 1.8.1.  \n   extract() \n Extracts the passed color from the PixelArray. extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray  Extracts the passed color by changing all matching pixels to white, while non-matching pixels are changed to black. This returns a new PixelArray with the black/white color mask. It uses a simple weighted Euclidean distance formula to calculate the distance between the colors. The distance space ranges from 0.0 to 1.0 and is used as threshold for the color detection. This causes the extraction to take pixels with a similar, but not exactly identical color, into account as well.  New in pygame 1.8.1.  \n   compare() \n Compares the PixelArray with another one. compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray  Compares the contents of the PixelArray with those from the passed in PixelArray. It returns a new PixelArray with a black/white color mask that indicates the differences (black) of both arrays. Both PixelArray objects must have identical bit depths and dimensions. It uses a simple weighted Euclidean distance formula to calculate the distance between the colors. The distance space ranges from 0.0 to 1.0 and is used as a threshold for the color detection. This causes the comparison to mark pixels with a similar, but not exactly identical color, as white.  New in pygame 1.8.1.  \n   transpose() \n Exchanges the x and y axis. transpose() -> PixelArray  This method returns a new view of the pixel array with the rows and columns swapped. So for a (w, h) sized array a (h, w) slice is returned. If an array is one dimensional, then a length 1 x dimension is added, resulting in a 2D pixel array.  New in pygame 1.9.2.  \n   close() \n Closes the PixelArray, and releases Surface lock. transpose() -> PixelArray  This method is for explicitly closing the PixelArray, and releasing a lock on the Suface.  New in pygame 1.9.4.  \n \n \n"}, {"name": "PixelArray.close", "path": "ref/pixelarray#pygame.PixelArray.close", "type": "pygame.PixelArray", "text": "  close() \n Closes the PixelArray, and releases Surface lock. transpose() -> PixelArray  This method is for explicitly closing the PixelArray, and releasing a lock on the Suface.  New in pygame 1.9.4.  \n"}, {"name": "PixelArray.compare", "path": "ref/pixelarray#pygame.PixelArray.compare", "type": "pygame.PixelArray", "text": "  compare() \n Compares the PixelArray with another one. compare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray  Compares the contents of the PixelArray with those from the passed in PixelArray. It returns a new PixelArray with a black/white color mask that indicates the differences (black) of both arrays. Both PixelArray objects must have identical bit depths and dimensions. It uses a simple weighted Euclidean distance formula to calculate the distance between the colors. The distance space ranges from 0.0 to 1.0 and is used as a threshold for the color detection. This causes the comparison to mark pixels with a similar, but not exactly identical color, as white.  New in pygame 1.8.1.  \n"}, {"name": "PixelArray.extract", "path": "ref/pixelarray#pygame.PixelArray.extract", "type": "pygame.PixelArray", "text": "  extract() \n Extracts the passed color from the PixelArray. extract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray  Extracts the passed color by changing all matching pixels to white, while non-matching pixels are changed to black. This returns a new PixelArray with the black/white color mask. It uses a simple weighted Euclidean distance formula to calculate the distance between the colors. The distance space ranges from 0.0 to 1.0 and is used as threshold for the color detection. This causes the extraction to take pixels with a similar, but not exactly identical color, into account as well.  New in pygame 1.8.1.  \n"}, {"name": "PixelArray.itemsize", "path": "ref/pixelarray#pygame.PixelArray.itemsize", "type": "pygame.PixelArray", "text": "  itemsize \n Returns the byte size of a pixel array item itemsize -> int  This is the same as Surface.get_bytesize() for the pixel array's surface.  New in pygame 1.9.2.  \n"}, {"name": "PixelArray.make_surface", "path": "ref/pixelarray#pygame.PixelArray.make_surface", "type": "pygame.PixelArray", "text": "  make_surface() \n Creates a new Surface from the current PixelArray. make_surface() -> Surface  Creates a new Surface from the current PixelArray. Depending on the current PixelArray the size, pixel order etc. will be different from the original Surface. # Create a new surface flipped around the vertical axis.\nsf = pxarray[:,::-1].make_surface ()  New in pygame 1.8.1.  \n"}, {"name": "PixelArray.ndim", "path": "ref/pixelarray#pygame.PixelArray.ndim", "type": "pygame.PixelArray", "text": "  ndim \n Returns the number of dimensions. ndim -> int  A pixel array can be 1 or 2 dimensional.  New in pygame 1.9.2.  \n"}, {"name": "PixelArray.replace", "path": "ref/pixelarray#pygame.PixelArray.replace", "type": "pygame.PixelArray", "text": "  replace() \n Replaces the passed color in the PixelArray with another one. replace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None  Replaces the pixels with the passed color in the PixelArray by changing them them to the passed replacement color. It uses a simple weighted Euclidean distance formula to calculate the distance between the colors. The distance space ranges from 0.0 to 1.0 and is used as threshold for the color detection. This causes the replacement to take pixels with a similar, but not exactly identical color, into account as well. This is an in place operation that directly affects the pixels of the PixelArray.  New in pygame 1.8.1.  \n"}, {"name": "PixelArray.shape", "path": "ref/pixelarray#pygame.PixelArray.shape", "type": "pygame.PixelArray", "text": "  shape \n Returns the array size. shape -> tuple of int's  A tuple or length ndim giving the length of each dimension. Analogous to Surface.get_size().  New in pygame 1.9.2.  \n"}, {"name": "PixelArray.strides", "path": "ref/pixelarray#pygame.PixelArray.strides", "type": "pygame.PixelArray", "text": "  strides \n Returns byte offsets for each array dimension. strides -> tuple of int's  A tuple or length ndim byte counts. When a stride is multiplied by the corresponding index it gives the offset of that index from the start of the array. A stride is negative for an array that has is inverted (has a negative step).  New in pygame 1.9.2.  \n"}, {"name": "PixelArray.surface", "path": "ref/pixelarray#pygame.PixelArray.surface", "type": "pygame.PixelArray", "text": "  surface \n Gets the Surface the PixelArray uses. surface -> Surface  The Surface the PixelArray was created for. \n"}, {"name": "PixelArray.transpose", "path": "ref/pixelarray#pygame.PixelArray.transpose", "type": "pygame.PixelArray", "text": "  transpose() \n Exchanges the x and y axis. transpose() -> PixelArray  This method returns a new view of the pixel array with the rows and columns swapped. So for a (w, h) sized array a (h, w) slice is returned. If an array is one dimensional, then a length 1 x dimension is added, resulting in a 2D pixel array.  New in pygame 1.9.2.  \n"}, {"name": "pixelcopy", "path": "ref/pixelcopy", "type": "pygame.pixelcopy", "text": " pygame.pixelcopy\n  \n pygame module for general pixel array copying  The pygame.pixelcopy module contains functions for copying between surfaces and objects exporting an array structure interface. It is a backend for pygame.surfarray, adding NumPy support. But pixelcopy is more general, and intended for direct use. The array struct interface exposes an array's data in a standard way. It was introduced in NumPy. In Python 2.7 and above it is replaced by the new buffer protocol, though the buffer protocol is still a work in progress. The array struct interface, on the other hand, is stable and works with earlier Python versions. So for now the array struct interface is the predominate way pygame handles array introspection. New in pygame 1.9.2.   pygame.pixelcopy.surface_to_array() \n copy surface pixels to an array object surface_to_array(array, surface, kind='P', opaque=255, clear=0) -> None  The surface_to_array function copies pixels from a Surface object to a 2D or 3D array. Depending on argument kind and the target array dimension, a copy may be raw pixel value, RGB, a color component slice, or colorkey alpha transparency value. Recognized kind values are the single character codes 'P', 'R', 'G', 'B', 'A', and 'C'. Kind codes are case insensitive, so 'p' is equivalent to 'P'. The first two dimensions of the target must be the surface size (w, h). The default 'P' kind code does a direct raw integer pixel (mapped) value copy to a 2D array and a 'RGB' pixel component (unmapped) copy to a 3D array having shape (w, h, 3). For an 8 bit colormap surface this means the table index is copied to a 2D array, not the table value itself. A 2D array's item size must be at least as large as the surface's pixel byte size. The item size of a 3D array must be at least one byte. For the 'R', 'G', 'B', and 'A' copy kinds a single color component of the unmapped surface pixels are copied to the target 2D array. For kind 'A' and surfaces with source alpha (the surface was created with the SRCALPHA flag), has a colorkey (set with Surface.set_colorkey()), or has a blanket alpha (set with Surface.set_alpha()) then the alpha values are those expected for a SDL surface. If a surface has no explicit alpha value, then the target array is filled with the value of the optional opaque surface_to_array argument (default 255: not transparent). Copy kind 'C' is a special case for alpha copy of a source surface with colorkey. Unlike the 'A' color component copy, the clear argument value is used for colorkey matches, opaque otherwise. By default, a match has alpha 0 (totally transparent), while everything else is alpha 255 (totally opaque). It is a more general implementation of pygame.surfarray.array_colorkey(). Specific to surface_to_array, a ValueError is raised for target arrays with incorrect shape or item size. A TypeError is raised for an incorrect kind code. Surface specific problems, such as locking, raise a pygame.error. \n   pygame.pixelcopy.array_to_surface() \n copy an array object to a surface array_to_surface(<surface>, <array>) -> None  See pygame.surfarray.blit_array(). \n   pygame.pixelcopy.map_array() \n copy an array to another array, using surface format map_array(<array>, <array>, <surface>) -> None  Map an array of color element values - (w, h, ..., 3) - to an array of pixels - (w, h) according to the format of <surface>. \n   pygame.pixelcopy.make_surface() \n Copy an array to a new surface pygame.pixelcopy.make_surface(array) -> Surface  Create a new Surface that best resembles the data and format of the array. The array can be 2D or 3D with any sized integer values. \n \n \n"}, {"name": "pixelcopy.array_to_surface", "path": "ref/pixelcopy#pygame.pixelcopy.array_to_surface", "type": "pygame.pixelcopy", "text": "  pygame.pixelcopy.array_to_surface() \n copy an array object to a surface array_to_surface(<surface>, <array>) -> None  See pygame.surfarray.blit_array(). \n"}, {"name": "pixelcopy.make_surface", "path": "ref/pixelcopy#pygame.pixelcopy.make_surface", "type": "pygame.pixelcopy", "text": "  pygame.pixelcopy.make_surface() \n Copy an array to a new surface pygame.pixelcopy.make_surface(array) -> Surface  Create a new Surface that best resembles the data and format of the array. The array can be 2D or 3D with any sized integer values. \n"}, {"name": "pixelcopy.map_array", "path": "ref/pixelcopy#pygame.pixelcopy.map_array", "type": "pygame.pixelcopy", "text": "  pygame.pixelcopy.map_array() \n copy an array to another array, using surface format map_array(<array>, <array>, <surface>) -> None  Map an array of color element values - (w, h, ..., 3) - to an array of pixels - (w, h) according to the format of <surface>. \n"}, {"name": "pixelcopy.surface_to_array", "path": "ref/pixelcopy#pygame.pixelcopy.surface_to_array", "type": "pygame.pixelcopy", "text": "  pygame.pixelcopy.surface_to_array() \n copy surface pixels to an array object surface_to_array(array, surface, kind='P', opaque=255, clear=0) -> None  The surface_to_array function copies pixels from a Surface object to a 2D or 3D array. Depending on argument kind and the target array dimension, a copy may be raw pixel value, RGB, a color component slice, or colorkey alpha transparency value. Recognized kind values are the single character codes 'P', 'R', 'G', 'B', 'A', and 'C'. Kind codes are case insensitive, so 'p' is equivalent to 'P'. The first two dimensions of the target must be the surface size (w, h). The default 'P' kind code does a direct raw integer pixel (mapped) value copy to a 2D array and a 'RGB' pixel component (unmapped) copy to a 3D array having shape (w, h, 3). For an 8 bit colormap surface this means the table index is copied to a 2D array, not the table value itself. A 2D array's item size must be at least as large as the surface's pixel byte size. The item size of a 3D array must be at least one byte. For the 'R', 'G', 'B', and 'A' copy kinds a single color component of the unmapped surface pixels are copied to the target 2D array. For kind 'A' and surfaces with source alpha (the surface was created with the SRCALPHA flag), has a colorkey (set with Surface.set_colorkey()), or has a blanket alpha (set with Surface.set_alpha()) then the alpha values are those expected for a SDL surface. If a surface has no explicit alpha value, then the target array is filled with the value of the optional opaque surface_to_array argument (default 255: not transparent). Copy kind 'C' is a special case for alpha copy of a source surface with colorkey. Unlike the 'A' color component copy, the clear argument value is used for colorkey matches, opaque otherwise. By default, a match has alpha 0 (totally transparent), while everything else is alpha 255 (totally opaque). It is a more general implementation of pygame.surfarray.array_colorkey(). Specific to surface_to_array, a ValueError is raised for target arrays with incorrect shape or item size. A TypeError is raised for an incorrect kind code. Surface specific problems, such as locking, raise a pygame.error. \n"}, {"name": "pygame", "path": "ref/pygame", "type": "pygame", "text": " pygame\n  \n the top level pygame package  The pygame package represents the top-level package for others to use. Pygame itself is broken into many submodules, but this does not affect programs that use pygame. As a convenience, most of the top-level variables in pygame have been placed inside a module named pygame.locals. This is meant to be used with from pygame.locals import *, in addition to import pygame. When you import pygame all available pygame submodules are automatically imported. Be aware that some of the pygame modules are considered optional, and may not be available. In that case, pygame will provide a placeholder object instead of the module, which can be used to test for availability.   pygame.init() \n initialize all imported pygame modules init() -> (numpass, numfail)  Initialize all imported pygame modules. No exceptions will be raised if a module fails, but the total number if successful and failed inits will be returned as a tuple. You can always initialize individual modules manually, but pygame.init() is a convenient way to get everything started. The init() functions for individual modules will raise exceptions when they fail. You may want to initialize the different modules separately to speed up your program or to not use modules your game does not require. It is safe to call this init() more than once as repeated calls will have no effect. This is true even if you have pygame.quit() all the modules. \n   pygame.quit() \n uninitialize all pygame modules quit() -> None  Uninitialize all pygame modules that have previously been initialized. When the Python interpreter shuts down, this method is called regardless, so your program should not need it, except when it wants to terminate its pygame resources and continue. It is safe to call this function more than once as repeated calls have no effect.  Note Calling pygame.quit() will not exit your program. Consider letting your program end in the same way a normal Python program will end.  \n   pygame.get_init() \n returns True if pygame is currently initialized get_init() -> bool  Returns True if pygame is currently initialized.  New in pygame 1.9.5.  \n   exception pygame.error \n standard pygame exception raise pygame.error(message)  This exception is raised whenever a pygame or SDL operation fails. You can catch any anticipated problems and deal with the error. The exception is always raised with a descriptive message about the problem. Derived from the RuntimeError exception, which can also be used to catch these raised errors. \n   pygame.get_error() \n get the current error message get_error() -> errorstr  SDL maintains an internal error message. This message will usually be given to you when pygame.error() is raised, so this function will rarely be needed. \n   pygame.set_error() \n set the current error message set_error(error_msg) -> None  SDL maintains an internal error message. This message will usually be given to you when pygame.error() is raised, so this function will rarely be needed. \n   pygame.get_sdl_version() \n get the version number of SDL get_sdl_version() -> major, minor, patch  Returns the three version numbers of the SDL library. This version is built at compile time. It can be used to detect which features may or may not be available through pygame.  New in pygame 1.7.0.  \n   pygame.get_sdl_byteorder() \n get the byte order of SDL get_sdl_byteorder() -> int  Returns the byte order of the SDL library. It returns 1234 for little endian byte order and 4321 for big endian byte order.  New in pygame 1.8.  \n   pygame.register_quit() \n register a function to be called when pygame quits register_quit(callable) -> None  When pygame.quit() is called, all registered quit functions are called. Pygame modules do this automatically when they are initializing, so this function will rarely be needed. \n   pygame.encode_string() \n Encode a Unicode or bytes object encode_string([obj [, encoding [, errors [, etype]]]]) -> bytes or None  obj: If Unicode, encode; if bytes, return unaltered; if anything else, return None; if not given, raise SyntaxError. encoding (string): If present, encoding to use. The default is 'unicode_escape'. errors (string): If given, how to handle unencodable characters. The default is 'backslashreplace'. etype (exception type): If given, the exception type to raise for an encoding error. The default is UnicodeEncodeError, as returned by PyUnicode_AsEncodedString(). For the default encoding and errors values there should be no encoding errors. This function is used in encoding file paths. Keyword arguments are supported.  New in pygame 1.9.2: (primarily for use in unit tests)  \n   pygame.encode_file_path() \n Encode a Unicode or bytes object as a file system path encode_file_path([obj [, etype]]) -> bytes or None  obj: If Unicode, encode; if bytes, return unaltered; if anything else, return None; if not given, raise SyntaxError. etype (exception type): If given, the exception type to raise for an encoding error. The default is UnicodeEncodeError, as returned by PyUnicode_AsEncodedString(). This function is used to encode file paths in pygame. Encoding is to the codec as returned by sys.getfilesystemencoding(). Keyword arguments are supported.  New in pygame 1.9.2: (primarily for use in unit tests)  \n \n   pygame.version\n  \n small module containing version information  This module is automatically imported into the pygame package and can be used to check which version of pygame has been imported.   pygame.version.ver \n version number as a string ver = '1.2'  This is the version represented as a string. It can contain a micro release number as well, e.g. '1.5.2' \n   pygame.version.vernum \n tupled integers of the version vernum = (1, 5, 3)  This version information can easily be compared with other version numbers of the same format. An example of checking pygame version numbers would look like this: if pygame.version.vernum < (1, 5):\n    print('Warning, older version of pygame (%s)' %  pygame.version.ver)\n    disable_advanced_features = True  New in pygame 1.9.6: Attributes major, minor, and patch.  vernum.major == vernum[0]\nvernum.minor == vernum[1]\nvernum.patch == vernum[2]  Changed in pygame 1.9.6: str(pygame.version.vernum) returns a string like \"2.0.0\" instead of \"(2, 0, 0)\".   Changed in pygame 1.9.6: repr(pygame.version.vernum) returns a string like \"PygameVersion(major=2, minor=0, patch=0)\" instead of \"(2, 0, 0)\".  \n   pygame.version.rev \n repository revision of the build rev = 'a6f89747b551+'  The Mercurial node identifier of the repository checkout from which this package was built. If the identifier ends with a plus sign '+' then the package contains uncommitted changes. Please include this revision number in bug reports, especially for non-release pygame builds. Important note: pygame development has moved to github, this variable is obsolete now. As soon as development shifted to github, this variable started returning an empty string \"\". It has always been returning an empty string since v1.9.5.  Changed in pygame 1.9.5: Always returns an empty string \"\".  \n   pygame.version.SDL \n tupled integers of the SDL library version SDL = '(2, 0, 12)'  This is the SDL library version represented as an extended tuple. It also has attributes 'major', 'minor' & 'patch' that can be accessed like this: >>> pygame.version.SDL.major\n2 printing the whole thing returns a string like this: >>> pygame.version.SDL\nSDLVersion(major=2, minor=0, patch=12)  New in pygame 2.0.0.  \n Setting Environment Variables Some aspects of pygame's behaviour can be controlled by setting environment variables, they cover a wide range of the library's functionality. Some of the variables are from pygame itself, while others come from the underlying C SDL library that pygame uses. In python, environment variables are usually set in code like this: import os\nos.environ['NAME_OF_ENVIRONMENT_VARIABLE'] = 'value_to_set' Or to preserve users ability to override the variable: import os\nos.environ['ENV_VAR'] = os.environ.get('ENV_VAR', 'value') If the variable is more useful for users of an app to set than the developer then they can set it like this: Windows: set NAME_OF_ENVIRONMENT_VARIABLE=value_to_set\npython my_application.py Linux/Mac: ENV_VAR=value python my_application.py For some variables they need to be set before initialising pygame, some must be set before even importing pygame, and others can simply be set right before the area of code they control is run. Below is a list of environment variables, their settable values, and a brief description of what they do.    Pygame Environment Variables These variables are defined by pygame itself.    PYGAME_DISPLAY - Experimental (subject to change)\nSet index of the display to use, \"0\" is the default. This sets the display where pygame will open its window or screen. The value set here will be used if set before calling pygame.display.set_mode(), and as long as no 'display' parameter is passed into pygame.display.set_mode().    PYGAME_FORCE_SCALE -\nSet to \"photo\" or \"default\". This forces set_mode() to use the SCALED display mode and, if \"photo\" is set, makes the scaling use the slowest, but highest quality anisotropic scaling algorithm, if it is available. Must be set before calling pygame.display.set_mode().    PYGAME_BLEND_ALPHA_SDL2 - New in pygame 2.0.0\nSet to \"1\" to enable the SDL2 blitter. This makes pygame use the SDL2 blitter for all alpha blending. The SDL2 blitter is sometimes faster than the default blitter but uses a different formula so the final colours may differ. Must be set before pygame.init() is called.    PYGAME_HIDE_SUPPORT_PROMPT -\nSet to \"1\" to hide the prompt. This stops the welcome message popping up in the console that tells you which version of python, pygame & SDL you are using. Must be set before importing pygame.    PYGAME_FREETYPE -\nSet to \"1\" to enable. This switches the pygame.font module to a pure freetype implementation that bypasses SDL_ttf. See the font module for why you might want to do this. Must be set before importing pygame.    PYGAME_CAMERA -\nSet to \"opencv\" or \"vidcapture\" Forces the library backend used in the camera module, overriding the platform defaults. Must be set before calling pygame.camera.init().     SDL Environment Variables These variables are defined by SDL. For documentation on the environment variables available in pygame 1 try here. For Pygame 2, some selected environment variables are listed below.    SDL_VIDEO_CENTERED -\nSet to \"1\" to enable centering the window. This will make the pygame window open in the centre of the display. Must be set before calling pygame.display.set_mode().    SDL_VIDEO_WINDOW_POS -\nSet to \"x,y\" to position the top left corner of the window. This allows control over the placement of the pygame window within the display. Must be set before calling pygame.display.set_mode().    SDL_VIDEODRIVER -\nSet to \"drivername\" to change the video driver used. On some platforms there are multiple video drivers available and this allows users to pick between them. More information is available here. Must be set before calling pygame.init() or pygame.display.init().    SDL_AUDIODRIVER -\nSet to \"drivername\" to change the audio driver used. On some platforms there are multiple audio drivers available and this allows users to pick between them. More information is available here. Must be set before calling pygame.init() or pygame.mixer.init().    SDL_VIDEO_ALLOW_SCREENSAVER\nSet to \"1\" to allow screensavers while pygame apps are running. By default pygame apps disable screensavers while they are running. Setting this environment variable allows users or developers to change that and make screensavers run again.    SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\nSet to \"0\" to re-enable the compositor. By default SDL tries to disable the X11 compositor for all pygame apps. This is usually a good thing as it's faster, however if you have an app which doesn't update every frame and are using linux you may want to disable this bypass. The bypass has reported problems on KDE linux. This variable is only used on x11/linux platforms. \n \n"}, {"name": "quit", "path": "ref/pygame#pygame.quit", "type": "pygame", "text": "  pygame.quit() \n uninitialize all pygame modules quit() -> None  Uninitialize all pygame modules that have previously been initialized. When the Python interpreter shuts down, this method is called regardless, so your program should not need it, except when it wants to terminate its pygame resources and continue. It is safe to call this function more than once as repeated calls have no effect.  Note Calling pygame.quit() will not exit your program. Consider letting your program end in the same way a normal Python program will end.  \n"}, {"name": "Rect", "path": "ref/rect", "type": "pygame.Rect", "text": " pygame.Rect\n  \n pygame object for storing rectangular coordinates Rect(left, top, width, height) -> Rect Rect((left, top), (width, height)) -> Rect Rect(object) -> Rect  Pygame uses Rect objects to store and manipulate rectangular areas. A Rect can be created from a combination of left, top, width, and height values. Rects can also be created from python objects that are already a Rect or have an attribute named \"rect\". Any pygame function that requires a Rect argument also accepts any of these values to construct a Rect. This makes it easier to create Rects on the fly as arguments to functions. The Rect functions that change the position or size of a Rect return a new copy of the Rect with the affected changes. The original Rect is not modified. Some methods have an alternate \"in-place\" version that returns None but affects the original Rect. These \"in-place\" methods are denoted with the \"ip\" suffix. The Rect object has several virtual attributes which can be used to move and align the Rect: x,y\ntop, left, bottom, right\ntopleft, bottomleft, topright, bottomright\nmidtop, midleft, midbottom, midright\ncenter, centerx, centery\nsize, width, height\nw,h All of these attributes can be assigned to: rect1.right = 10\nrect2.center = (20,30) Assigning to size, width or height changes the dimensions of the rectangle; all other assignments move the rectangle without resizing it. Notice that some attributes are integers and others are pairs of integers. If a Rect has a nonzero width or height, it will return True for a nonzero test. Some methods return a Rect with 0 size to represent an invalid rectangle. A Rect with a 0 size will not collide when using collision detection methods (e.g. collidepoint(), colliderect(), etc.). The coordinates for Rect objects are all integers. The size values can be programmed to have negative values, but these are considered illegal Rects for most operations. There are several collision tests between other rectangles. Most python containers can be searched for collisions against a single Rect. The area covered by a Rect does not include the right- and bottom-most edge of pixels. If one Rect's bottom border is another Rect's top border (i.e., rect1.bottom=rect2.top), the two meet exactly on the screen but do not overlap, and rect1.colliderect(rect2) returns false.  New in pygame 1.9.2: The Rect class can be subclassed. Methods such as copy() and move() will recognize this and return instances of the subclass. However, the subclass's __init__() method is not called, and __new__() is assumed to take no arguments. So these methods should be overridden if any extra attributes need to be copied.    copy() \n copy the rectangle copy() -> Rect  Returns a new rectangle having the same position and size as the original. New in pygame 1.9 \n   move() \n moves the rectangle move(x, y) -> Rect  Returns a new rectangle that is moved by the given offset. The x and y arguments can be any integer value, positive or negative. \n   move_ip() \n moves the rectangle, in place move_ip(x, y) -> None  Same as the Rect.move() method, but operates in place. \n   inflate() \n grow or shrink the rectangle size inflate(x, y) -> Rect  Returns a new rectangle with the size changed by the given offset. The rectangle remains centered around its current center. Negative values will shrink the rectangle. Note, uses integers, if the offset given is too small(< 2 > -2), center will be off. \n   inflate_ip() \n grow or shrink the rectangle size, in place inflate_ip(x, y) -> None  Same as the Rect.inflate() method, but operates in place. \n   update() \n sets the position and size of the rectangle update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None  Sets the position and size of the rectangle, in place. See parameters for pygame.Rect() for the parameters of this function.  New in pygame 2.0.1.  \n   clamp() \n moves the rectangle inside another clamp(Rect) -> Rect  Returns a new rectangle that is moved to be completely inside the argument Rect. If the rectangle is too large to fit inside, it is centered inside the argument Rect, but its size is not changed. \n   clamp_ip() \n moves the rectangle inside another, in place clamp_ip(Rect) -> None  Same as the Rect.clamp() method, but operates in place. \n   clip() \n crops a rectangle inside another clip(Rect) -> Rect  Returns a new rectangle that is cropped to be completely inside the argument Rect. If the two rectangles do not overlap to begin with, a Rect with 0 size is returned. \n   clipline() \n crops a line inside a rectangle clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> ()  Returns the coordinates of a line that is cropped to be completely inside the rectangle. If the line does not overlap the rectangle, then an empty tuple is returned. The line to crop can be any of the following formats (floats can be used in place of ints, but they will be truncated):  \n four ints 2 lists/tuples/Vector2s of 2 ints a list/tuple of four ints a list/tuple of 2 lists/tuples/Vector2s of 2 ints  \n     \nReturns:\na tuple with the coordinates of the given line cropped to be completely inside the rectangle is returned, if the given line does not overlap the rectangle, an empty tuple is returned  \nReturn type:\ntuple(tuple(int, int), tuple(int, int)) or ()  \nRaises:\n\nTypeError -- if the line coordinates are not given as one of the above described line formats     Note This method can be used for collision detection between a rect and a line. See example code below.   Note The rect.bottom and rect.right attributes of a pygame.Rect always lie one pixel outside of its actual border.  # Example using clipline().\nclipped_line = rect.clipline(line)\n\nif clipped_line:\n    # If clipped_line is not an empty tuple then the line\n    # collides/overlaps with the rect. The returned value contains\n    # the endpoints of the clipped line.\n    start, end = clipped_line\n    x1, y1 = start\n    x2, y2 = end\nelse:\n    print(\"No clipping. The line is fully outside the rect.\")  New in pygame 2.0.0.  \n   union() \n joins two rectangles into one union(Rect) -> Rect  Returns a new rectangle that completely covers the area of the two provided rectangles. There may be area inside the new Rect that is not covered by the originals. \n   union_ip() \n joins two rectangles into one, in place union_ip(Rect) -> None  Same as the Rect.union() method, but operates in place. \n   unionall() \n the union of many rectangles unionall(Rect_sequence) -> Rect  Returns the union of one rectangle with a sequence of many rectangles. \n   unionall_ip() \n the union of many rectangles, in place unionall_ip(Rect_sequence) -> None  The same as the Rect.unionall() method, but operates in place. \n   fit() \n resize and move a rectangle with aspect ratio fit(Rect) -> Rect  Returns a new rectangle that is moved and resized to fit another. The aspect ratio of the original Rect is preserved, so the new rectangle may be smaller than the target in either width or height. \n   normalize() \n correct negative sizes normalize() -> None  This will flip the width or height of a rectangle if it has a negative size. The rectangle will remain in the same place, with only the sides swapped. \n   contains() \n test if one rectangle is inside another contains(Rect) -> bool  Returns true when the argument is completely inside the Rect. \n   collidepoint() \n test if a point is inside a rectangle collidepoint(x, y) -> bool collidepoint((x,y)) -> bool  Returns true if the given point is inside the rectangle. A point along the right or bottom edge is not considered to be inside the rectangle.  Note For collision detection between a rect and a line the clipline() method can be used.  \n   colliderect() \n test if two rectangles overlap colliderect(Rect) -> bool  Returns true if any portion of either rectangle overlap (except the top+bottom or left+right edges).  Note For collision detection between a rect and a line the clipline() method can be used.  \n   collidelist() \n test if one rectangle in a list intersects collidelist(list) -> index  Test whether the rectangle collides with any in a sequence of rectangles. The index of the first collision found is returned. If no collisions are found an index of -1 is returned. \n   collidelistall() \n test if all rectangles in a list intersect collidelistall(list) -> indices  Returns a list of all the indices that contain rectangles that collide with the Rect. If no intersecting rectangles are found, an empty list is returned. \n   collidedict() \n test if one rectangle in a dictionary intersects collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None  Returns the first key and value pair that intersects with the calling Rect object. If no collisions are found, None is returned. If use_values is 0 (default) then the dict's keys will be used in the collision detection, otherwise the dict's values will be used.  Note Rect objects cannot be used as keys in a dictionary (they are not hashable), so they must be converted to a tuple/list. e.g. rect.collidedict({tuple(key_rect) : value})  \n   collidedictall() \n test if all rectangles in a dictionary intersect collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...]  Returns a list of all the key and value pairs that intersect with the calling Rect object. If no collisions are found an empty list is returned. If use_values is 0 (default) then the dict's keys will be used in the collision detection, otherwise the dict's values will be used.  Note Rect objects cannot be used as keys in a dictionary (they are not hashable), so they must be converted to a tuple/list. e.g. rect.collidedictall({tuple(key_rect) : value})  \n \n \n"}, {"name": "Rect.clamp", "path": "ref/rect#pygame.Rect.clamp", "type": "pygame.Rect", "text": "  clamp() \n moves the rectangle inside another clamp(Rect) -> Rect  Returns a new rectangle that is moved to be completely inside the argument Rect. If the rectangle is too large to fit inside, it is centered inside the argument Rect, but its size is not changed. \n"}, {"name": "Rect.clamp_ip", "path": "ref/rect#pygame.Rect.clamp_ip", "type": "pygame.Rect", "text": "  clamp_ip() \n moves the rectangle inside another, in place clamp_ip(Rect) -> None  Same as the Rect.clamp() method, but operates in place. \n"}, {"name": "Rect.clip", "path": "ref/rect#pygame.Rect.clip", "type": "pygame.Rect", "text": "  clip() \n crops a rectangle inside another clip(Rect) -> Rect  Returns a new rectangle that is cropped to be completely inside the argument Rect. If the two rectangles do not overlap to begin with, a Rect with 0 size is returned. \n"}, {"name": "Rect.clipline", "path": "ref/rect#pygame.Rect.clipline", "type": "pygame.Rect", "text": "  clipline() \n crops a line inside a rectangle clipline(x1, y1, x2, y2) -> ((cx1, cy1), (cx2, cy2)) clipline(x1, y1, x2, y2) -> () clipline((x1, y1), (x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1), (x2, y2)) -> () clipline((x1, y1, x2, y2)) -> ((cx1, cy1), (cx2, cy2)) clipline((x1, y1, x2, y2)) -> () clipline(((x1, y1), (x2, y2))) -> ((cx1, cy1), (cx2, cy2)) clipline(((x1, y1), (x2, y2))) -> ()  Returns the coordinates of a line that is cropped to be completely inside the rectangle. If the line does not overlap the rectangle, then an empty tuple is returned. The line to crop can be any of the following formats (floats can be used in place of ints, but they will be truncated):  \n four ints 2 lists/tuples/Vector2s of 2 ints a list/tuple of four ints a list/tuple of 2 lists/tuples/Vector2s of 2 ints  \n     \nReturns:\na tuple with the coordinates of the given line cropped to be completely inside the rectangle is returned, if the given line does not overlap the rectangle, an empty tuple is returned  \nReturn type:\ntuple(tuple(int, int), tuple(int, int)) or ()  \nRaises:\n\nTypeError -- if the line coordinates are not given as one of the above described line formats     Note This method can be used for collision detection between a rect and a line. See example code below.   Note The rect.bottom and rect.right attributes of a pygame.Rect always lie one pixel outside of its actual border.  # Example using clipline().\nclipped_line = rect.clipline(line)\n\nif clipped_line:\n    # If clipped_line is not an empty tuple then the line\n    # collides/overlaps with the rect. The returned value contains\n    # the endpoints of the clipped line.\n    start, end = clipped_line\n    x1, y1 = start\n    x2, y2 = end\nelse:\n    print(\"No clipping. The line is fully outside the rect.\")  New in pygame 2.0.0.  \n"}, {"name": "Rect.collidedict", "path": "ref/rect#pygame.Rect.collidedict", "type": "pygame.Rect", "text": "  collidedict() \n test if one rectangle in a dictionary intersects collidedict(dict) -> (key, value) collidedict(dict) -> None collidedict(dict, use_values=0) -> (key, value) collidedict(dict, use_values=0) -> None  Returns the first key and value pair that intersects with the calling Rect object. If no collisions are found, None is returned. If use_values is 0 (default) then the dict's keys will be used in the collision detection, otherwise the dict's values will be used.  Note Rect objects cannot be used as keys in a dictionary (they are not hashable), so they must be converted to a tuple/list. e.g. rect.collidedict({tuple(key_rect) : value})  \n"}, {"name": "Rect.collidedictall", "path": "ref/rect#pygame.Rect.collidedictall", "type": "pygame.Rect", "text": "  collidedictall() \n test if all rectangles in a dictionary intersect collidedictall(dict) -> [(key, value), ...] collidedictall(dict, use_values=0) -> [(key, value), ...]  Returns a list of all the key and value pairs that intersect with the calling Rect object. If no collisions are found an empty list is returned. If use_values is 0 (default) then the dict's keys will be used in the collision detection, otherwise the dict's values will be used.  Note Rect objects cannot be used as keys in a dictionary (they are not hashable), so they must be converted to a tuple/list. e.g. rect.collidedictall({tuple(key_rect) : value})  \n"}, {"name": "Rect.collidelist", "path": "ref/rect#pygame.Rect.collidelist", "type": "pygame.Rect", "text": "  collidelist() \n test if one rectangle in a list intersects collidelist(list) -> index  Test whether the rectangle collides with any in a sequence of rectangles. The index of the first collision found is returned. If no collisions are found an index of -1 is returned. \n"}, {"name": "Rect.collidelistall", "path": "ref/rect#pygame.Rect.collidelistall", "type": "pygame.Rect", "text": "  collidelistall() \n test if all rectangles in a list intersect collidelistall(list) -> indices  Returns a list of all the indices that contain rectangles that collide with the Rect. If no intersecting rectangles are found, an empty list is returned. \n"}, {"name": "Rect.collidepoint", "path": "ref/rect#pygame.Rect.collidepoint", "type": "pygame.Rect", "text": "  collidepoint() \n test if a point is inside a rectangle collidepoint(x, y) -> bool collidepoint((x,y)) -> bool  Returns true if the given point is inside the rectangle. A point along the right or bottom edge is not considered to be inside the rectangle.  Note For collision detection between a rect and a line the clipline() method can be used.  \n"}, {"name": "Rect.colliderect", "path": "ref/rect#pygame.Rect.colliderect", "type": "pygame.Rect", "text": "  colliderect() \n test if two rectangles overlap colliderect(Rect) -> bool  Returns true if any portion of either rectangle overlap (except the top+bottom or left+right edges).  Note For collision detection between a rect and a line the clipline() method can be used.  \n"}, {"name": "Rect.contains", "path": "ref/rect#pygame.Rect.contains", "type": "pygame.Rect", "text": "  contains() \n test if one rectangle is inside another contains(Rect) -> bool  Returns true when the argument is completely inside the Rect. \n"}, {"name": "Rect.copy", "path": "ref/rect#pygame.Rect.copy", "type": "pygame.Rect", "text": "  copy() \n copy the rectangle copy() -> Rect  Returns a new rectangle having the same position and size as the original. New in pygame 1.9 \n"}, {"name": "Rect.fit", "path": "ref/rect#pygame.Rect.fit", "type": "pygame.Rect", "text": "  fit() \n resize and move a rectangle with aspect ratio fit(Rect) -> Rect  Returns a new rectangle that is moved and resized to fit another. The aspect ratio of the original Rect is preserved, so the new rectangle may be smaller than the target in either width or height. \n"}, {"name": "Rect.inflate", "path": "ref/rect#pygame.Rect.inflate", "type": "pygame.Rect", "text": "  inflate() \n grow or shrink the rectangle size inflate(x, y) -> Rect  Returns a new rectangle with the size changed by the given offset. The rectangle remains centered around its current center. Negative values will shrink the rectangle. Note, uses integers, if the offset given is too small(< 2 > -2), center will be off. \n"}, {"name": "Rect.inflate_ip", "path": "ref/rect#pygame.Rect.inflate_ip", "type": "pygame.Rect", "text": "  inflate_ip() \n grow or shrink the rectangle size, in place inflate_ip(x, y) -> None  Same as the Rect.inflate() method, but operates in place. \n"}, {"name": "Rect.move", "path": "ref/rect#pygame.Rect.move", "type": "pygame.Rect", "text": "  move() \n moves the rectangle move(x, y) -> Rect  Returns a new rectangle that is moved by the given offset. The x and y arguments can be any integer value, positive or negative. \n"}, {"name": "Rect.move_ip", "path": "ref/rect#pygame.Rect.move_ip", "type": "pygame.Rect", "text": "  move_ip() \n moves the rectangle, in place move_ip(x, y) -> None  Same as the Rect.move() method, but operates in place. \n"}, {"name": "Rect.normalize", "path": "ref/rect#pygame.Rect.normalize", "type": "pygame.Rect", "text": "  normalize() \n correct negative sizes normalize() -> None  This will flip the width or height of a rectangle if it has a negative size. The rectangle will remain in the same place, with only the sides swapped. \n"}, {"name": "Rect.union", "path": "ref/rect#pygame.Rect.union", "type": "pygame.Rect", "text": "  union() \n joins two rectangles into one union(Rect) -> Rect  Returns a new rectangle that completely covers the area of the two provided rectangles. There may be area inside the new Rect that is not covered by the originals. \n"}, {"name": "Rect.union_ip", "path": "ref/rect#pygame.Rect.union_ip", "type": "pygame.Rect", "text": "  union_ip() \n joins two rectangles into one, in place union_ip(Rect) -> None  Same as the Rect.union() method, but operates in place. \n"}, {"name": "Rect.unionall", "path": "ref/rect#pygame.Rect.unionall", "type": "pygame.Rect", "text": "  unionall() \n the union of many rectangles unionall(Rect_sequence) -> Rect  Returns the union of one rectangle with a sequence of many rectangles. \n"}, {"name": "Rect.unionall_ip", "path": "ref/rect#pygame.Rect.unionall_ip", "type": "pygame.Rect", "text": "  unionall_ip() \n the union of many rectangles, in place unionall_ip(Rect_sequence) -> None  The same as the Rect.unionall() method, but operates in place. \n"}, {"name": "Rect.update", "path": "ref/rect#pygame.Rect.update", "type": "pygame.Rect", "text": "  update() \n sets the position and size of the rectangle update(left, top, width, height) -> None update((left, top), (width, height)) -> None update(object) -> None  Sets the position and size of the rectangle, in place. See parameters for pygame.Rect() for the parameters of this function.  New in pygame 2.0.1.  \n"}, {"name": "register_quit", "path": "ref/pygame#pygame.register_quit", "type": "pygame", "text": "  pygame.register_quit() \n register a function to be called when pygame quits register_quit(callable) -> None  When pygame.quit() is called, all registered quit functions are called. Pygame modules do this automatically when they are initializing, so this function will rarely be needed. \n"}, {"name": "scrap", "path": "ref/scrap", "type": "pygame.scrap", "text": " pygame.scrap\n  \n pygame module for clipboard support.  EXPERIMENTAL!: This API may change or disappear in later pygame releases. If you use this, your code may break with the next pygame release. The scrap module is for transferring data to/from the clipboard. This allows for cutting and pasting data between pygame and other applications. Some basic data (MIME) types are defined and registered: pygame         string\nconstant        value        description\n--------------------------------------------------\nSCRAP_TEXT   \"text/plain\"    plain text\nSCRAP_BMP    \"image/bmp\"     BMP encoded image data\nSCRAP_PBM    \"image/pbm\"     PBM encoded image data\nSCRAP_PPM    \"image/ppm\"     PPM encoded image data pygame.SCRAP_PPM, pygame.SCRAP_PBM and pygame.SCRAP_BMP are suitable for surface buffers to be shared with other applications. pygame.SCRAP_TEXT is an alias for the plain text clipboard type. Depending on the platform, additional types are automatically registered when data is placed into the clipboard to guarantee a consistent sharing behaviour with other applications. The following listed types can be used as strings to be passed to the respective pygame.scrap module functions. For Windows platforms, these additional types are supported automatically and resolve to their internal definitions: \"text/plain;charset=utf-8\"   UTF-8 encoded text\n\"audio/wav\"                  WAV encoded audio\n\"image/tiff\"                 TIFF encoded image data For X11 platforms, these additional types are supported automatically and resolve to their internal definitions: \"text/plain;charset=utf-8\"   UTF-8 encoded text\n\"UTF8_STRING\"                UTF-8 encoded text\n\"COMPOUND_TEXT\"              COMPOUND text User defined types can be used, but the data might not be accessible by other applications unless they know what data type to look for. Example: Data placed into the clipboard by pygame.scrap.put(\"my_data_type\", byte_data) can only be accessed by applications which query the clipboard for the \"my_data_type\" data type. For an example of how the scrap module works refer to the examples page (pygame.examples.scrap_clipboard.main()) or the code directly in GitHub (pygame/examples/scrap_clipboard.py).  New in pygame 1.8.   Note The scrap module is currently only supported for Windows, X11 and Mac OS X. On Mac OS X only text works at the moment - other types may be supported in future releases.    pygame.scrap.init() \n Initializes the scrap module. init() -> None  Initialize the scrap module.     \nRaises:\n\npygame.error -- if unable to initialize scrap module        Note The scrap module requires pygame.display.set_mode() be called before being initialized.  \n   pygame.scrap.get_init() \n Returns True if the scrap module is currently initialized. get_init() -> bool  Gets the scrap module's initialization state.     \nReturns:\n\nTrue if the pygame.scrap module is currently initialized, False otherwise  \nReturn type:\nbool     New in pygame 1.9.5.  \n   pygame.scrap.get() \n Gets the data for the specified type from the clipboard. get(type) -> bytes or str or None  Retrieves the data for the specified type from the clipboard. In python 3 the data is returned as a byte string and might need further processing (such as decoding to Unicode).     \nParameters:\n\ntype (string) -- data type to retrieve from the clipboard  \nReturns:\ndata (byte string in python 3 or str in python 2) for the given type identifier or None if no data for the given type is available  \nReturn type:\nbytes or str or None    text = pygame.scrap.get(pygame.SCRAP_TEXT)\nif text:\n    print(\"There is text in the clipboard.\")\nelse:\n    print(\"There does not seem to be text in the clipboard.\") \n   pygame.scrap.get_types() \n Gets a list of the available clipboard types. get_types() -> list  Gets a list of data type string identifiers for the data currently available on the clipboard. Each identifier can be used in the pygame.scrap.get() method to get the clipboard content of the specific type.     \nReturns:\nlist of strings of the available clipboard data types, if there is no data in the clipboard an empty list is returned  \nReturn type:\nlist    for t in pygame.scrap.get_types():\n    if \"text\" in t:\n        # There is some content with the word \"text\" in its type string.\n        print(pygame.scrap.get(t)) \n   pygame.scrap.put() \n Places data into the clipboard. put(type, data) -> None  Places data for a given clipboard type into the clipboard. The data must be a string buffer. The type is a string identifying the type of data to be placed into the clipboard. This can be one of the predefined pygame.SCRAP_PBM, pygame.SCRAP_PPM, pygame.SCRAP_BMP or pygame.SCRAP_TEXT values or a user defined string identifier.     \nParameters:\n\n \ntype (string) -- type identifier of the data to be placed into the clipboard \ndata (bytes or str) -- data to be place into the clipboard (in python 3 data is a byte string and in python 2 data is a str)    \nRaises:\n\npygame.error -- if unable to put the data into the clipboard     with open(\"example.bmp\", \"rb\") as fp:\n    pygame.scrap.put(pygame.SCRAP_BMP, fp.read())\n# The image data is now on the clipboard for other applications to access\n# it.\npygame.scrap.put(pygame.SCRAP_TEXT, b\"A text to copy\")\npygame.scrap.put(\"Plain text\", b\"Data for user defined type 'Plain text'\") \n   pygame.scrap.contains() \n Checks whether data for a given type is available in the clipboard. contains(type) -> bool  Checks whether data for the given type is currently available in the clipboard.     \nParameters:\n\ntype (string) -- data type to check availability of  \nReturns:\n\nTrue if data for the passed type is available in the clipboard, False otherwise  \nReturn type:\nbool    if pygame.scrap.contains(pygame.SCRAP_TEXT):\n    print(\"There is text in the clipboard.\")\nif pygame.scrap.contains(\"own_data_type\"):\n    print(\"There is stuff in the clipboard.\") \n   pygame.scrap.lost() \n Indicates if the clipboard ownership has been lost by the pygame application. lost() -> bool  Indicates if the clipboard ownership has been lost by the pygame application.     \nReturns:\n\nTrue, if the clipboard ownership has been lost by the pygame application, False if the pygame application still owns the clipboard  \nReturn type:\nbool    if pygame.scrap.lost():\n    print(\"The clipboard is in use by another application.\") \n   pygame.scrap.set_mode() \n Sets the clipboard access mode. set_mode(mode) -> None  Sets the access mode for the clipboard. This is only of interest for X11 environments where clipboard modes pygame.SCRAP_SELECTION (for mouse selections) and pygame.SCRAP_CLIPBOARD (for the clipboard) are available. Setting the mode to pygame.SCRAP_SELECTION in other environments will not change the mode from pygame.SCRAP_CLIPBOARD.     \nParameters:\n\nmode -- access mode, supported values are pygame.SCRAP_CLIPBOARD and pygame.SCRAP_SELECTION (pygame.SCRAP_SELECTION only has an effect when used on X11 platforms)  \nRaises:\n\nValueError -- if the mode parameter is not pygame.SCRAP_CLIPBOARD or pygame.SCRAP_SELECTION\n    \n \n \n"}, {"name": "scrap.contains", "path": "ref/scrap#pygame.scrap.contains", "type": "pygame.scrap", "text": "  pygame.scrap.contains() \n Checks whether data for a given type is available in the clipboard. contains(type) -> bool  Checks whether data for the given type is currently available in the clipboard.     \nParameters:\n\ntype (string) -- data type to check availability of  \nReturns:\n\nTrue if data for the passed type is available in the clipboard, False otherwise  \nReturn type:\nbool    if pygame.scrap.contains(pygame.SCRAP_TEXT):\n    print(\"There is text in the clipboard.\")\nif pygame.scrap.contains(\"own_data_type\"):\n    print(\"There is stuff in the clipboard.\") \n"}, {"name": "scrap.get", "path": "ref/scrap#pygame.scrap.get", "type": "pygame.scrap", "text": "  pygame.scrap.get() \n Gets the data for the specified type from the clipboard. get(type) -> bytes or str or None  Retrieves the data for the specified type from the clipboard. In python 3 the data is returned as a byte string and might need further processing (such as decoding to Unicode).     \nParameters:\n\ntype (string) -- data type to retrieve from the clipboard  \nReturns:\ndata (byte string in python 3 or str in python 2) for the given type identifier or None if no data for the given type is available  \nReturn type:\nbytes or str or None    text = pygame.scrap.get(pygame.SCRAP_TEXT)\nif text:\n    print(\"There is text in the clipboard.\")\nelse:\n    print(\"There does not seem to be text in the clipboard.\") \n"}, {"name": "scrap.get_init", "path": "ref/scrap#pygame.scrap.get_init", "type": "pygame.scrap", "text": "  pygame.scrap.get_init() \n Returns True if the scrap module is currently initialized. get_init() -> bool  Gets the scrap module's initialization state.     \nReturns:\n\nTrue if the pygame.scrap module is currently initialized, False otherwise  \nReturn type:\nbool     New in pygame 1.9.5.  \n"}, {"name": "scrap.get_types", "path": "ref/scrap#pygame.scrap.get_types", "type": "pygame.scrap", "text": "  pygame.scrap.get_types() \n Gets a list of the available clipboard types. get_types() -> list  Gets a list of data type string identifiers for the data currently available on the clipboard. Each identifier can be used in the pygame.scrap.get() method to get the clipboard content of the specific type.     \nReturns:\nlist of strings of the available clipboard data types, if there is no data in the clipboard an empty list is returned  \nReturn type:\nlist    for t in pygame.scrap.get_types():\n    if \"text\" in t:\n        # There is some content with the word \"text\" in its type string.\n        print(pygame.scrap.get(t)) \n"}, {"name": "scrap.init", "path": "ref/scrap#pygame.scrap.init", "type": "pygame.scrap", "text": "  pygame.scrap.init() \n Initializes the scrap module. init() -> None  Initialize the scrap module.     \nRaises:\n\npygame.error -- if unable to initialize scrap module        Note The scrap module requires pygame.display.set_mode() be called before being initialized.  \n"}, {"name": "scrap.lost", "path": "ref/scrap#pygame.scrap.lost", "type": "pygame.scrap", "text": "  pygame.scrap.lost() \n Indicates if the clipboard ownership has been lost by the pygame application. lost() -> bool  Indicates if the clipboard ownership has been lost by the pygame application.     \nReturns:\n\nTrue, if the clipboard ownership has been lost by the pygame application, False if the pygame application still owns the clipboard  \nReturn type:\nbool    if pygame.scrap.lost():\n    print(\"The clipboard is in use by another application.\") \n"}, {"name": "scrap.put", "path": "ref/scrap#pygame.scrap.put", "type": "pygame.scrap", "text": "  pygame.scrap.put() \n Places data into the clipboard. put(type, data) -> None  Places data for a given clipboard type into the clipboard. The data must be a string buffer. The type is a string identifying the type of data to be placed into the clipboard. This can be one of the predefined pygame.SCRAP_PBM, pygame.SCRAP_PPM, pygame.SCRAP_BMP or pygame.SCRAP_TEXT values or a user defined string identifier.     \nParameters:\n\n \ntype (string) -- type identifier of the data to be placed into the clipboard \ndata (bytes or str) -- data to be place into the clipboard (in python 3 data is a byte string and in python 2 data is a str)    \nRaises:\n\npygame.error -- if unable to put the data into the clipboard     with open(\"example.bmp\", \"rb\") as fp:\n    pygame.scrap.put(pygame.SCRAP_BMP, fp.read())\n# The image data is now on the clipboard for other applications to access\n# it.\npygame.scrap.put(pygame.SCRAP_TEXT, b\"A text to copy\")\npygame.scrap.put(\"Plain text\", b\"Data for user defined type 'Plain text'\") \n"}, {"name": "scrap.set_mode", "path": "ref/scrap#pygame.scrap.set_mode", "type": "pygame.scrap", "text": "  pygame.scrap.set_mode() \n Sets the clipboard access mode. set_mode(mode) -> None  Sets the access mode for the clipboard. This is only of interest for X11 environments where clipboard modes pygame.SCRAP_SELECTION (for mouse selections) and pygame.SCRAP_CLIPBOARD (for the clipboard) are available. Setting the mode to pygame.SCRAP_SELECTION in other environments will not change the mode from pygame.SCRAP_CLIPBOARD.     \nParameters:\n\nmode -- access mode, supported values are pygame.SCRAP_CLIPBOARD and pygame.SCRAP_SELECTION (pygame.SCRAP_SELECTION only has an effect when used on X11 platforms)  \nRaises:\n\nValueError -- if the mode parameter is not pygame.SCRAP_CLIPBOARD or pygame.SCRAP_SELECTION\n    \n"}, {"name": "set_error", "path": "ref/pygame#pygame.set_error", "type": "pygame", "text": "  pygame.set_error() \n set the current error message set_error(error_msg) -> None  SDL maintains an internal error message. This message will usually be given to you when pygame.error() is raised, so this function will rarely be needed. \n"}, {"name": "sndarray", "path": "ref/sndarray", "type": "pygame.sndarray", "text": " pygame.sndarray\n  \n pygame module for accessing sound sample data  Functions to convert between NumPy arrays and Sound objects. This module will only be available when pygame can use the external NumPy package. Sound data is made of thousands of samples per second, and each sample is the amplitude of the wave at a particular moment in time. For example, in 22-kHz format, element number 5 of the array is the amplitude of the wave after 5/22000 seconds. Each sample is an 8-bit or 16-bit integer, depending on the data format. A stereo sound file has two values per sample, while a mono sound file only has one.   pygame.sndarray.array() \n copy Sound samples into an array array(Sound) -> array  Creates a new array for the sound data and copies the samples. The array will always be in the format returned from pygame.mixer.get_init(). \n   pygame.sndarray.samples() \n reference Sound samples into an array samples(Sound) -> array  Creates a new array that directly references the samples in a Sound object. Modifying the array will change the Sound. The array will always be in the format returned from pygame.mixer.get_init(). \n   pygame.sndarray.make_sound() \n convert an array into a Sound object make_sound(array) -> Sound  Create a new playable Sound object from an array. The mixer module must be initialized and the array format must be similar to the mixer audio format. \n   pygame.sndarray.use_arraytype() \n Sets the array system to be used for sound arrays use_arraytype (arraytype) -> None  DEPRECATED: Uses the requested array type for the module functions. The only supported arraytype is 'numpy'. Other values will raise ValueError. \n   pygame.sndarray.get_arraytype() \n Gets the currently active array type. get_arraytype () -> str  DEPRECATED: Returns the currently active array type. This will be a value of the get_arraytypes() tuple and indicates which type of array module is used for the array creation.  New in pygame 1.8.  \n   pygame.sndarray.get_arraytypes() \n Gets the array system types currently supported. get_arraytypes () -> tuple  DEPRECATED: Checks, which array systems are available and returns them as a tuple of strings. The values of the tuple can be used directly in the pygame.sndarray.use_arraytype() () method. If no supported array system could be found, None will be returned.  New in pygame 1.8.  \n \n \n"}, {"name": "sndarray.array", "path": "ref/sndarray#pygame.sndarray.array", "type": "pygame.sndarray", "text": "  pygame.sndarray.array() \n copy Sound samples into an array array(Sound) -> array  Creates a new array for the sound data and copies the samples. The array will always be in the format returned from pygame.mixer.get_init(). \n"}, {"name": "sndarray.get_arraytype", "path": "ref/sndarray#pygame.sndarray.get_arraytype", "type": "pygame.sndarray", "text": "  pygame.sndarray.get_arraytype() \n Gets the currently active array type. get_arraytype () -> str  DEPRECATED: Returns the currently active array type. This will be a value of the get_arraytypes() tuple and indicates which type of array module is used for the array creation.  New in pygame 1.8.  \n"}, {"name": "sndarray.get_arraytypes", "path": "ref/sndarray#pygame.sndarray.get_arraytypes", "type": "pygame.sndarray", "text": "  pygame.sndarray.get_arraytypes() \n Gets the array system types currently supported. get_arraytypes () -> tuple  DEPRECATED: Checks, which array systems are available and returns them as a tuple of strings. The values of the tuple can be used directly in the pygame.sndarray.use_arraytype() () method. If no supported array system could be found, None will be returned.  New in pygame 1.8.  \n"}, {"name": "sndarray.make_sound", "path": "ref/sndarray#pygame.sndarray.make_sound", "type": "pygame.sndarray", "text": "  pygame.sndarray.make_sound() \n convert an array into a Sound object make_sound(array) -> Sound  Create a new playable Sound object from an array. The mixer module must be initialized and the array format must be similar to the mixer audio format. \n"}, {"name": "sndarray.samples", "path": "ref/sndarray#pygame.sndarray.samples", "type": "pygame.sndarray", "text": "  pygame.sndarray.samples() \n reference Sound samples into an array samples(Sound) -> array  Creates a new array that directly references the samples in a Sound object. Modifying the array will change the Sound. The array will always be in the format returned from pygame.mixer.get_init(). \n"}, {"name": "sndarray.use_arraytype", "path": "ref/sndarray#pygame.sndarray.use_arraytype", "type": "pygame.sndarray", "text": "  pygame.sndarray.use_arraytype() \n Sets the array system to be used for sound arrays use_arraytype (arraytype) -> None  DEPRECATED: Uses the requested array type for the module functions. The only supported arraytype is 'numpy'. Other values will raise ValueError. \n"}, {"name": "sprite", "path": "ref/sprite", "type": "pygame.sprite", "text": " pygame.sprite\n  \n pygame module with basic game object classes  This module contains several simple classes to be used within games. There is the main Sprite class and several Group classes that contain Sprites. The use of these classes is entirely optional when using pygame. The classes are fairly lightweight and only provide a starting place for the code that is common to most games. The Sprite class is intended to be used as a base class for the different types of objects in the game. There is also a base Group class that simply stores sprites. A game could create new types of Group classes that operate on specially customized Sprite instances they contain. The basic Sprite class can draw the Sprites it contains to a Surface. The Group.draw() method requires that each Sprite have a Surface.image attribute and a Surface.rect. The Group.clear() method requires these same attributes, and can be used to erase all the Sprites with background. There are also more advanced Groups: pygame.sprite.RenderUpdates() and pygame.sprite.OrderedUpdates(). Lastly, this module contains several collision functions. These help find sprites inside multiple groups that have intersecting bounding rectangles. To find the collisions, the Sprites are required to have a Surface.rect attribute assigned. The groups are designed for high efficiency in removing and adding Sprites to them. They also allow cheap testing to see if a Sprite already exists in a Group. A given Sprite can exist in any number of groups. A game could use some groups to control object rendering, and a completely separate set of groups to control interaction or player movement. Instead of adding type attributes or bools to a derived Sprite class, consider keeping the Sprites inside organized Groups. This will allow for easier lookup later in the game. Sprites and Groups manage their relationships with the add() and remove() methods. These methods can accept a single or multiple targets for membership. The default initializers for these classes also takes a single or list of targets for initial membership. It is safe to repeatedly add and remove the same Sprite from a Group. While it is possible to design sprite and group classes that don't derive from the Sprite and AbstractGroup classes below, it is strongly recommended that you extend those when you add a Sprite or Group class. Sprites are not thread safe. So lock them yourself if using threads.   pygame.sprite.Sprite \n Simple base class for visible game objects. Sprite(*groups) -> Sprite  The base class for visible game objects. Derived classes will want to override the Sprite.update() and assign a Sprite.image and Sprite.rect attributes. The initializer can accept any number of Group instances to be added to. When subclassing the Sprite, be sure to call the base initializer before adding the Sprite to Groups. For example: \nclass Block(pygame.sprite.Sprite):\n\n    # Constructor. Pass in the color of the block,\n    # and its x and y position\n    def __init__(self, color, width, height):\n       # Call the parent class (Sprite) constructor\n       pygame.sprite.Sprite.__init__(self)\n\n       # Create an image of the block, and fill it with a color.\n       # This could also be an image loaded from the disk.\n       self.image = pygame.Surface([width, height])\n       self.image.fill(color)\n\n       # Fetch the rectangle object that has the dimensions of the image\n       # Update the position of this object by setting the values of rect.x and rect.y\n       self.rect = self.image.get_rect()\n    update() \n method to control sprite behavior update(*args, **kwargs) -> None  The default implementation of this method does nothing; it's just a convenient \"hook\" that you can override. This method is called by Group.update() with whatever arguments you give it. There is no need to use this method if not using the convenience method by the same name in the Group class. \n   add() \n add the sprite to groups add(*groups) -> None  Any number of Group instances can be passed as arguments. The Sprite will be added to the Groups it is not already a member of. \n   remove() \n remove the sprite from groups remove(*groups) -> None  Any number of Group instances can be passed as arguments. The Sprite will be removed from the Groups it is currently a member of. \n   kill() \n remove the Sprite from all Groups kill() -> None  The Sprite is removed from all the Groups that contain it. This won't change anything about the state of the Sprite. It is possible to continue to use the Sprite after this method has been called, including adding it to Groups. \n   alive() \n does the sprite belong to any groups alive() -> bool  Returns True when the Sprite belongs to one or more Groups. \n   groups() \n list of Groups that contain this Sprite groups() -> group_list  Return a list of all the Groups that contain this Sprite. \n \n   pygame.sprite.DirtySprite \n A subclass of Sprite with more attributes and features. DirtySprite(*groups) -> DirtySprite  Extra DirtySprite attributes with their default values: dirty = 1 if set to 1, it is repainted and then set to 0 again\nif set to 2 then it is always dirty ( repainted each frame,\nflag is not reset)\n0 means that it is not dirty and therefore not repainted again blendmode = 0 its the special_flags argument of blit, blendmodes source_rect = None source rect to use, remember that it is relative to\ntopleft (0,0) of self.image visible = 1 normally 1, if set to 0 it will not be repainted\n(you must set it dirty too to be erased from screen) layer = 0 (READONLY value, it is read when adding it to the\nLayeredDirty, for details see doc of LayeredDirty) \n   pygame.sprite.Group \n A container class to hold and manage multiple Sprite objects. Group(*sprites) -> Group  A simple container for Sprite objects. This class can be inherited to create containers with more specific behaviors. The constructor takes any number of Sprite arguments to add to the Group. The group supports the following standard Python operations: in      test if a Sprite is contained\nlen     the number of Sprites contained\nbool    test if any Sprites are contained\niter    iterate through all the Sprites The Sprites in the Group are not ordered, so drawing and iterating the Sprites is in no particular order.   sprites() \n list of the Sprites this Group contains sprites() -> sprite_list  Return a list of all the Sprites this group contains. You can also get an iterator from the group, but you cannot iterate over a Group while modifying it. \n   copy() \n duplicate the Group copy() -> Group  Creates a new Group with all the same Sprites as the original. If you have subclassed Group, the new object will have the same (sub-)class as the original. This only works if the derived class's constructor takes the same arguments as the Group class's. \n   add() \n add Sprites to this Group add(*sprites) -> None  Add any number of Sprites to this Group. This will only add Sprites that are not already members of the Group. Each sprite argument can also be a iterator containing Sprites. \n   remove() \n remove Sprites from the Group remove(*sprites) -> None  Remove any number of Sprites from the Group. This will only remove Sprites that are already members of the Group. Each sprite argument can also be a iterator containing Sprites. \n   has() \n test if a Group contains Sprites has(*sprites) -> bool  Return True if the Group contains all of the given sprites. This is similar to using the \"in\" operator on the Group (\"if sprite in group: ...\"), which tests if a single Sprite belongs to a Group. Each sprite argument can also be a iterator containing Sprites. \n   update() \n call the update method on contained Sprites update(*args, **kwargs) -> None  Calls the update() method on all Sprites in the Group. The base Sprite class has an update method that takes any number of arguments and does nothing. The arguments passed to Group.update() will be passed to each Sprite. There is no way to get the return value from the Sprite.update() methods. \n   draw() \n blit the Sprite images draw(Surface) -> None  Draws the contained Sprites to the Surface argument. This uses the Sprite.image attribute for the source surface, and Sprite.rect for the position. The Group does not keep sprites in any order, so the draw order is arbitrary. \n   clear() \n draw a background over the Sprites clear(Surface_dest, background) -> None  Erases the Sprites used in the last Group.draw() call. The destination Surface is cleared by filling the drawn Sprite positions with the background. The background is usually a Surface image the same dimensions as the destination Surface. However, it can also be a callback function that takes two arguments; the destination Surface and an area to clear. The background callback function will be called several times each clear. Here is an example callback that will clear the Sprites with solid red: def clear_callback(surf, rect):\n    color = 255, 0, 0\n    surf.fill(color, rect) \n   empty() \n remove all Sprites empty() -> None  Removes all Sprites from this Group. \n \n   pygame.sprite.RenderPlain \n Same as pygame.sprite.Group  This class is an alias to pygame.sprite.Group(). It has no additional functionality. \n   pygame.sprite.RenderClear \n Same as pygame.sprite.Group  This class is an alias to pygame.sprite.Group(). It has no additional functionality. \n   pygame.sprite.RenderUpdates \n Group sub-class that tracks dirty updates. RenderUpdates(*sprites) -> RenderUpdates  This class is derived from pygame.sprite.Group(). It has an extended draw() method that tracks the changed areas of the screen.   draw() \n blit the Sprite images and track changed areas draw(surface) -> Rect_list  Draws all the Sprites to the surface, the same as Group.draw(). This method also returns a list of Rectangular areas on the screen that have been changed. The returned changes include areas of the screen that have been affected by previous Group.clear() calls. The returned Rect list should be passed to pygame.display.update(). This will help performance on software driven display modes. This type of updating is usually only helpful on destinations with non-animating backgrounds. \n \n   pygame.sprite.OrderedUpdates() \n RenderUpdates sub-class that draws Sprites in order of addition. OrderedUpdates(*spites) -> OrderedUpdates  This class derives from pygame.sprite.RenderUpdates(). It maintains the order in which the Sprites were added to the Group for rendering. This makes adding and removing Sprites from the Group a little slower than regular Groups. \n   pygame.sprite.LayeredUpdates \n LayeredUpdates is a sprite group that handles layers and draws like OrderedUpdates. LayeredUpdates(*spites, **kwargs) -> LayeredUpdates  This group is fully compatible with pygame.sprite.Sprite. You can set the default layer through kwargs using 'default_layer' and an integer for the layer. The default layer is 0. If the sprite you add has an attribute _layer then that layer will be used. If the **kwarg contains 'layer' then the sprites passed will be added to that layer (overriding the sprite.layer attribute). If neither sprite has attribute layer nor **kwarg then the default layer is used to add the sprites.  New in pygame 1.8.    add() \n add a sprite or sequence of sprites to a group add(*sprites, **kwargs) -> None  If the sprite(s) have an attribute layer then that is used for the layer. If **kwargs contains 'layer' then the sprite(s) will be added to that argument (overriding the sprite layer attribute). If neither is passed then the sprite(s) will be added to the default layer. \n   sprites() \n returns a ordered list of sprites (first back, last top). sprites() -> sprites  \n   draw() \n draw all sprites in the right order onto the passed surface. draw(surface) -> Rect_list  \n   get_sprites_at() \n returns a list with all sprites at that position. get_sprites_at(pos) -> colliding_sprites  Bottom sprites first, top last. \n   get_sprite() \n returns the sprite at the index idx from the groups sprites get_sprite(idx) -> sprite  Raises IndexOutOfBounds if the idx is not within range. \n   remove_sprites_of_layer() \n removes all sprites from a layer and returns them as a list. remove_sprites_of_layer(layer_nr) -> sprites  \n   layers() \n returns a list of layers defined (unique), sorted from bottom up. layers() -> layers  \n   change_layer() \n changes the layer of the sprite change_layer(sprite, new_layer) -> None  sprite must have been added to the renderer. It is not checked. \n   get_layer_of_sprite() \n returns the layer that sprite is currently in. get_layer_of_sprite(sprite) -> layer  If the sprite is not found then it will return the default layer. \n   get_top_layer() \n returns the top layer get_top_layer() -> layer  \n   get_bottom_layer() \n returns the bottom layer get_bottom_layer() -> layer  \n   move_to_front() \n brings the sprite to front layer move_to_front(sprite) -> None  Brings the sprite to front, changing sprite layer to topmost layer (added at the end of that layer). \n   move_to_back() \n moves the sprite to the bottom layer move_to_back(sprite) -> None  Moves the sprite to the bottom layer, moving it behind all other layers and adding one additional layer. \n   get_top_sprite() \n returns the topmost sprite get_top_sprite() -> Sprite  \n   get_sprites_from_layer() \n returns all sprites from a layer, ordered by how they where added get_sprites_from_layer(layer) -> sprites  Returns all sprites from a layer, ordered by how they where added. It uses linear search and the sprites are not removed from layer. \n   switch_layer() \n switches the sprites from layer1 to layer2 switch_layer(layer1_nr, layer2_nr) -> None  The layers number must exist, it is not checked. \n \n   pygame.sprite.LayeredDirty \n LayeredDirty group is for DirtySprite objects. Subclasses LayeredUpdates. LayeredDirty(*spites, **kwargs) -> LayeredDirty  This group requires pygame.sprite.DirtySprite or any sprite that has the following attributes: image, rect, dirty, visible, blendmode (see doc of DirtySprite). It uses the dirty flag technique and is therefore faster than the pygame.sprite.RenderUpdates if you have many static sprites. It also switches automatically between dirty rect update and full screen drawing, so you do no have to worry what would be faster. Same as for the pygame.sprite.Group. You can specify some additional attributes through kwargs: _use_update: True/False   default is False\n_default_layer: default layer where sprites without a layer are added.\n_time_threshold: threshold time for switching between dirty rect mode\n    and fullscreen mode, defaults to 1000./80  == 1000./fps  New in pygame 1.8.    draw() \n draw all sprites in the right order onto the passed surface. draw(surface, bgd=None) -> Rect_list  You can pass the background too. If a background is already set, then the bgd argument has no effect. \n   clear() \n used to set background clear(surface, bgd) -> None  \n   repaint_rect() \n repaints the given area repaint_rect(screen_rect) -> None  screen_rect is in screen coordinates. \n   set_clip() \n clip the area where to draw. Just pass None (default) to reset the clip set_clip(screen_rect=None) -> None  \n   get_clip() \n clip the area where to draw. Just pass None (default) to reset the clip get_clip() -> Rect  \n   change_layer() \n changes the layer of the sprite change_layer(sprite, new_layer) -> None  sprite must have been added to the renderer. It is not checked. \n   set_timing_treshold() \n sets the threshold in milliseconds set_timing_treshold(time_ms) -> None  Default is 1000./80 where 80 is the fps I want to switch to full screen mode. This method's name is a typo and should be fixed.     \nRaises:\n\nTypeError -- if time_ms is not int or float    \n \n   pygame.sprite.GroupSingle() \n Group container that holds a single sprite. GroupSingle(sprite=None) -> GroupSingle  The GroupSingle container only holds a single Sprite. When a new Sprite is added, the old one is removed. There is a special property, GroupSingle.sprite, that accesses the Sprite that this Group contains. It can be None when the Group is empty. The property can also be assigned to add a Sprite into the GroupSingle container. \n   pygame.sprite.spritecollide() \n Find sprites in a group that intersect another sprite. spritecollide(sprite, group, dokill, collided = None) -> Sprite_list  Return a list containing all Sprites in a Group that intersect with another Sprite. Intersection is determined by comparing the Sprite.rect attribute of each Sprite. The dokill argument is a bool. If set to True, all Sprites that collide will be removed from the Group. The collided argument is a callback function used to calculate if two sprites are colliding. it should take two sprites as values, and return a bool value indicating if they are colliding. If collided is not passed, all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. collided callables: collide_rect, collide_rect_ratio, collide_circle,\ncollide_circle_ratio, collide_mask Example: \n# See if the Sprite block has collided with anything in the Group block_list\n# The True flag will remove the sprite in block_list\nblocks_hit_list = pygame.sprite.spritecollide(player, block_list, True)\n\n# Check the list of colliding sprites, and add one to the score for each one\nfor block in blocks_hit_list:\n    score +=1\n  \n   pygame.sprite.collide_rect() \n Collision detection between two sprites, using rects. collide_rect(left, right) -> bool  Tests for collision between two sprites. Uses the pygame rect colliderect function to calculate the collision. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" attributes.  New in pygame 1.8.  \n   pygame.sprite.collide_rect_ratio() \n Collision detection between two sprites, using rects scaled to a ratio. collide_rect_ratio(ratio) -> collided_callable  A callable class that checks for collisions between two sprites, using a scaled version of the sprites rects. Is created with a ratio, the instance is then intended to be passed as a collided callback function to the *collide functions. A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size.  New in pygame 1.8.1.  \n   pygame.sprite.collide_circle() \n Collision detection between two sprites, using circles. collide_circle(left, right) -> bool  Tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap. If the sprites have a \"radius\" attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the \"rect\" attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" and an optional \"radius\" attribute.  New in pygame 1.8.1.  \n   pygame.sprite.collide_circle_ratio() \n Collision detection between two sprites, using circles scaled to a ratio. collide_circle_ratio(ratio) -> collided_callable  A callable class that checks for collisions between two sprites, using a scaled version of the sprites radius. Is created with a floating point ratio, the instance is then intended to be passed as a collided callback function to the *collide functions. A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size. The created callable tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap, after scaling the circles radius by the stored ratio. If the sprites have a \"radius\" attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the \"rect\" attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" and an optional \"radius\" attribute.  New in pygame 1.8.1.  \n   pygame.sprite.collide_mask() \n Collision detection between two sprites, using masks. collide_mask(sprite1, sprite2) -> (int, int) collide_mask(sprite1, sprite2) -> None  Tests for collision between two sprites, by testing if their bitmasks overlap (uses pygame.mask.Mask.overlap()). If the sprites have a mask attribute, it is used as the mask, otherwise a mask is created from the sprite's image (uses pygame.mask.from_surface()). Sprites must have a rect attribute; the mask attribute is optional. The first point of collision between the masks is returned. The collision point is offset from sprite1's mask's topleft corner (which is always (0, 0)). The collision point is a position within the mask and is not related to the actual screen position of sprite1. This function is intended to be passed as a collided callback function to the group collide functions (see spritecollide(), groupcollide(), spritecollideany()).  Note To increase performance, create and set a mask attibute for all sprites that will use this function to check for collisions. Otherwise, each time this function is called it will create new masks.   Note A new mask needs to be recreated each time a sprite's image is changed (e.g. if a new image is used or the existing image is rotated).  # Example of mask creation for a sprite.\nsprite.mask = pygame.mask.from_surface(sprite.image)     \nReturns:\nfirst point of collision between the masks or None if no collision  \nReturn type:\ntuple(int, int) or NoneType     New in pygame 1.8.0.  \n   pygame.sprite.groupcollide() \n Find all sprites that collide between two groups. groupcollide(group1, group2, dokill1, dokill2, collided = None) -> Sprite_dict  This will find collisions between all the Sprites in two groups. Collision is determined by comparing the Sprite.rect attribute of each Sprite or by using the collided function if it is not None. Every Sprite inside group1 is added to the return dictionary. The value for each item is the list of Sprites in group2 that intersect. If either dokill argument is True, the colliding Sprites will be removed from their respective Group. The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. \n   pygame.sprite.spritecollideany() \n Simple test if a sprite intersects anything in a group. \nspritecollideany(sprite, group, collided = None) -> Sprite Collision with the returned sprite. \nspritecollideany(sprite, group, collided = None) -> None No collision  If the sprite collides with any single sprite in the group, a single sprite from the group is returned. On no collision None is returned. If you don't need all the features of the pygame.sprite.spritecollide() function, this function will be a bit quicker. The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. \n \n \n"}, {"name": "sprite.collide_circle", "path": "ref/sprite#pygame.sprite.collide_circle", "type": "pygame.sprite", "text": "  pygame.sprite.collide_circle() \n Collision detection between two sprites, using circles. collide_circle(left, right) -> bool  Tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap. If the sprites have a \"radius\" attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the \"rect\" attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" and an optional \"radius\" attribute.  New in pygame 1.8.1.  \n"}, {"name": "sprite.collide_circle_ratio", "path": "ref/sprite#pygame.sprite.collide_circle_ratio", "type": "pygame.sprite", "text": "  pygame.sprite.collide_circle_ratio() \n Collision detection between two sprites, using circles scaled to a ratio. collide_circle_ratio(ratio) -> collided_callable  A callable class that checks for collisions between two sprites, using a scaled version of the sprites radius. Is created with a floating point ratio, the instance is then intended to be passed as a collided callback function to the *collide functions. A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size. The created callable tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap, after scaling the circles radius by the stored ratio. If the sprites have a \"radius\" attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the \"rect\" attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" and an optional \"radius\" attribute.  New in pygame 1.8.1.  \n"}, {"name": "sprite.collide_mask", "path": "ref/sprite#pygame.sprite.collide_mask", "type": "pygame.sprite", "text": "  pygame.sprite.collide_mask() \n Collision detection between two sprites, using masks. collide_mask(sprite1, sprite2) -> (int, int) collide_mask(sprite1, sprite2) -> None  Tests for collision between two sprites, by testing if their bitmasks overlap (uses pygame.mask.Mask.overlap()). If the sprites have a mask attribute, it is used as the mask, otherwise a mask is created from the sprite's image (uses pygame.mask.from_surface()). Sprites must have a rect attribute; the mask attribute is optional. The first point of collision between the masks is returned. The collision point is offset from sprite1's mask's topleft corner (which is always (0, 0)). The collision point is a position within the mask and is not related to the actual screen position of sprite1. This function is intended to be passed as a collided callback function to the group collide functions (see spritecollide(), groupcollide(), spritecollideany()).  Note To increase performance, create and set a mask attibute for all sprites that will use this function to check for collisions. Otherwise, each time this function is called it will create new masks.   Note A new mask needs to be recreated each time a sprite's image is changed (e.g. if a new image is used or the existing image is rotated).  # Example of mask creation for a sprite.\nsprite.mask = pygame.mask.from_surface(sprite.image)     \nReturns:\nfirst point of collision between the masks or None if no collision  \nReturn type:\ntuple(int, int) or NoneType     New in pygame 1.8.0.  \n"}, {"name": "sprite.collide_rect", "path": "ref/sprite#pygame.sprite.collide_rect", "type": "pygame.sprite", "text": "  pygame.sprite.collide_rect() \n Collision detection between two sprites, using rects. collide_rect(left, right) -> bool  Tests for collision between two sprites. Uses the pygame rect colliderect function to calculate the collision. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a \"rect\" attributes.  New in pygame 1.8.  \n"}, {"name": "sprite.collide_rect_ratio", "path": "ref/sprite#pygame.sprite.collide_rect_ratio", "type": "pygame.sprite", "text": "  pygame.sprite.collide_rect_ratio() \n Collision detection between two sprites, using rects scaled to a ratio. collide_rect_ratio(ratio) -> collided_callable  A callable class that checks for collisions between two sprites, using a scaled version of the sprites rects. Is created with a ratio, the instance is then intended to be passed as a collided callback function to the *collide functions. A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size.  New in pygame 1.8.1.  \n"}, {"name": "sprite.DirtySprite", "path": "ref/sprite#pygame.sprite.DirtySprite", "type": "pygame.sprite", "text": "  pygame.sprite.DirtySprite \n A subclass of Sprite with more attributes and features. DirtySprite(*groups) -> DirtySprite  Extra DirtySprite attributes with their default values: dirty = 1 if set to 1, it is repainted and then set to 0 again\nif set to 2 then it is always dirty ( repainted each frame,\nflag is not reset)\n0 means that it is not dirty and therefore not repainted again blendmode = 0 its the special_flags argument of blit, blendmodes source_rect = None source rect to use, remember that it is relative to\ntopleft (0,0) of self.image visible = 1 normally 1, if set to 0 it will not be repainted\n(you must set it dirty too to be erased from screen) layer = 0 (READONLY value, it is read when adding it to the\nLayeredDirty, for details see doc of LayeredDirty) \n"}, {"name": "sprite.Group", "path": "ref/sprite#pygame.sprite.Group", "type": "pygame.sprite", "text": "  pygame.sprite.Group \n A container class to hold and manage multiple Sprite objects. Group(*sprites) -> Group  A simple container for Sprite objects. This class can be inherited to create containers with more specific behaviors. The constructor takes any number of Sprite arguments to add to the Group. The group supports the following standard Python operations: in      test if a Sprite is contained\nlen     the number of Sprites contained\nbool    test if any Sprites are contained\niter    iterate through all the Sprites The Sprites in the Group are not ordered, so drawing and iterating the Sprites is in no particular order.   sprites() \n list of the Sprites this Group contains sprites() -> sprite_list  Return a list of all the Sprites this group contains. You can also get an iterator from the group, but you cannot iterate over a Group while modifying it. \n   copy() \n duplicate the Group copy() -> Group  Creates a new Group with all the same Sprites as the original. If you have subclassed Group, the new object will have the same (sub-)class as the original. This only works if the derived class's constructor takes the same arguments as the Group class's. \n   add() \n add Sprites to this Group add(*sprites) -> None  Add any number of Sprites to this Group. This will only add Sprites that are not already members of the Group. Each sprite argument can also be a iterator containing Sprites. \n   remove() \n remove Sprites from the Group remove(*sprites) -> None  Remove any number of Sprites from the Group. This will only remove Sprites that are already members of the Group. Each sprite argument can also be a iterator containing Sprites. \n   has() \n test if a Group contains Sprites has(*sprites) -> bool  Return True if the Group contains all of the given sprites. This is similar to using the \"in\" operator on the Group (\"if sprite in group: ...\"), which tests if a single Sprite belongs to a Group. Each sprite argument can also be a iterator containing Sprites. \n   update() \n call the update method on contained Sprites update(*args, **kwargs) -> None  Calls the update() method on all Sprites in the Group. The base Sprite class has an update method that takes any number of arguments and does nothing. The arguments passed to Group.update() will be passed to each Sprite. There is no way to get the return value from the Sprite.update() methods. \n   draw() \n blit the Sprite images draw(Surface) -> None  Draws the contained Sprites to the Surface argument. This uses the Sprite.image attribute for the source surface, and Sprite.rect for the position. The Group does not keep sprites in any order, so the draw order is arbitrary. \n   clear() \n draw a background over the Sprites clear(Surface_dest, background) -> None  Erases the Sprites used in the last Group.draw() call. The destination Surface is cleared by filling the drawn Sprite positions with the background. The background is usually a Surface image the same dimensions as the destination Surface. However, it can also be a callback function that takes two arguments; the destination Surface and an area to clear. The background callback function will be called several times each clear. Here is an example callback that will clear the Sprites with solid red: def clear_callback(surf, rect):\n    color = 255, 0, 0\n    surf.fill(color, rect) \n   empty() \n remove all Sprites empty() -> None  Removes all Sprites from this Group. \n \n"}, {"name": "sprite.Group.add", "path": "ref/sprite#pygame.sprite.Group.add", "type": "pygame.sprite", "text": "  add() \n add Sprites to this Group add(*sprites) -> None  Add any number of Sprites to this Group. This will only add Sprites that are not already members of the Group. Each sprite argument can also be a iterator containing Sprites. \n"}, {"name": "sprite.Group.clear", "path": "ref/sprite#pygame.sprite.Group.clear", "type": "pygame.sprite", "text": "  clear() \n draw a background over the Sprites clear(Surface_dest, background) -> None  Erases the Sprites used in the last Group.draw() call. The destination Surface is cleared by filling the drawn Sprite positions with the background. The background is usually a Surface image the same dimensions as the destination Surface. However, it can also be a callback function that takes two arguments; the destination Surface and an area to clear. The background callback function will be called several times each clear. Here is an example callback that will clear the Sprites with solid red: def clear_callback(surf, rect):\n    color = 255, 0, 0\n    surf.fill(color, rect) \n"}, {"name": "sprite.Group.copy", "path": "ref/sprite#pygame.sprite.Group.copy", "type": "pygame.sprite", "text": "  copy() \n duplicate the Group copy() -> Group  Creates a new Group with all the same Sprites as the original. If you have subclassed Group, the new object will have the same (sub-)class as the original. This only works if the derived class's constructor takes the same arguments as the Group class's. \n"}, {"name": "sprite.Group.draw", "path": "ref/sprite#pygame.sprite.Group.draw", "type": "pygame.sprite", "text": "  draw() \n blit the Sprite images draw(Surface) -> None  Draws the contained Sprites to the Surface argument. This uses the Sprite.image attribute for the source surface, and Sprite.rect for the position. The Group does not keep sprites in any order, so the draw order is arbitrary. \n"}, {"name": "sprite.Group.empty", "path": "ref/sprite#pygame.sprite.Group.empty", "type": "pygame.sprite", "text": "  empty() \n remove all Sprites empty() -> None  Removes all Sprites from this Group. \n"}, {"name": "sprite.Group.has", "path": "ref/sprite#pygame.sprite.Group.has", "type": "pygame.sprite", "text": "  has() \n test if a Group contains Sprites has(*sprites) -> bool  Return True if the Group contains all of the given sprites. This is similar to using the \"in\" operator on the Group (\"if sprite in group: ...\"), which tests if a single Sprite belongs to a Group. Each sprite argument can also be a iterator containing Sprites. \n"}, {"name": "sprite.Group.remove", "path": "ref/sprite#pygame.sprite.Group.remove", "type": "pygame.sprite", "text": "  remove() \n remove Sprites from the Group remove(*sprites) -> None  Remove any number of Sprites from the Group. This will only remove Sprites that are already members of the Group. Each sprite argument can also be a iterator containing Sprites. \n"}, {"name": "sprite.Group.sprites", "path": "ref/sprite#pygame.sprite.Group.sprites", "type": "pygame.sprite", "text": "  sprites() \n list of the Sprites this Group contains sprites() -> sprite_list  Return a list of all the Sprites this group contains. You can also get an iterator from the group, but you cannot iterate over a Group while modifying it. \n"}, {"name": "sprite.Group.update", "path": "ref/sprite#pygame.sprite.Group.update", "type": "pygame.sprite", "text": "  update() \n call the update method on contained Sprites update(*args, **kwargs) -> None  Calls the update() method on all Sprites in the Group. The base Sprite class has an update method that takes any number of arguments and does nothing. The arguments passed to Group.update() will be passed to each Sprite. There is no way to get the return value from the Sprite.update() methods. \n"}, {"name": "sprite.groupcollide", "path": "ref/sprite#pygame.sprite.groupcollide", "type": "pygame.sprite", "text": "  pygame.sprite.groupcollide() \n Find all sprites that collide between two groups. groupcollide(group1, group2, dokill1, dokill2, collided = None) -> Sprite_dict  This will find collisions between all the Sprites in two groups. Collision is determined by comparing the Sprite.rect attribute of each Sprite or by using the collided function if it is not None. Every Sprite inside group1 is added to the return dictionary. The value for each item is the list of Sprites in group2 that intersect. If either dokill argument is True, the colliding Sprites will be removed from their respective Group. The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. \n"}, {"name": "sprite.GroupSingle", "path": "ref/sprite#pygame.sprite.GroupSingle", "type": "pygame.sprite", "text": "  pygame.sprite.GroupSingle() \n Group container that holds a single sprite. GroupSingle(sprite=None) -> GroupSingle  The GroupSingle container only holds a single Sprite. When a new Sprite is added, the old one is removed. There is a special property, GroupSingle.sprite, that accesses the Sprite that this Group contains. It can be None when the Group is empty. The property can also be assigned to add a Sprite into the GroupSingle container. \n"}, {"name": "sprite.LayeredDirty", "path": "ref/sprite#pygame.sprite.LayeredDirty", "type": "pygame.sprite", "text": "  pygame.sprite.LayeredDirty \n LayeredDirty group is for DirtySprite objects. Subclasses LayeredUpdates. LayeredDirty(*spites, **kwargs) -> LayeredDirty  This group requires pygame.sprite.DirtySprite or any sprite that has the following attributes: image, rect, dirty, visible, blendmode (see doc of DirtySprite). It uses the dirty flag technique and is therefore faster than the pygame.sprite.RenderUpdates if you have many static sprites. It also switches automatically between dirty rect update and full screen drawing, so you do no have to worry what would be faster. Same as for the pygame.sprite.Group. You can specify some additional attributes through kwargs: _use_update: True/False   default is False\n_default_layer: default layer where sprites without a layer are added.\n_time_threshold: threshold time for switching between dirty rect mode\n    and fullscreen mode, defaults to 1000./80  == 1000./fps  New in pygame 1.8.    draw() \n draw all sprites in the right order onto the passed surface. draw(surface, bgd=None) -> Rect_list  You can pass the background too. If a background is already set, then the bgd argument has no effect. \n   clear() \n used to set background clear(surface, bgd) -> None  \n   repaint_rect() \n repaints the given area repaint_rect(screen_rect) -> None  screen_rect is in screen coordinates. \n   set_clip() \n clip the area where to draw. Just pass None (default) to reset the clip set_clip(screen_rect=None) -> None  \n   get_clip() \n clip the area where to draw. Just pass None (default) to reset the clip get_clip() -> Rect  \n   change_layer() \n changes the layer of the sprite change_layer(sprite, new_layer) -> None  sprite must have been added to the renderer. It is not checked. \n   set_timing_treshold() \n sets the threshold in milliseconds set_timing_treshold(time_ms) -> None  Default is 1000./80 where 80 is the fps I want to switch to full screen mode. This method's name is a typo and should be fixed.     \nRaises:\n\nTypeError -- if time_ms is not int or float    \n \n"}, {"name": "sprite.LayeredDirty.change_layer", "path": "ref/sprite#pygame.sprite.LayeredDirty.change_layer", "type": "pygame.sprite", "text": "  change_layer() \n changes the layer of the sprite change_layer(sprite, new_layer) -> None  sprite must have been added to the renderer. It is not checked. \n"}, {"name": "sprite.LayeredDirty.clear", "path": "ref/sprite#pygame.sprite.LayeredDirty.clear", "type": "pygame.sprite", "text": "  clear() \n used to set background clear(surface, bgd) -> None  \n"}, {"name": "sprite.LayeredDirty.draw", "path": "ref/sprite#pygame.sprite.LayeredDirty.draw", "type": "pygame.sprite", "text": "  draw() \n draw all sprites in the right order onto the passed surface. draw(surface, bgd=None) -> Rect_list  You can pass the background too. If a background is already set, then the bgd argument has no effect. \n"}, {"name": "sprite.LayeredDirty.get_clip", "path": "ref/sprite#pygame.sprite.LayeredDirty.get_clip", "type": "pygame.sprite", "text": "  get_clip() \n clip the area where to draw. Just pass None (default) to reset the clip get_clip() -> Rect  \n"}, {"name": "sprite.LayeredDirty.repaint_rect", "path": "ref/sprite#pygame.sprite.LayeredDirty.repaint_rect", "type": "pygame.sprite", "text": "  repaint_rect() \n repaints the given area repaint_rect(screen_rect) -> None  screen_rect is in screen coordinates. \n"}, {"name": "sprite.LayeredDirty.set_clip", "path": "ref/sprite#pygame.sprite.LayeredDirty.set_clip", "type": "pygame.sprite", "text": "  set_clip() \n clip the area where to draw. Just pass None (default) to reset the clip set_clip(screen_rect=None) -> None  \n"}, {"name": "sprite.LayeredDirty.set_timing_treshold", "path": "ref/sprite#pygame.sprite.LayeredDirty.set_timing_treshold", "type": "pygame.sprite", "text": "  set_timing_treshold() \n sets the threshold in milliseconds set_timing_treshold(time_ms) -> None  Default is 1000./80 where 80 is the fps I want to switch to full screen mode. This method's name is a typo and should be fixed.     \nRaises:\n\nTypeError -- if time_ms is not int or float    \n"}, {"name": "sprite.LayeredUpdates", "path": "ref/sprite#pygame.sprite.LayeredUpdates", "type": "pygame.sprite", "text": "  pygame.sprite.LayeredUpdates \n LayeredUpdates is a sprite group that handles layers and draws like OrderedUpdates. LayeredUpdates(*spites, **kwargs) -> LayeredUpdates  This group is fully compatible with pygame.sprite.Sprite. You can set the default layer through kwargs using 'default_layer' and an integer for the layer. The default layer is 0. If the sprite you add has an attribute _layer then that layer will be used. If the **kwarg contains 'layer' then the sprites passed will be added to that layer (overriding the sprite.layer attribute). If neither sprite has attribute layer nor **kwarg then the default layer is used to add the sprites.  New in pygame 1.8.    add() \n add a sprite or sequence of sprites to a group add(*sprites, **kwargs) -> None  If the sprite(s) have an attribute layer then that is used for the layer. If **kwargs contains 'layer' then the sprite(s) will be added to that argument (overriding the sprite layer attribute). If neither is passed then the sprite(s) will be added to the default layer. \n   sprites() \n returns a ordered list of sprites (first back, last top). sprites() -> sprites  \n   draw() \n draw all sprites in the right order onto the passed surface. draw(surface) -> Rect_list  \n   get_sprites_at() \n returns a list with all sprites at that position. get_sprites_at(pos) -> colliding_sprites  Bottom sprites first, top last. \n   get_sprite() \n returns the sprite at the index idx from the groups sprites get_sprite(idx) -> sprite  Raises IndexOutOfBounds if the idx is not within range. \n   remove_sprites_of_layer() \n removes all sprites from a layer and returns them as a list. remove_sprites_of_layer(layer_nr) -> sprites  \n   layers() \n returns a list of layers defined (unique), sorted from bottom up. layers() -> layers  \n   change_layer() \n changes the layer of the sprite change_layer(sprite, new_layer) -> None  sprite must have been added to the renderer. It is not checked. \n   get_layer_of_sprite() \n returns the layer that sprite is currently in. get_layer_of_sprite(sprite) -> layer  If the sprite is not found then it will return the default layer. \n   get_top_layer() \n returns the top layer get_top_layer() -> layer  \n   get_bottom_layer() \n returns the bottom layer get_bottom_layer() -> layer  \n   move_to_front() \n brings the sprite to front layer move_to_front(sprite) -> None  Brings the sprite to front, changing sprite layer to topmost layer (added at the end of that layer). \n   move_to_back() \n moves the sprite to the bottom layer move_to_back(sprite) -> None  Moves the sprite to the bottom layer, moving it behind all other layers and adding one additional layer. \n   get_top_sprite() \n returns the topmost sprite get_top_sprite() -> Sprite  \n   get_sprites_from_layer() \n returns all sprites from a layer, ordered by how they where added get_sprites_from_layer(layer) -> sprites  Returns all sprites from a layer, ordered by how they where added. It uses linear search and the sprites are not removed from layer. \n   switch_layer() \n switches the sprites from layer1 to layer2 switch_layer(layer1_nr, layer2_nr) -> None  The layers number must exist, it is not checked. \n \n"}, {"name": "sprite.LayeredUpdates.add", "path": "ref/sprite#pygame.sprite.LayeredUpdates.add", "type": "pygame.sprite", "text": "  add() \n add a sprite or sequence of sprites to a group add(*sprites, **kwargs) -> None  If the sprite(s) have an attribute layer then that is used for the layer. If **kwargs contains 'layer' then the sprite(s) will be added to that argument (overriding the sprite layer attribute). If neither is passed then the sprite(s) will be added to the default layer. \n"}, {"name": "sprite.LayeredUpdates.change_layer", "path": "ref/sprite#pygame.sprite.LayeredUpdates.change_layer", "type": "pygame.sprite", "text": "  change_layer() \n changes the layer of the sprite change_layer(sprite, new_layer) -> None  sprite must have been added to the renderer. It is not checked. \n"}, {"name": "sprite.LayeredUpdates.draw", "path": "ref/sprite#pygame.sprite.LayeredUpdates.draw", "type": "pygame.sprite", "text": "  draw() \n draw all sprites in the right order onto the passed surface. draw(surface) -> Rect_list  \n"}, {"name": "sprite.LayeredUpdates.get_bottom_layer", "path": "ref/sprite#pygame.sprite.LayeredUpdates.get_bottom_layer", "type": "pygame.sprite", "text": "  get_bottom_layer() \n returns the bottom layer get_bottom_layer() -> layer  \n"}, {"name": "sprite.LayeredUpdates.get_layer_of_sprite", "path": "ref/sprite#pygame.sprite.LayeredUpdates.get_layer_of_sprite", "type": "pygame.sprite", "text": "  get_layer_of_sprite() \n returns the layer that sprite is currently in. get_layer_of_sprite(sprite) -> layer  If the sprite is not found then it will return the default layer. \n"}, {"name": "sprite.LayeredUpdates.get_sprite", "path": "ref/sprite#pygame.sprite.LayeredUpdates.get_sprite", "type": "pygame.sprite", "text": "  get_sprite() \n returns the sprite at the index idx from the groups sprites get_sprite(idx) -> sprite  Raises IndexOutOfBounds if the idx is not within range. \n"}, {"name": "sprite.LayeredUpdates.get_sprites_at", "path": "ref/sprite#pygame.sprite.LayeredUpdates.get_sprites_at", "type": "pygame.sprite", "text": "  get_sprites_at() \n returns a list with all sprites at that position. get_sprites_at(pos) -> colliding_sprites  Bottom sprites first, top last. \n"}, {"name": "sprite.LayeredUpdates.get_sprites_from_layer", "path": "ref/sprite#pygame.sprite.LayeredUpdates.get_sprites_from_layer", "type": "pygame.sprite", "text": "  get_sprites_from_layer() \n returns all sprites from a layer, ordered by how they where added get_sprites_from_layer(layer) -> sprites  Returns all sprites from a layer, ordered by how they where added. It uses linear search and the sprites are not removed from layer. \n"}, {"name": "sprite.LayeredUpdates.get_top_layer", "path": "ref/sprite#pygame.sprite.LayeredUpdates.get_top_layer", "type": "pygame.sprite", "text": "  get_top_layer() \n returns the top layer get_top_layer() -> layer  \n"}, {"name": "sprite.LayeredUpdates.get_top_sprite", "path": "ref/sprite#pygame.sprite.LayeredUpdates.get_top_sprite", "type": "pygame.sprite", "text": "  get_top_sprite() \n returns the topmost sprite get_top_sprite() -> Sprite  \n"}, {"name": "sprite.LayeredUpdates.layers", "path": "ref/sprite#pygame.sprite.LayeredUpdates.layers", "type": "pygame.sprite", "text": "  layers() \n returns a list of layers defined (unique), sorted from bottom up. layers() -> layers  \n"}, {"name": "sprite.LayeredUpdates.move_to_back", "path": "ref/sprite#pygame.sprite.LayeredUpdates.move_to_back", "type": "pygame.sprite", "text": "  move_to_back() \n moves the sprite to the bottom layer move_to_back(sprite) -> None  Moves the sprite to the bottom layer, moving it behind all other layers and adding one additional layer. \n"}, {"name": "sprite.LayeredUpdates.move_to_front", "path": "ref/sprite#pygame.sprite.LayeredUpdates.move_to_front", "type": "pygame.sprite", "text": "  move_to_front() \n brings the sprite to front layer move_to_front(sprite) -> None  Brings the sprite to front, changing sprite layer to topmost layer (added at the end of that layer). \n"}, {"name": "sprite.LayeredUpdates.remove_sprites_of_layer", "path": "ref/sprite#pygame.sprite.LayeredUpdates.remove_sprites_of_layer", "type": "pygame.sprite", "text": "  remove_sprites_of_layer() \n removes all sprites from a layer and returns them as a list. remove_sprites_of_layer(layer_nr) -> sprites  \n"}, {"name": "sprite.LayeredUpdates.sprites", "path": "ref/sprite#pygame.sprite.LayeredUpdates.sprites", "type": "pygame.sprite", "text": "  sprites() \n returns a ordered list of sprites (first back, last top). sprites() -> sprites  \n"}, {"name": "sprite.LayeredUpdates.switch_layer", "path": "ref/sprite#pygame.sprite.LayeredUpdates.switch_layer", "type": "pygame.sprite", "text": "  switch_layer() \n switches the sprites from layer1 to layer2 switch_layer(layer1_nr, layer2_nr) -> None  The layers number must exist, it is not checked. \n"}, {"name": "sprite.OrderedUpdates", "path": "ref/sprite#pygame.sprite.OrderedUpdates", "type": "pygame.sprite", "text": "  pygame.sprite.OrderedUpdates() \n RenderUpdates sub-class that draws Sprites in order of addition. OrderedUpdates(*spites) -> OrderedUpdates  This class derives from pygame.sprite.RenderUpdates(). It maintains the order in which the Sprites were added to the Group for rendering. This makes adding and removing Sprites from the Group a little slower than regular Groups. \n"}, {"name": "sprite.RenderClear", "path": "ref/sprite#pygame.sprite.RenderClear", "type": "pygame.sprite", "text": "  pygame.sprite.RenderClear \n Same as pygame.sprite.Group  This class is an alias to pygame.sprite.Group(). It has no additional functionality. \n"}, {"name": "sprite.RenderPlain", "path": "ref/sprite#pygame.sprite.RenderPlain", "type": "pygame.sprite", "text": "  pygame.sprite.RenderPlain \n Same as pygame.sprite.Group  This class is an alias to pygame.sprite.Group(). It has no additional functionality. \n"}, {"name": "sprite.RenderUpdates", "path": "ref/sprite#pygame.sprite.RenderUpdates", "type": "pygame.sprite", "text": "  pygame.sprite.RenderUpdates \n Group sub-class that tracks dirty updates. RenderUpdates(*sprites) -> RenderUpdates  This class is derived from pygame.sprite.Group(). It has an extended draw() method that tracks the changed areas of the screen.   draw() \n blit the Sprite images and track changed areas draw(surface) -> Rect_list  Draws all the Sprites to the surface, the same as Group.draw(). This method also returns a list of Rectangular areas on the screen that have been changed. The returned changes include areas of the screen that have been affected by previous Group.clear() calls. The returned Rect list should be passed to pygame.display.update(). This will help performance on software driven display modes. This type of updating is usually only helpful on destinations with non-animating backgrounds. \n \n"}, {"name": "sprite.RenderUpdates.draw", "path": "ref/sprite#pygame.sprite.RenderUpdates.draw", "type": "pygame.sprite", "text": "  draw() \n blit the Sprite images and track changed areas draw(surface) -> Rect_list  Draws all the Sprites to the surface, the same as Group.draw(). This method also returns a list of Rectangular areas on the screen that have been changed. The returned changes include areas of the screen that have been affected by previous Group.clear() calls. The returned Rect list should be passed to pygame.display.update(). This will help performance on software driven display modes. This type of updating is usually only helpful on destinations with non-animating backgrounds. \n"}, {"name": "sprite.Sprite", "path": "ref/sprite#pygame.sprite.Sprite", "type": "pygame.sprite", "text": "  pygame.sprite.Sprite \n Simple base class for visible game objects. Sprite(*groups) -> Sprite  The base class for visible game objects. Derived classes will want to override the Sprite.update() and assign a Sprite.image and Sprite.rect attributes. The initializer can accept any number of Group instances to be added to. When subclassing the Sprite, be sure to call the base initializer before adding the Sprite to Groups. For example: \nclass Block(pygame.sprite.Sprite):\n\n    # Constructor. Pass in the color of the block,\n    # and its x and y position\n    def __init__(self, color, width, height):\n       # Call the parent class (Sprite) constructor\n       pygame.sprite.Sprite.__init__(self)\n\n       # Create an image of the block, and fill it with a color.\n       # This could also be an image loaded from the disk.\n       self.image = pygame.Surface([width, height])\n       self.image.fill(color)\n\n       # Fetch the rectangle object that has the dimensions of the image\n       # Update the position of this object by setting the values of rect.x and rect.y\n       self.rect = self.image.get_rect()\n    update() \n method to control sprite behavior update(*args, **kwargs) -> None  The default implementation of this method does nothing; it's just a convenient \"hook\" that you can override. This method is called by Group.update() with whatever arguments you give it. There is no need to use this method if not using the convenience method by the same name in the Group class. \n   add() \n add the sprite to groups add(*groups) -> None  Any number of Group instances can be passed as arguments. The Sprite will be added to the Groups it is not already a member of. \n   remove() \n remove the sprite from groups remove(*groups) -> None  Any number of Group instances can be passed as arguments. The Sprite will be removed from the Groups it is currently a member of. \n   kill() \n remove the Sprite from all Groups kill() -> None  The Sprite is removed from all the Groups that contain it. This won't change anything about the state of the Sprite. It is possible to continue to use the Sprite after this method has been called, including adding it to Groups. \n   alive() \n does the sprite belong to any groups alive() -> bool  Returns True when the Sprite belongs to one or more Groups. \n   groups() \n list of Groups that contain this Sprite groups() -> group_list  Return a list of all the Groups that contain this Sprite. \n \n"}, {"name": "sprite.Sprite.add", "path": "ref/sprite#pygame.sprite.Sprite.add", "type": "pygame.sprite", "text": "  add() \n add the sprite to groups add(*groups) -> None  Any number of Group instances can be passed as arguments. The Sprite will be added to the Groups it is not already a member of. \n"}, {"name": "sprite.Sprite.alive", "path": "ref/sprite#pygame.sprite.Sprite.alive", "type": "pygame.sprite", "text": "  alive() \n does the sprite belong to any groups alive() -> bool  Returns True when the Sprite belongs to one or more Groups. \n"}, {"name": "sprite.Sprite.groups", "path": "ref/sprite#pygame.sprite.Sprite.groups", "type": "pygame.sprite", "text": "  groups() \n list of Groups that contain this Sprite groups() -> group_list  Return a list of all the Groups that contain this Sprite. \n"}, {"name": "sprite.Sprite.kill", "path": "ref/sprite#pygame.sprite.Sprite.kill", "type": "pygame.sprite", "text": "  kill() \n remove the Sprite from all Groups kill() -> None  The Sprite is removed from all the Groups that contain it. This won't change anything about the state of the Sprite. It is possible to continue to use the Sprite after this method has been called, including adding it to Groups. \n"}, {"name": "sprite.Sprite.remove", "path": "ref/sprite#pygame.sprite.Sprite.remove", "type": "pygame.sprite", "text": "  remove() \n remove the sprite from groups remove(*groups) -> None  Any number of Group instances can be passed as arguments. The Sprite will be removed from the Groups it is currently a member of. \n"}, {"name": "sprite.Sprite.update", "path": "ref/sprite#pygame.sprite.Sprite.update", "type": "pygame.sprite", "text": "  update() \n method to control sprite behavior update(*args, **kwargs) -> None  The default implementation of this method does nothing; it's just a convenient \"hook\" that you can override. This method is called by Group.update() with whatever arguments you give it. There is no need to use this method if not using the convenience method by the same name in the Group class. \n"}, {"name": "sprite.spritecollide", "path": "ref/sprite#pygame.sprite.spritecollide", "type": "pygame.sprite", "text": "  pygame.sprite.spritecollide() \n Find sprites in a group that intersect another sprite. spritecollide(sprite, group, dokill, collided = None) -> Sprite_list  Return a list containing all Sprites in a Group that intersect with another Sprite. Intersection is determined by comparing the Sprite.rect attribute of each Sprite. The dokill argument is a bool. If set to True, all Sprites that collide will be removed from the Group. The collided argument is a callback function used to calculate if two sprites are colliding. it should take two sprites as values, and return a bool value indicating if they are colliding. If collided is not passed, all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. collided callables: collide_rect, collide_rect_ratio, collide_circle,\ncollide_circle_ratio, collide_mask Example: \n# See if the Sprite block has collided with anything in the Group block_list\n# The True flag will remove the sprite in block_list\nblocks_hit_list = pygame.sprite.spritecollide(player, block_list, True)\n\n# Check the list of colliding sprites, and add one to the score for each one\nfor block in blocks_hit_list:\n    score +=1\n  \n"}, {"name": "sprite.spritecollideany", "path": "ref/sprite#pygame.sprite.spritecollideany", "type": "pygame.sprite", "text": "  pygame.sprite.spritecollideany() \n Simple test if a sprite intersects anything in a group. \nspritecollideany(sprite, group, collided = None) -> Sprite Collision with the returned sprite. \nspritecollideany(sprite, group, collided = None) -> None No collision  If the sprite collides with any single sprite in the group, a single sprite from the group is returned. On no collision None is returned. If you don't need all the features of the pygame.sprite.spritecollide() function, this function will be a bit quicker. The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a \"rect\" value, which is a rectangle of the sprite area, which will be used to calculate the collision. \n"}, {"name": "Surface", "path": "ref/surface", "type": "pygame.Surface", "text": " pygame.Surface\n  \n pygame object for representing images Surface((width, height), flags=0, depth=0, masks=None) -> Surface Surface((width, height), flags=0, Surface) -> Surface  A pygame Surface is used to represent any image. The Surface has a fixed resolution and pixel format. Surfaces with 8-bit pixels use a color palette to map to 24-bit color. Call pygame.Surface() to create a new image object. The Surface will be cleared to all black. The only required arguments are the sizes. With no additional arguments, the Surface will be created in a format that best matches the display Surface. The pixel format can be controlled by passing the bit depth or an existing Surface. The flags argument is a bitmask of additional features for the surface. You can pass any combination of these flags: HWSURFACE    creates the image in video memory\nSRCALPHA     the pixel format will include a per-pixel alpha Both flags are only a request, and may not be possible for all displays and formats. Advance users can combine a set of bitmasks with a depth value. The masks are a set of 4 integers representing which bits in a pixel will represent each color. Normal Surfaces should not require the masks argument. Surfaces can have many extra attributes like alpha planes, colorkeys, source rectangle clipping. These functions mainly effect how the Surface is blitted to other Surfaces. The blit routines will attempt to use hardware acceleration when possible, otherwise they will use highly optimized software blitting methods. There are three types of transparency supported in pygame: colorkeys, surface alphas, and pixel alphas. Surface alphas can be mixed with colorkeys, but an image with per pixel alphas cannot use the other modes. Colorkey transparency makes a single color value transparent. Any pixels matching the colorkey will not be drawn. The surface alpha value is a single value that changes the transparency for the entire image. A surface alpha of 255 is opaque, and a value of 0 is completely transparent. Per pixel alphas are different because they store a transparency value for every pixel. This allows for the most precise transparency effects, but it also the slowest. Per pixel alphas cannot be mixed with surface alpha and colorkeys. There is support for pixel access for the Surfaces. Pixel access on hardware surfaces is slow and not recommended. Pixels can be accessed using the get_at() and set_at() functions. These methods are fine for simple access, but will be considerably slow when doing of pixel work with them. If you plan on doing a lot of pixel level work, it is recommended to use a pygame.PixelArray, which gives an array like view of the surface. For involved mathematical manipulations try the pygame.surfarray module (It's quite quick, but requires NumPy.) Any functions that directly access a surface's pixel data will need that surface to be lock()'ed. These functions can lock() and unlock() the surfaces themselves without assistance. But, if a function will be called many times, there will be a lot of overhead for multiple locking and unlocking of the surface. It is best to lock the surface manually before making the function call many times, and then unlocking when you are finished. All functions that need a locked surface will say so in their docs. Remember to leave the Surface locked only while necessary. Surface pixels are stored internally as a single number that has all the colors encoded into it. Use the map_rgb() and unmap_rgb() to convert between individual red, green, and blue values into a packed integer for that Surface. Surfaces can also reference sections of other Surfaces. These are created with the subsurface() method. Any change to either Surface will effect the other. Each Surface contains a clipping area. By default the clip area covers the entire Surface. If it is changed, all drawing operations will only effect the smaller area.   blit() \n draw one image onto another blit(source, dest, area=None, special_flags=0) -> Rect  Draws a source Surface onto this Surface. The draw can be positioned with the dest argument. The dest argument can either be a pair of coordinates representing the position of the upper left corner of the blit or a Rect, where the upper left corner of the rectangle will be used as the position for the blit. The size of the destination rectangle does not effect the blit. An optional area rectangle can be passed as well. This represents a smaller portion of the source Surface to draw.  New in pygame 1.8: Optional special_flags: BLEND_ADD, BLEND_SUB, BLEND_MULT, BLEND_MIN, BLEND_MAX.   New in pygame 1.8.1: Optional special_flags: BLEND_RGBA_ADD, BLEND_RGBA_SUB, BLEND_RGBA_MULT, BLEND_RGBA_MIN, BLEND_RGBA_MAX BLEND_RGB_ADD, BLEND_RGB_SUB, BLEND_RGB_MULT, BLEND_RGB_MIN, BLEND_RGB_MAX.   New in pygame 1.9.2: Optional special_flags: BLEND_PREMULTIPLIED   New in pygame 2.0.0: Optional special_flags: BLEND_ALPHA_SDL2 - Uses the SDL2 blitter for alpha blending, this gives different results than the default blitter, which is modelled after SDL1, due to different approximations used for the alpha blending formula. The SDL2 blitter also supports RLE on alpha blended surfaces which the pygame one does not.  The return rectangle is the area of the affected pixels, excluding any pixels outside the destination Surface, or outside the clipping area. Pixel alphas will be ignored when blitting to an 8 bit Surface. For a surface with colorkey or blanket alpha, a blit to self may give slightly different colors than a non self-blit. \n   blits() \n draw many images onto another blits(blit_sequence=(source, dest), ...), doreturn=1) -> [Rect, ...] or None blits((source, dest, area), ...)) -> [Rect, ...] blits((source, dest, area, special_flags), ...)) -> [Rect, ...]  Draws many surfaces onto this Surface. It takes a sequence as input, with each of the elements corresponding to the ones of blit(). It needs at minimum a sequence of (source, dest).     \nParameters:\n\n \nblit_sequence -- a sequence of surfaces and arguments to blit them, they correspond to the blit() arguments \ndoreturn -- if True, return a list of rects of the areas changed, otherwise return None\n    \nReturns:\n\na list of rects of the areas changed if doreturn is True, otherwise None   \nReturn type:\n\nlist or None     New in pygame 1.9.4. \n   convert() \n change the pixel format of an image convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface  Creates a new copy of the Surface with the pixel format changed. The new pixel format can be determined from another existing Surface. Otherwise depth, flags, and masks arguments can be used, similar to the pygame.Surface() call. If no arguments are passed the new Surface will have the same pixel format as the display Surface. This is always the fastest format for blitting. It is a good idea to convert all Surfaces before they are blitted many times. The converted Surface will have no pixel alphas. They will be stripped if the original had them. See convert_alpha() for preserving or creating per-pixel alphas. The new copy will have the same class as the copied surface. This lets as Surface subclass inherit this method without the need to override, unless subclass specific instance attributes also need copying. \n   convert_alpha() \n change the pixel format of an image including per pixel alphas convert_alpha(Surface) -> Surface convert_alpha() -> Surface  Creates a new copy of the surface with the desired pixel format. The new surface will be in a format suited for quick blitting to the given format with per pixel alpha. If no surface is given, the new surface will be optimized for blitting to the current display. Unlike the convert() method, the pixel format for the new image will not be exactly the same as the requested source, but it will be optimized for fast alpha blitting to the destination. As with convert() the returned surface has the same class as the converted surface. \n   copy() \n create a new copy of a Surface copy() -> Surface  Makes a duplicate copy of a Surface. The new surface will have the same pixel formats, color palettes, transparency settings, and class as the original. If a Surface subclass also needs to copy any instance specific attributes then it should override copy(). \n   fill() \n fill Surface with a solid color fill(color, rect=None, special_flags=0) -> Rect  Fill the Surface with a solid color. If no rect argument is given the entire Surface will be filled. The rect argument will limit the fill to a specific area. The fill will also be contained by the Surface clip area. The color argument can be either a RGB sequence, a RGBA sequence or a mapped color index. If using RGBA, the Alpha (A part of RGBA) is ignored unless the surface uses per pixel alpha (Surface has the SRCALPHA flag).  New in pygame 1.8: Optional special_flags: BLEND_ADD, BLEND_SUB, BLEND_MULT, BLEND_MIN, BLEND_MAX.   New in pygame 1.8.1: Optional special_flags: BLEND_RGBA_ADD, BLEND_RGBA_SUB, BLEND_RGBA_MULT, BLEND_RGBA_MIN, BLEND_RGBA_MAX BLEND_RGB_ADD, BLEND_RGB_SUB, BLEND_RGB_MULT, BLEND_RGB_MIN, BLEND_RGB_MAX.  This will return the affected Surface area. \n   scroll() \n Shift the surface image in place scroll(dx=0, dy=0) -> None  Move the image by dx pixels right and dy pixels down. dx and dy may be negative for left and up scrolls respectively. Areas of the surface that are not overwritten retain their original pixel values. Scrolling is contained by the Surface clip area. It is safe to have dx and dy values that exceed the surface size.  New in pygame 1.9.  \n   set_colorkey() \n Set the transparent colorkey set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None  Set the current color key for the Surface. When blitting this Surface onto a destination, any pixels that have the same color as the colorkey will be transparent. The color can be an RGB color or a mapped color integer. If None is passed, the colorkey will be unset. The colorkey will be ignored if the Surface is formatted to use per pixel alpha values. The colorkey can be mixed with the full Surface alpha value. The optional flags argument can be set to pygame.RLEACCEL to provide better performance on non accelerated displays. An RLEACCEL Surface will be slower to modify, but quicker to blit as a source. \n   get_colorkey() \n Get the current transparent colorkey get_colorkey() -> RGB or None  Return the current colorkey value for the Surface. If the colorkey is not set then None is returned. \n   set_alpha() \n set the alpha value for the full Surface image set_alpha(value, flags=0) -> None set_alpha(None) -> None  Set the current alpha value for the Surface. When blitting this Surface onto a destination, the pixels will be drawn slightly transparent. The alpha value is an integer from 0 to 255, 0 is fully transparent and 255 is fully opaque. If None is passed for the alpha value, then alpha blending will be disabled, including per-pixel alpha. This value is different than the per pixel Surface alpha. For a surface with per pixel alpha, blanket alpha is ignored and None is returned.  Changed in pygame 2.0: per-surface alpha can be combined with per-pixel alpha.  The optional flags argument can be set to pygame.RLEACCEL to provide better performance on non accelerated displays. An RLEACCEL Surface will be slower to modify, but quicker to blit as a source. \n   get_alpha() \n get the current Surface transparency value get_alpha() -> int_value  Return the current alpha value for the Surface. \n   lock() \n lock the Surface memory for pixel access lock() -> None  Lock the pixel data of a Surface for access. On accelerated Surfaces, the pixel data may be stored in volatile video memory or nonlinear compressed forms. When a Surface is locked the pixel memory becomes available to access by regular software. Code that reads or writes pixel values will need the Surface to be locked. Surfaces should not remain locked for more than necessary. A locked Surface can often not be displayed or managed by pygame. Not all Surfaces require locking. The mustlock() method can determine if it is actually required. There is no performance penalty for locking and unlocking a Surface that does not need it. All pygame functions will automatically lock and unlock the Surface data as needed. If a section of code is going to make calls that will repeatedly lock and unlock the Surface many times, it can be helpful to wrap the block inside a lock and unlock pair. It is safe to nest locking and unlocking calls. The surface will only be unlocked after the final lock is released. \n   unlock() \n unlock the Surface memory from pixel access unlock() -> None  Unlock the Surface pixel data after it has been locked. The unlocked Surface can once again be drawn and managed by pygame. See the lock() documentation for more details. All pygame functions will automatically lock and unlock the Surface data as needed. If a section of code is going to make calls that will repeatedly lock and unlock the Surface many times, it can be helpful to wrap the block inside a lock and unlock pair. It is safe to nest locking and unlocking calls. The surface will only be unlocked after the final lock is released. \n   mustlock() \n test if the Surface requires locking mustlock() -> bool  Returns True if the Surface is required to be locked to access pixel data. Usually pure software Surfaces do not require locking. This method is rarely needed, since it is safe and quickest to just lock all Surfaces as needed. All pygame functions will automatically lock and unlock the Surface data as needed. If a section of code is going to make calls that will repeatedly lock and unlock the Surface many times, it can be helpful to wrap the block inside a lock and unlock pair. \n   get_locked() \n test if the Surface is current locked get_locked() -> bool  Returns True when the Surface is locked. It doesn't matter how many times the Surface is locked. \n   get_locks() \n Gets the locks for the Surface get_locks() -> tuple  Returns the currently existing locks for the Surface. \n   get_at() \n get the color value at a single pixel get_at((x, y)) -> Color  Return a copy of the RGBA Color value at the given pixel. If the Surface has no per pixel alpha, then the alpha value will always be 255 (opaque). If the pixel position is outside the area of the Surface an IndexError exception will be raised. Getting and setting pixels one at a time is generally too slow to be used in a game or realtime situation. It is better to use methods which operate on many pixels at a time like with the blit, fill and draw methods - or by using pygame.surfarray/pygame.PixelArray. This function will temporarily lock and unlock the Surface as needed.  New in pygame 1.9: Returning a Color instead of tuple. Use tuple(surf.get_at((x,y))) if you want a tuple, and not a Color. This should only matter if you want to use the color as a key in a dict.  \n   set_at() \n set the color value for a single pixel set_at((x, y), Color) -> None  Set the RGBA or mapped integer color value for a single pixel. If the Surface does not have per pixel alphas, the alpha value is ignored. Setting pixels outside the Surface area or outside the Surface clipping will have no effect. Getting and setting pixels one at a time is generally too slow to be used in a game or realtime situation. This function will temporarily lock and unlock the Surface as needed. \n   get_at_mapped() \n get the mapped color value at a single pixel get_at_mapped((x, y)) -> Color  Return the integer value of the given pixel. If the pixel position is outside the area of the Surface an IndexError exception will be raised. This method is intended for pygame unit testing. It unlikely has any use in an application. This function will temporarily lock and unlock the Surface as needed.  New in pygame 1.9.2.  \n   get_palette() \n get the color index palette for an 8-bit Surface get_palette() -> [RGB, RGB, RGB, ...]  Return a list of up to 256 color elements that represent the indexed colors used in an 8-bit Surface. The returned list is a copy of the palette, and changes will have no effect on the Surface. Returning a list of Color(with length 3) instances instead of tuples.  New in pygame 1.9.  \n   get_palette_at() \n get the color for a single entry in a palette get_palette_at(index) -> RGB  Returns the red, green, and blue color values for a single index in a Surface palette. The index should be a value from 0 to 255.  New in pygame 1.9: Returning Color(with length 3) instance instead of a tuple.  \n   set_palette() \n set the color palette for an 8-bit Surface set_palette([RGB, RGB, RGB, ...]) -> None  Set the full palette for an 8-bit Surface. This will replace the colors in the existing palette. A partial palette can be passed and only the first colors in the original palette will be changed. This function has no effect on a Surface with more than 8-bits per pixel. \n   set_palette_at() \n set the color for a single index in an 8-bit Surface palette set_palette_at(index, RGB) -> None  Set the palette value for a single entry in a Surface palette. The index should be a value from 0 to 255. This function has no effect on a Surface with more than 8-bits per pixel. \n   map_rgb() \n convert a color into a mapped color value map_rgb(Color) -> mapped_int  Convert an RGBA color into the mapped integer value for this Surface. The returned integer will contain no more bits than the bit depth of the Surface. Mapped color values are not often used inside pygame, but can be passed to most functions that require a Surface and a color. See the Surface object documentation for more information about colors and pixel formats. \n   unmap_rgb() \n convert a mapped integer color value into a Color unmap_rgb(mapped_int) -> Color  Convert an mapped integer color into the RGB color components for this Surface. Mapped color values are not often used inside pygame, but can be passed to most functions that require a Surface and a color. See the Surface object documentation for more information about colors and pixel formats. \n   set_clip() \n set the current clipping area of the Surface set_clip(rect) -> None set_clip(None) -> None  Each Surface has an active clipping area. This is a rectangle that represents the only pixels on the Surface that can be modified. If None is passed for the rectangle the full Surface will be available for changes. The clipping area is always restricted to the area of the Surface itself. If the clip rectangle is too large it will be shrunk to fit inside the Surface. \n   get_clip() \n get the current clipping area of the Surface get_clip() -> Rect  Return a rectangle of the current clipping area. The Surface will always return a valid rectangle that will never be outside the bounds of the image. If the Surface has had None set for the clipping area, the Surface will return a rectangle with the full area of the Surface. \n   subsurface() \n create a new surface that references its parent subsurface(Rect) -> Surface  Returns a new Surface that shares its pixels with its new parent. The new Surface is considered a child of the original. Modifications to either Surface pixels will effect each other. Surface information like clipping area and color keys are unique to each Surface. The new Surface will inherit the palette, color key, and alpha settings from its parent. It is possible to have any number of subsurfaces and subsubsurfaces on the parent. It is also possible to subsurface the display Surface if the display mode is not hardware accelerated. See get_offset() and get_parent() to learn more about the state of a subsurface. A subsurface will have the same class as the parent surface. \n   get_parent() \n find the parent of a subsurface get_parent() -> Surface  Returns the parent Surface of a subsurface. If this is not a subsurface then None will be returned. \n   get_abs_parent() \n find the top level parent of a subsurface get_abs_parent() -> Surface  Returns the parent Surface of a subsurface. If this is not a subsurface then this surface will be returned. \n   get_offset() \n find the position of a child subsurface inside a parent get_offset() -> (x, y)  Get the offset position of a child subsurface inside of a parent. If the Surface is not a subsurface this will return (0, 0). \n   get_abs_offset() \n find the absolute position of a child subsurface inside its top level parent get_abs_offset() -> (x, y)  Get the offset position of a child subsurface inside of its top level parent Surface. If the Surface is not a subsurface this will return (0, 0). \n   get_size() \n get the dimensions of the Surface get_size() -> (width, height)  Return the width and height of the Surface in pixels. \n   get_width() \n get the width of the Surface get_width() -> width  Return the width of the Surface in pixels. \n   get_height() \n get the height of the Surface get_height() -> height  Return the height of the Surface in pixels. \n   get_rect() \n get the rectangular area of the Surface get_rect(**kwargs) -> Rect  Returns a new rectangle covering the entire surface. This rectangle will always start at (0, 0) with a width and height the same size as the image. You can pass keyword argument values to this function. These named values will be applied to the attributes of the Rect before it is returned. An example would be mysurf.get_rect(center=(100, 100)) to create a rectangle for the Surface centered at a given position. \n   get_bitsize() \n get the bit depth of the Surface pixel format get_bitsize() -> int  Returns the number of bits used to represent each pixel. This value may not exactly fill the number of bytes used per pixel. For example a 15 bit Surface still requires a full 2 bytes. \n   get_bytesize() \n get the bytes used per Surface pixel get_bytesize() -> int  Return the number of bytes used per pixel. \n   get_flags() \n get the additional flags used for the Surface get_flags() -> int  Returns a set of current Surface features. Each feature is a bit in the flags bitmask. Typical flags are HWSURFACE, RLEACCEL, SRCALPHA, and SRCCOLORKEY. Here is a more complete list of flags. A full list can be found in SDL_video.h SWSURFACE      0x00000000    # Surface is in system memory\nHWSURFACE      0x00000001    # Surface is in video memory\nASYNCBLIT      0x00000004    # Use asynchronous blits if possible Available for pygame.display.set_mode() ANYFORMAT      0x10000000    # Allow any video depth/pixel-format\nHWPALETTE      0x20000000    # Surface has exclusive palette\nDOUBLEBUF      0x40000000    # Set up double-buffered video mode\nFULLSCREEN     0x80000000    # Surface is a full screen display\nOPENGL         0x00000002    # Create an OpenGL rendering context\nOPENGLBLIT     0x0000000A    # OBSOLETE. Create an OpenGL rendering context and use it for blitting.\nRESIZABLE      0x00000010    # This video mode may be resized\nNOFRAME        0x00000020    # No window caption or edge frame Used internally (read-only) HWACCEL        0x00000100    # Blit uses hardware acceleration\nSRCCOLORKEY    0x00001000    # Blit uses a source color key\nRLEACCELOK     0x00002000    # Private flag\nRLEACCEL       0x00004000    # Surface is RLE encoded\nSRCALPHA       0x00010000    # Blit uses source alpha blending\nPREALLOC       0x01000000    # Surface uses preallocated memory \n   get_pitch() \n get the number of bytes used per Surface row get_pitch() -> int  Return the number of bytes separating each row in the Surface. Surfaces in video memory are not always linearly packed. Subsurfaces will also have a larger pitch than their real width. This value is not needed for normal pygame usage. \n   get_masks() \n the bitmasks needed to convert between a color and a mapped integer get_masks() -> (R, G, B, A)  Returns the bitmasks used to isolate each color in a mapped integer. This value is not needed for normal pygame usage. \n   set_masks() \n set the bitmasks needed to convert between a color and a mapped integer set_masks((r,g,b,a)) -> None  This is not needed for normal pygame usage.  Note In SDL2, the masks are read-only and accordingly this method will raise an AttributeError if called.   New in pygame 1.8.1.  \n   get_shifts() \n the bit shifts needed to convert between a color and a mapped integer get_shifts() -> (R, G, B, A)  Returns the pixel shifts need to convert between each color and a mapped integer. This value is not needed for normal pygame usage. \n   set_shifts() \n sets the bit shifts needed to convert between a color and a mapped integer set_shifts((r,g,b,a)) -> None  This is not needed for normal pygame usage.  Note In SDL2, the shifts are read-only and accordingly this method will raise an AttributeError if called.   New in pygame 1.8.1.  \n   get_losses() \n the significant bits used to convert between a color and a mapped integer get_losses() -> (R, G, B, A)  Return the least significant number of bits stripped from each color in a mapped integer. This value is not needed for normal pygame usage. \n   get_bounding_rect() \n find the smallest rect containing data get_bounding_rect(min_alpha = 1) -> Rect  Returns the smallest rectangular region that contains all the pixels in the surface that have an alpha value greater than or equal to the minimum alpha value. This function will temporarily lock and unlock the Surface as needed.  New in pygame 1.8.  \n   get_view() \n return a buffer view of the Surface's pixels. get_view(<kind>='2') -> BufferProxy  Return an object which exports a surface's internal pixel buffer as a C level array struct, Python level array interface or a C level buffer interface. The pixel buffer is writeable. The new buffer protocol is supported for Python 2.6 and up in CPython. The old buffer protocol is also supported for Python 2.x. The old buffer data is in one segment for kind '0', multi-segment for other buffer view kinds. The kind argument is the length 1 string '0', '1', '2', '3', 'r', 'g', 'b', or 'a'. The letters are case insensitive; 'A' will work as well. The argument can be either a Unicode or byte (char) string. The default is '2'. '0' returns a contiguous unstructured bytes view. No surface shape information is given. A ValueError is raised if the surface's pixels are discontinuous. '1' returns a (surface-width * surface-height) array of continuous pixels. A ValueError is raised if the surface pixels are discontinuous. '2' returns a (surface-width, surface-height) array of raw pixels. The pixels are surface-bytesize-d unsigned integers. The pixel format is surface specific. The 3 byte unsigned integers of 24 bit surfaces are unlikely accepted by anything other than other pygame functions. '3' returns a (surface-width, surface-height, 3) array of RGB color components. Each of the red, green, and blue components are unsigned bytes. Only 24-bit and 32-bit surfaces are supported. The color components must be in either RGB or BGR order within the pixel. 'r' for red, 'g' for green, 'b' for blue, and 'a' for alpha return a (surface-width, surface-height) view of a single color component within a surface: a color plane. Color components are unsigned bytes. Both 24-bit and 32-bit surfaces support 'r', 'g', and 'b'. Only 32-bit surfaces with SRCALPHA support 'a'. The surface is locked only when an exposed interface is accessed. For new buffer interface accesses, the surface is unlocked once the last buffer view is released. For array interface and old buffer interface accesses, the surface remains locked until the BufferProxy object is released.  New in pygame 1.9.2.  \n   get_buffer() \n acquires a buffer object for the pixels of the Surface. get_buffer() -> BufferProxy  Return a buffer object for the pixels of the Surface. The buffer can be used for direct pixel access and manipulation. Surface pixel data is represented as an unstructured block of memory, with a start address and length in bytes. The data need not be contiguous. Any gaps are included in the length, but otherwise ignored. This method implicitly locks the Surface. The lock will be released when the returned pygame.BufferProxy object is garbage collected.  New in pygame 1.8.  \n   _pixels_address \n pixel buffer address _pixels_address -> int  The starting address of the surface's raw pixel bytes.  New in pygame 1.9.2.  \n \n \n"}, {"name": "Surface._pixels_address", "path": "ref/surface#pygame.Surface._pixels_address", "type": "pygame.Surface", "text": "  _pixels_address \n pixel buffer address _pixels_address -> int  The starting address of the surface's raw pixel bytes.  New in pygame 1.9.2.  \n"}, {"name": "Surface.blit", "path": "ref/surface#pygame.Surface.blit", "type": "pygame.Surface", "text": "  blit() \n draw one image onto another blit(source, dest, area=None, special_flags=0) -> Rect  Draws a source Surface onto this Surface. The draw can be positioned with the dest argument. The dest argument can either be a pair of coordinates representing the position of the upper left corner of the blit or a Rect, where the upper left corner of the rectangle will be used as the position for the blit. The size of the destination rectangle does not effect the blit. An optional area rectangle can be passed as well. This represents a smaller portion of the source Surface to draw.  New in pygame 1.8: Optional special_flags: BLEND_ADD, BLEND_SUB, BLEND_MULT, BLEND_MIN, BLEND_MAX.   New in pygame 1.8.1: Optional special_flags: BLEND_RGBA_ADD, BLEND_RGBA_SUB, BLEND_RGBA_MULT, BLEND_RGBA_MIN, BLEND_RGBA_MAX BLEND_RGB_ADD, BLEND_RGB_SUB, BLEND_RGB_MULT, BLEND_RGB_MIN, BLEND_RGB_MAX.   New in pygame 1.9.2: Optional special_flags: BLEND_PREMULTIPLIED   New in pygame 2.0.0: Optional special_flags: BLEND_ALPHA_SDL2 - Uses the SDL2 blitter for alpha blending, this gives different results than the default blitter, which is modelled after SDL1, due to different approximations used for the alpha blending formula. The SDL2 blitter also supports RLE on alpha blended surfaces which the pygame one does not.  The return rectangle is the area of the affected pixels, excluding any pixels outside the destination Surface, or outside the clipping area. Pixel alphas will be ignored when blitting to an 8 bit Surface. For a surface with colorkey or blanket alpha, a blit to self may give slightly different colors than a non self-blit. \n"}, {"name": "Surface.blits", "path": "ref/surface#pygame.Surface.blits", "type": "pygame.Surface", "text": "  blits() \n draw many images onto another blits(blit_sequence=(source, dest), ...), doreturn=1) -> [Rect, ...] or None blits((source, dest, area), ...)) -> [Rect, ...] blits((source, dest, area, special_flags), ...)) -> [Rect, ...]  Draws many surfaces onto this Surface. It takes a sequence as input, with each of the elements corresponding to the ones of blit(). It needs at minimum a sequence of (source, dest).     \nParameters:\n\n \nblit_sequence -- a sequence of surfaces and arguments to blit them, they correspond to the blit() arguments \ndoreturn -- if True, return a list of rects of the areas changed, otherwise return None\n    \nReturns:\n\na list of rects of the areas changed if doreturn is True, otherwise None   \nReturn type:\n\nlist or None     New in pygame 1.9.4. \n"}, {"name": "Surface.convert", "path": "ref/surface#pygame.Surface.convert", "type": "pygame.Surface", "text": "  convert() \n change the pixel format of an image convert(Surface=None) -> Surface convert(depth, flags=0) -> Surface convert(masks, flags=0) -> Surface  Creates a new copy of the Surface with the pixel format changed. The new pixel format can be determined from another existing Surface. Otherwise depth, flags, and masks arguments can be used, similar to the pygame.Surface() call. If no arguments are passed the new Surface will have the same pixel format as the display Surface. This is always the fastest format for blitting. It is a good idea to convert all Surfaces before they are blitted many times. The converted Surface will have no pixel alphas. They will be stripped if the original had them. See convert_alpha() for preserving or creating per-pixel alphas. The new copy will have the same class as the copied surface. This lets as Surface subclass inherit this method without the need to override, unless subclass specific instance attributes also need copying. \n"}, {"name": "Surface.convert_alpha", "path": "ref/surface#pygame.Surface.convert_alpha", "type": "pygame.Surface", "text": "  convert_alpha() \n change the pixel format of an image including per pixel alphas convert_alpha(Surface) -> Surface convert_alpha() -> Surface  Creates a new copy of the surface with the desired pixel format. The new surface will be in a format suited for quick blitting to the given format with per pixel alpha. If no surface is given, the new surface will be optimized for blitting to the current display. Unlike the convert() method, the pixel format for the new image will not be exactly the same as the requested source, but it will be optimized for fast alpha blitting to the destination. As with convert() the returned surface has the same class as the converted surface. \n"}, {"name": "Surface.copy", "path": "ref/surface#pygame.Surface.copy", "type": "pygame.Surface", "text": "  copy() \n create a new copy of a Surface copy() -> Surface  Makes a duplicate copy of a Surface. The new surface will have the same pixel formats, color palettes, transparency settings, and class as the original. If a Surface subclass also needs to copy any instance specific attributes then it should override copy(). \n"}, {"name": "Surface.fill", "path": "ref/surface#pygame.Surface.fill", "type": "pygame.Surface", "text": "  fill() \n fill Surface with a solid color fill(color, rect=None, special_flags=0) -> Rect  Fill the Surface with a solid color. If no rect argument is given the entire Surface will be filled. The rect argument will limit the fill to a specific area. The fill will also be contained by the Surface clip area. The color argument can be either a RGB sequence, a RGBA sequence or a mapped color index. If using RGBA, the Alpha (A part of RGBA) is ignored unless the surface uses per pixel alpha (Surface has the SRCALPHA flag).  New in pygame 1.8: Optional special_flags: BLEND_ADD, BLEND_SUB, BLEND_MULT, BLEND_MIN, BLEND_MAX.   New in pygame 1.8.1: Optional special_flags: BLEND_RGBA_ADD, BLEND_RGBA_SUB, BLEND_RGBA_MULT, BLEND_RGBA_MIN, BLEND_RGBA_MAX BLEND_RGB_ADD, BLEND_RGB_SUB, BLEND_RGB_MULT, BLEND_RGB_MIN, BLEND_RGB_MAX.  This will return the affected Surface area. \n"}, {"name": "Surface.get_abs_offset", "path": "ref/surface#pygame.Surface.get_abs_offset", "type": "pygame.Surface", "text": "  get_abs_offset() \n find the absolute position of a child subsurface inside its top level parent get_abs_offset() -> (x, y)  Get the offset position of a child subsurface inside of its top level parent Surface. If the Surface is not a subsurface this will return (0, 0). \n"}, {"name": "Surface.get_abs_parent", "path": "ref/surface#pygame.Surface.get_abs_parent", "type": "pygame.Surface", "text": "  get_abs_parent() \n find the top level parent of a subsurface get_abs_parent() -> Surface  Returns the parent Surface of a subsurface. If this is not a subsurface then this surface will be returned. \n"}, {"name": "Surface.get_alpha", "path": "ref/surface#pygame.Surface.get_alpha", "type": "pygame.Surface", "text": "  get_alpha() \n get the current Surface transparency value get_alpha() -> int_value  Return the current alpha value for the Surface. \n"}, {"name": "Surface.get_at", "path": "ref/surface#pygame.Surface.get_at", "type": "pygame.Surface", "text": "  get_at() \n get the color value at a single pixel get_at((x, y)) -> Color  Return a copy of the RGBA Color value at the given pixel. If the Surface has no per pixel alpha, then the alpha value will always be 255 (opaque). If the pixel position is outside the area of the Surface an IndexError exception will be raised. Getting and setting pixels one at a time is generally too slow to be used in a game or realtime situation. It is better to use methods which operate on many pixels at a time like with the blit, fill and draw methods - or by using pygame.surfarray/pygame.PixelArray. This function will temporarily lock and unlock the Surface as needed.  New in pygame 1.9: Returning a Color instead of tuple. Use tuple(surf.get_at((x,y))) if you want a tuple, and not a Color. This should only matter if you want to use the color as a key in a dict.  \n"}, {"name": "Surface.get_at_mapped", "path": "ref/surface#pygame.Surface.get_at_mapped", "type": "pygame.Surface", "text": "  get_at_mapped() \n get the mapped color value at a single pixel get_at_mapped((x, y)) -> Color  Return the integer value of the given pixel. If the pixel position is outside the area of the Surface an IndexError exception will be raised. This method is intended for pygame unit testing. It unlikely has any use in an application. This function will temporarily lock and unlock the Surface as needed.  New in pygame 1.9.2.  \n"}, {"name": "Surface.get_bitsize", "path": "ref/surface#pygame.Surface.get_bitsize", "type": "pygame.Surface", "text": "  get_bitsize() \n get the bit depth of the Surface pixel format get_bitsize() -> int  Returns the number of bits used to represent each pixel. This value may not exactly fill the number of bytes used per pixel. For example a 15 bit Surface still requires a full 2 bytes. \n"}, {"name": "Surface.get_bounding_rect", "path": "ref/surface#pygame.Surface.get_bounding_rect", "type": "pygame.Surface", "text": "  get_bounding_rect() \n find the smallest rect containing data get_bounding_rect(min_alpha = 1) -> Rect  Returns the smallest rectangular region that contains all the pixels in the surface that have an alpha value greater than or equal to the minimum alpha value. This function will temporarily lock and unlock the Surface as needed.  New in pygame 1.8.  \n"}, {"name": "Surface.get_buffer", "path": "ref/surface#pygame.Surface.get_buffer", "type": "pygame.Surface", "text": "  get_buffer() \n acquires a buffer object for the pixels of the Surface. get_buffer() -> BufferProxy  Return a buffer object for the pixels of the Surface. The buffer can be used for direct pixel access and manipulation. Surface pixel data is represented as an unstructured block of memory, with a start address and length in bytes. The data need not be contiguous. Any gaps are included in the length, but otherwise ignored. This method implicitly locks the Surface. The lock will be released when the returned pygame.BufferProxy object is garbage collected.  New in pygame 1.8.  \n"}, {"name": "Surface.get_bytesize", "path": "ref/surface#pygame.Surface.get_bytesize", "type": "pygame.Surface", "text": "  get_bytesize() \n get the bytes used per Surface pixel get_bytesize() -> int  Return the number of bytes used per pixel. \n"}, {"name": "Surface.get_clip", "path": "ref/surface#pygame.Surface.get_clip", "type": "pygame.Surface", "text": "  get_clip() \n get the current clipping area of the Surface get_clip() -> Rect  Return a rectangle of the current clipping area. The Surface will always return a valid rectangle that will never be outside the bounds of the image. If the Surface has had None set for the clipping area, the Surface will return a rectangle with the full area of the Surface. \n"}, {"name": "Surface.get_colorkey", "path": "ref/surface#pygame.Surface.get_colorkey", "type": "pygame.Surface", "text": "  get_colorkey() \n Get the current transparent colorkey get_colorkey() -> RGB or None  Return the current colorkey value for the Surface. If the colorkey is not set then None is returned. \n"}, {"name": "Surface.get_flags", "path": "ref/surface#pygame.Surface.get_flags", "type": "pygame.Surface", "text": "  get_flags() \n get the additional flags used for the Surface get_flags() -> int  Returns a set of current Surface features. Each feature is a bit in the flags bitmask. Typical flags are HWSURFACE, RLEACCEL, SRCALPHA, and SRCCOLORKEY. Here is a more complete list of flags. A full list can be found in SDL_video.h SWSURFACE      0x00000000    # Surface is in system memory\nHWSURFACE      0x00000001    # Surface is in video memory\nASYNCBLIT      0x00000004    # Use asynchronous blits if possible Available for pygame.display.set_mode() ANYFORMAT      0x10000000    # Allow any video depth/pixel-format\nHWPALETTE      0x20000000    # Surface has exclusive palette\nDOUBLEBUF      0x40000000    # Set up double-buffered video mode\nFULLSCREEN     0x80000000    # Surface is a full screen display\nOPENGL         0x00000002    # Create an OpenGL rendering context\nOPENGLBLIT     0x0000000A    # OBSOLETE. Create an OpenGL rendering context and use it for blitting.\nRESIZABLE      0x00000010    # This video mode may be resized\nNOFRAME        0x00000020    # No window caption or edge frame Used internally (read-only) HWACCEL        0x00000100    # Blit uses hardware acceleration\nSRCCOLORKEY    0x00001000    # Blit uses a source color key\nRLEACCELOK     0x00002000    # Private flag\nRLEACCEL       0x00004000    # Surface is RLE encoded\nSRCALPHA       0x00010000    # Blit uses source alpha blending\nPREALLOC       0x01000000    # Surface uses preallocated memory \n"}, {"name": "Surface.get_height", "path": "ref/surface#pygame.Surface.get_height", "type": "pygame.Surface", "text": "  get_height() \n get the height of the Surface get_height() -> height  Return the height of the Surface in pixels. \n"}, {"name": "Surface.get_locked", "path": "ref/surface#pygame.Surface.get_locked", "type": "pygame.Surface", "text": "  get_locked() \n test if the Surface is current locked get_locked() -> bool  Returns True when the Surface is locked. It doesn't matter how many times the Surface is locked. \n"}, {"name": "Surface.get_locks", "path": "ref/surface#pygame.Surface.get_locks", "type": "pygame.Surface", "text": "  get_locks() \n Gets the locks for the Surface get_locks() -> tuple  Returns the currently existing locks for the Surface. \n"}, {"name": "Surface.get_losses", "path": "ref/surface#pygame.Surface.get_losses", "type": "pygame.Surface", "text": "  get_losses() \n the significant bits used to convert between a color and a mapped integer get_losses() -> (R, G, B, A)  Return the least significant number of bits stripped from each color in a mapped integer. This value is not needed for normal pygame usage. \n"}, {"name": "Surface.get_masks", "path": "ref/surface#pygame.Surface.get_masks", "type": "pygame.Surface", "text": "  get_masks() \n the bitmasks needed to convert between a color and a mapped integer get_masks() -> (R, G, B, A)  Returns the bitmasks used to isolate each color in a mapped integer. This value is not needed for normal pygame usage. \n"}, {"name": "Surface.get_offset", "path": "ref/surface#pygame.Surface.get_offset", "type": "pygame.Surface", "text": "  get_offset() \n find the position of a child subsurface inside a parent get_offset() -> (x, y)  Get the offset position of a child subsurface inside of a parent. If the Surface is not a subsurface this will return (0, 0). \n"}, {"name": "Surface.get_palette", "path": "ref/surface#pygame.Surface.get_palette", "type": "pygame.Surface", "text": "  get_palette() \n get the color index palette for an 8-bit Surface get_palette() -> [RGB, RGB, RGB, ...]  Return a list of up to 256 color elements that represent the indexed colors used in an 8-bit Surface. The returned list is a copy of the palette, and changes will have no effect on the Surface. Returning a list of Color(with length 3) instances instead of tuples.  New in pygame 1.9.  \n"}, {"name": "Surface.get_palette_at", "path": "ref/surface#pygame.Surface.get_palette_at", "type": "pygame.Surface", "text": "  get_palette_at() \n get the color for a single entry in a palette get_palette_at(index) -> RGB  Returns the red, green, and blue color values for a single index in a Surface palette. The index should be a value from 0 to 255.  New in pygame 1.9: Returning Color(with length 3) instance instead of a tuple.  \n"}, {"name": "Surface.get_parent", "path": "ref/surface#pygame.Surface.get_parent", "type": "pygame.Surface", "text": "  get_parent() \n find the parent of a subsurface get_parent() -> Surface  Returns the parent Surface of a subsurface. If this is not a subsurface then None will be returned. \n"}, {"name": "Surface.get_pitch", "path": "ref/surface#pygame.Surface.get_pitch", "type": "pygame.Surface", "text": "  get_pitch() \n get the number of bytes used per Surface row get_pitch() -> int  Return the number of bytes separating each row in the Surface. Surfaces in video memory are not always linearly packed. Subsurfaces will also have a larger pitch than their real width. This value is not needed for normal pygame usage. \n"}, {"name": "Surface.get_rect", "path": "ref/surface#pygame.Surface.get_rect", "type": "pygame.Surface", "text": "  get_rect() \n get the rectangular area of the Surface get_rect(**kwargs) -> Rect  Returns a new rectangle covering the entire surface. This rectangle will always start at (0, 0) with a width and height the same size as the image. You can pass keyword argument values to this function. These named values will be applied to the attributes of the Rect before it is returned. An example would be mysurf.get_rect(center=(100, 100)) to create a rectangle for the Surface centered at a given position. \n"}, {"name": "Surface.get_shifts", "path": "ref/surface#pygame.Surface.get_shifts", "type": "pygame.Surface", "text": "  get_shifts() \n the bit shifts needed to convert between a color and a mapped integer get_shifts() -> (R, G, B, A)  Returns the pixel shifts need to convert between each color and a mapped integer. This value is not needed for normal pygame usage. \n"}, {"name": "Surface.get_size", "path": "ref/surface#pygame.Surface.get_size", "type": "pygame.Surface", "text": "  get_size() \n get the dimensions of the Surface get_size() -> (width, height)  Return the width and height of the Surface in pixels. \n"}, {"name": "Surface.get_view", "path": "ref/surface#pygame.Surface.get_view", "type": "pygame.Surface", "text": "  get_view() \n return a buffer view of the Surface's pixels. get_view(<kind>='2') -> BufferProxy  Return an object which exports a surface's internal pixel buffer as a C level array struct, Python level array interface or a C level buffer interface. The pixel buffer is writeable. The new buffer protocol is supported for Python 2.6 and up in CPython. The old buffer protocol is also supported for Python 2.x. The old buffer data is in one segment for kind '0', multi-segment for other buffer view kinds. The kind argument is the length 1 string '0', '1', '2', '3', 'r', 'g', 'b', or 'a'. The letters are case insensitive; 'A' will work as well. The argument can be either a Unicode or byte (char) string. The default is '2'. '0' returns a contiguous unstructured bytes view. No surface shape information is given. A ValueError is raised if the surface's pixels are discontinuous. '1' returns a (surface-width * surface-height) array of continuous pixels. A ValueError is raised if the surface pixels are discontinuous. '2' returns a (surface-width, surface-height) array of raw pixels. The pixels are surface-bytesize-d unsigned integers. The pixel format is surface specific. The 3 byte unsigned integers of 24 bit surfaces are unlikely accepted by anything other than other pygame functions. '3' returns a (surface-width, surface-height, 3) array of RGB color components. Each of the red, green, and blue components are unsigned bytes. Only 24-bit and 32-bit surfaces are supported. The color components must be in either RGB or BGR order within the pixel. 'r' for red, 'g' for green, 'b' for blue, and 'a' for alpha return a (surface-width, surface-height) view of a single color component within a surface: a color plane. Color components are unsigned bytes. Both 24-bit and 32-bit surfaces support 'r', 'g', and 'b'. Only 32-bit surfaces with SRCALPHA support 'a'. The surface is locked only when an exposed interface is accessed. For new buffer interface accesses, the surface is unlocked once the last buffer view is released. For array interface and old buffer interface accesses, the surface remains locked until the BufferProxy object is released.  New in pygame 1.9.2.  \n"}, {"name": "Surface.get_width", "path": "ref/surface#pygame.Surface.get_width", "type": "pygame.Surface", "text": "  get_width() \n get the width of the Surface get_width() -> width  Return the width of the Surface in pixels. \n"}, {"name": "Surface.lock", "path": "ref/surface#pygame.Surface.lock", "type": "pygame.Surface", "text": "  lock() \n lock the Surface memory for pixel access lock() -> None  Lock the pixel data of a Surface for access. On accelerated Surfaces, the pixel data may be stored in volatile video memory or nonlinear compressed forms. When a Surface is locked the pixel memory becomes available to access by regular software. Code that reads or writes pixel values will need the Surface to be locked. Surfaces should not remain locked for more than necessary. A locked Surface can often not be displayed or managed by pygame. Not all Surfaces require locking. The mustlock() method can determine if it is actually required. There is no performance penalty for locking and unlocking a Surface that does not need it. All pygame functions will automatically lock and unlock the Surface data as needed. If a section of code is going to make calls that will repeatedly lock and unlock the Surface many times, it can be helpful to wrap the block inside a lock and unlock pair. It is safe to nest locking and unlocking calls. The surface will only be unlocked after the final lock is released. \n"}, {"name": "Surface.map_rgb", "path": "ref/surface#pygame.Surface.map_rgb", "type": "pygame.Surface", "text": "  map_rgb() \n convert a color into a mapped color value map_rgb(Color) -> mapped_int  Convert an RGBA color into the mapped integer value for this Surface. The returned integer will contain no more bits than the bit depth of the Surface. Mapped color values are not often used inside pygame, but can be passed to most functions that require a Surface and a color. See the Surface object documentation for more information about colors and pixel formats. \n"}, {"name": "Surface.mustlock", "path": "ref/surface#pygame.Surface.mustlock", "type": "pygame.Surface", "text": "  mustlock() \n test if the Surface requires locking mustlock() -> bool  Returns True if the Surface is required to be locked to access pixel data. Usually pure software Surfaces do not require locking. This method is rarely needed, since it is safe and quickest to just lock all Surfaces as needed. All pygame functions will automatically lock and unlock the Surface data as needed. If a section of code is going to make calls that will repeatedly lock and unlock the Surface many times, it can be helpful to wrap the block inside a lock and unlock pair. \n"}, {"name": "Surface.scroll", "path": "ref/surface#pygame.Surface.scroll", "type": "pygame.Surface", "text": "  scroll() \n Shift the surface image in place scroll(dx=0, dy=0) -> None  Move the image by dx pixels right and dy pixels down. dx and dy may be negative for left and up scrolls respectively. Areas of the surface that are not overwritten retain their original pixel values. Scrolling is contained by the Surface clip area. It is safe to have dx and dy values that exceed the surface size.  New in pygame 1.9.  \n"}, {"name": "Surface.set_alpha", "path": "ref/surface#pygame.Surface.set_alpha", "type": "pygame.Surface", "text": "  set_alpha() \n set the alpha value for the full Surface image set_alpha(value, flags=0) -> None set_alpha(None) -> None  Set the current alpha value for the Surface. When blitting this Surface onto a destination, the pixels will be drawn slightly transparent. The alpha value is an integer from 0 to 255, 0 is fully transparent and 255 is fully opaque. If None is passed for the alpha value, then alpha blending will be disabled, including per-pixel alpha. This value is different than the per pixel Surface alpha. For a surface with per pixel alpha, blanket alpha is ignored and None is returned.  Changed in pygame 2.0: per-surface alpha can be combined with per-pixel alpha.  The optional flags argument can be set to pygame.RLEACCEL to provide better performance on non accelerated displays. An RLEACCEL Surface will be slower to modify, but quicker to blit as a source. \n"}, {"name": "Surface.set_at", "path": "ref/surface#pygame.Surface.set_at", "type": "pygame.Surface", "text": "  set_at() \n set the color value for a single pixel set_at((x, y), Color) -> None  Set the RGBA or mapped integer color value for a single pixel. If the Surface does not have per pixel alphas, the alpha value is ignored. Setting pixels outside the Surface area or outside the Surface clipping will have no effect. Getting and setting pixels one at a time is generally too slow to be used in a game or realtime situation. This function will temporarily lock and unlock the Surface as needed. \n"}, {"name": "Surface.set_clip", "path": "ref/surface#pygame.Surface.set_clip", "type": "pygame.Surface", "text": "  set_clip() \n set the current clipping area of the Surface set_clip(rect) -> None set_clip(None) -> None  Each Surface has an active clipping area. This is a rectangle that represents the only pixels on the Surface that can be modified. If None is passed for the rectangle the full Surface will be available for changes. The clipping area is always restricted to the area of the Surface itself. If the clip rectangle is too large it will be shrunk to fit inside the Surface. \n"}, {"name": "Surface.set_colorkey", "path": "ref/surface#pygame.Surface.set_colorkey", "type": "pygame.Surface", "text": "  set_colorkey() \n Set the transparent colorkey set_colorkey(Color, flags=0) -> None set_colorkey(None) -> None  Set the current color key for the Surface. When blitting this Surface onto a destination, any pixels that have the same color as the colorkey will be transparent. The color can be an RGB color or a mapped color integer. If None is passed, the colorkey will be unset. The colorkey will be ignored if the Surface is formatted to use per pixel alpha values. The colorkey can be mixed with the full Surface alpha value. The optional flags argument can be set to pygame.RLEACCEL to provide better performance on non accelerated displays. An RLEACCEL Surface will be slower to modify, but quicker to blit as a source. \n"}, {"name": "Surface.set_masks", "path": "ref/surface#pygame.Surface.set_masks", "type": "pygame.Surface", "text": "  set_masks() \n set the bitmasks needed to convert between a color and a mapped integer set_masks((r,g,b,a)) -> None  This is not needed for normal pygame usage.  Note In SDL2, the masks are read-only and accordingly this method will raise an AttributeError if called.   New in pygame 1.8.1.  \n"}, {"name": "Surface.set_palette", "path": "ref/surface#pygame.Surface.set_palette", "type": "pygame.Surface", "text": "  set_palette() \n set the color palette for an 8-bit Surface set_palette([RGB, RGB, RGB, ...]) -> None  Set the full palette for an 8-bit Surface. This will replace the colors in the existing palette. A partial palette can be passed and only the first colors in the original palette will be changed. This function has no effect on a Surface with more than 8-bits per pixel. \n"}, {"name": "Surface.set_palette_at", "path": "ref/surface#pygame.Surface.set_palette_at", "type": "pygame.Surface", "text": "  set_palette_at() \n set the color for a single index in an 8-bit Surface palette set_palette_at(index, RGB) -> None  Set the palette value for a single entry in a Surface palette. The index should be a value from 0 to 255. This function has no effect on a Surface with more than 8-bits per pixel. \n"}, {"name": "Surface.set_shifts", "path": "ref/surface#pygame.Surface.set_shifts", "type": "pygame.Surface", "text": "  set_shifts() \n sets the bit shifts needed to convert between a color and a mapped integer set_shifts((r,g,b,a)) -> None  This is not needed for normal pygame usage.  Note In SDL2, the shifts are read-only and accordingly this method will raise an AttributeError if called.   New in pygame 1.8.1.  \n"}, {"name": "Surface.subsurface", "path": "ref/surface#pygame.Surface.subsurface", "type": "pygame.Surface", "text": "  subsurface() \n create a new surface that references its parent subsurface(Rect) -> Surface  Returns a new Surface that shares its pixels with its new parent. The new Surface is considered a child of the original. Modifications to either Surface pixels will effect each other. Surface information like clipping area and color keys are unique to each Surface. The new Surface will inherit the palette, color key, and alpha settings from its parent. It is possible to have any number of subsurfaces and subsubsurfaces on the parent. It is also possible to subsurface the display Surface if the display mode is not hardware accelerated. See get_offset() and get_parent() to learn more about the state of a subsurface. A subsurface will have the same class as the parent surface. \n"}, {"name": "Surface.unlock", "path": "ref/surface#pygame.Surface.unlock", "type": "pygame.Surface", "text": "  unlock() \n unlock the Surface memory from pixel access unlock() -> None  Unlock the Surface pixel data after it has been locked. The unlocked Surface can once again be drawn and managed by pygame. See the lock() documentation for more details. All pygame functions will automatically lock and unlock the Surface data as needed. If a section of code is going to make calls that will repeatedly lock and unlock the Surface many times, it can be helpful to wrap the block inside a lock and unlock pair. It is safe to nest locking and unlocking calls. The surface will only be unlocked after the final lock is released. \n"}, {"name": "Surface.unmap_rgb", "path": "ref/surface#pygame.Surface.unmap_rgb", "type": "pygame.Surface", "text": "  unmap_rgb() \n convert a mapped integer color value into a Color unmap_rgb(mapped_int) -> Color  Convert an mapped integer color into the RGB color components for this Surface. Mapped color values are not often used inside pygame, but can be passed to most functions that require a Surface and a color. See the Surface object documentation for more information about colors and pixel formats. \n"}, {"name": "surfarray", "path": "ref/surfarray", "type": "pygame.surfarray", "text": " pygame.surfarray\n  \n pygame module for accessing surface pixel data using array interfaces  Functions to convert pixel data between pygame Surfaces and arrays. This module will only be functional when pygame can use the external NumPy package. Every pixel is stored as a single integer value to represent the red, green, and blue colors. The 8-bit images use a value that looks into a colormap. Pixels with higher depth use a bit packing process to place three or four values into a single number. The arrays are indexed by the X axis first, followed by the Y axis. Arrays that treat the pixels as a single integer are referred to as 2D arrays. This module can also separate the red, green, and blue color values into separate indices. These types of arrays are referred to as 3D arrays, and the last index is 0 for red, 1 for green, and 2 for blue.   pygame.surfarray.array2d() \n Copy pixels into a 2d array array2d(Surface) -> array  Copy the mapped (raw) pixels from a Surface into a 2D array. The bit depth of the surface will control the size of the integer values, and will work for any type of pixel format. This function will temporarily lock the Surface as pixels are copied (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.pixels2d() \n Reference pixels into a 2d array pixels2d(Surface) -> array  Create a new 2D array that directly references the pixel values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. Pixels from a 24-bit Surface cannot be referenced, but all other Surface bit depths can. The Surface this references will remain locked for the lifetime of the array (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.array3d() \n Copy pixels into a 3d array array3d(Surface) -> array  Copy the pixels from a Surface into a 3D array. The bit depth of the surface will control the size of the integer values, and will work for any type of pixel format. This function will temporarily lock the Surface as pixels are copied (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.pixels3d() \n Reference pixels into a 3d array pixels3d(Surface) -> array  Create a new 3D array that directly references the pixel values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This will only work on Surfaces that have 24-bit or 32-bit formats. Lower pixel formats cannot be referenced. The Surface this references will remain locked for the lifetime of the array (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.array_alpha() \n Copy pixel alphas into a 2d array array_alpha(Surface) -> array  Copy the pixel alpha values (degree of transparency) from a Surface into a 2D array. This will work for any type of Surface format. Surfaces without a pixel alpha will return an array with all opaque values. This function will temporarily lock the Surface as pixels are copied (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n   pygame.surfarray.pixels_alpha() \n Reference pixel alphas into a 2d array pixels_alpha(Surface) -> array  Create a new 2D array that directly references the alpha values (degree of transparency) in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 32-bit Surfaces with a per-pixel alpha value. The Surface this array references will remain locked for the lifetime of the array. \n   pygame.surfarray.pixels_red() \n Reference pixel red into a 2d array. pixels_red (Surface) -> array  Create a new 2D array that directly references the red values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 24-bit or 32-bit Surfaces. The Surface this array references will remain locked for the lifetime of the array. \n   pygame.surfarray.pixels_green() \n Reference pixel green into a 2d array. pixels_green (Surface) -> array  Create a new 2D array that directly references the green values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 24-bit or 32-bit Surfaces. The Surface this array references will remain locked for the lifetime of the array. \n   pygame.surfarray.pixels_blue() \n Reference pixel blue into a 2d array. pixels_blue (Surface) -> array  Create a new 2D array that directly references the blue values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 24-bit or 32-bit Surfaces. The Surface this array references will remain locked for the lifetime of the array. \n   pygame.surfarray.array_colorkey() \n Copy the colorkey values into a 2d array array_colorkey(Surface) -> array  Create a new array with the colorkey transparency value from each pixel. If the pixel matches the colorkey it will be fully transparent; otherwise it will be fully opaque. This will work on any type of Surface format. If the image has no colorkey a solid opaque array will be returned. This function will temporarily lock the Surface as pixels are copied. \n   pygame.surfarray.make_surface() \n Copy an array to a new surface make_surface(array) -> Surface  Create a new Surface that best resembles the data and format on the array. The array can be 2D or 3D with any sized integer values. Function make_surface uses the array struct interface to acquire array properties, so is not limited to just NumPy arrays. See pygame.pixelcopy. New in pygame 1.9.2: array struct interface support. \n   pygame.surfarray.blit_array() \n Blit directly from a array values blit_array(Surface, array) -> None  Directly copy values from an array into a Surface. This is faster than converting the array into a Surface and blitting. The array must be the same dimensions as the Surface and will completely replace all pixel values. Only integer, ASCII character and record arrays are accepted. This function will temporarily lock the Surface as the new values are copied. \n   pygame.surfarray.map_array() \n Map a 3d array into a 2d array map_array(Surface, array3d) -> array2d  Convert a 3D array into a 2D array. This will use the given Surface format to control the conversion. Palette surface formats are supported for NumPy arrays. \n   pygame.surfarray.use_arraytype() \n Sets the array system to be used for surface arrays use_arraytype (arraytype) -> None  DEPRECATED: Uses the requested array type for the module functions. The only supported arraytype is 'numpy'. Other values will raise ValueError. \n   pygame.surfarray.get_arraytype() \n Gets the currently active array type. get_arraytype () -> str  DEPRECATED: Returns the currently active array type. This will be a value of the get_arraytypes() tuple and indicates which type of array module is used for the array creation.  New in pygame 1.8.  \n   pygame.surfarray.get_arraytypes() \n Gets the array system types currently supported. get_arraytypes () -> tuple  DEPRECATED: Checks, which array systems are available and returns them as a tuple of strings. The values of the tuple can be used directly in the pygame.surfarray.use_arraytype() () method. If no supported array system could be found, None will be returned.  New in pygame 1.8.  \n \n \n"}, {"name": "surfarray.array2d", "path": "ref/surfarray#pygame.surfarray.array2d", "type": "pygame.surfarray", "text": "  pygame.surfarray.array2d() \n Copy pixels into a 2d array array2d(Surface) -> array  Copy the mapped (raw) pixels from a Surface into a 2D array. The bit depth of the surface will control the size of the integer values, and will work for any type of pixel format. This function will temporarily lock the Surface as pixels are copied (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n"}, {"name": "surfarray.array3d", "path": "ref/surfarray#pygame.surfarray.array3d", "type": "pygame.surfarray", "text": "  pygame.surfarray.array3d() \n Copy pixels into a 3d array array3d(Surface) -> array  Copy the pixels from a Surface into a 3D array. The bit depth of the surface will control the size of the integer values, and will work for any type of pixel format. This function will temporarily lock the Surface as pixels are copied (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n"}, {"name": "surfarray.array_alpha", "path": "ref/surfarray#pygame.surfarray.array_alpha", "type": "pygame.surfarray", "text": "  pygame.surfarray.array_alpha() \n Copy pixel alphas into a 2d array array_alpha(Surface) -> array  Copy the pixel alpha values (degree of transparency) from a Surface into a 2D array. This will work for any type of Surface format. Surfaces without a pixel alpha will return an array with all opaque values. This function will temporarily lock the Surface as pixels are copied (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n"}, {"name": "surfarray.array_colorkey", "path": "ref/surfarray#pygame.surfarray.array_colorkey", "type": "pygame.surfarray", "text": "  pygame.surfarray.array_colorkey() \n Copy the colorkey values into a 2d array array_colorkey(Surface) -> array  Create a new array with the colorkey transparency value from each pixel. If the pixel matches the colorkey it will be fully transparent; otherwise it will be fully opaque. This will work on any type of Surface format. If the image has no colorkey a solid opaque array will be returned. This function will temporarily lock the Surface as pixels are copied. \n"}, {"name": "surfarray.blit_array", "path": "ref/surfarray#pygame.surfarray.blit_array", "type": "pygame.surfarray", "text": "  pygame.surfarray.blit_array() \n Blit directly from a array values blit_array(Surface, array) -> None  Directly copy values from an array into a Surface. This is faster than converting the array into a Surface and blitting. The array must be the same dimensions as the Surface and will completely replace all pixel values. Only integer, ASCII character and record arrays are accepted. This function will temporarily lock the Surface as the new values are copied. \n"}, {"name": "surfarray.get_arraytype", "path": "ref/surfarray#pygame.surfarray.get_arraytype", "type": "pygame.surfarray", "text": "  pygame.surfarray.get_arraytype() \n Gets the currently active array type. get_arraytype () -> str  DEPRECATED: Returns the currently active array type. This will be a value of the get_arraytypes() tuple and indicates which type of array module is used for the array creation.  New in pygame 1.8.  \n"}, {"name": "surfarray.get_arraytypes", "path": "ref/surfarray#pygame.surfarray.get_arraytypes", "type": "pygame.surfarray", "text": "  pygame.surfarray.get_arraytypes() \n Gets the array system types currently supported. get_arraytypes () -> tuple  DEPRECATED: Checks, which array systems are available and returns them as a tuple of strings. The values of the tuple can be used directly in the pygame.surfarray.use_arraytype() () method. If no supported array system could be found, None will be returned.  New in pygame 1.8.  \n"}, {"name": "surfarray.make_surface", "path": "ref/surfarray#pygame.surfarray.make_surface", "type": "pygame.surfarray", "text": "  pygame.surfarray.make_surface() \n Copy an array to a new surface make_surface(array) -> Surface  Create a new Surface that best resembles the data and format on the array. The array can be 2D or 3D with any sized integer values. Function make_surface uses the array struct interface to acquire array properties, so is not limited to just NumPy arrays. See pygame.pixelcopy. New in pygame 1.9.2: array struct interface support. \n"}, {"name": "surfarray.map_array", "path": "ref/surfarray#pygame.surfarray.map_array", "type": "pygame.surfarray", "text": "  pygame.surfarray.map_array() \n Map a 3d array into a 2d array map_array(Surface, array3d) -> array2d  Convert a 3D array into a 2D array. This will use the given Surface format to control the conversion. Palette surface formats are supported for NumPy arrays. \n"}, {"name": "surfarray.pixels2d", "path": "ref/surfarray#pygame.surfarray.pixels2d", "type": "pygame.surfarray", "text": "  pygame.surfarray.pixels2d() \n Reference pixels into a 2d array pixels2d(Surface) -> array  Create a new 2D array that directly references the pixel values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. Pixels from a 24-bit Surface cannot be referenced, but all other Surface bit depths can. The Surface this references will remain locked for the lifetime of the array (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n"}, {"name": "surfarray.pixels3d", "path": "ref/surfarray#pygame.surfarray.pixels3d", "type": "pygame.surfarray", "text": "  pygame.surfarray.pixels3d() \n Reference pixels into a 3d array pixels3d(Surface) -> array  Create a new 3D array that directly references the pixel values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This will only work on Surfaces that have 24-bit or 32-bit formats. Lower pixel formats cannot be referenced. The Surface this references will remain locked for the lifetime of the array (see the pygame.Surface.lock() - lock the Surface memory for pixel access method). \n"}, {"name": "surfarray.pixels_alpha", "path": "ref/surfarray#pygame.surfarray.pixels_alpha", "type": "pygame.surfarray", "text": "  pygame.surfarray.pixels_alpha() \n Reference pixel alphas into a 2d array pixels_alpha(Surface) -> array  Create a new 2D array that directly references the alpha values (degree of transparency) in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 32-bit Surfaces with a per-pixel alpha value. The Surface this array references will remain locked for the lifetime of the array. \n"}, {"name": "surfarray.pixels_blue", "path": "ref/surfarray#pygame.surfarray.pixels_blue", "type": "pygame.surfarray", "text": "  pygame.surfarray.pixels_blue() \n Reference pixel blue into a 2d array. pixels_blue (Surface) -> array  Create a new 2D array that directly references the blue values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 24-bit or 32-bit Surfaces. The Surface this array references will remain locked for the lifetime of the array. \n"}, {"name": "surfarray.pixels_green", "path": "ref/surfarray#pygame.surfarray.pixels_green", "type": "pygame.surfarray", "text": "  pygame.surfarray.pixels_green() \n Reference pixel green into a 2d array. pixels_green (Surface) -> array  Create a new 2D array that directly references the green values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 24-bit or 32-bit Surfaces. The Surface this array references will remain locked for the lifetime of the array. \n"}, {"name": "surfarray.pixels_red", "path": "ref/surfarray#pygame.surfarray.pixels_red", "type": "pygame.surfarray", "text": "  pygame.surfarray.pixels_red() \n Reference pixel red into a 2d array. pixels_red (Surface) -> array  Create a new 2D array that directly references the red values in a Surface. Any changes to the array will affect the pixels in the Surface. This is a fast operation since no data is copied. This can only work on 24-bit or 32-bit Surfaces. The Surface this array references will remain locked for the lifetime of the array. \n"}, {"name": "surfarray.use_arraytype", "path": "ref/surfarray#pygame.surfarray.use_arraytype", "type": "pygame.surfarray", "text": "  pygame.surfarray.use_arraytype() \n Sets the array system to be used for surface arrays use_arraytype (arraytype) -> None  DEPRECATED: Uses the requested array type for the module functions. The only supported arraytype is 'numpy'. Other values will raise ValueError. \n"}, {"name": "tests", "path": "ref/tests", "type": "pygame.tests", "text": " pygame.tests\n  \n Pygame unit test suite package  A quick way to run the test suite package from the command line is to import the go submodule with the Python -m option: python -m pygame.tests [<test options>] Command line option --help displays a usage message. Available options correspond to the pygame.tests.run() arguments. The xxxx_test submodules of the tests package are unit test suites for individual parts of pygame. Each can also be run as a main program. This is useful if the test, such as cdrom_test, is interactive. For pygame development the test suite can be run from a pygame distribution root directory. Program run_tests.py is provided for convenience, though test/go.py can be run directly. Module level tags control which modules are included in a unit test run. Tags are assigned to a unit test module with a corresponding <name>_tags.py module. The tags module has the global __tags__, a list of tag names. For example, cdrom_test.py has a tag file cdrom_tags.py containing a tags list that has the 'interactive' string. The 'interactive' tag indicates cdrom_test.py expects user input. It is excluded from a run_tests.py or pygame.tests.go run. Two other tags that are excluded are 'ignore' and 'subprocess_ignore'. These two tags indicate unit tests that will not run on a particular platform, or for which no corresponding pygame module is available. The test runner will list each excluded module along with the tag responsible.   pygame.tests.run() \n Run the pygame unit test suite run(*args, **kwds) -> tuple  Positional arguments (optional): The names of tests to include. If omitted then all tests are run. Test names\nneed not include the trailing '_test'. Keyword arguments: incomplete - fail incomplete tests (default False)\nnosubprocess - run all test suites in the current process\n               (default False, use separate subprocesses)\ndump - dump failures/errors as dict ready to eval (default False)\nfile - if provided, the name of a file into which to dump failures/errors\ntimings - if provided, the number of times to run each individual test to\n          get an average run time (default is run each test once)\nexclude - A list of TAG names to exclude from the run\nshow_output - show silenced stderr/stdout on errors (default False)\nall - dump all results, not just errors (default False)\nrandomize - randomize order of tests (default False)\nseed - if provided, a seed randomizer integer\nmulti_thread - if provided, the number of THREADS in which to run\n               subprocessed tests\ntime_out - if subprocess is True then the time limit in seconds before\n           killing a test (default 30)\nfake - if provided, the name of the fake tests package in the\n       run_tests__tests subpackage to run instead of the normal\n       pygame tests\npython - the path to a python executable to run subprocessed tests\n         (default sys.executable) Return value: A tuple of total number of tests run, dictionary of error information.\nThe dictionary is empty if no errors were recorded. By default individual test modules are run in separate subprocesses. This recreates normal pygame usage where pygame.init() and pygame.quit() are called only once per program execution, and avoids unfortunate interactions between test modules. Also, a time limit is placed on test execution, so frozen tests are killed when there time allotment expired. Use the single process option if threading is not working properly or if tests are taking too long. It is not guaranteed that all tests will pass in single process mode. Tests are run in a randomized order if the randomize argument is True or a seed argument is provided. If no seed integer is provided then the system time is used. Individual test modules may have a __tags__ attribute, a list of tag strings used to selectively omit modules from a run. By default only 'interactive' modules such as cdrom_test are ignored. An interactive module must be run from the console as a Python program. This function can only be called once per Python session. It is not reentrant. \n \n \n"}, {"name": "tests.run", "path": "ref/tests#pygame.tests.run", "type": "pygame.tests", "text": "  pygame.tests.run() \n Run the pygame unit test suite run(*args, **kwds) -> tuple  Positional arguments (optional): The names of tests to include. If omitted then all tests are run. Test names\nneed not include the trailing '_test'. Keyword arguments: incomplete - fail incomplete tests (default False)\nnosubprocess - run all test suites in the current process\n               (default False, use separate subprocesses)\ndump - dump failures/errors as dict ready to eval (default False)\nfile - if provided, the name of a file into which to dump failures/errors\ntimings - if provided, the number of times to run each individual test to\n          get an average run time (default is run each test once)\nexclude - A list of TAG names to exclude from the run\nshow_output - show silenced stderr/stdout on errors (default False)\nall - dump all results, not just errors (default False)\nrandomize - randomize order of tests (default False)\nseed - if provided, a seed randomizer integer\nmulti_thread - if provided, the number of THREADS in which to run\n               subprocessed tests\ntime_out - if subprocess is True then the time limit in seconds before\n           killing a test (default 30)\nfake - if provided, the name of the fake tests package in the\n       run_tests__tests subpackage to run instead of the normal\n       pygame tests\npython - the path to a python executable to run subprocessed tests\n         (default sys.executable) Return value: A tuple of total number of tests run, dictionary of error information.\nThe dictionary is empty if no errors were recorded. By default individual test modules are run in separate subprocesses. This recreates normal pygame usage where pygame.init() and pygame.quit() are called only once per program execution, and avoids unfortunate interactions between test modules. Also, a time limit is placed on test execution, so frozen tests are killed when there time allotment expired. Use the single process option if threading is not working properly or if tests are taking too long. It is not guaranteed that all tests will pass in single process mode. Tests are run in a randomized order if the randomize argument is True or a seed argument is provided. If no seed integer is provided then the system time is used. Individual test modules may have a __tags__ attribute, a list of tag strings used to selectively omit modules from a run. By default only 'interactive' modules such as cdrom_test are ignored. An interactive module must be run from the console as a Python program. This function can only be called once per Python session. It is not reentrant. \n"}, {"name": "time", "path": "ref/time", "type": "pygame.time", "text": " pygame.time\n  \n pygame module for monitoring time  Times in pygame are represented in milliseconds (1/1000 seconds). Most platforms have a limited time resolution of around 10 milliseconds. This resolution, in milliseconds, is given in the TIMER_RESOLUTION constant.   pygame.time.get_ticks() \n get the time in milliseconds get_ticks() -> milliseconds  Return the number of milliseconds since pygame.init() was called. Before pygame is initialized this will always be 0. \n   pygame.time.wait() \n pause the program for an amount of time wait(milliseconds) -> time  Will pause for a given number of milliseconds. This function sleeps the process to share the processor with other programs. A program that waits for even a few milliseconds will consume very little processor time. It is slightly less accurate than the pygame.time.delay() function. This returns the actual number of milliseconds used. \n   pygame.time.delay() \n pause the program for an amount of time delay(milliseconds) -> time  Will pause for a given number of milliseconds. This function will use the processor (rather than sleeping) in order to make the delay more accurate than pygame.time.wait(). This returns the actual number of milliseconds used. \n   pygame.time.set_timer() \n repeatedly create an event on the event queue set_timer(eventid, milliseconds) -> None set_timer(eventid, milliseconds, once) -> None  Set an event type to appear on the event queue every given number of milliseconds. The first event will not appear until the amount of time has passed. Every event type can have a separate timer attached to it. It is best to use the value between pygame.USEREVENT and pygame.NUMEVENTS. To disable the timer for an event, set the milliseconds argument to 0. If the once argument is True, then only send the timer once.  New in pygame 2.0.0.dev3: once argument added.  \n   pygame.time.Clock \n create an object to help track time Clock() -> Clock  Creates a new Clock object that can be used to track an amount of time. The clock also provides several functions to help control a game's framerate.   tick() \n update the clock tick(framerate=0) -> milliseconds  This method should be called once per frame. It will compute how many milliseconds have passed since the previous call. If you pass the optional framerate argument the function will delay to keep the game running slower than the given ticks per second. This can be used to help limit the runtime speed of a game. By calling Clock.tick(40) once per frame, the program will never run at more than 40 frames per second. Note that this function uses SDL_Delay function which is not accurate on every platform, but does not use much CPU. Use tick_busy_loop if you want an accurate timer, and don't mind chewing CPU. \n   tick_busy_loop() \n update the clock tick_busy_loop(framerate=0) -> milliseconds  This method should be called once per frame. It will compute how many milliseconds have passed since the previous call. If you pass the optional framerate argument the function will delay to keep the game running slower than the given ticks per second. This can be used to help limit the runtime speed of a game. By calling Clock.tick_busy_loop(40) once per frame, the program will never run at more than 40 frames per second. Note that this function uses pygame.time.delay(), which uses lots of CPU in a busy loop to make sure that timing is more accurate.  New in pygame 1.8.  \n   get_time() \n time used in the previous tick get_time() -> milliseconds  The number of milliseconds that passed between the previous two calls to Clock.tick(). \n   get_rawtime() \n actual time used in the previous tick get_rawtime() -> milliseconds  Similar to Clock.get_time(), but does not include any time used while Clock.tick() was delaying to limit the framerate. \n   get_fps() \n compute the clock framerate get_fps() -> float  Compute your game's framerate (in frames per second). It is computed by averaging the last ten calls to Clock.tick(). \n \n \n \n"}, {"name": "time.Clock", "path": "ref/time#pygame.time.Clock", "type": "pygame.time", "text": "  pygame.time.Clock \n create an object to help track time Clock() -> Clock  Creates a new Clock object that can be used to track an amount of time. The clock also provides several functions to help control a game's framerate.   tick() \n update the clock tick(framerate=0) -> milliseconds  This method should be called once per frame. It will compute how many milliseconds have passed since the previous call. If you pass the optional framerate argument the function will delay to keep the game running slower than the given ticks per second. This can be used to help limit the runtime speed of a game. By calling Clock.tick(40) once per frame, the program will never run at more than 40 frames per second. Note that this function uses SDL_Delay function which is not accurate on every platform, but does not use much CPU. Use tick_busy_loop if you want an accurate timer, and don't mind chewing CPU. \n   tick_busy_loop() \n update the clock tick_busy_loop(framerate=0) -> milliseconds  This method should be called once per frame. It will compute how many milliseconds have passed since the previous call. If you pass the optional framerate argument the function will delay to keep the game running slower than the given ticks per second. This can be used to help limit the runtime speed of a game. By calling Clock.tick_busy_loop(40) once per frame, the program will never run at more than 40 frames per second. Note that this function uses pygame.time.delay(), which uses lots of CPU in a busy loop to make sure that timing is more accurate.  New in pygame 1.8.  \n   get_time() \n time used in the previous tick get_time() -> milliseconds  The number of milliseconds that passed between the previous two calls to Clock.tick(). \n   get_rawtime() \n actual time used in the previous tick get_rawtime() -> milliseconds  Similar to Clock.get_time(), but does not include any time used while Clock.tick() was delaying to limit the framerate. \n   get_fps() \n compute the clock framerate get_fps() -> float  Compute your game's framerate (in frames per second). It is computed by averaging the last ten calls to Clock.tick(). \n \n"}, {"name": "time.Clock.get_fps", "path": "ref/time#pygame.time.Clock.get_fps", "type": "pygame.time", "text": "  get_fps() \n compute the clock framerate get_fps() -> float  Compute your game's framerate (in frames per second). It is computed by averaging the last ten calls to Clock.tick(). \n"}, {"name": "time.Clock.get_rawtime", "path": "ref/time#pygame.time.Clock.get_rawtime", "type": "pygame.time", "text": "  get_rawtime() \n actual time used in the previous tick get_rawtime() -> milliseconds  Similar to Clock.get_time(), but does not include any time used while Clock.tick() was delaying to limit the framerate. \n"}, {"name": "time.Clock.get_time", "path": "ref/time#pygame.time.Clock.get_time", "type": "pygame.time", "text": "  get_time() \n time used in the previous tick get_time() -> milliseconds  The number of milliseconds that passed between the previous two calls to Clock.tick(). \n"}, {"name": "time.Clock.tick", "path": "ref/time#pygame.time.Clock.tick", "type": "pygame.time", "text": "  tick() \n update the clock tick(framerate=0) -> milliseconds  This method should be called once per frame. It will compute how many milliseconds have passed since the previous call. If you pass the optional framerate argument the function will delay to keep the game running slower than the given ticks per second. This can be used to help limit the runtime speed of a game. By calling Clock.tick(40) once per frame, the program will never run at more than 40 frames per second. Note that this function uses SDL_Delay function which is not accurate on every platform, but does not use much CPU. Use tick_busy_loop if you want an accurate timer, and don't mind chewing CPU. \n"}, {"name": "time.Clock.tick_busy_loop", "path": "ref/time#pygame.time.Clock.tick_busy_loop", "type": "pygame.time", "text": "  tick_busy_loop() \n update the clock tick_busy_loop(framerate=0) -> milliseconds  This method should be called once per frame. It will compute how many milliseconds have passed since the previous call. If you pass the optional framerate argument the function will delay to keep the game running slower than the given ticks per second. This can be used to help limit the runtime speed of a game. By calling Clock.tick_busy_loop(40) once per frame, the program will never run at more than 40 frames per second. Note that this function uses pygame.time.delay(), which uses lots of CPU in a busy loop to make sure that timing is more accurate.  New in pygame 1.8.  \n"}, {"name": "time.delay", "path": "ref/time#pygame.time.delay", "type": "pygame.time", "text": "  pygame.time.delay() \n pause the program for an amount of time delay(milliseconds) -> time  Will pause for a given number of milliseconds. This function will use the processor (rather than sleeping) in order to make the delay more accurate than pygame.time.wait(). This returns the actual number of milliseconds used. \n"}, {"name": "time.get_ticks", "path": "ref/time#pygame.time.get_ticks", "type": "pygame.time", "text": "  pygame.time.get_ticks() \n get the time in milliseconds get_ticks() -> milliseconds  Return the number of milliseconds since pygame.init() was called. Before pygame is initialized this will always be 0. \n"}, {"name": "time.set_timer", "path": "ref/time#pygame.time.set_timer", "type": "pygame.time", "text": "  pygame.time.set_timer() \n repeatedly create an event on the event queue set_timer(eventid, milliseconds) -> None set_timer(eventid, milliseconds, once) -> None  Set an event type to appear on the event queue every given number of milliseconds. The first event will not appear until the amount of time has passed. Every event type can have a separate timer attached to it. It is best to use the value between pygame.USEREVENT and pygame.NUMEVENTS. To disable the timer for an event, set the milliseconds argument to 0. If the once argument is True, then only send the timer once.  New in pygame 2.0.0.dev3: once argument added.  \n"}, {"name": "time.wait", "path": "ref/time#pygame.time.wait", "type": "pygame.time", "text": "  pygame.time.wait() \n pause the program for an amount of time wait(milliseconds) -> time  Will pause for a given number of milliseconds. This function sleeps the process to share the processor with other programs. A program that waits for even a few milliseconds will consume very little processor time. It is slightly less accurate than the pygame.time.delay() function. This returns the actual number of milliseconds used. \n"}, {"name": "transform", "path": "ref/transform", "type": "pygame.transform", "text": " pygame.transform\n  \n pygame module to transform surfaces  A Surface transform is an operation that moves or resizes the pixels. All these functions take a Surface to operate on and return a new Surface with the results. Some of the transforms are considered destructive. These means every time they are performed they lose pixel data. Common examples of this are resizing and rotating. For this reason, it is better to re-transform the original surface than to keep transforming an image multiple times. (For example, suppose you are animating a bouncing spring which expands and contracts. If you applied the size changes incrementally to the previous images, you would lose detail. Instead, always begin with the original image and scale to the desired size.)   pygame.transform.flip() \n flip vertically and horizontally flip(Surface, xbool, ybool) -> Surface  This can flip a Surface either vertically, horizontally, or both. Flipping a Surface is non-destructive and returns a new Surface with the same dimensions. \n   pygame.transform.scale() \n resize to new resolution scale(Surface, (width, height), DestSurface = None) -> Surface  Resizes the Surface to a new resolution. This is a fast scale operation that does not sample the results. An optional destination surface can be used, rather than have it create a new one. This is quicker if you want to repeatedly scale something. However the destination must be the same size as the (width, height) passed in. Also the destination surface must be the same format. \n   pygame.transform.rotate() \n rotate an image rotate(Surface, angle) -> Surface  Unfiltered counterclockwise rotation. The angle argument represents degrees and can be any floating point value. Negative angle amounts will rotate clockwise. Unless rotating by 90 degree increments, the image will be padded larger to hold the new size. If the image has pixel alphas, the padded area will be transparent. Otherwise pygame will pick a color that matches the Surface colorkey or the topleft pixel value. \n   pygame.transform.rotozoom() \n filtered scale and rotation rotozoom(Surface, angle, scale) -> Surface  This is a combined scale and rotation transform. The resulting Surface will be a filtered 32-bit Surface. The scale argument is a floating point value that will be multiplied by the current resolution. The angle argument is a floating point value that represents the counterclockwise degrees to rotate. A negative rotation angle will rotate clockwise. \n   pygame.transform.scale2x() \n specialized image doubler scale2x(Surface, DestSurface = None) -> Surface  This will return a new image that is double the size of the original. It uses the AdvanceMAME Scale2X algorithm which does a 'jaggie-less' scale of bitmap graphics. This really only has an effect on simple images with solid colors. On photographic and antialiased images it will look like a regular unfiltered scale. An optional destination surface can be used, rather than have it create a new one. This is quicker if you want to repeatedly scale something. However the destination must be twice the size of the source surface passed in. Also the destination surface must be the same format. \n   pygame.transform.smoothscale() \n scale a surface to an arbitrary size smoothly smoothscale(Surface, (width, height), DestSurface = None) -> Surface  Uses one of two different algorithms for scaling each dimension of the input surface as required. For shrinkage, the output pixels are area averages of the colors they cover. For expansion, a bilinear filter is used. For the x86-64 and i686 architectures, optimized MMX routines are included and will run much faster than other machine types. The size is a 2 number sequence for (width, height). This function only works for 24-bit or 32-bit surfaces. An exception will be thrown if the input surface bit depth is less than 24.  New in pygame 1.8.  \n   pygame.transform.get_smoothscale_backend() \n return smoothscale filter version in use: 'GENERIC', 'MMX', or 'SSE' get_smoothscale_backend() -> String  Shows whether or not smoothscale is using MMX or SSE acceleration. If no acceleration is available then \"GENERIC\" is returned. For a x86 processor the level of acceleration to use is determined at runtime. This function is provided for pygame testing and debugging. \n   pygame.transform.set_smoothscale_backend() \n set smoothscale filter version to one of: 'GENERIC', 'MMX', or 'SSE' set_smoothscale_backend(type) -> None  Sets smoothscale acceleration. Takes a string argument. A value of 'GENERIC' turns off acceleration. 'MMX' uses MMX instructions only. 'SSE' allows SSE extensions as well. A value error is raised if type is not recognized or not supported by the current processor. This function is provided for pygame testing and debugging. If smoothscale causes an invalid instruction error then it is a pygame/SDL bug that should be reported. Use this function as a temporary fix only. \n   pygame.transform.chop() \n gets a copy of an image with an interior area removed chop(Surface, rect) -> Surface  Extracts a portion of an image. All vertical and horizontal pixels surrounding the given rectangle area are removed. The corner areas (diagonal to the rect) are then brought together. (The original image is not altered by this operation.) NOTE: If you want a \"crop\" that returns the part of an image within a rect, you can blit with a rect to a new surface or copy a subsurface. \n   pygame.transform.laplacian() \n find edges in a surface laplacian(Surface, DestSurface = None) -> Surface  Finds the edges in a surface using the laplacian algorithm.  New in pygame 1.8.  \n   pygame.transform.average_surfaces() \n find the average surface from many surfaces. average_surfaces(Surfaces, DestSurface = None, palette_colors = 1) -> Surface  Takes a sequence of surfaces and returns a surface with average colors from each of the surfaces. palette_colors - if true we average the colors in palette, otherwise we average the pixel values. This is useful if the surface is actually greyscale colors, and not palette colors. Note, this function currently does not handle palette using surfaces correctly.  New in pygame 1.8.   New in pygame 1.9: palette_colors argument  \n   pygame.transform.average_color() \n finds the average color of a surface average_color(Surface, Rect = None) -> Color  Finds the average color of a Surface or a region of a surface specified by a Rect, and returns it as a Color. \n   pygame.transform.threshold() \n finds which, and how many pixels in a surface are within a threshold of a 'search_color' or a 'search_surf'. threshold(dest_surf, surf, search_color, threshold=(0,0,0,0), set_color=(0,0,0,0), set_behavior=1, search_surf=None, inverse_set=False) -> num_threshold_pixels  This versatile function can be used for find colors in a 'surf' close to a 'search_color' or close to colors in a separate 'search_surf'. It can also be used to transfer pixels into a 'dest_surf' that match or don't match. By default it sets pixels in the 'dest_surf' where all of the pixels NOT within the threshold are changed to set_color. If inverse_set is optionally set to True, the pixels that ARE within the threshold are changed to set_color. If the optional 'search_surf' surface is given, it is used to threshold against rather than the specified 'set_color'. That is, it will find each pixel in the 'surf' that is within the 'threshold' of the pixel at the same coordinates of the 'search_surf'.     \nParameters:\n\n \ndest_surf (pygame.Surface or None) -- Surface we are changing. See 'set_behavior'. Should be None if counting (set_behavior is 0). \nsurf (pygame.Surface) -- Surface we are looking at. \nsearch_color (pygame.Color) -- Color we are searching for. \nthreshold (pygame.Color) -- Within this distance from search_color (or search_surf). You can use a threshold of (r,g,b,a) where the r,g,b can have different thresholds. So you could use an r threshold of 40 and a blue threshold of 2 if you like. \nset_color (pygame.Color or None) -- Color we set in dest_surf. \nset_behavior (int) --  set_behavior=1 (default). Pixels in dest_surface will be changed to 'set_color'. set_behavior=0 we do not change 'dest_surf', just count. Make dest_surf=None. set_behavior=2 pixels set in 'dest_surf' will be from 'surf'.   \nsearch_surf (pygame.Surface or None) --  search_surf=None (default). Search against 'search_color' instead. search_surf=Surface. Look at the color in 'search_surf' rather than using 'search_color'.   \ninverse_set (bool) --  False, default. Pixels outside of threshold are changed. True, Pixels within threshold are changed.      \nReturn type:\n\nint   \nReturns:\n\nThe number of pixels that are within the 'threshold' in 'surf' compared to either 'search_color' or search_surf.   \nExamples:\n    See the threshold tests for a full of examples: https://github.com/pygame/pygame/blob/master/test/transform_test.py def test_threshold_dest_surf_not_change(self):\n        \"\"\" the pixels within the threshold.\n\n        All pixels not within threshold are changed to set_color.\n        So there should be none changed in this test.\n        \"\"\"\n        (w, h) = size = (32, 32)\n        threshold = (20, 20, 20, 20)\n        original_color = (25, 25, 25, 25)\n        original_dest_color = (65, 65, 65, 55)\n        threshold_color = (10, 10, 10, 10)\n        set_color = (255, 10, 10, 10)\n\n        surf = pygame.Surface(size, pygame.SRCALPHA, 32)\n        dest_surf = pygame.Surface(size, pygame.SRCALPHA, 32)\n        search_surf = pygame.Surface(size, pygame.SRCALPHA, 32)\n\n        surf.fill(original_color)\n        search_surf.fill(threshold_color)\n        dest_surf.fill(original_dest_color)\n\n        # set_behavior=1, set dest_surface from set_color.\n        # all within threshold of third_surface, so no color is set.\n\n        THRESHOLD_BEHAVIOR_FROM_SEARCH_COLOR = 1\n        pixels_within_threshold = pygame.transform.threshold(\n            dest_surf=dest_surf,\n            surf=surf,\n            search_color=None,\n            threshold=threshold,\n            set_color=set_color,\n            set_behavior=THRESHOLD_BEHAVIOR_FROM_SEARCH_COLOR,\n            search_surf=search_surf,\n        )\n\n        # # Return, of pixels within threshold is correct\n        self.assertEqual(w * h, pixels_within_threshold)\n\n        # # Size of dest surface is correct\n        dest_rect = dest_surf.get_rect()\n        dest_size = dest_rect.size\n        self.assertEqual(size, dest_size)\n\n        # The color is not the change_color specified for every pixel As all\n        # pixels are within threshold\n\n        for pt in test_utils.rect_area_pts(dest_rect):\n            self.assertNotEqual(dest_surf.get_at(pt), set_color)\n            self.assertEqual(dest_surf.get_at(pt), original_dest_color)  New in pygame 1.8.   Changed in pygame 1.9.4: Fixed a lot of bugs and added keyword arguments. Test your code.  \n \n \n"}, {"name": "transform.average_color", "path": "ref/transform#pygame.transform.average_color", "type": "pygame.transform", "text": "  pygame.transform.average_color() \n finds the average color of a surface average_color(Surface, Rect = None) -> Color  Finds the average color of a Surface or a region of a surface specified by a Rect, and returns it as a Color. \n"}, {"name": "transform.average_surfaces", "path": "ref/transform#pygame.transform.average_surfaces", "type": "pygame.transform", "text": "  pygame.transform.average_surfaces() \n find the average surface from many surfaces. average_surfaces(Surfaces, DestSurface = None, palette_colors = 1) -> Surface  Takes a sequence of surfaces and returns a surface with average colors from each of the surfaces. palette_colors - if true we average the colors in palette, otherwise we average the pixel values. This is useful if the surface is actually greyscale colors, and not palette colors. Note, this function currently does not handle palette using surfaces correctly.  New in pygame 1.8.   New in pygame 1.9: palette_colors argument  \n"}, {"name": "transform.chop", "path": "ref/transform#pygame.transform.chop", "type": "pygame.transform", "text": "  pygame.transform.chop() \n gets a copy of an image with an interior area removed chop(Surface, rect) -> Surface  Extracts a portion of an image. All vertical and horizontal pixels surrounding the given rectangle area are removed. The corner areas (diagonal to the rect) are then brought together. (The original image is not altered by this operation.) NOTE: If you want a \"crop\" that returns the part of an image within a rect, you can blit with a rect to a new surface or copy a subsurface. \n"}, {"name": "transform.flip", "path": "ref/transform#pygame.transform.flip", "type": "pygame.transform", "text": "  pygame.transform.flip() \n flip vertically and horizontally flip(Surface, xbool, ybool) -> Surface  This can flip a Surface either vertically, horizontally, or both. Flipping a Surface is non-destructive and returns a new Surface with the same dimensions. \n"}, {"name": "transform.get_smoothscale_backend", "path": "ref/transform#pygame.transform.get_smoothscale_backend", "type": "pygame.transform", "text": "  pygame.transform.get_smoothscale_backend() \n return smoothscale filter version in use: 'GENERIC', 'MMX', or 'SSE' get_smoothscale_backend() -> String  Shows whether or not smoothscale is using MMX or SSE acceleration. If no acceleration is available then \"GENERIC\" is returned. For a x86 processor the level of acceleration to use is determined at runtime. This function is provided for pygame testing and debugging. \n"}, {"name": "transform.laplacian", "path": "ref/transform#pygame.transform.laplacian", "type": "pygame.transform", "text": "  pygame.transform.laplacian() \n find edges in a surface laplacian(Surface, DestSurface = None) -> Surface  Finds the edges in a surface using the laplacian algorithm.  New in pygame 1.8.  \n"}, {"name": "transform.rotate", "path": "ref/transform#pygame.transform.rotate", "type": "pygame.transform", "text": "  pygame.transform.rotate() \n rotate an image rotate(Surface, angle) -> Surface  Unfiltered counterclockwise rotation. The angle argument represents degrees and can be any floating point value. Negative angle amounts will rotate clockwise. Unless rotating by 90 degree increments, the image will be padded larger to hold the new size. If the image has pixel alphas, the padded area will be transparent. Otherwise pygame will pick a color that matches the Surface colorkey or the topleft pixel value. \n"}, {"name": "transform.rotozoom", "path": "ref/transform#pygame.transform.rotozoom", "type": "pygame.transform", "text": "  pygame.transform.rotozoom() \n filtered scale and rotation rotozoom(Surface, angle, scale) -> Surface  This is a combined scale and rotation transform. The resulting Surface will be a filtered 32-bit Surface. The scale argument is a floating point value that will be multiplied by the current resolution. The angle argument is a floating point value that represents the counterclockwise degrees to rotate. A negative rotation angle will rotate clockwise. \n"}, {"name": "transform.scale", "path": "ref/transform#pygame.transform.scale", "type": "pygame.transform", "text": "  pygame.transform.scale() \n resize to new resolution scale(Surface, (width, height), DestSurface = None) -> Surface  Resizes the Surface to a new resolution. This is a fast scale operation that does not sample the results. An optional destination surface can be used, rather than have it create a new one. This is quicker if you want to repeatedly scale something. However the destination must be the same size as the (width, height) passed in. Also the destination surface must be the same format. \n"}, {"name": "transform.scale2x", "path": "ref/transform#pygame.transform.scale2x", "type": "pygame.transform", "text": "  pygame.transform.scale2x() \n specialized image doubler scale2x(Surface, DestSurface = None) -> Surface  This will return a new image that is double the size of the original. It uses the AdvanceMAME Scale2X algorithm which does a 'jaggie-less' scale of bitmap graphics. This really only has an effect on simple images with solid colors. On photographic and antialiased images it will look like a regular unfiltered scale. An optional destination surface can be used, rather than have it create a new one. This is quicker if you want to repeatedly scale something. However the destination must be twice the size of the source surface passed in. Also the destination surface must be the same format. \n"}, {"name": "transform.set_smoothscale_backend", "path": "ref/transform#pygame.transform.set_smoothscale_backend", "type": "pygame.transform", "text": "  pygame.transform.set_smoothscale_backend() \n set smoothscale filter version to one of: 'GENERIC', 'MMX', or 'SSE' set_smoothscale_backend(type) -> None  Sets smoothscale acceleration. Takes a string argument. A value of 'GENERIC' turns off acceleration. 'MMX' uses MMX instructions only. 'SSE' allows SSE extensions as well. A value error is raised if type is not recognized or not supported by the current processor. This function is provided for pygame testing and debugging. If smoothscale causes an invalid instruction error then it is a pygame/SDL bug that should be reported. Use this function as a temporary fix only. \n"}, {"name": "transform.smoothscale", "path": "ref/transform#pygame.transform.smoothscale", "type": "pygame.transform", "text": "  pygame.transform.smoothscale() \n scale a surface to an arbitrary size smoothly smoothscale(Surface, (width, height), DestSurface = None) -> Surface  Uses one of two different algorithms for scaling each dimension of the input surface as required. For shrinkage, the output pixels are area averages of the colors they cover. For expansion, a bilinear filter is used. For the x86-64 and i686 architectures, optimized MMX routines are included and will run much faster than other machine types. The size is a 2 number sequence for (width, height). This function only works for 24-bit or 32-bit surfaces. An exception will be thrown if the input surface bit depth is less than 24.  New in pygame 1.8.  \n"}, {"name": "transform.threshold", "path": "ref/transform#pygame.transform.threshold", "type": "pygame.transform", "text": "  pygame.transform.threshold() \n finds which, and how many pixels in a surface are within a threshold of a 'search_color' or a 'search_surf'. threshold(dest_surf, surf, search_color, threshold=(0,0,0,0), set_color=(0,0,0,0), set_behavior=1, search_surf=None, inverse_set=False) -> num_threshold_pixels  This versatile function can be used for find colors in a 'surf' close to a 'search_color' or close to colors in a separate 'search_surf'. It can also be used to transfer pixels into a 'dest_surf' that match or don't match. By default it sets pixels in the 'dest_surf' where all of the pixels NOT within the threshold are changed to set_color. If inverse_set is optionally set to True, the pixels that ARE within the threshold are changed to set_color. If the optional 'search_surf' surface is given, it is used to threshold against rather than the specified 'set_color'. That is, it will find each pixel in the 'surf' that is within the 'threshold' of the pixel at the same coordinates of the 'search_surf'.     \nParameters:\n\n \ndest_surf (pygame.Surface or None) -- Surface we are changing. See 'set_behavior'. Should be None if counting (set_behavior is 0). \nsurf (pygame.Surface) -- Surface we are looking at. \nsearch_color (pygame.Color) -- Color we are searching for. \nthreshold (pygame.Color) -- Within this distance from search_color (or search_surf). You can use a threshold of (r,g,b,a) where the r,g,b can have different thresholds. So you could use an r threshold of 40 and a blue threshold of 2 if you like. \nset_color (pygame.Color or None) -- Color we set in dest_surf. \nset_behavior (int) --  set_behavior=1 (default). Pixels in dest_surface will be changed to 'set_color'. set_behavior=0 we do not change 'dest_surf', just count. Make dest_surf=None. set_behavior=2 pixels set in 'dest_surf' will be from 'surf'.   \nsearch_surf (pygame.Surface or None) --  search_surf=None (default). Search against 'search_color' instead. search_surf=Surface. Look at the color in 'search_surf' rather than using 'search_color'.   \ninverse_set (bool) --  False, default. Pixels outside of threshold are changed. True, Pixels within threshold are changed.      \nReturn type:\n\nint   \nReturns:\n\nThe number of pixels that are within the 'threshold' in 'surf' compared to either 'search_color' or search_surf.   \nExamples:\n    See the threshold tests for a full of examples: https://github.com/pygame/pygame/blob/master/test/transform_test.py def test_threshold_dest_surf_not_change(self):\n        \"\"\" the pixels within the threshold.\n\n        All pixels not within threshold are changed to set_color.\n        So there should be none changed in this test.\n        \"\"\"\n        (w, h) = size = (32, 32)\n        threshold = (20, 20, 20, 20)\n        original_color = (25, 25, 25, 25)\n        original_dest_color = (65, 65, 65, 55)\n        threshold_color = (10, 10, 10, 10)\n        set_color = (255, 10, 10, 10)\n\n        surf = pygame.Surface(size, pygame.SRCALPHA, 32)\n        dest_surf = pygame.Surface(size, pygame.SRCALPHA, 32)\n        search_surf = pygame.Surface(size, pygame.SRCALPHA, 32)\n\n        surf.fill(original_color)\n        search_surf.fill(threshold_color)\n        dest_surf.fill(original_dest_color)\n\n        # set_behavior=1, set dest_surface from set_color.\n        # all within threshold of third_surface, so no color is set.\n\n        THRESHOLD_BEHAVIOR_FROM_SEARCH_COLOR = 1\n        pixels_within_threshold = pygame.transform.threshold(\n            dest_surf=dest_surf,\n            surf=surf,\n            search_color=None,\n            threshold=threshold,\n            set_color=set_color,\n            set_behavior=THRESHOLD_BEHAVIOR_FROM_SEARCH_COLOR,\n            search_surf=search_surf,\n        )\n\n        # # Return, of pixels within threshold is correct\n        self.assertEqual(w * h, pixels_within_threshold)\n\n        # # Size of dest surface is correct\n        dest_rect = dest_surf.get_rect()\n        dest_size = dest_rect.size\n        self.assertEqual(size, dest_size)\n\n        # The color is not the change_color specified for every pixel As all\n        # pixels are within threshold\n\n        for pt in test_utils.rect_area_pts(dest_rect):\n            self.assertNotEqual(dest_surf.get_at(pt), set_color)\n            self.assertEqual(dest_surf.get_at(pt), original_dest_color)  New in pygame 1.8.   Changed in pygame 1.9.4: Fixed a lot of bugs and added keyword arguments. Test your code.  \n"}, {"name": "version.rev", "path": "ref/pygame#pygame.version.rev", "type": "pygame", "text": "  pygame.version.rev \n repository revision of the build rev = 'a6f89747b551+'  The Mercurial node identifier of the repository checkout from which this package was built. If the identifier ends with a plus sign '+' then the package contains uncommitted changes. Please include this revision number in bug reports, especially for non-release pygame builds. Important note: pygame development has moved to github, this variable is obsolete now. As soon as development shifted to github, this variable started returning an empty string \"\". It has always been returning an empty string since v1.9.5.  Changed in pygame 1.9.5: Always returns an empty string \"\".  \n"}, {"name": "version.SDL", "path": "ref/pygame#pygame.version.SDL", "type": "pygame", "text": "  pygame.version.SDL \n tupled integers of the SDL library version SDL = '(2, 0, 12)'  This is the SDL library version represented as an extended tuple. It also has attributes 'major', 'minor' & 'patch' that can be accessed like this: >>> pygame.version.SDL.major\n2 printing the whole thing returns a string like this: >>> pygame.version.SDL\nSDLVersion(major=2, minor=0, patch=12)  New in pygame 2.0.0.  \n"}, {"name": "version.ver", "path": "ref/pygame#pygame.version.ver", "type": "pygame", "text": "  pygame.version.ver \n version number as a string ver = '1.2'  This is the version represented as a string. It can contain a micro release number as well, e.g. '1.5.2' \n"}, {"name": "version.vernum", "path": "ref/pygame#pygame.version.vernum", "type": "pygame", "text": "  pygame.version.vernum \n tupled integers of the version vernum = (1, 5, 3)  This version information can easily be compared with other version numbers of the same format. An example of checking pygame version numbers would look like this: if pygame.version.vernum < (1, 5):\n    print('Warning, older version of pygame (%s)' %  pygame.version.ver)\n    disable_advanced_features = True  New in pygame 1.9.6: Attributes major, minor, and patch.  vernum.major == vernum[0]\nvernum.minor == vernum[1]\nvernum.patch == vernum[2]  Changed in pygame 1.9.6: str(pygame.version.vernum) returns a string like \"2.0.0\" instead of \"(2, 0, 0)\".   Changed in pygame 1.9.6: repr(pygame.version.vernum) returns a string like \"PygameVersion(major=2, minor=0, patch=0)\" instead of \"(2, 0, 0)\".  \n"}]