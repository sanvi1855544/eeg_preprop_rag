[{"name": "0: Quickstart", "path": "tutorial/quickstart/index", "type": "Tutorial", "text": "\nWe're going to create a simple API to allow admin users to view and edit the\nusers and groups in the system.\n\nCreate a new Django project named `tutorial`, then start a new app called\n`quickstart`.\n\nThe project layout should look like:\n\nIt may look unusual that the application has been created within the project\ndirectory. Using the project's namespace avoids name clashes with external\nmodules (a topic that goes outside the scope of the quickstart).\n\nNow sync your database for the first time:\n\nWe'll also create an initial user named `admin` with a password of\n`password123`. We'll authenticate as that user later in our example.\n\nOnce you've set up a database and the initial user is created and ready to go,\nopen up the app's directory and we'll get coding...\n\nFirst up we're going to define some serializers. Let's create a new module\nnamed `tutorial/quickstart/serializers.py` that we'll use for our data\nrepresentations.\n\nNotice that we're using hyperlinked relations in this case with\n`HyperlinkedModelSerializer`. You can also use primary key and various other\nrelationships, but hyperlinking is good RESTful design.\n\nRight, we'd better write some views then. Open `tutorial/quickstart/views.py`\nand get typing.\n\nRather than write multiple views we're grouping together all the common\nbehavior into classes called `ViewSets`.\n\nWe can easily break these down into individual views if we need to, but using\nviewsets keeps the view logic nicely organized as well as being very concise.\n\nOkay, now let's wire up the API URLs. On to `tutorial/urls.py`...\n\nBecause we're using viewsets instead of views, we can automatically generate\nthe URL conf for our API, by simply registering the viewsets with a router\nclass.\n\nAgain, if we need more control over the API URLs we can simply drop down to\nusing regular class-based views, and writing the URL conf explicitly.\n\nFinally, we're including default login and logout views for use with the\nbrowsable API. That's optional, but useful if your API requires authentication\nand you want to use the browsable API.\n\nPagination allows you to control how many objects per page are returned. To\nenable it add the following lines to `tutorial/settings.py`\n\nAdd `'rest_framework'` to `INSTALLED_APPS`. The settings module will be in\n`tutorial/settings.py`\n\nOkay, we're done.\n\nWe're now ready to test the API we've built. Let's fire up the server from the\ncommand line.\n\nWe can now access our API, both from the command-line, using tools like\n`curl`...\n\nOr using the httpie, command line tool...\n\nOr directly through the browser, by going to the URL\n`http://127.0.0.1:8000/users/`...\n\nIf you're working through the browser, make sure to login using the control in\nthe top right corner.\n\nGreat, that was easy!\n\nIf you want to get a more in depth understanding of how REST framework fits\ntogether head on over to the tutorial, or start browsing the API guide.\n\n"}, {"name": "1: Serialization", "path": "tutorial/1-serialization/index", "type": "Tutorial", "text": "\nThis tutorial will cover creating a simple pastebin code highlighting Web API.\nAlong the way it will introduce the various components that make up REST\nframework, and give you a comprehensive understanding of how everything fits\ntogether.\n\nThe tutorial is fairly in-depth, so you should probably get a cookie and a cup\nof your favorite brew before getting started. If you just want a quick\noverview, you should head over to the quickstart documentation instead.\n\nNote: The code for this tutorial is available in the encode/rest-framework-\ntutorial repository on GitHub. The completed implementation is also online as\na sandbox version for testing, available here.\n\nBefore we do anything else we'll create a new virtual environment, using venv.\nThis will make sure our package configuration is kept nicely isolated from any\nother projects we're working on.\n\nNow that we're inside a virtual environment, we can install our package\nrequirements.\n\nNote: To exit the virtual environment at any time, just type `deactivate`. For\nmore information see the venv documentation.\n\nOkay, we're ready to get coding. To get started, let's create a new project to\nwork with.\n\nOnce that's done we can create an app that we'll use to create a simple Web\nAPI.\n\nWe'll need to add our new `snippets` app and the `rest_framework` app to\n`INSTALLED_APPS`. Let's edit the `tutorial/settings.py` file:\n\nOkay, we're ready to roll.\n\nFor the purposes of this tutorial we're going to start by creating a simple\n`Snippet` model that is used to store code snippets. Go ahead and edit the\n`snippets/models.py` file. Note: Good programming practices include comments.\nAlthough you will find them in our repository version of this tutorial code,\nwe have omitted them here to focus on the code itself.\n\nWe'll also need to create an initial migration for our snippet model, and sync\nthe database for the first time.\n\nThe first thing we need to get started on our Web API is to provide a way of\nserializing and deserializing the snippet instances into representations such\nas `json`. We can do this by declaring serializers that work very similar to\nDjango's forms. Create a file in the `snippets` directory named\n`serializers.py` and add the following.\n\nThe first part of the serializer class defines the fields that get\nserialized/deserialized. The `create()` and `update()` methods define how\nfully fledged instances are created or modified when calling\n`serializer.save()`\n\nA serializer class is very similar to a Django `Form` class, and includes\nsimilar validation flags on the various fields, such as `required`,\n`max_length` and `default`.\n\nThe field flags can also control how the serializer should be displayed in\ncertain circumstances, such as when rendering to HTML. The `{'base_template':\n'textarea.html'}` flag above is equivalent to using `widget=widgets.Textarea`\non a Django `Form` class. This is particularly useful for controlling how the\nbrowsable API should be displayed, as we'll see later in the tutorial.\n\nWe can actually also save ourselves some time by using the `ModelSerializer`\nclass, as we'll see later, but for now we'll keep our serializer definition\nexplicit.\n\nBefore we go any further we'll familiarize ourselves with using our new\nSerializer class. Let's drop into the Django shell.\n\nOkay, once we've got a few imports out of the way, let's create a couple of\ncode snippets to work with.\n\nWe've now got a few snippet instances to play with. Let's take a look at\nserializing one of those instances.\n\nAt this point we've translated the model instance into Python native\ndatatypes. To finalize the serialization process we render the data into\n`json`.\n\nDeserialization is similar. First we parse a stream into Python native\ndatatypes...\n\n...then we restore those native datatypes into a fully populated object\ninstance.\n\nNotice how similar the API is to working with forms. The similarity should\nbecome even more apparent when we start writing views that use our serializer.\n\nWe can also serialize querysets instead of model instances. To do so we simply\nadd a `many=True` flag to the serializer arguments.\n\nOur `SnippetSerializer` class is replicating a lot of information that's also\ncontained in the `Snippet` model. It would be nice if we could keep our code a\nbit more concise.\n\nIn the same way that Django provides both `Form` classes and `ModelForm`\nclasses, REST framework includes both `Serializer` classes, and\n`ModelSerializer` classes.\n\nLet's look at refactoring our serializer using the `ModelSerializer` class.\nOpen the file `snippets/serializers.py` again, and replace the\n`SnippetSerializer` class with the following.\n\nOne nice property that serializers have is that you can inspect all the fields\nin a serializer instance, by printing its representation. Open the Django\nshell with `python manage.py shell`, then try the following:\n\nIt's important to remember that `ModelSerializer` classes don't do anything\nparticularly magical, they are simply a shortcut for creating serializer\nclasses:\n\nLet's see how we can write some API views using our new Serializer class. For\nthe moment we won't use any of REST framework's other features, we'll just\nwrite the views as regular Django views.\n\nEdit the `snippets/views.py` file, and add the following.\n\nThe root of our API is going to be a view that supports listing all the\nexisting snippets, or creating a new snippet.\n\nNote that because we want to be able to POST to this view from clients that\nwon't have a CSRF token we need to mark the view as `csrf_exempt`. This isn't\nsomething that you'd normally want to do, and REST framework views actually\nuse more sensible behavior than this, but it'll do for our purposes right now.\n\nWe'll also need a view which corresponds to an individual snippet, and can be\nused to retrieve, update or delete the snippet.\n\nFinally we need to wire these views up. Create the `snippets/urls.py` file:\n\nWe also need to wire up the root urlconf, in the `tutorial/urls.py` file, to\ninclude our snippet app's URLs.\n\nIt's worth noting that there are a couple of edge cases we're not dealing with\nproperly at the moment. If we send malformed `json`, or if a request is made\nwith a method that the view doesn't handle, then we'll end up with a 500\n\"server error\" response. Still, this'll do for now.\n\nNow we can start up a sample server that serves our snippets.\n\nQuit out of the shell...\n\n...and start up Django's development server.\n\nIn another terminal window, we can test the server.\n\nWe can test our API using curl or httpie. Httpie is a user friendly http\nclient that's written in Python. Let's install that.\n\nYou can install httpie using pip:\n\nFinally, we can get a list of all of the snippets:\n\nOr we can get a particular snippet by referencing its id:\n\nSimilarly, you can have the same json displayed by visiting these URLs in a\nweb browser.\n\nWe're doing okay so far, we've got a serialization API that feels pretty\nsimilar to Django's Forms API, and some regular Django views.\n\nOur API views don't do anything particularly special at the moment, beyond\nserving `json` responses, and there are some error handling edge cases we'd\nstill like to clean up, but it's a functioning Web API.\n\nWe'll see how we can start to improve things in part 2 of the tutorial.\n\n"}, {"name": "2: Requests and Responses", "path": "tutorial/2-requests-and-responses/index", "type": "Tutorial", "text": "\nFrom this point we're going to really start covering the core of REST\nframework. Let's introduce a couple of essential building blocks.\n\nREST framework introduces a `Request` object that extends the regular\n`HttpRequest`, and provides more flexible request parsing. The core\nfunctionality of the `Request` object is the `request.data` attribute, which\nis similar to `request.POST`, but more useful for working with Web APIs.\n\nREST framework also introduces a `Response` object, which is a type of\n`TemplateResponse` that takes unrendered content and uses content negotiation\nto determine the correct content type to return to the client.\n\nUsing numeric HTTP status codes in your views doesn't always make for obvious\nreading, and it's easy to not notice if you get an error code wrong. REST\nframework provides more explicit identifiers for each status code, such as\n`HTTP_400_BAD_REQUEST` in the `status` module. It's a good idea to use these\nthroughout rather than using numeric identifiers.\n\nREST framework provides two wrappers you can use to write API views.\n\nThese wrappers provide a few bits of functionality such as making sure you\nreceive `Request` instances in your view, and adding context to `Response`\nobjects so that content negotiation can be performed.\n\nThe wrappers also provide behaviour such as returning `405 Method Not Allowed`\nresponses when appropriate, and handling any `ParseError` exceptions that\noccur when accessing `request.data` with malformed input.\n\nOkay, let's go ahead and start using these new components to refactor our\nviews slightly.\n\nOur instance view is an improvement over the previous example. It's a little\nmore concise, and the code now feels very similar to if we were working with\nthe Forms API. We're also using named status codes, which makes the response\nmeanings more obvious.\n\nHere is the view for an individual snippet, in the `views.py` module.\n\nThis should all feel very familiar - it is not a lot different from working\nwith regular Django views.\n\nNotice that we're no longer explicitly tying our requests or responses to a\ngiven content type. `request.data` can handle incoming `json` requests, but it\ncan also handle other formats. Similarly we're returning response objects with\ndata, but allowing REST framework to render the response into the correct\ncontent type for us.\n\nTo take advantage of the fact that our responses are no longer hardwired to a\nsingle content type let's add support for format suffixes to our API\nendpoints. Using format suffixes gives us URLs that explicitly refer to a\ngiven format, and means our API will be able to handle URLs such as\nhttp://example.com/api/items/4.json.\n\nStart by adding a `format` keyword argument to both of the views, like so.\n\nand\n\nNow update the `snippets/urls.py` file slightly, to append a set of\n`format_suffix_patterns` in addition to the existing URLs.\n\nWe don't necessarily need to add these extra url patterns in, but it gives us\na simple, clean way of referring to a specific format.\n\nGo ahead and test the API from the command line, as we did in tutorial part 1.\nEverything is working pretty similarly, although we've got some nicer error\nhandling if we send invalid requests.\n\nWe can get a list of all of the snippets, as before.\n\nWe can control the format of the response that we get back, either by using\nthe `Accept` header:\n\nOr by appending a format suffix:\n\nSimilarly, we can control the format of the request that we send, using the\n`Content-Type` header.\n\nIf you add a `--debug` switch to the `http` requests above, you will be able\nto see the request type in request headers.\n\nNow go and open the API in a web browser, by visiting\nhttp://127.0.0.1:8000/snippets/.\n\nBecause the API chooses the content type of the response based on the client\nrequest, it will, by default, return an HTML-formatted representation of the\nresource when that resource is requested by a web browser. This allows for the\nAPI to return a fully web-browsable HTML representation.\n\nHaving a web-browsable API is a huge usability win, and makes developing and\nusing your API much easier. It also dramatically lowers the barrier-to-entry\nfor other developers wanting to inspect and work with your API.\n\nSee the browsable api topic for more information about the browsable API\nfeature and how to customize it.\n\nIn tutorial part 3, we'll start using class-based views, and see how generic\nviews reduce the amount of code we need to write.\n\n"}, {"name": "3: Class-based Views", "path": "tutorial/3-class-based-views/index", "type": "Tutorial", "text": "\nWe can also write our API views using class-based views, rather than function\nbased views. As we'll see this is a powerful pattern that allows us to reuse\ncommon functionality, and helps us keep our code DRY.\n\nWe'll start by rewriting the root view as a class-based view. All this\ninvolves is a little bit of refactoring of `views.py`.\n\nSo far, so good. It looks pretty similar to the previous case, but we've got\nbetter separation between the different HTTP methods. We'll also need to\nupdate the instance view in `views.py`.\n\nThat's looking good. Again, it's still pretty similar to the function based\nview right now.\n\nWe'll also need to refactor our `snippets/urls.py` slightly now that we're\nusing class-based views.\n\nOkay, we're done. If you run the development server everything should be\nworking just as before.\n\nOne of the big wins of using class-based views is that it allows us to easily\ncompose reusable bits of behaviour.\n\nThe create/retrieve/update/delete operations that we've been using so far are\ngoing to be pretty similar for any model-backed API views we create. Those\nbits of common behaviour are implemented in REST framework's mixin classes.\n\nLet's take a look at how we can compose the views by using the mixin classes.\nHere's our `views.py` module again.\n\nWe'll take a moment to examine exactly what's happening here. We're building\nour view using `GenericAPIView`, and adding in `ListModelMixin` and\n`CreateModelMixin`.\n\nThe base class provides the core functionality, and the mixin classes provide\nthe `.list()` and `.create()` actions. We're then explicitly binding the `get`\nand `post` methods to the appropriate actions. Simple enough stuff so far.\n\nPretty similar. Again we're using the `GenericAPIView` class to provide the\ncore functionality, and adding in mixins to provide the `.retrieve()`,\n`.update()` and `.destroy()` actions.\n\nUsing the mixin classes we've rewritten the views to use slightly less code\nthan before, but we can go one step further. REST framework provides a set of\nalready mixed-in generic views that we can use to trim down our `views.py`\nmodule even more.\n\nWow, that's pretty concise. We've gotten a huge amount for free, and our code\nlooks like good, clean, idiomatic Django.\n\nNext we'll move onto part 4 of the tutorial, where we'll take a look at how we\ncan deal with authentication and permissions for our API.\n\n"}, {"name": "4: Authentication & Permissions", "path": "tutorial/4-authentication-and-permissions/index", "type": "Tutorial", "text": "\nCurrently our API doesn't have any restrictions on who can edit or delete code\nsnippets. We'd like to have some more advanced behavior in order to make sure\nthat:\n\nWe're going to make a couple of changes to our `Snippet` model class. First,\nlet's add a couple of fields. One of those fields will be used to represent\nthe user who created the code snippet. The other field will be used to store\nthe highlighted HTML representation of the code.\n\nAdd the following two fields to the `Snippet` model in `models.py`.\n\nWe'd also need to make sure that when the model is saved, that we populate the\nhighlighted field, using the `pygments` code highlighting library.\n\nWe'll need some extra imports:\n\nAnd now we can add a `.save()` method to our model class:\n\nWhen that's all done we'll need to update our database tables. Normally we'd\ncreate a database migration in order to do that, but for the purposes of this\ntutorial, let's just delete the database and start again.\n\nYou might also want to create a few different users, to use for testing the\nAPI. The quickest way to do this will be with the `createsuperuser` command.\n\nNow that we've got some users to work with, we'd better add representations of\nthose users to our API. Creating a new serializer is easy. In `serializers.py`\nadd:\n\nBecause `'snippets'` is a reverse relationship on the User model, it will not\nbe included by default when using the `ModelSerializer` class, so we needed to\nadd an explicit field for it.\n\nWe'll also add a couple of views to `views.py`. We'd like to just use read-\nonly views for the user representations, so we'll use the `ListAPIView` and\n`RetrieveAPIView` generic class-based views.\n\nMake sure to also import the `UserSerializer` class\n\nFinally we need to add those views into the API, by referencing them from the\nURL conf. Add the following to the patterns in `snippets/urls.py`.\n\nRight now, if we created a code snippet, there'd be no way of associating the\nuser that created the snippet, with the snippet instance. The user isn't sent\nas part of the serialized representation, but is instead a property of the\nincoming request.\n\nThe way we deal with that is by overriding a `.perform_create()` method on our\nsnippet views, that allows us to modify how the instance save is managed, and\nhandle any information that is implicit in the incoming request or requested\nURL.\n\nOn the `SnippetList` view class, add the following method:\n\nThe `create()` method of our serializer will now be passed an additional\n`'owner'` field, along with the validated data from the request.\n\nNow that snippets are associated with the user that created them, let's update\nour `SnippetSerializer` to reflect that. Add the following field to the\nserializer definition in `serializers.py`:\n\nNote: Make sure you also add `'owner',` to the list of fields in the inner\n`Meta` class.\n\nThis field is doing something quite interesting. The `source` argument\ncontrols which attribute is used to populate a field, and can point at any\nattribute on the serialized instance. It can also take the dotted notation\nshown above, in which case it will traverse the given attributes, in a similar\nway as it is used with Django's template language.\n\nThe field we've added is the untyped `ReadOnlyField` class, in contrast to the\nother typed fields, such as `CharField`, `BooleanField` etc... The untyped\n`ReadOnlyField` is always read-only, and will be used for serialized\nrepresentations, but will not be used for updating model instances when they\nare deserialized. We could have also used `CharField(read_only=True)` here.\n\nNow that code snippets are associated with users, we want to make sure that\nonly authenticated users are able to create, update and delete code snippets.\n\nREST framework includes a number of permission classes that we can use to\nrestrict who can access a given view. In this case the one we're looking for\nis `IsAuthenticatedOrReadOnly`, which will ensure that authenticated requests\nget read-write access, and unauthenticated requests get read-only access.\n\nFirst add the following import in the views module\n\nThen, add the following property to both the `SnippetList` and `SnippetDetail`\nview classes.\n\nIf you open a browser and navigate to the browsable API at the moment, you'll\nfind that you're no longer able to create new code snippets. In order to do so\nwe'd need to be able to login as a user.\n\nWe can add a login view for use with the browsable API, by editing the URLconf\nin our project-level `urls.py` file.\n\nAdd the following import at the top of the file:\n\nAnd, at the end of the file, add a pattern to include the login and logout\nviews for the browsable API.\n\nThe `'api-auth/'` part of pattern can actually be whatever URL you want to\nuse.\n\nNow if you open up the browser again and refresh the page you'll see a 'Login'\nlink in the top right of the page. If you log in as one of the users you\ncreated earlier, you'll be able to create code snippets again.\n\nOnce you've created a few code snippets, navigate to the '/users/' endpoint,\nand notice that the representation includes a list of the snippet ids that are\nassociated with each user, in each user's 'snippets' field.\n\nReally we'd like all code snippets to be visible to anyone, but also make sure\nthat only the user that created a code snippet is able to update or delete it.\n\nTo do that we're going to need to create a custom permission.\n\nIn the snippets app, create a new file, `permissions.py`\n\nNow we can add that custom permission to our snippet instance endpoint, by\nediting the `permission_classes` property on the `SnippetDetail` view class:\n\nMake sure to also import the `IsOwnerOrReadOnly` class.\n\nNow, if you open a browser again, you find that the 'DELETE' and 'PUT' actions\nonly appear on a snippet instance endpoint if you're logged in as the same\nuser that created the code snippet.\n\nBecause we now have a set of permissions on the API, we need to authenticate\nour requests to it if we want to edit any snippets. We haven't set up any\nauthentication classes, so the defaults are currently applied, which are\n`SessionAuthentication` and `BasicAuthentication`.\n\nWhen we interact with the API through the web browser, we can login, and the\nbrowser session will then provide the required authentication for the\nrequests.\n\nIf we're interacting with the API programmatically we need to explicitly\nprovide the authentication credentials on each request.\n\nIf we try to create a snippet without authenticating, we'll get an error:\n\nWe can make a successful request by including the username and password of one\nof the users we created earlier.\n\nWe've now got a fairly fine-grained set of permissions on our Web API, and end\npoints for users of the system and for the code snippets that they have\ncreated.\n\nIn part 5 of the tutorial we'll look at how we can tie everything together by\ncreating an HTML endpoint for our highlighted snippets, and improve the\ncohesion of our API by using hyperlinking for the relationships within the\nsystem.\n\n"}, {"name": "5: Relationships & Hyperlinked APIs", "path": "tutorial/5-relationships-and-hyperlinked-apis/index", "type": "Tutorial", "text": "\nAt the moment relationships within our API are represented by using primary\nkeys. In this part of the tutorial we'll improve the cohesion and\ndiscoverability of our API, by instead using hyperlinking for relationships.\n\nRight now we have endpoints for 'snippets' and 'users', but we don't have a\nsingle entry point to our API. To create one, we'll use a regular function-\nbased view and the `@api_view` decorator we introduced earlier. In your\n`snippets/views.py` add:\n\nTwo things should be noticed here. First, we're using REST framework's\n`reverse` function in order to return fully-qualified URLs; second, URL\npatterns are identified by convenience names that we will declare later on in\nour `snippets/urls.py`.\n\nThe other obvious thing that's still missing from our pastebin API is the code\nhighlighting endpoints.\n\nUnlike all our other API endpoints, we don't want to use JSON, but instead\njust present an HTML representation. There are two styles of HTML renderer\nprovided by REST framework, one for dealing with HTML rendered using\ntemplates, the other for dealing with pre-rendered HTML. The second renderer\nis the one we'd like to use for this endpoint.\n\nThe other thing we need to consider when creating the code highlight view is\nthat there's no existing concrete generic view that we can use. We're not\nreturning an object instance, but instead a property of an object instance.\n\nInstead of using a concrete generic view, we'll use the base class for\nrepresenting instances, and create our own `.get()` method. In your\n`snippets/views.py` add:\n\nAs usual we need to add the new views that we've created in to our URLconf.\nWe'll add a url pattern for our new API root in `snippets/urls.py`:\n\nAnd then add a url pattern for the snippet highlights:\n\nDealing with relationships between entities is one of the more challenging\naspects of Web API design. There are a number of different ways that we might\nchoose to represent a relationship:\n\nREST framework supports all of these styles, and can apply them across forward\nor reverse relationships, or apply them across custom managers such as generic\nforeign keys.\n\nIn this case we'd like to use a hyperlinked style between entities. In order\nto do so, we'll modify our serializers to extend `HyperlinkedModelSerializer`\ninstead of the existing `ModelSerializer`.\n\nThe `HyperlinkedModelSerializer` has the following differences from\n`ModelSerializer`:\n\nWe can easily re-write our existing serializers to use hyperlinking. In your\n`snippets/serializers.py` add:\n\nNotice that we've also added a new `'highlight'` field. This field is of the\nsame type as the `url` field, except that it points to the `'snippet-\nhighlight'` url pattern, instead of the `'snippet-detail'` url pattern.\n\nBecause we've included format suffixed URLs such as `'.json'`, we also need to\nindicate on the `highlight` field that any format suffixed hyperlinks it\nreturns should use the `'.html'` suffix.\n\nIf we're going to have a hyperlinked API, we need to make sure we name our URL\npatterns. Let's take a look at which URL patterns we need to name.\n\nAfter adding all those names into our URLconf, our final `snippets/urls.py`\nfile should look like this:\n\nThe list views for users and code snippets could end up returning quite a lot\nof instances, so really we'd like to make sure we paginate the results, and\nallow the API client to step through each of the individual pages.\n\nWe can change the default list style to use pagination, by modifying our\n`tutorial/settings.py` file slightly. Add the following setting:\n\nNote that settings in REST framework are all namespaced into a single\ndictionary setting, named `REST_FRAMEWORK`, which helps keep them well\nseparated from your other project settings.\n\nWe could also customize the pagination style if we needed to, but in this case\nwe'll just stick with the default.\n\nIf we open a browser and navigate to the browsable API, you'll find that you\ncan now work your way around the API simply by following links.\n\nYou'll also be able to see the 'highlight' links on the snippet instances,\nthat will take you to the highlighted code HTML representations.\n\nIn part 6 of the tutorial we'll look at how we can use ViewSets and Routers to\nreduce the amount of code we need to build our API.\n\n"}, {"name": "6: ViewSets & Routers", "path": "tutorial/6-viewsets-and-routers/index", "type": "Tutorial", "text": "\nREST framework includes an abstraction for dealing with `ViewSets`, that\nallows the developer to concentrate on modeling the state and interactions of\nthe API, and leave the URL construction to be handled automatically, based on\ncommon conventions.\n\n`ViewSet` classes are almost the same thing as `View` classes, except that\nthey provide operations such as `retrieve`, or `update`, and not method\nhandlers such as `get` or `put`.\n\nA `ViewSet` class is only bound to a set of method handlers at the last\nmoment, when it is instantiated into a set of views, typically by using a\n`Router` class which handles the complexities of defining the URL conf for\nyou.\n\nLet's take our current set of views, and refactor them into view sets.\n\nFirst of all let's refactor our `UserList` and `UserDetail` views into a\nsingle `UserViewSet`. We can remove the two views, and replace them with a\nsingle class:\n\nHere we've used the `ReadOnlyModelViewSet` class to automatically provide the\ndefault 'read-only' operations. We're still setting the `queryset` and\n`serializer_class` attributes exactly as we did when we were using regular\nviews, but we no longer need to provide the same information to two separate\nclasses.\n\nNext we're going to replace the `SnippetList`, `SnippetDetail` and\n`SnippetHighlight` view classes. We can remove the three views, and again\nreplace them with a single class.\n\nThis time we've used the `ModelViewSet` class in order to get the complete set\nof default read and write operations.\n\nNotice that we've also used the `@action` decorator to create a custom action,\nnamed `highlight`. This decorator can be used to add any custom endpoints that\ndon't fit into the standard `create`/`update`/`delete` style.\n\nCustom actions which use the `@action` decorator will respond to `GET`\nrequests by default. We can use the `methods` argument if we wanted an action\nthat responded to `POST` requests.\n\nThe URLs for custom actions by default depend on the method name itself. If\nyou want to change the way url should be constructed, you can include\n`url_path` as a decorator keyword argument.\n\nThe handler methods only get bound to the actions when we define the URLConf.\nTo see what's going on under the hood let's first explicitly create a set of\nviews from our ViewSets.\n\nIn the `snippets/urls.py` file we bind our `ViewSet` classes into a set of\nconcrete views.\n\nNotice how we're creating multiple views from each `ViewSet` class, by binding\nthe http methods to the required action for each view.\n\nNow that we've bound our resources into concrete views, we can register the\nviews with the URL conf as usual.\n\nBecause we're using `ViewSet` classes rather than `View` classes, we actually\ndon't need to design the URL conf ourselves. The conventions for wiring up\nresources into views and urls can be handled automatically, using a `Router`\nclass. All we need to do is register the appropriate view sets with a router,\nand let it do the rest.\n\nHere's our re-wired `snippets/urls.py` file.\n\nRegistering the viewsets with the router is similar to providing a urlpattern.\nWe include two arguments - the URL prefix for the views, and the viewset\nitself.\n\nThe `DefaultRouter` class we're using also automatically creates the API root\nview for us, so we can now delete the `api_root` method from our `views`\nmodule.\n\nUsing viewsets can be a really useful abstraction. It helps ensure that URL\nconventions will be consistent across your API, minimizes the amount of code\nyou need to write, and allows you to concentrate on the interactions and\nrepresentations your API provides rather than the specifics of the URL conf.\n\nThat doesn't mean it's always the right approach to take. There's a similar\nset of trade-offs to consider as when using class-based views instead of\nfunction based views. Using viewsets is less explicit than building your views\nindividually.\n\n"}, {"name": "AcceptHeaderVersioning", "path": "api-guide/versioning/index#acceptheaderversioning", "type": "Ref: Versioning", "text": "\nVersioning an interface is just a \"polite\" way to kill deployed clients.\n\n\u2014 Roy Fielding.\n\nAPI versioning allows you to alter behavior between different clients. REST\nframework provides for a number of different versioning schemes.\n\nVersioning is determined by the incoming client request, and may either be\nbased on the request URL, or based on the request headers.\n\nThere are a number of valid approaches to approaching versioning. Non-\nversioned systems can also be appropriate, particularly if you're engineering\nfor very long-term systems with multiple clients outside of your control.\n\nWhen API versioning is enabled, the `request.version` attribute will contain a\nstring that corresponds to the version requested in the incoming client\nrequest.\n\nBy default, versioning is not enabled, and `request.version` will always\nreturn `None`.\n\nHow you vary the API behavior is up to you, but one example you might\ntypically want is to switch to a different serialization style in a newer\nversion. For example:\n\nThe `reverse` function included by REST framework ties in with the versioning\nscheme. You need to make sure to include the current `request` as a keyword\nargument, like so.\n\nThe above function will apply any URL transformations appropriate to the\nrequest version. For example:\n\nWhen using hyperlinked serialization styles together with a URL based\nversioning scheme make sure to include the request as context to the\nserializer.\n\nDoing so will allow any returned URLs to include the appropriate versioning.\n\nThe versioning scheme is defined by the `DEFAULT_VERSIONING_CLASS` settings\nkey.\n\nUnless it is explicitly set, the value for `DEFAULT_VERSIONING_CLASS` will be\n`None`. In this case the `request.version` attribute will always return\n`None`.\n\nYou can also set the versioning scheme on an individual view. Typically you\nwon't need to do this, as it makes more sense to have a single versioning\nscheme used globally. If you do need to do so, use the `versioning_class`\nattribute.\n\nThe following settings keys are also used to control versioning:\n\nYou can also set your versioning class plus those three values on a per-view\nor a per-viewset basis by defining your own versioning scheme and using the\n`default_version`, `allowed_versions` and `version_param` class variables. For\nexample, if you want to use `URLPathVersioning`:\n\nThis scheme requires the client to specify the version as part of the media\ntype in the `Accept` header. The version is included as a media type\nparameter, that supplements the main media type.\n\nHere's an example HTTP request using the accept header versioning style.\n\nIn the example request above `request.version` attribute would return the\nstring `'1.0'`.\n\nVersioning based on accept headers is generally considered as best practice,\nalthough other styles may be suitable depending on your client requirements.\n\nStrictly speaking the `json` media type is not specified as including\nadditional parameters. If you are building a well-specified public API you\nmight consider using a vendor media type. To do so, configure your renderers\nto use a JSON based renderer with a custom media type:\n\nYour client requests would now look like this:\n\nThis scheme requires the client to specify the version as part of the URL\npath.\n\nYour URL conf must include a pattern that matches the version with a\n`'version'` keyword argument, so that this information is available to the\nversioning scheme.\n\nTo the client, this scheme is the same as `URLPathVersioning`. The only\ndifference is how it is configured in your Django application, as it uses URL\nnamespacing, instead of URL keyword arguments.\n\nWith this scheme the `request.version` attribute is determined based on the\n`namespace` that matches the incoming request path.\n\nIn the following example we're giving a set of views two different possible\nURL prefixes, each under a different namespace:\n\nBoth `URLPathVersioning` and `NamespaceVersioning` are reasonable if you just\nneed a simple versioning scheme. The `URLPathVersioning` approach might be\nbetter suitable for small ad-hoc projects, and the `NamespaceVersioning` is\nprobably easier to manage for larger projects.\n\nThe hostname versioning scheme requires the client to specify the requested\nversion as part of the hostname in the URL.\n\nFor example the following is an HTTP request to the\n`http://v1.example.com/bookings/` URL:\n\nBy default this implementation expects the hostname to match this simple\nregular expression:\n\nNote that the first group is enclosed in brackets, indicating that this is the\nmatched portion of the hostname.\n\nThe `HostNameVersioning` scheme can be awkward to use in debug mode as you\nwill typically be accessing a raw IP address such as `127.0.0.1`. There are\nvarious online tutorials on how to access localhost with a custom subdomain\nwhich you may find helpful in this case.\n\nHostname based versioning can be particularly useful if you have requirements\nto route incoming requests to different servers based on the version, as you\ncan configure different DNS records for different API versions.\n\nThis scheme is a simple style that includes the version as a query parameter\nin the URL. For example:\n\nTo implement a custom versioning scheme, subclass `BaseVersioning` and\noverride the `.determine_version` method.\n\nThe following example uses a custom `X-API-Version` header to determine the\nrequested version.\n\nIf your versioning scheme is based on the request URL, you will also want to\nalter how versioned URLs are determined. In order to do so you should override\nthe `.reverse()` method on the class. See the source code for examples.\n\nversioning.py\n\n"}, {"name": "AdminRenderer", "path": "api-guide/renderers/index#adminrenderer", "type": "Ref: Renderers", "text": "\nBefore a TemplateResponse instance can be returned to the client, it must be\nrendered. The rendering process takes the intermediate representation of\ntemplate and context, and turns it into the final byte stream that can be\nserved to the client.\n\n\u2014 Django documentation\n\nREST framework includes a number of built in Renderer classes, that allow you\nto return responses with various media types. There is also support for\ndefining your own custom renderers, which gives you the flexibility to design\nyour own media types.\n\nThe set of valid renderers for a view is always defined as a list of classes.\nWhen a view is entered REST framework will perform content negotiation on the\nincoming request, and determine the most appropriate renderer to satisfy the\nrequest.\n\nThe basic process of content negotiation involves examining the request's\n`Accept` header, to determine which media types it expects in the response.\nOptionally, format suffixes on the URL may be used to explicitly request a\nparticular representation. For example the URL\n`http://example.com/api/users_count.json` might be an endpoint that always\nreturns JSON data.\n\nFor more information see the documentation on content negotiation.\n\nThe default set of renderers may be set globally, using the\n`DEFAULT_RENDERER_CLASSES` setting. For example, the following settings would\nuse `JSON` as the main media type and also include the self describing API.\n\nYou can also set the renderers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nIt's important when specifying the renderer classes for your API to think\nabout what priority you want to assign to each media type. If a client\nunderspecifies the representations it can accept, such as sending an `Accept:\n*/*` header, or not including an `Accept` header at all, then REST framework\nwill select the first renderer in the list to use for the response.\n\nFor example if your API serves JSON responses and the HTML browsable API, you\nmight want to make `JSONRenderer` your default renderer, in order to send\n`JSON` responses to clients that do not specify an `Accept` header.\n\nIf your API includes views that can serve both regular webpages and API\nresponses depending on the request, then you might consider making\n`TemplateHTMLRenderer` your default renderer, in order to play nicely with\nolder browsers that send broken accept headers.\n\nRenders the request data into `JSON`, using utf-8 encoding.\n\nNote that the default style is to include unicode characters, and render the\nresponse using a compact style with no unnecessary whitespace:\n\nThe client may additionally include an `'indent'` media type parameter, in\nwhich case the returned `JSON` will be indented. For example `Accept:\napplication/json; indent=4`.\n\nThe default JSON encoding style can be altered using the `UNICODE_JSON` and\n`COMPACT_JSON` settings keys.\n\n.media_type: `application/json`\n\n.format: `'json'`\n\n.charset: `None`\n\nRenders data to HTML, using Django's standard template rendering. Unlike other\nrenderers, the data passed to the `Response` does not need to be serialized.\nAlso, unlike other renderers, you may want to include a `template_name`\nargument when creating the `Response`.\n\nThe TemplateHTMLRenderer will create a `RequestContext`, using the\n`response.data` as the context dict, and determine a template name to use to\nrender the context.\n\nNote: When used with a view that makes use of a serializer the `Response` sent\nfor rendering may not be a dictionary and will need to be wrapped in a dict\nbefore returning to allow the TemplateHTMLRenderer to render it. For example:\n\nThe template name is determined by (in order of preference):\n\nAn example of a view that uses `TemplateHTMLRenderer`:\n\nYou can use `TemplateHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\nIf you're building websites that use `TemplateHTMLRenderer` along with other\nrenderer classes, you should consider listing `TemplateHTMLRenderer` as the\nfirst class in the `renderer_classes` list, so that it will be prioritised\nfirst even for browsers that send poorly formed `ACCEPT:` headers.\n\nSee the HTML & Forms Topic Page for further examples of `TemplateHTMLRenderer`\nusage.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `StaticHTMLRenderer`\n\nA simple renderer that simply returns pre-rendered HTML. Unlike other\nrenderers, the data passed to the response object should be a string\nrepresenting the content to be returned.\n\nAn example of a view that uses `StaticHTMLRenderer`:\n\nYou can use `StaticHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `TemplateHTMLRenderer`\n\nRenders data into HTML for the Browsable API:\n\nThis renderer will determine which other renderer would have been given\nhighest priority, and use that to display an API style response within the\nHTML page.\n\n.media_type: `text/html`\n\n.format: `'api'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/api.html'`\n\nBy default the response content will be rendered with the highest priority\nrenderer apart from `BrowsableAPIRenderer`. If you need to customize this\nbehavior, for example to use HTML as the default return format, but use JSON\nin the browsable API, you can do so by overriding the `get_default_renderer()`\nmethod. For example:\n\nRenders data into HTML for an admin-like display:\n\nThis renderer is suitable for CRUD-style web APIs that should also present a\nuser-friendly interface for managing the data.\n\nNote that views that have nested or list serializers for their input won't\nwork well with the `AdminRenderer`, as the HTML forms are unable to properly\nsupport them.\n\nNote: The `AdminRenderer` is only able to include links to detail pages when a\nproperly configured `URL_FIELD_NAME` (`url` by default) attribute is present\nin the data. For `HyperlinkedModelSerializer` this will be the case, but for\n`ModelSerializer` or plain `Serializer` classes you'll need to make sure to\ninclude the field explicitly. For example here we use models\n`get_absolute_url` method:\n\n.media_type: `text/html`\n\n.format: `'admin'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/admin.html'`\n\nRenders data returned by a serializer into an HTML form. The output of this\nrenderer does not include the enclosing `<form>` tags, a hidden CSRF input or\nany submit buttons.\n\nThis renderer is not intended to be used directly, but can instead be used in\ntemplates by passing a serializer instance to the `render_form` template tag.\n\nFor more information see the HTML & Forms documentation.\n\n.media_type: `text/html`\n\n.format: `'form'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/horizontal/form.html'`\n\nThis renderer is used for rendering HTML multipart form data. It is not\nsuitable as a response renderer, but is instead used for creating test\nrequests, using REST framework's test client and test request factory.\n\n.media_type: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n.format: `'multipart'`\n\n.charset: `utf-8`\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the\n`.media_type` and `.format` properties, and implement the `.render(self, data,\nmedia_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the\nHTTP response.\n\nThe arguments passed to the `.render()` method are:\n\nThe request data, as set by the `Response()` instantiation.\n\nOptional. If provided, this is the accepted media type, as determined by the\ncontent negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the\nrenderer's `media_type` attribute, and may include media type parameters. For\nexample `\"application/json; nested=true\"`.\n\nOptional. If provided, this is a dictionary of contextual information provided\nby the view.\n\nBy default this will include the following keys: `view`, `request`,\n`response`, `args`, `kwargs`.\n\nThe following is an example plaintext renderer that will return a response\nwith the `data` parameter as the content of the response.\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To\nuse a different encoding, set the `charset` attribute on the renderer.\n\nNote that if a renderer class returns a unicode string, then the response\ncontent will be coerced into a bytestring by the `Response` class, with the\n`charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you\nshould set a charset value of `None`, which will ensure the `Content-Type`\nheader of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to\n`'binary'`. Doing so will also ensure that the browsable API will not attempt\nto display the binary content as a string.\n\nYou can do some pretty flexible things using REST framework's renderers. Some\nexamples...\n\nIn some cases you might want your view to use different serialization styles\ndepending on the accepted media type. If you need to do this you can access\n`request.accepted_renderer` to determine the negotiated renderer that will be\nused for the response.\n\nFor example:\n\nIn some cases you might want a renderer to serve a range of media types. In\nthis case you can underspecify the media types it should respond to, by using\na `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify\nthe media type explicitly when you return the response, using the\n`content_type` attribute. For example:\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked\nrelations may be sufficient. If you want to fully embrace RESTful design and\nHATEOAS you'll need to consider the design and usage of your media types in\nmore detail.\n\nIn the words of Roy Fielding, \"A REST API should spend almost all of its\ndescriptive effort in defining the media type(s) used for representing\nresources and driving application state, or in defining extended relation\nnames and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom\napplication/vnd.github+json media type, and Mike Amundsen's IANA approved\napplication/vnd.collection+json JSON-based hypermedia.\n\nTypically a renderer will behave the same regardless of if it's dealing with a\nregular response, or with a response caused by an exception being raised, such\nas an `Http404` or `PermissionDenied` exception, or a subclass of\n`APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer`\nand an exception is raised, the behavior is slightly different, and mirrors\nDjango's default handling of error views.\n\nExceptions raised and handled by an HTML renderer will attempt to render using\none of the following methods, by order of precedence.\n\nTemplates will render with a `RequestContext` which includes the `status_code`\nand `details` keys.\n\nNote: If `DEBUG=True`, Django's standard traceback error page will be\ndisplayed instead of rendering the HTTP status code and text.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST framework JSONP provides JSONP rendering support. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nWarning: If you require cross-domain AJAX requests, you should generally be\nusing the more modern approach of CORS as an alternative to `JSONP`. See the\nCORS documentation for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is only appropriate\nfor globally readable API endpoints, where `GET` requests are unauthenticated\nand do not require any user permissions.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\nXLSX is the world's most popular binary spreadsheet format. Tim Allen of The\nWharton School maintains drf-renderer-xlsx, which renders an endpoint as an\nXLSX spreadsheet using OpenPyXL, and allows the client to download it.\nSpreadsheets can be styled on a per-view basis.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nTo avoid having a file streamed without a filename (which the browser will\noften default to the filename \"download\", with no extension), we need to use a\nmixin to override the `Content-Disposition` header. If no filename is\nprovided, it will default to `export.xlsx`. For example:\n\nComma-separated values are a plain-text tabular data format, that can be\neasily imported into spreadsheet applications. Mjumbe Poe maintains the\ndjangorestframework-csv package which provides CSV renderer support for REST\nframework.\n\nUltraJSON is an optimized C JSON encoder which can give significantly faster\nJSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now\nunmaintained drf-ujson-renderer, which implements JSON rendering using the\nUJSON package.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nDjango REST Pandas provides a serializer and renderers that support additional\ndata processing and output via the Pandas DataFrame API. Django REST Pandas\nincludes renderers for Pandas-style CSV files, Excel workbooks (both `.xls`\nand `.xlsx`), and a number of other formats. It is maintained by S. Andrew\nSheppard as part of the wq Project.\n\nRest Framework Latex provides a renderer that outputs PDFs using Laulatex. It\nis maintained by Pebble (S/F Software).\n\nrenderers.py\n\n"}, {"name": "AllowAny", "path": "api-guide/permissions/index#allowany", "type": "Ref: Permissions", "text": "\nAuthentication or identification by itself is not usually sufficient to gain\naccess to information or code. For that, the entity requesting access must\nhave authorization.\n\n\u2014 Apple Developer Documentation\n\nTogether with authentication and throttling, permissions determine whether a\nrequest should be granted or denied access.\n\nPermission checks are always run at the very start of the view, before any\nother code is allowed to proceed. Permission checks will typically use the\nauthentication information in the `request.user` and `request.auth` properties\nto determine if the incoming request should be permitted.\n\nPermissions are used to grant or deny access for different classes of users to\ndifferent parts of the API.\n\nThe simplest style of permission would be to allow access to any authenticated\nuser, and deny access to any unauthenticated user. This corresponds to the\n`IsAuthenticated` class in REST framework.\n\nA slightly less strict style of permission would be to allow full access to\nauthenticated users, but allow read-only access to unauthenticated users. This\ncorresponds to the `IsAuthenticatedOrReadOnly` class in REST framework.\n\nPermissions in REST framework are always defined as a list of permission\nclasses.\n\nBefore running the main body of the view each permission in the list is\nchecked. If any permission check fails an `exceptions.PermissionDenied` or\n`exceptions.NotAuthenticated` exception will be raised, and the main body of\nthe view will not run.\n\nWhen the permissions checks fail either a \"403 Forbidden\" or a \"401\nUnauthorized\" response will be returned, according to the following rules:\n\nREST framework permissions also support object-level permissioning. Object\nlevel permissions are used to determine if a user should be allowed to act on\na particular object, which will typically be a model instance.\n\nObject level permissions are run by REST framework's generic views when\n`.get_object()` is called. As with view level permissions, an\n`exceptions.PermissionDenied` exception will be raised if the user is not\nallowed to act on the given object.\n\nIf you're writing your own views and want to enforce object level permissions,\nor if you override the `get_object` method on a generic view, then you'll need\nto explicitly call the `.check_object_permissions(request, obj)` method on the\nview at the point at which you've retrieved the object.\n\nThis will either raise a `PermissionDenied` or `NotAuthenticated` exception,\nor simply return if the view has the appropriate permissions.\n\nFor example:\n\nNote: With the exception of `DjangoObjectPermissions`, the provided permission\nclasses in `rest_framework.permissions` do not implement the methods necessary\nto check object permissions.\n\nIf you wish to use the provided permission classes in order to check object\npermissions, you must subclass them and implement the\n`has_object_permission()` method described in the Custom permissions section\n(below).\n\nFor performance reasons the generic views will not automatically apply object\nlevel permissions to each instance in a queryset when returning a list of\nobjects.\n\nOften when you're using object level permissions you'll also want to filter\nthe queryset appropriately, to ensure that users only have visibility onto\ninstances that they are permitted to view.\n\nBecause the `get_object()` method is not called, object level permissions from\nthe `has_object_permission()` method are not applied when creating objects. In\norder to restrict object creation you need to implement the permission check\neither in your Serializer class or override the `perform_create()` method of\nyour ViewSet class.\n\nThe default permission policy may be set globally, using the\n`DEFAULT_PERMISSION_CLASSES` setting. For example.\n\nIf not specified, this setting defaults to allowing unrestricted access:\n\nYou can also set the authentication policy on a per-view, or per-viewset\nbasis, using the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nNote: when you set new permission classes via the class attribute or\ndecorators you're telling the view to ignore the default list set in the\nsettings.py file.\n\nProvided they inherit from `rest_framework.permissions.BasePermission`,\npermissions can be composed using standard Python bitwise operators. For\nexample, `IsAuthenticatedOrReadOnly` could be written:\n\nNote: it supports & (and), | (or) and ~ (not).\n\nThe `AllowAny` permission class will allow unrestricted access, regardless of\nif the request was authenticated or unauthenticated.\n\nThis permission is not strictly required, since you can achieve the same\nresult by using an empty list or tuple for the permissions setting, but you\nmay find it useful to specify this class because it makes the intention\nexplicit.\n\nThe `IsAuthenticated` permission class will deny permission to any\nunauthenticated user, and allow permission otherwise.\n\nThis permission is suitable if you want your API to only be accessible to\nregistered users.\n\nThe `IsAdminUser` permission class will deny permission to any user, unless\n`user.is_staff` is `True` in which case permission will be allowed.\n\nThis permission is suitable if you want your API to only be accessible to a\nsubset of trusted administrators.\n\nThe `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any\nrequest. Requests for unauthorised users will only be permitted if the request\nmethod is one of the \"safe\" methods; `GET`, `HEAD` or `OPTIONS`.\n\nThis permission is suitable if you want to your API to allow read permissions\nto anonymous users, and only allow write permissions to authenticated users.\n\nThis permission class ties into Django's standard `django.contrib.auth` model\npermissions. This permission must only be applied to views that have a\n`.queryset` property or `get_queryset()` method. Authorization will only be\ngranted if the user is authenticated and has the relevant model permissions\nassigned.\n\nThe default behaviour can also be overridden to support custom model\npermissions. For example, you might want to include a `view` model permission\nfor `GET` requests.\n\nTo use custom model permissions, override `DjangoModelPermissions` and set the\n`.perms_map` property. Refer to the source code for details.\n\nSimilar to `DjangoModelPermissions`, but also allows unauthenticated users to\nhave read-only access to the API.\n\nThis permission class ties into Django's standard object permissions framework\nthat allows per-object permissions on models. In order to use this permission\nclass, you'll also need to add a permission backend that supports object-level\npermissions, such as django-guardian.\n\nAs with `DjangoModelPermissions`, this permission must only be applied to\nviews that have a `.queryset` property or `.get_queryset()` method.\nAuthorization will only be granted if the user is authenticated and has the\nrelevant per-object permissions and relevant model permissions assigned.\n\nNote that `DjangoObjectPermissions` does not require the `django-guardian`\npackage, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by\noverriding `DjangoObjectPermissions` and setting the `.perms_map` property.\nRefer to the source code for details.\n\nNote: If you need object level `view` permissions for `GET`, `HEAD` and\n`OPTIONS` requests and are using django-guardian for your object-level\npermissions backend, you'll want to consider using the\n`DjangoObjectPermissionsFilter` class provided by the `djangorestframework-\nguardian` package. It ensures that list endpoints only return results\nincluding objects for which the user has appropriate view permissions.\n\nTo implement a custom permission, override `BasePermission` and implement\neither, or both, of the following methods:\n\nThe methods should return `True` if the request should be granted access, and\n`False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you\nshould check the request method against the constant `SAFE_METHODS`, which is\na tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\nNote: The instance-level `has_object_permission` method will only be called if\nthe view-level `has_permission` checks have already passed. Also note that in\norder for the instance-level checks to run, the view code should explicitly\ncall `.check_object_permissions(request, obj)`. If you are using the generic\nviews then this will be handled for you by default. (Function-based views will\nneed to check object permissions explicitly, raising `PermissionDenied` on\nfailure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test\nfails. To change the error message associated with the exception, implement a\n`message` attribute directly on your custom permission. Otherwise the\n`default_detail` attribute from `PermissionDenied` will be used. Similarly, to\nchange the code identifier associated with the exception, implement a `code`\nattribute directly on your custom permission - otherwise the `default_code`\nattribute from `PermissionDenied` will be used.\n\nThe following is an example of a permission class that checks the incoming\nrequest's IP address against a blocklist, and denies the request if the IP has\nbeen blocked.\n\nAs well as global permissions, that are run against all incoming requests, you\ncan also create object-level permissions, that are only run against operations\nthat affect a particular object instance. For example:\n\nNote that the generic views will check the appropriate object level\npermissions, but if you're writing your own custom views, you'll need to make\nsure you check the object level permission checks yourself. You can do so by\ncalling `self.check_object_permissions(request, obj)` from the view once you\nhave the object instance. This call will raise an appropriate `APIException`\nif any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions\nfor views that retrieve a single model instance. If you require object-level\nfiltering of list views, you'll need to filter the queryset separately. See\nthe filtering documentation for more details.\n\nREST framework offers three different methods to customize access restrictions\non a case-by-case basis. These apply in different scenarios and have different\neffects and limitations.\n\nThe following table lists the access restriction methods and the level of\ncontrol they offer over which actions.\n\n* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.   \n** The `get_*()` methods have access to the current view and can return\ndifferent Serializer or QuerySet instances based on the request or action.\n\nThe following third party packages are also available.\n\nThe Django REST - Access Policy package provides a way to define complex\naccess rules in declarative policy classes that are attached to view sets or\nfunction-based views. The policies are defined in JSON in a format similar to\nAWS' Identity & Access Management policies.\n\nThe Composed Permissions package provides a simple way to define complex and\nmulti-depth (with logic operators) permission objects, using small and\nreusable components.\n\nThe REST Condition package is another extension for building complex\npermissions in a simple and convenient way. The extension allows you to\ncombine permissions with logical operators.\n\nThe DRY Rest Permissions package provides the ability to define different\npermissions for individual default and custom actions. This package is made\nfor apps with permissions that are derived from relationships defined in the\napp's data model. It also supports permission checks being returned to a\nclient app through the API's serializer. Additionally it supports adding\npermissions to the default and custom list actions to restrict the data they\nretrieve per user.\n\nThe Django Rest Framework Roles package makes it easier to parameterize your\nAPI over multiple types of users.\n\nThe Django REST Framework API Key package provides permissions classes, models\nand helpers to add API key authorization to your API. It can be used to\nauthorize internal or third-party backends and services (i.e. machines) which\ndo not have a user account. API keys are stored securely using Django's\npassword hashing infrastructure, and they can be viewed, edited and revoked at\nanytime in the Django admin.\n\nThe Django Rest Framework Role Filters package provides simple filtering over\nmultiple types of roles.\n\nThe Django Rest Framework PSQ package is an extension that gives support for\nhaving action-based permission_classes, serializer_class, and queryset\ndependent on permission-based rules.\n\npermissions.py\n\n"}, {"name": "AnonRateThrottle", "path": "api-guide/throttling/index#anonratethrottle", "type": "Ref: Throttling", "text": "\nHTTP/1.1 420 Enhance Your Calm\n\nTwitter API rate limiting response\n\nThrottling is similar to permissions, in that it determines if a request\nshould be authorized. Throttles indicate a temporary state, and are used to\ncontrol the rate of requests that clients can make to an API.\n\nAs with permissions, multiple throttles may be used. Your API might have a\nrestrictive throttle for unauthenticated requests, and a less restrictive\nthrottle for authenticated requests.\n\nAnother scenario where you might want to use multiple throttles would be if\nyou need to impose different constraints on different parts of the API, due to\nsome services being particularly resource-intensive.\n\nMultiple throttles can also be used if you want to impose both burst\nthrottling rates, and sustained throttling rates. For example, you might want\nto limit a user to a maximum of 60 requests per minute, and 1000 requests per\nday.\n\nThrottles do not necessarily only refer to rate-limiting requests. For example\na storage service might also need to throttle against bandwidth, and a paid\ndata service might want to throttle against a certain number of a records\nbeing accessed.\n\nAs with permissions and authentication, throttling in REST framework is always\ndefined as a list of classes.\n\nBefore running the main body of the view each throttle in the list is checked.\nIf any throttle check fails an `exceptions.Throttled` exception will be\nraised, and the main body of the view will not run.\n\nThe default throttling policy may be set globally, using the\n`DEFAULT_THROTTLE_CLASSES` and `DEFAULT_THROTTLE_RATES` settings. For example.\n\nThe rate descriptions used in `DEFAULT_THROTTLE_RATES` may include `second`,\n`minute`, `hour` or `day` as the throttle period.\n\nYou can also set the throttling policy on a per-view or per-viewset basis,\nusing the `APIView` class-based views.\n\nIf you're using the `@api_view` decorator with function based views you can\nuse the following decorator.\n\nIt's also possible to set throttle classes for routes that are created using\nthe `@action` decorator. Throttle classes set in this way will override any\nviewset level class settings.\n\nThe `X-Forwarded-For` HTTP header and `REMOTE_ADDR` WSGI variable are used to\nuniquely identify client IP addresses for throttling. If the `X-Forwarded-For`\nheader is present then it will be used, otherwise the value of the\n`REMOTE_ADDR` variable from the WSGI environment will be used.\n\nIf you need to strictly identify unique client IP addresses, you'll need to\nfirst configure the number of application proxies that the API runs behind by\nsetting the `NUM_PROXIES` setting. This setting should be an integer of zero\nor more. If set to non-zero then the client IP will be identified as being the\nlast IP address in the `X-Forwarded-For` header, once any application proxy IP\naddresses have first been excluded. If set to zero, then the `REMOTE_ADDR`\nvalue will always be used as the identifying IP address.\n\nIt is important to understand that if you configure the `NUM_PROXIES` setting,\nthen all clients behind a unique NAT'd gateway will be treated as a single\nclient.\n\nFurther context on how the `X-Forwarded-For` header works, and identifying a\nremote client IP can be found here.\n\nThe throttle classes provided by REST framework use Django's cache backend.\nYou should make sure that you've set appropriate cache settings. The default\nvalue of `LocMemCache` backend should be okay for simple setups. See Django's\ncache documentation for more details.\n\nIf you need to use a cache other than `'default'`, you can do so by creating a\ncustom throttle class and setting the `cache` attribute. For example:\n\nYou'll need to remember to also set your custom throttle class in the\n`'DEFAULT_THROTTLE_CLASSES'` settings key, or using the `throttle_classes`\nview attribute.\n\nThe `AnonRateThrottle` will only ever throttle unauthenticated users. The IP\naddress of the incoming request is used to generate a unique key to throttle\nagainst.\n\nThe allowed request rate is determined from one of the following (in order of\npreference).\n\n`AnonRateThrottle` is suitable if you want to restrict the rate of requests\nfrom unknown sources.\n\nThe `UserRateThrottle` will throttle users to a given rate of requests across\nthe API. The user id is used to generate a unique key to throttle against.\nUnauthenticated requests will fall back to using the IP address of the\nincoming request to generate a unique key to throttle against.\n\nThe allowed request rate is determined from one of the following (in order of\npreference).\n\nAn API may have multiple `UserRateThrottles` in place at the same time. To do\nso, override `UserRateThrottle` and set a unique \"scope\" for each class.\n\nFor example, multiple user throttle rates could be implemented by using the\nfollowing classes...\n\n...and the following settings.\n\n`UserRateThrottle` is suitable if you want simple global rate restrictions\nper-user.\n\nThe `ScopedRateThrottle` class can be used to restrict access to specific\nparts of the API. This throttle will only be applied if the view that is being\naccessed includes a `.throttle_scope` property. The unique throttle key will\nthen be formed by concatenating the \"scope\" of the request with the unique\nuser id or IP address.\n\nThe allowed request rate is determined by the `DEFAULT_THROTTLE_RATES` setting\nusing a key from the request \"scope\".\n\nFor example, given the following views...\n\n...and the following settings.\n\nUser requests to either `ContactListView` or `ContactDetailView` would be\nrestricted to a total of 1000 requests per-day. User requests to `UploadView`\nwould be restricted to 20 requests per day.\n\nTo create a custom throttle, override `BaseThrottle` and implement\n`.allow_request(self, request, view)`. The method should return `True` if the\nrequest should be allowed, and `False` otherwise.\n\nOptionally you may also override the `.wait()` method. If implemented,\n`.wait()` should return a recommended number of seconds to wait before\nattempting the next request, or `None`. The `.wait()` method will only be\ncalled if `.allow_request()` has previously returned `False`.\n\nIf the `.wait()` method is implemented and the request is throttled, then a\n`Retry-After` header will be included in the response.\n\nThe following is an example of a rate throttle, that will randomly throttle 1\nin every 10 requests.\n\nthrottling.py\n\n"}, {"name": "API policy settings", "path": "api-guide/settings/index#api-policy-settings", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "APIException", "path": "api-guide/exceptions/index#apiexception", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "Authentication", "path": "api-guide/authentication/index", "type": "API Guide", "text": "\nAuth needs to be pluggable.\n\n\u2014 Jacob Kaplan-Moss, \"REST worst practices\"\n\nAuthentication is the mechanism of associating an incoming request with a set\nof identifying credentials, such as the user the request came from, or the\ntoken that it was signed with. The permission and throttling policies can then\nuse those credentials to determine if the request should be permitted.\n\nREST framework provides several authentication schemes out of the box, and\nalso allows you to implement custom schemes.\n\nAuthentication always runs at the very start of the view, before the\npermission and throttling checks occur, and before any other code is allowed\nto proceed.\n\nThe `request.user` property will typically be set to an instance of the\n`contrib.auth` package's `User` class.\n\nThe `request.auth` property is used for any additional authentication\ninformation, for example, it may be used to represent an authentication token\nthat the request was signed with.\n\nNote: Don't forget that authentication by itself won't allow or disallow an\nincoming request, it simply identifies the credentials that the request was\nmade with.\n\nFor information on how to set up the permission policies for your API please\nsee the permissions documentation.\n\nThe authentication schemes are always defined as a list of classes. REST\nframework will attempt to authenticate with each class in the list, and will\nset `request.user` and `request.auth` using the return value of the first\nclass that successfully authenticates.\n\nIf no class authenticates, `request.user` will be set to an instance of\n`django.contrib.auth.models.AnonymousUser`, and `request.auth` will be set to\n`None`.\n\nThe value of `request.user` and `request.auth` for unauthenticated requests\ncan be modified using the `UNAUTHENTICATED_USER` and `UNAUTHENTICATED_TOKEN`\nsettings.\n\nThe default authentication schemes may be set globally, using the\n`DEFAULT_AUTHENTICATION_CLASSES` setting. For example.\n\nYou can also set the authentication scheme on a per-view or per-viewset basis,\nusing the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nWhen an unauthenticated request is denied permission there are two different\nerror codes that may be appropriate.\n\nHTTP 401 responses must always include a `WWW-Authenticate` header, that\ninstructs the client how to authenticate. HTTP 403 responses do not include\nthe `WWW-Authenticate` header.\n\nThe kind of response that will be used depends on the authentication scheme.\nAlthough multiple authentication schemes may be in use, only one scheme may be\nused to determine the type of response. The first authentication class set on\nthe view is used when determining the type of response.\n\nNote that when a request may successfully authenticate, but still be denied\npermission to perform the request, in which case a `403 Permission Denied`\nresponse will always be used, regardless of the authentication scheme.\n\nNote that if deploying to Apache using mod_wsgi, the authorization header is\nnot passed through to a WSGI application by default, as it is assumed that\nauthentication will be handled by Apache, rather than at an application level.\n\nIf you are deploying to Apache, and using any non-session based\nauthentication, you will need to explicitly configure mod_wsgi to pass the\nrequired headers through to the application. This can be done by specifying\nthe `WSGIPassAuthorization` directive in the appropriate context and setting\nit to `'On'`.\n\nThis authentication scheme uses HTTP Basic Authentication, signed against a\nuser's username and password. Basic authentication is generally only\nappropriate for testing.\n\nIf successfully authenticated, `BasicAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nNote: If you use `BasicAuthentication` in production you must ensure that your\nAPI is only available over `https`. You should also ensure that your API\nclients will always re-request the username and password at login, and will\nnever store those details to persistent storage.\n\nThis authentication scheme uses a simple token-based HTTP Authentication\nscheme. Token authentication is appropriate for client-server setups, such as\nnative desktop and mobile clients.\n\nTo use the `TokenAuthentication` scheme you'll need to configure the\nauthentication classes to include `TokenAuthentication`, and additionally\ninclude `rest_framework.authtoken` in your `INSTALLED_APPS` setting:\n\nNote: Make sure to run `manage.py migrate` after changing your settings. The\n`rest_framework.authtoken` app provides Django database migrations.\n\nYou'll also need to create tokens for your users.\n\nFor clients to authenticate, the token key should be included in the\n`Authorization` HTTP header. The key should be prefixed by the string literal\n\"Token\", with whitespace separating the two strings. For example:\n\nNote: If you want to use a different keyword in the header, such as `Bearer`,\nsimply subclass `TokenAuthentication` and set the `keyword` class variable.\n\nIf successfully authenticated, `TokenAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nThe `curl` command line tool may be useful for testing token authenticated\nAPIs. For example:\n\nNote: If you use `TokenAuthentication` in production you must ensure that your\nAPI is only available over `https`.\n\nIf you want every user to have an automatically generated Token, you can\nsimply catch the User's `post_save` signal.\n\nNote that you'll want to ensure you place this code snippet in an installed\n`models.py` module, or some other location that will be imported by Django on\nstartup.\n\nIf you've already created some users, you can generate tokens for all existing\nusers like this:\n\nWhen using `TokenAuthentication`, you may want to provide a mechanism for\nclients to obtain a token given the username and password. REST framework\nprovides a built-in view to provide this behaviour. To use it, add the\n`obtain_auth_token` view to your URLconf:\n\nNote that the URL part of the pattern can be whatever you want to use.\n\nThe `obtain_auth_token` view will return a JSON response when valid `username`\nand `password` fields are POSTed to the view using form data or JSON:\n\nNote that the default `obtain_auth_token` view explicitly uses JSON requests\nand responses, rather than using default renderer and parser classes in your\nsettings.\n\nBy default, there are no permissions or throttling applied to the\n`obtain_auth_token` view. If you do wish to apply to throttle you'll need to\noverride the view class, and include them using the `throttle_classes`\nattribute.\n\nIf you need a customized version of the `obtain_auth_token` view, you can do\nso by subclassing the `ObtainAuthToken` view class, and using that in your url\nconf instead.\n\nFor example, you may return additional user information beyond the `token`\nvalue:\n\nAnd in your `urls.py`:\n\nIt is also possible to create Tokens manually through the admin interface. In\ncase you are using a large user base, we recommend that you monkey patch the\n`TokenAdmin` class customize it to your needs, more specifically by declaring\nthe `user` field as `raw_field`.\n\n`your_app/admin.py`:\n\nSince version 3.6.4 it's possible to generate a user token using the following\ncommand:\n\nthis command will return the API token for the given user, creating it if it\ndoesn't exist:\n\nIn case you want to regenerate the token (for example if it has been\ncompromised or leaked) you can pass an additional parameter:\n\nThis authentication scheme uses Django's default session backend for\nauthentication. Session authentication is appropriate for AJAX clients that\nare running in the same session context as your website.\n\nIf successfully authenticated, `SessionAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n403 Forbidden` response.\n\nIf you're using an AJAX-style API with SessionAuthentication, you'll need to\nmake sure you include a valid CSRF token for any \"unsafe\" HTTP method calls,\nsuch as `PUT`, `PATCH`, `POST` or `DELETE` requests. See the Django CSRF\ndocumentation for more details.\n\nWarning: Always use Django's standard login view when creating login pages.\nThis will ensure your login views are properly protected.\n\nCSRF validation in REST framework works slightly differently from standard\nDjango due to the need to support both session and non-session based\nauthentication to the same views. This means that only authenticated requests\nrequire CSRF tokens, and anonymous requests may be sent without CSRF tokens.\nThis behaviour is not suitable for login views, which should always have CSRF\nvalidation applied.\n\nThis authentication scheme allows you to delegate authentication to your web\nserver, which sets the `REMOTE_USER` environment variable.\n\nTo use it, you must have `django.contrib.auth.backends.RemoteUserBackend` (or\na subclass) in your `AUTHENTICATION_BACKENDS` setting. By default,\n`RemoteUserBackend` creates `User` objects for usernames that don't already\nexist. To change this and other behaviour, consult the Django documentation.\n\nIf successfully authenticated, `RemoteUserAuthentication` provides the\nfollowing credentials:\n\nConsult your web server's documentation for information about configuring an\nauthentication method, e.g.:\n\nTo implement a custom authentication scheme, subclass `BaseAuthentication` and\noverride the `.authenticate(self, request)` method. The method should return a\ntwo-tuple of `(user, auth)` if authentication succeeds, or `None` otherwise.\n\nIn some circumstances instead of returning `None`, you may want to raise an\n`AuthenticationFailed` exception from the `.authenticate()` method.\n\nTypically the approach you should take is:\n\nYou may also override the `.authenticate_header(self, request)` method. If\nimplemented, it should return a string that will be used as the value of the\n`WWW-Authenticate` header in a `HTTP 401 Unauthorized` response.\n\nIf the `.authenticate_header()` method is not overridden, the authentication\nscheme will return `HTTP 403 Forbidden` responses when an unauthenticated\nrequest is denied access.\n\nNote: When your custom authenticator is invoked by the request object's\n`.user` or `.auth` properties, you may see an `AttributeError` re-raised as a\n`WrappedAttributeError`. This is necessary to prevent the original exception\nfrom being suppressed by the outer property access. Python will not recognize\nthat the `AttributeError` originates from your custom authenticator and will\ninstead assume that the request object does not have a `.user` or `.auth`\nproperty. These errors should be fixed or otherwise handled by your\nauthenticator.\n\nThe following example will authenticate any incoming request as the user given\nby the username in a custom request header named 'X-USERNAME'.\n\nThe following third-party packages are also available.\n\nThe Django OAuth Toolkit package provides OAuth 2.0 support and works with\nPython 3.4+. The package is maintained by jazzband and uses the excellent\nOAuthLib. The package is well documented, and well supported and is currently\nour recommended package for OAuth 2.0 support.\n\nInstall using `pip`.\n\nAdd the package to your `INSTALLED_APPS` and modify your REST framework\nsettings.\n\nFor more details see the Django REST framework - Getting started\ndocumentation.\n\nThe Django REST framework OAuth package provides both OAuth1 and OAuth2\nsupport for REST framework.\n\nThis package was previously included directly in the REST framework but is now\nsupported and maintained as a third-party package.\n\nInstall the package using `pip`.\n\nFor details on configuration and usage see the Django REST framework OAuth\ndocumentation for authentication and permissions.\n\nJSON Web Token is a fairly new standard which can be used for token-based\nauthentication. Unlike the built-in TokenAuthentication scheme, JWT\nAuthentication doesn't need to use a database to validate a token. A package\nfor JWT authentication is djangorestframework-simplejwt which provides some\nfeatures as well as a pluggable token blacklist app.\n\nThe HawkREST library builds on the Mohawk library to let you work with Hawk\nsigned requests and responses in your API. Hawk lets two parties securely\ncommunicate with each other using messages signed by a shared key. It is based\non HTTP MAC access authentication (which was based on parts of OAuth 1.0).\n\nHTTP Signature (currently a IETF draft) provides a way to achieve origin\nauthentication and message integrity for HTTP messages. Similar to Amazon's\nHTTP Signature scheme, used by many of its services, it permits stateless,\nper-request authentication. Elvio Toccalino maintains the djangorestframework-\nhttpsignature (outdated) package which provides an easy to use HTTP Signature\nAuthentication mechanism. You can use the updated fork version of\ndjangorestframework-httpsignature, which is drf-httpsig.\n\nDjoser library provides a set of views to handle basic actions such as\nregistration, login, logout, password reset and account activation. The\npackage works with a custom user model and uses token-based authentication.\nThis is ready to use REST implementation of the Django authentication system.\n\nThis library provides a set of REST API endpoints for registration,\nauthentication (including social media authentication), password reset,\nretrieve and update user details, etc. By having these API endpoints, your\nclient apps such as AngularJS, iOS, Android, and others can communicate to\nyour Django backend site independently via REST APIs for user management.\n\nThere are currently two forks of this project.\n\nDjango-rest-framework-social-oauth2 library provides an easy way to integrate\nsocial plugins (facebook, twitter, google, etc.) to your authentication system\nand an easy oauth2 setup. With this library, you will be able to authenticate\nusers based on external tokens (e.g. facebook access token), convert these\ntokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to\nauthenticate your users.\n\nDjango-rest-knox library provides models and views to handle token-based\nauthentication in a more secure and extensible way than the built-in\nTokenAuthentication scheme - with Single Page Applications and Mobile clients\nin mind. It provides per-client tokens, and views to generate them when\nprovided some other authentication (usually basic authentication), to delete\nthe token (providing a server enforced logout) and to delete all tokens (logs\nout all clients that a user is logged into).\n\ndrfpasswordless adds (Medium, Square Cash inspired) passwordless support to\nDjango REST Framework's TokenAuthentication scheme. Users log in and sign up\nwith a token sent to a contact point like an email address or a mobile number.\n\ndjango-rest-authemail provides a RESTful API interface for user signup and\nauthentication. Email addresses are used for authentication, rather than\nusernames. API endpoints are available for signup, signup email verification,\nlogin, logout, password reset, password reset verification, email change,\nemail change verification, password change, and user detail. A fully\nfunctional example project and detailed instructions are included.\n\nDjango-Rest-Durin is built with the idea to have one library that does token\nauth for multiple Web/CLI/Mobile API clients via one interface but allows\ndifferent token configuration for each API Client that consumes the API. It\nprovides support for multiple tokens per user via custom models, views,\npermissions that work with Django-Rest-Framework. The token expiration time\ncan be different per API client and is customizable via the Django Admin\nInterface.\n\nMore information can be found in the Documentation.\n\nauthentication.py\n\n"}, {"name": "Authentication settings", "path": "api-guide/settings/index#authentication-settings", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "AuthenticationFailed", "path": "api-guide/exceptions/index#authenticationfailed", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "BaseSerializer", "path": "api-guide/serializers/index#baseserializer", "type": "Ref: Serializers", "text": "\nExpanding the usefulness of the serializers is something that we would like to\naddress. However, it's not a trivial problem, and it will take some serious\ndesign work.\n\n\u2014 Russell Keith-Magee, Django users group\n\nSerializers allow complex data such as querysets and model instances to be\nconverted to native Python datatypes that can then be easily rendered into\n`JSON`, `XML` or other content types. Serializers also provide\ndeserialization, allowing parsed data to be converted back into complex types,\nafter first validating the incoming data.\n\nThe serializers in REST framework work very similarly to Django's `Form` and\n`ModelForm` classes. We provide a `Serializer` class which gives you a\npowerful, generic way to control the output of your responses, as well as a\n`ModelSerializer` class which provides a useful shortcut for creating\nserializers that deal with model instances and querysets.\n\nLet's start by creating a simple object we can use for example purposes:\n\nWe'll declare a serializer that we can use to serialize and deserialize data\nthat corresponds to `Comment` objects.\n\nDeclaring a serializer looks very similar to declaring a form:\n\nWe can now use `CommentSerializer` to serialize a comment, or list of\ncomments. Again, using the `Serializer` class looks a lot like using a `Form`\nclass.\n\nAt this point we've translated the model instance into Python native\ndatatypes. To finalise the serialization process we render the data into\n`json`.\n\nDeserialization is similar. First we parse a stream into Python native\ndatatypes...\n\n...then we restore those native datatypes into a dictionary of validated data.\n\nIf we want to be able to return complete object instances based on the\nvalidated data we need to implement one or both of the `.create()` and\n`.update()` methods. For example:\n\nIf your object instances correspond to Django models you'll also want to\nensure that these methods save the object to the database. For example, if\n`Comment` was a Django model, the methods might look like this:\n\nNow when deserializing data, we can call `.save()` to return an object\ninstance, based on the validated data.\n\nCalling `.save()` will either create a new instance, or update an existing\ninstance, depending on if an existing instance was passed when instantiating\nthe serializer class:\n\nBoth the `.create()` and `.update()` methods are optional. You can implement\neither neither, one, or both of them, depending on the use-case for your\nserializer class.\n\nSometimes you'll want your view code to be able to inject additional data at\nthe point of saving the instance. This additional data might include\ninformation like the current user, the current time, or anything else that is\nnot part of the request data.\n\nYou can do so by including additional keyword arguments when calling\n`.save()`. For example:\n\nAny additional keyword arguments will be included in the `validated_data`\nargument when `.create()` or `.update()` are called.\n\nIn some cases the `.create()` and `.update()` method names may not be\nmeaningful. For example, in a contact form we may not be creating new\ninstances, but instead sending an email or other message.\n\nIn these cases you might instead choose to override `.save()` directly, as\nbeing more readable and meaningful.\n\nFor example:\n\nNote that in the case above we're now having to access the serializer\n`.validated_data` property directly.\n\nWhen deserializing data, you always need to call `is_valid()` before\nattempting to access the validated data, or save an object instance. If any\nvalidation errors occur, the `.errors` property will contain a dictionary\nrepresenting the resulting error messages. For example:\n\nEach key in the dictionary will be the field name, and the values will be\nlists of strings of any error messages corresponding to that field. The\n`non_field_errors` key may also be present, and will list any general\nvalidation errors. The name of the `non_field_errors` key may be customized\nusing the `NON_FIELD_ERRORS_KEY` REST framework setting.\n\nWhen deserializing a list of items, errors will be returned as a list of\ndictionaries representing each of the deserialized items.\n\nThe `.is_valid()` method takes an optional `raise_exception` flag that will\ncause it to raise a `serializers.ValidationError` exception if there are\nvalidation errors.\n\nThese exceptions are automatically dealt with by the default exception handler\nthat REST framework provides, and will return `HTTP 400 Bad Request` responses\nby default.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. These are\nsimilar to the `.clean_<field_name>` methods on Django forms.\n\nThese methods take a single argument, which is the field value that requires\nvalidation.\n\nYour `validate_<field_name>` methods should return the validated value or\nraise a `serializers.ValidationError`. For example:\n\nNote: If your `<field_name>` is declared on your serializer with the parameter\n`required=False` then this validation step will not take place if the field is\nnot included.\n\nTo do any other validation that requires access to multiple fields, add a\nmethod called `.validate()` to your `Serializer` subclass. This method takes a\nsingle argument, which is a dictionary of field values. It should raise a\n`serializers.ValidationError` if necessary, or just return the validated\nvalues. For example:\n\nIndividual fields on a serializer can include validators, by declaring them on\nthe field instance, for example:\n\nSerializer classes can also include reusable validators that are applied to\nthe complete set of field data. These validators are included by declaring\nthem on an inner `Meta` class, like so:\n\nFor more information see the validators documentation.\n\nWhen passing an initial object or queryset to a serializer instance, the\nobject will be made available as `.instance`. If no initial object is passed\nthen the `.instance` attribute will be `None`.\n\nWhen passing data to a serializer instance, the unmodified data will be made\navailable as `.initial_data`. If the `data` keyword argument is not passed\nthen the `.initial_data` attribute will not exist.\n\nBy default, serializers must be passed values for all required fields or they\nwill raise validation errors. You can use the `partial` argument in order to\nallow partial updates.\n\nThe previous examples are fine for dealing with objects that only have simple\ndatatypes, but sometimes we also need to be able to represent more complex\nobjects, where some of the attributes of an object might not be simple\ndatatypes such as strings, dates or integers.\n\nThe `Serializer` class is itself a type of `Field`, and can be used to\nrepresent relationships where one object type is nested inside another.\n\nIf a nested representation may optionally accept the `None` value you should\npass the `required=False` flag to the nested serializer.\n\nSimilarly if a nested representation should be a list of items, you should\npass the `many=True` flag to the nested serializer.\n\nWhen dealing with nested representations that support deserializing the data,\nany errors with nested objects will be nested under the field name of the\nnested object.\n\nSimilarly, the `.validated_data` property will include nested data structures.\n\nIf you're supporting writable nested representations you'll need to write\n`.create()` or `.update()` methods that handle saving multiple objects.\n\nThe following example demonstrates how you might handle creating a user with a\nnested profile object.\n\nFor updates you'll want to think carefully about how to handle updates to\nrelationships. For example if the data for the relationship is `None`, or not\nprovided, which of the following should occur?\n\nHere's an example for an `.update()` method on our previous `UserSerializer`\nclass.\n\nBecause the behavior of nested creates and updates can be ambiguous, and may\nrequire complex dependencies between related models, REST framework 3 requires\nyou to always write these methods explicitly. The default `ModelSerializer`\n`.create()` and `.update()` methods do not include support for writable nested\nrepresentations.\n\nThere are however, third-party packages available such as DRF Writable Nested\nthat support automatic writable nested representations.\n\nAn alternative to saving multiple related instances in the serializer is to\nwrite custom model manager classes that handle creating the correct instances.\n\nFor example, suppose we wanted to ensure that `User` instances and `Profile`\ninstances are always created together as a pair. We might write a custom\nmanager class that looks something like this:\n\nThis manager class now more nicely encapsulates that user instances and\nprofile instances are always created at the same time. Our `.create()` method\non the serializer class can now be re-written to use the new manager method.\n\nFor more details on this approach see the Django documentation on model\nmanagers, and this blogpost on using model and manager classes.\n\nThe `Serializer` class can also handle serializing or deserializing lists of\nobjects.\n\nTo serialize a queryset or list of objects instead of a single object\ninstance, you should pass the `many=True` flag when instantiating the\nserializer. You can then pass a queryset or list of objects to be serialized.\n\nThe default behavior for deserializing multiple objects is to support multiple\nobject creation, but not support multiple object updates. For more information\non how to support or customize either of these cases, see the ListSerializer\ndocumentation below.\n\nThere are some cases where you need to provide extra context to the serializer\nin addition to the object being serialized. One common case is if you're using\na serializer that includes hyperlinked relations, which requires the\nserializer to have access to the current request so that it can properly\ngenerate fully qualified URLs.\n\nYou can provide arbitrary additional context by passing a `context` argument\nwhen instantiating the serializer. For example:\n\nThe context dictionary can be used within any serializer field logic, such as\na custom `.to_representation()` method, by accessing the `self.context`\nattribute.\n\nOften you'll want serializer classes that map closely to Django model\ndefinitions.\n\nThe `ModelSerializer` class provides a shortcut that lets you automatically\ncreate a `Serializer` class with fields that correspond to the Model fields.\n\nThe `ModelSerializer` class is the same as a regular `Serializer` class,\nexcept that:\n\nDeclaring a `ModelSerializer` looks like this:\n\nBy default, all the model fields on the class will be mapped to a\ncorresponding serializer fields.\n\nAny relationships such as foreign keys on the model will be mapped to\n`PrimaryKeyRelatedField`. Reverse relationships are not included by default\nunless explicitly included as specified in the serializer relations\ndocumentation.\n\nSerializer classes generate helpful verbose representation strings, that allow\nyou to fully inspect the state of their fields. This is particularly useful\nwhen working with `ModelSerializers` where you want to determine what set of\nfields and validators are being automatically created for you.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIf you only want a subset of the default fields to be used in a model\nserializer, you can do so using `fields` or `exclude` options, just as you\nwould with a `ModelForm`. It is strongly recommended that you explicitly set\nall fields that should be serialized using the `fields` attribute. This will\nmake it less likely to result in unintentionally exposing data when your\nmodels change.\n\nFor example:\n\nYou can also set the `fields` attribute to the special value `'__all__'` to\nindicate that all fields in the model should be used.\n\nFor example:\n\nYou can set the `exclude` attribute to a list of fields to be excluded from\nthe serializer.\n\nFor example:\n\nIn the example above, if the `Account` model had 3 fields `account_name`,\n`users`, and `created`, this will result in the fields `account_name` and\n`created` to be serialized.\n\nThe names in the `fields` and `exclude` attributes will normally map to model\nfields on the model class.\n\nAlternatively names in the `fields` options can map to properties or methods\nwhich take no arguments that exist on the model class.\n\nSince version 3.3.0, it is mandatory to provide one of the attributes `fields`\nor `exclude`.\n\nThe default `ModelSerializer` uses primary keys for relationships, but you can\nalso easily generate nested representations using the `depth` option:\n\nThe `depth` option should be set to an integer value that indicates the depth\nof relationships that should be traversed before reverting to a flat\nrepresentation.\n\nIf you want to customize the way the serialization is done you'll need to\ndefine the field yourself.\n\nYou can add extra fields to a `ModelSerializer` or override the default fields\nby declaring fields on the class, just as you would for a `Serializer` class.\n\nExtra fields can correspond to any property or callable on the model.\n\nYou may wish to specify multiple fields as read-only. Instead of adding each\nfield explicitly with the `read_only=True` attribute, you may use the shortcut\nMeta option, `read_only_fields`.\n\nThis option should be a list or tuple of field names, and is declared as\nfollows:\n\nModel fields which have `editable=False` set, and `AutoField` fields will be\nset to read-only by default, and do not need to be added to the\n`read_only_fields` option.\n\nNote: There is a special-case where a read-only field is part of a\n`unique_together` constraint at the model level. In this case the field is\nrequired by the serializer class in order to validate the constraint, but\nshould also not be editable by the user.\n\nThe right way to deal with this is to specify the field explicitly on the\nserializer, providing both the `read_only=True` and `default=\u2026` keyword\narguments.\n\nOne example of this is a read-only relation to the currently authenticated\n`User` which is `unique_together` with another identifier. In this case you\nwould declare the user field like so:\n\nPlease review the Validators Documentation for details on the\nUniqueTogetherValidator and CurrentUserDefault classes.\n\nThere is also a shortcut allowing you to specify arbitrary additional keyword\narguments on fields, using the `extra_kwargs` option. As in the case of\n`read_only_fields`, this means you do not need to explicitly declare the field\non the serializer.\n\nThis option is a dictionary, mapping field names to a dictionary of keyword\narguments. For example:\n\nPlease keep in mind that, if the field has already been explicitly declared on\nthe serializer class, then the `extra_kwargs` option will be ignored.\n\nWhen serializing model instances, there are a number of different ways you\nmight choose to represent relationships. The default representation for\n`ModelSerializer` is to use the primary keys of the related instances.\n\nAlternative representations include serializing using hyperlinks, serializing\ncomplete nested representations, or serializing with a custom representation.\n\nFor full details see the serializer relations documentation.\n\nThe ModelSerializer class also exposes an API that you can override in order\nto alter how serializer fields are automatically determined when instantiating\nthe serializer.\n\nNormally if a `ModelSerializer` does not generate the fields you need by\ndefault then you should either add them to the class explicitly, or simply use\na regular `Serializer` class instead. However in some cases you may want to\ncreate a new base class that defines how the serializer fields are created for\nany given model.\n\nA mapping of Django model fields to REST framework serializer fields. You can\noverride this mapping to alter the default serializer fields that should be\nused for each model field.\n\nThis property should be the serializer field class, that is used for\nrelational fields by default.\n\nFor `ModelSerializer` this defaults to `PrimaryKeyRelatedField`.\n\nFor `HyperlinkedModelSerializer` this defaults to\n`serializers.HyperlinkedRelatedField`.\n\nThe serializer field class that should be used for any `url` field on the\nserializer.\n\nDefaults to `serializers.HyperlinkedIdentityField`\n\nThe serializer field class that should be used for any choice fields on the\nserializer.\n\nDefaults to `serializers.ChoiceField`\n\nThe following methods are called to determine the class and keyword arguments\nfor each field that should be automatically included on the serializer. Each\nof these methods should return a two tuple of `(field_class, field_kwargs)`.\n\nCalled to generate a serializer field that maps to a standard model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_field_mapping` attribute.\n\nCalled to generate a serializer field that maps to a relational model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_related_field` attribute.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a relational model field,\nwhen the `depth` option has been set.\n\nThe default implementation dynamically creates a nested serializer class based\non either `ModelSerializer` or `HyperlinkedModelSerializer`.\n\nThe `nested_depth` will be the value of the `depth` option, minus one.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a property or zero-argument\nmethod on the model class.\n\nThe default implementation returns a `ReadOnlyField` class.\n\nCalled to generate a serializer field for the serializer's own `url` field.\nThe default implementation returns a `HyperlinkedIdentityField` class.\n\nCalled when the field name did not map to any model field or model property.\nThe default implementation raises an error, although subclasses may customize\nthis behavior.\n\nThe `HyperlinkedModelSerializer` class is similar to the `ModelSerializer`\nclass except that it uses hyperlinks to represent relationships, rather than\nprimary keys.\n\nBy default the serializer will include a `url` field instead of a primary key\nfield.\n\nThe url field will be represented using a `HyperlinkedIdentityField`\nserializer field, and any relationships on the model will be represented using\na `HyperlinkedRelatedField` serializer field.\n\nYou can explicitly include the primary key by adding it to the `fields`\noption, for example:\n\nWhen instantiating a `HyperlinkedModelSerializer` you must include the current\n`request` in the serializer context, for example:\n\nDoing so will ensure that the hyperlinks can include an appropriate hostname,\nso that the resulting representation uses fully qualified URLs, such as:\n\nRather than relative URLs, such as:\n\nIf you do want to use relative URLs, you should explicitly pass `{'request':\nNone}` in the serializer context.\n\nThere needs to be a way of determining which views should be used for\nhyperlinking to model instances.\n\nBy default hyperlinks are expected to correspond to a view name that matches\nthe style `'{model_name}-detail'`, and looks up the instance by a `pk` keyword\nargument.\n\nYou can override a URL field view name and lookup field by using either, or\nboth of, the `view_name` and `lookup_field` options in the `extra_kwargs`\nsetting, like so:\n\nAlternatively you can set the fields on the serializer explicitly. For\nexample:\n\nTip: Properly matching together hyperlinked representations and your URL conf\ncan sometimes be a bit fiddly. Printing the `repr` of a\n`HyperlinkedModelSerializer` instance is a particularly useful way to inspect\nexactly which view names and lookup fields the relationships are expected to\nmap too.\n\nThe name of the URL field defaults to 'url'. You can override this globally,\nby using the `URL_FIELD_NAME` setting.\n\nThe `ListSerializer` class provides the behavior for serializing and\nvalidating multiple objects at once. You won't typically need to use\n`ListSerializer` directly, but should instead simply pass `many=True` when\ninstantiating a serializer.\n\nWhen a serializer is instantiated and `many=True` is passed, a\n`ListSerializer` instance will be created. The serializer class then becomes a\nchild of the parent `ListSerializer`\n\nThe following argument can also be passed to a `ListSerializer` field or a\nserializer that is passed `many=True`:\n\nThis is `True` by default, but can be set to `False` if you want to disallow\nempty lists as valid input.\n\nThere are a few use cases when you might want to customize the\n`ListSerializer` behavior. For example:\n\nFor these cases you can modify the class that is used when `many=True` is\npassed, by using the `list_serializer_class` option on the serializer `Meta`\nclass.\n\nFor example:\n\nThe default implementation for multiple object creation is to simply call\n`.create()` for each item in the list. If you want to customize this behavior,\nyou'll need to customize the `.create()` method on `ListSerializer` class that\nis used when `many=True` is passed.\n\nFor example:\n\nBy default the `ListSerializer` class does not support multiple updates. This\nis because the behavior that should be expected for insertions and deletions\nis ambiguous.\n\nTo support multiple updates you'll need to do so explicitly. When writing your\nmultiple update code make sure to keep the following in mind:\n\nYou will need to add an explicit `id` field to the instance serializer. The\ndefault implicitly-generated `id` field is marked as `read_only`. This causes\nit to be removed on updates. Once you declare it explicitly, it will be\navailable in the list serializer's `update` method.\n\nHere's an example of how you might choose to implement multiple updates:\n\nIt is possible that a third party package may be included alongside the 3.1\nrelease that provides some automatic support for multiple update operations,\nsimilar to the `allow_add_remove` behavior that was present in REST framework\n2.\n\nWhen a serializer with `many=True` is instantiated, we need to determine which\narguments and keyword arguments should be passed to the `.__init__()` method\nfor both the child `Serializer` class, and for the parent `ListSerializer`\nclass.\n\nThe default implementation is to pass all arguments to both classes, except\nfor `validators`, and any custom keyword arguments, both of which are assumed\nto be intended for the child serializer class.\n\nOccasionally you might need to explicitly specify how the child and parent\nclasses should be instantiated when `many=True` is passed. You can do so by\nusing the `many_init` class method.\n\n`BaseSerializer` class that can be used to easily support alternative\nserialization and deserialization styles.\n\nThis class implements the same basic API as the `Serializer` class:\n\nThere are four methods that can be overridden, depending on what functionality\nyou want the serializer class to support:\n\nBecause this class provides the same interface as the `Serializer` class, you\ncan use it with the existing generic class-based views exactly as you would\nfor a regular `Serializer` or `ModelSerializer`.\n\nThe only difference you'll notice when doing so is the `BaseSerializer`\nclasses will not generate HTML forms in the browsable API. This is because the\ndata they return does not include all the field information that would allow\neach field to be rendered into a suitable HTML input.\n\nTo implement a read-only serializer using the `BaseSerializer` class, we just\nneed to override the `.to_representation()` method. Let's take a look at an\nexample using a simple Django model:\n\nIt's simple to create a read-only serializer for converting `HighScore`\ninstances into primitive data types.\n\nWe can now use this class to serialize single `HighScore` instances:\n\nOr use it to serialize multiple instances:\n\nTo create a read-write serializer we first need to implement a\n`.to_internal_value()` method. This method returns the validated values that\nwill be used to construct the object instance, and may raise a\n`serializers.ValidationError` if the supplied data is in an incorrect format.\n\nOnce you've implemented `.to_internal_value()`, the basic validation API will\nbe available on the serializer, and you will be able to use `.is_valid()`,\n`.validated_data` and `.errors`.\n\nIf you want to also support `.save()` you'll need to also implement either or\nboth of the `.create()` and `.update()` methods.\n\nHere's a complete example of our previous `HighScoreSerializer`, that's been\nupdated to support both read and write operations.\n\nThe `BaseSerializer` class is also useful if you want to implement new generic\nserializer classes for dealing with particular serialization styles, or for\nintegrating with alternative storage backends.\n\nThe following class is an example of a generic serializer that can handle\ncoercing arbitrary objects into primitive representations.\n\nIf you need to alter the serialization or deserialization behavior of a\nserializer class, you can do so by overriding the `.to_representation()` or\n`.to_internal_value()` methods.\n\nSome reasons this might be useful include...\n\nThe signatures for these methods are as follows:\n\nTakes the object instance that requires serialization, and should return a\nprimitive representation. Typically this means returning a structure of built-\nin Python datatypes. The exact types that can be handled will depend on the\nrender classes you have configured for your API.\n\nMay be overridden in order to modify the representation style. For example:\n\nTakes the unvalidated incoming data as input and should return the validated\ndata that will be made available as `serializer.validated_data`. The return\nvalue will also be passed to the `.create()` or `.update()` methods if\n`.save()` is called on the serializer class.\n\nIf any of the validation fails, then the method should raise a\n`serializers.ValidationError(errors)`. The `errors` argument should be a\ndictionary mapping field names (or `settings.NON_FIELD_ERRORS_KEY`) to a list\nof error messages. If you don't need to alter deserialization behavior and\ninstead want to provide object-level validation, it's recommended that you\ninstead override the `.validate()` method.\n\nThe `data` argument passed to this method will normally be the value of\n`request.data`, so the datatype it provides will depend on the parser classes\nyou have configured for your API.\n\nSimilar to Django forms, you can extend and reuse serializers through\ninheritance. This allows you to declare a common set of fields or methods on a\nparent class that can then be used in a number of serializers. For example,\n\nLike Django's `Model` and `ModelForm` classes, the inner `Meta` class on\nserializers does not implicitly inherit from it's parents' inner `Meta`\nclasses. If you want the `Meta` class to inherit from a parent class you must\ndo so explicitly. For example:\n\nTypically we would recommend not using inheritance on inner Meta classes, but\ninstead declaring all options explicitly.\n\nAdditionally, the following caveats apply to serializer inheritance:\n\nIt\u2019s possible to declaratively remove a `Field` inherited from a parent class\nby setting the name to be `None` on the subclass.\n\nHowever, you can only use this technique to opt out from a field defined\ndeclaratively by a parent class; it won\u2019t prevent the `ModelSerializer` from\ngenerating a default field. To opt-out from default fields, see Specifying\nwhich fields to include.\n\nOnce a serializer has been initialized, the dictionary of fields that are set\non the serializer may be accessed using the `.fields` attribute. Accessing and\nmodifying this attribute allows you to dynamically modify the serializer.\n\nModifying the `fields` argument directly allows you to do interesting things\nsuch as changing the arguments on serializer fields at runtime, rather than at\nthe point of declaring the serializer.\n\nFor example, if you wanted to be able to set which fields should be used by a\nserializer at the point of initializing it, you could create a serializer\nclass like so:\n\nThis would then allow you to do the following:\n\nREST framework 2 provided an API to allow developers to override how a\n`ModelSerializer` class would automatically generate the default set of\nfields.\n\nThis API included the `.get_field()`, `.get_pk_field()` and other methods.\n\nBecause the serializers have been fundamentally redesigned with 3.0 this API\nno longer exists. You can still modify the fields that get created but you'll\nneed to refer to the source code, and be aware that if the changes you make\nare against private bits of API then they may be subject to change.\n\nThe following third party packages are also available.\n\nThe django-rest-marshmallow package provides an alternative implementation for\nserializers, using the python marshmallow library. It exposes the same API as\nthe REST framework serializers, and can be used as a drop-in replacement in\nsome use-cases.\n\nThe serpy package is an alternative implementation for serializers that is\nbuilt for speed. Serpy serializes complex datatypes to simple native types.\nThe native types can be easily converted to JSON or any other format needed.\n\nThe django-rest-framework-mongoengine package provides a\n`MongoEngineModelSerializer` serializer class that supports using MongoDB as\nthe storage layer for Django REST framework.\n\nThe django-rest-framework-gis package provides a `GeoFeatureModelSerializer`\nserializer class that supports GeoJSON both for read and write operations.\n\nThe django-rest-framework-hstore package provides an `HStoreSerializer` to\nsupport django-hstore `DictionaryField` model field and its `schema-mode`\nfeature.\n\nThe dynamic-rest package extends the ModelSerializer and ModelViewSet\ninterfaces, adding API query parameters for filtering, sorting, and including\n/ excluding all fields and relationships defined by your serializers.\n\nThe drf-dynamic-fields package provides a mixin to dynamically limit the\nfields per serializer to a subset specified by an URL parameter.\n\nThe drf-flex-fields package extends the ModelSerializer and ModelViewSet to\nprovide commonly used functionality for dynamically setting fields and\nexpanding primitive fields to nested models, both from URL parameters and your\nserializer class definitions.\n\nThe django-rest-framework-serializer-extensions package provides a collection\nof tools to DRY up your serializers, by allowing fields to be defined on a\nper-view/request basis. Fields can be whitelisted, blacklisted and child\nserializers can be optionally expanded.\n\nThe html-json-forms package provides an algorithm and serializer for\nprocessing `<form>` submissions per the (inactive) HTML JSON Form\nspecification. The serializer facilitates processing of arbitrarily nested\nJSON structures within HTML. For example, `<input name=\"items[0][id]\"\nvalue=\"5\">` will be interpreted as `{\"items\": [{\"id\": \"5\"}]}`.\n\nDRF-Base64 provides a set of field and model serializers that handles the\nupload of base64-encoded files.\n\ndjangorestframework-queryfields allows API clients to specify which fields\nwill be sent in the response via inclusion/exclusion query parameters.\n\nThe drf-writable-nested package provides writable nested model serializer\nwhich allows to create/update models with nested related data.\n\nThe drf-encrypt-content package helps you encrypt your data, serialized\nthrough ModelSerializer. It also contains some helper functions. Which helps\nyou to encrypt your data.\n\nserializers.py\n\n"}, {"name": "BasicAuthentication", "path": "api-guide/authentication/index#basicauthentication", "type": "Ref: Authentication", "text": "\nAuth needs to be pluggable.\n\n\u2014 Jacob Kaplan-Moss, \"REST worst practices\"\n\nAuthentication is the mechanism of associating an incoming request with a set\nof identifying credentials, such as the user the request came from, or the\ntoken that it was signed with. The permission and throttling policies can then\nuse those credentials to determine if the request should be permitted.\n\nREST framework provides several authentication schemes out of the box, and\nalso allows you to implement custom schemes.\n\nAuthentication always runs at the very start of the view, before the\npermission and throttling checks occur, and before any other code is allowed\nto proceed.\n\nThe `request.user` property will typically be set to an instance of the\n`contrib.auth` package's `User` class.\n\nThe `request.auth` property is used for any additional authentication\ninformation, for example, it may be used to represent an authentication token\nthat the request was signed with.\n\nNote: Don't forget that authentication by itself won't allow or disallow an\nincoming request, it simply identifies the credentials that the request was\nmade with.\n\nFor information on how to set up the permission policies for your API please\nsee the permissions documentation.\n\nThe authentication schemes are always defined as a list of classes. REST\nframework will attempt to authenticate with each class in the list, and will\nset `request.user` and `request.auth` using the return value of the first\nclass that successfully authenticates.\n\nIf no class authenticates, `request.user` will be set to an instance of\n`django.contrib.auth.models.AnonymousUser`, and `request.auth` will be set to\n`None`.\n\nThe value of `request.user` and `request.auth` for unauthenticated requests\ncan be modified using the `UNAUTHENTICATED_USER` and `UNAUTHENTICATED_TOKEN`\nsettings.\n\nThe default authentication schemes may be set globally, using the\n`DEFAULT_AUTHENTICATION_CLASSES` setting. For example.\n\nYou can also set the authentication scheme on a per-view or per-viewset basis,\nusing the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nWhen an unauthenticated request is denied permission there are two different\nerror codes that may be appropriate.\n\nHTTP 401 responses must always include a `WWW-Authenticate` header, that\ninstructs the client how to authenticate. HTTP 403 responses do not include\nthe `WWW-Authenticate` header.\n\nThe kind of response that will be used depends on the authentication scheme.\nAlthough multiple authentication schemes may be in use, only one scheme may be\nused to determine the type of response. The first authentication class set on\nthe view is used when determining the type of response.\n\nNote that when a request may successfully authenticate, but still be denied\npermission to perform the request, in which case a `403 Permission Denied`\nresponse will always be used, regardless of the authentication scheme.\n\nNote that if deploying to Apache using mod_wsgi, the authorization header is\nnot passed through to a WSGI application by default, as it is assumed that\nauthentication will be handled by Apache, rather than at an application level.\n\nIf you are deploying to Apache, and using any non-session based\nauthentication, you will need to explicitly configure mod_wsgi to pass the\nrequired headers through to the application. This can be done by specifying\nthe `WSGIPassAuthorization` directive in the appropriate context and setting\nit to `'On'`.\n\nThis authentication scheme uses HTTP Basic Authentication, signed against a\nuser's username and password. Basic authentication is generally only\nappropriate for testing.\n\nIf successfully authenticated, `BasicAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nNote: If you use `BasicAuthentication` in production you must ensure that your\nAPI is only available over `https`. You should also ensure that your API\nclients will always re-request the username and password at login, and will\nnever store those details to persistent storage.\n\nThis authentication scheme uses a simple token-based HTTP Authentication\nscheme. Token authentication is appropriate for client-server setups, such as\nnative desktop and mobile clients.\n\nTo use the `TokenAuthentication` scheme you'll need to configure the\nauthentication classes to include `TokenAuthentication`, and additionally\ninclude `rest_framework.authtoken` in your `INSTALLED_APPS` setting:\n\nNote: Make sure to run `manage.py migrate` after changing your settings. The\n`rest_framework.authtoken` app provides Django database migrations.\n\nYou'll also need to create tokens for your users.\n\nFor clients to authenticate, the token key should be included in the\n`Authorization` HTTP header. The key should be prefixed by the string literal\n\"Token\", with whitespace separating the two strings. For example:\n\nNote: If you want to use a different keyword in the header, such as `Bearer`,\nsimply subclass `TokenAuthentication` and set the `keyword` class variable.\n\nIf successfully authenticated, `TokenAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nThe `curl` command line tool may be useful for testing token authenticated\nAPIs. For example:\n\nNote: If you use `TokenAuthentication` in production you must ensure that your\nAPI is only available over `https`.\n\nIf you want every user to have an automatically generated Token, you can\nsimply catch the User's `post_save` signal.\n\nNote that you'll want to ensure you place this code snippet in an installed\n`models.py` module, or some other location that will be imported by Django on\nstartup.\n\nIf you've already created some users, you can generate tokens for all existing\nusers like this:\n\nWhen using `TokenAuthentication`, you may want to provide a mechanism for\nclients to obtain a token given the username and password. REST framework\nprovides a built-in view to provide this behaviour. To use it, add the\n`obtain_auth_token` view to your URLconf:\n\nNote that the URL part of the pattern can be whatever you want to use.\n\nThe `obtain_auth_token` view will return a JSON response when valid `username`\nand `password` fields are POSTed to the view using form data or JSON:\n\nNote that the default `obtain_auth_token` view explicitly uses JSON requests\nand responses, rather than using default renderer and parser classes in your\nsettings.\n\nBy default, there are no permissions or throttling applied to the\n`obtain_auth_token` view. If you do wish to apply to throttle you'll need to\noverride the view class, and include them using the `throttle_classes`\nattribute.\n\nIf you need a customized version of the `obtain_auth_token` view, you can do\nso by subclassing the `ObtainAuthToken` view class, and using that in your url\nconf instead.\n\nFor example, you may return additional user information beyond the `token`\nvalue:\n\nAnd in your `urls.py`:\n\nIt is also possible to create Tokens manually through the admin interface. In\ncase you are using a large user base, we recommend that you monkey patch the\n`TokenAdmin` class customize it to your needs, more specifically by declaring\nthe `user` field as `raw_field`.\n\n`your_app/admin.py`:\n\nSince version 3.6.4 it's possible to generate a user token using the following\ncommand:\n\nthis command will return the API token for the given user, creating it if it\ndoesn't exist:\n\nIn case you want to regenerate the token (for example if it has been\ncompromised or leaked) you can pass an additional parameter:\n\nThis authentication scheme uses Django's default session backend for\nauthentication. Session authentication is appropriate for AJAX clients that\nare running in the same session context as your website.\n\nIf successfully authenticated, `SessionAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n403 Forbidden` response.\n\nIf you're using an AJAX-style API with SessionAuthentication, you'll need to\nmake sure you include a valid CSRF token for any \"unsafe\" HTTP method calls,\nsuch as `PUT`, `PATCH`, `POST` or `DELETE` requests. See the Django CSRF\ndocumentation for more details.\n\nWarning: Always use Django's standard login view when creating login pages.\nThis will ensure your login views are properly protected.\n\nCSRF validation in REST framework works slightly differently from standard\nDjango due to the need to support both session and non-session based\nauthentication to the same views. This means that only authenticated requests\nrequire CSRF tokens, and anonymous requests may be sent without CSRF tokens.\nThis behaviour is not suitable for login views, which should always have CSRF\nvalidation applied.\n\nThis authentication scheme allows you to delegate authentication to your web\nserver, which sets the `REMOTE_USER` environment variable.\n\nTo use it, you must have `django.contrib.auth.backends.RemoteUserBackend` (or\na subclass) in your `AUTHENTICATION_BACKENDS` setting. By default,\n`RemoteUserBackend` creates `User` objects for usernames that don't already\nexist. To change this and other behaviour, consult the Django documentation.\n\nIf successfully authenticated, `RemoteUserAuthentication` provides the\nfollowing credentials:\n\nConsult your web server's documentation for information about configuring an\nauthentication method, e.g.:\n\nTo implement a custom authentication scheme, subclass `BaseAuthentication` and\noverride the `.authenticate(self, request)` method. The method should return a\ntwo-tuple of `(user, auth)` if authentication succeeds, or `None` otherwise.\n\nIn some circumstances instead of returning `None`, you may want to raise an\n`AuthenticationFailed` exception from the `.authenticate()` method.\n\nTypically the approach you should take is:\n\nYou may also override the `.authenticate_header(self, request)` method. If\nimplemented, it should return a string that will be used as the value of the\n`WWW-Authenticate` header in a `HTTP 401 Unauthorized` response.\n\nIf the `.authenticate_header()` method is not overridden, the authentication\nscheme will return `HTTP 403 Forbidden` responses when an unauthenticated\nrequest is denied access.\n\nNote: When your custom authenticator is invoked by the request object's\n`.user` or `.auth` properties, you may see an `AttributeError` re-raised as a\n`WrappedAttributeError`. This is necessary to prevent the original exception\nfrom being suppressed by the outer property access. Python will not recognize\nthat the `AttributeError` originates from your custom authenticator and will\ninstead assume that the request object does not have a `.user` or `.auth`\nproperty. These errors should be fixed or otherwise handled by your\nauthenticator.\n\nThe following example will authenticate any incoming request as the user given\nby the username in a custom request header named 'X-USERNAME'.\n\nThe following third-party packages are also available.\n\nThe Django OAuth Toolkit package provides OAuth 2.0 support and works with\nPython 3.4+. The package is maintained by jazzband and uses the excellent\nOAuthLib. The package is well documented, and well supported and is currently\nour recommended package for OAuth 2.0 support.\n\nInstall using `pip`.\n\nAdd the package to your `INSTALLED_APPS` and modify your REST framework\nsettings.\n\nFor more details see the Django REST framework - Getting started\ndocumentation.\n\nThe Django REST framework OAuth package provides both OAuth1 and OAuth2\nsupport for REST framework.\n\nThis package was previously included directly in the REST framework but is now\nsupported and maintained as a third-party package.\n\nInstall the package using `pip`.\n\nFor details on configuration and usage see the Django REST framework OAuth\ndocumentation for authentication and permissions.\n\nJSON Web Token is a fairly new standard which can be used for token-based\nauthentication. Unlike the built-in TokenAuthentication scheme, JWT\nAuthentication doesn't need to use a database to validate a token. A package\nfor JWT authentication is djangorestframework-simplejwt which provides some\nfeatures as well as a pluggable token blacklist app.\n\nThe HawkREST library builds on the Mohawk library to let you work with Hawk\nsigned requests and responses in your API. Hawk lets two parties securely\ncommunicate with each other using messages signed by a shared key. It is based\non HTTP MAC access authentication (which was based on parts of OAuth 1.0).\n\nHTTP Signature (currently a IETF draft) provides a way to achieve origin\nauthentication and message integrity for HTTP messages. Similar to Amazon's\nHTTP Signature scheme, used by many of its services, it permits stateless,\nper-request authentication. Elvio Toccalino maintains the djangorestframework-\nhttpsignature (outdated) package which provides an easy to use HTTP Signature\nAuthentication mechanism. You can use the updated fork version of\ndjangorestframework-httpsignature, which is drf-httpsig.\n\nDjoser library provides a set of views to handle basic actions such as\nregistration, login, logout, password reset and account activation. The\npackage works with a custom user model and uses token-based authentication.\nThis is ready to use REST implementation of the Django authentication system.\n\nThis library provides a set of REST API endpoints for registration,\nauthentication (including social media authentication), password reset,\nretrieve and update user details, etc. By having these API endpoints, your\nclient apps such as AngularJS, iOS, Android, and others can communicate to\nyour Django backend site independently via REST APIs for user management.\n\nThere are currently two forks of this project.\n\nDjango-rest-framework-social-oauth2 library provides an easy way to integrate\nsocial plugins (facebook, twitter, google, etc.) to your authentication system\nand an easy oauth2 setup. With this library, you will be able to authenticate\nusers based on external tokens (e.g. facebook access token), convert these\ntokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to\nauthenticate your users.\n\nDjango-rest-knox library provides models and views to handle token-based\nauthentication in a more secure and extensible way than the built-in\nTokenAuthentication scheme - with Single Page Applications and Mobile clients\nin mind. It provides per-client tokens, and views to generate them when\nprovided some other authentication (usually basic authentication), to delete\nthe token (providing a server enforced logout) and to delete all tokens (logs\nout all clients that a user is logged into).\n\ndrfpasswordless adds (Medium, Square Cash inspired) passwordless support to\nDjango REST Framework's TokenAuthentication scheme. Users log in and sign up\nwith a token sent to a contact point like an email address or a mobile number.\n\ndjango-rest-authemail provides a RESTful API interface for user signup and\nauthentication. Email addresses are used for authentication, rather than\nusernames. API endpoints are available for signup, signup email verification,\nlogin, logout, password reset, password reset verification, email change,\nemail change verification, password change, and user detail. A fully\nfunctional example project and detailed instructions are included.\n\nDjango-Rest-Durin is built with the idea to have one library that does token\nauth for multiple Web/CLI/Mobile API clients via one interface but allows\ndifferent token configuration for each API Client that consumes the API. It\nprovides support for multiple tokens per user via custom models, views,\npermissions that work with Django-Rest-Framework. The token expiration time\ncan be different per API client and is customizable via the Django Admin\nInterface.\n\nMore information can be found in the Documentation.\n\nauthentication.py\n\n"}, {"name": "BooleanField", "path": "api-guide/fields/index#booleanfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "BrowsableAPIRenderer", "path": "api-guide/renderers/index#browsableapirenderer", "type": "Ref: Renderers", "text": "\nBefore a TemplateResponse instance can be returned to the client, it must be\nrendered. The rendering process takes the intermediate representation of\ntemplate and context, and turns it into the final byte stream that can be\nserved to the client.\n\n\u2014 Django documentation\n\nREST framework includes a number of built in Renderer classes, that allow you\nto return responses with various media types. There is also support for\ndefining your own custom renderers, which gives you the flexibility to design\nyour own media types.\n\nThe set of valid renderers for a view is always defined as a list of classes.\nWhen a view is entered REST framework will perform content negotiation on the\nincoming request, and determine the most appropriate renderer to satisfy the\nrequest.\n\nThe basic process of content negotiation involves examining the request's\n`Accept` header, to determine which media types it expects in the response.\nOptionally, format suffixes on the URL may be used to explicitly request a\nparticular representation. For example the URL\n`http://example.com/api/users_count.json` might be an endpoint that always\nreturns JSON data.\n\nFor more information see the documentation on content negotiation.\n\nThe default set of renderers may be set globally, using the\n`DEFAULT_RENDERER_CLASSES` setting. For example, the following settings would\nuse `JSON` as the main media type and also include the self describing API.\n\nYou can also set the renderers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nIt's important when specifying the renderer classes for your API to think\nabout what priority you want to assign to each media type. If a client\nunderspecifies the representations it can accept, such as sending an `Accept:\n*/*` header, or not including an `Accept` header at all, then REST framework\nwill select the first renderer in the list to use for the response.\n\nFor example if your API serves JSON responses and the HTML browsable API, you\nmight want to make `JSONRenderer` your default renderer, in order to send\n`JSON` responses to clients that do not specify an `Accept` header.\n\nIf your API includes views that can serve both regular webpages and API\nresponses depending on the request, then you might consider making\n`TemplateHTMLRenderer` your default renderer, in order to play nicely with\nolder browsers that send broken accept headers.\n\nRenders the request data into `JSON`, using utf-8 encoding.\n\nNote that the default style is to include unicode characters, and render the\nresponse using a compact style with no unnecessary whitespace:\n\nThe client may additionally include an `'indent'` media type parameter, in\nwhich case the returned `JSON` will be indented. For example `Accept:\napplication/json; indent=4`.\n\nThe default JSON encoding style can be altered using the `UNICODE_JSON` and\n`COMPACT_JSON` settings keys.\n\n.media_type: `application/json`\n\n.format: `'json'`\n\n.charset: `None`\n\nRenders data to HTML, using Django's standard template rendering. Unlike other\nrenderers, the data passed to the `Response` does not need to be serialized.\nAlso, unlike other renderers, you may want to include a `template_name`\nargument when creating the `Response`.\n\nThe TemplateHTMLRenderer will create a `RequestContext`, using the\n`response.data` as the context dict, and determine a template name to use to\nrender the context.\n\nNote: When used with a view that makes use of a serializer the `Response` sent\nfor rendering may not be a dictionary and will need to be wrapped in a dict\nbefore returning to allow the TemplateHTMLRenderer to render it. For example:\n\nThe template name is determined by (in order of preference):\n\nAn example of a view that uses `TemplateHTMLRenderer`:\n\nYou can use `TemplateHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\nIf you're building websites that use `TemplateHTMLRenderer` along with other\nrenderer classes, you should consider listing `TemplateHTMLRenderer` as the\nfirst class in the `renderer_classes` list, so that it will be prioritised\nfirst even for browsers that send poorly formed `ACCEPT:` headers.\n\nSee the HTML & Forms Topic Page for further examples of `TemplateHTMLRenderer`\nusage.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `StaticHTMLRenderer`\n\nA simple renderer that simply returns pre-rendered HTML. Unlike other\nrenderers, the data passed to the response object should be a string\nrepresenting the content to be returned.\n\nAn example of a view that uses `StaticHTMLRenderer`:\n\nYou can use `StaticHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `TemplateHTMLRenderer`\n\nRenders data into HTML for the Browsable API:\n\nThis renderer will determine which other renderer would have been given\nhighest priority, and use that to display an API style response within the\nHTML page.\n\n.media_type: `text/html`\n\n.format: `'api'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/api.html'`\n\nBy default the response content will be rendered with the highest priority\nrenderer apart from `BrowsableAPIRenderer`. If you need to customize this\nbehavior, for example to use HTML as the default return format, but use JSON\nin the browsable API, you can do so by overriding the `get_default_renderer()`\nmethod. For example:\n\nRenders data into HTML for an admin-like display:\n\nThis renderer is suitable for CRUD-style web APIs that should also present a\nuser-friendly interface for managing the data.\n\nNote that views that have nested or list serializers for their input won't\nwork well with the `AdminRenderer`, as the HTML forms are unable to properly\nsupport them.\n\nNote: The `AdminRenderer` is only able to include links to detail pages when a\nproperly configured `URL_FIELD_NAME` (`url` by default) attribute is present\nin the data. For `HyperlinkedModelSerializer` this will be the case, but for\n`ModelSerializer` or plain `Serializer` classes you'll need to make sure to\ninclude the field explicitly. For example here we use models\n`get_absolute_url` method:\n\n.media_type: `text/html`\n\n.format: `'admin'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/admin.html'`\n\nRenders data returned by a serializer into an HTML form. The output of this\nrenderer does not include the enclosing `<form>` tags, a hidden CSRF input or\nany submit buttons.\n\nThis renderer is not intended to be used directly, but can instead be used in\ntemplates by passing a serializer instance to the `render_form` template tag.\n\nFor more information see the HTML & Forms documentation.\n\n.media_type: `text/html`\n\n.format: `'form'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/horizontal/form.html'`\n\nThis renderer is used for rendering HTML multipart form data. It is not\nsuitable as a response renderer, but is instead used for creating test\nrequests, using REST framework's test client and test request factory.\n\n.media_type: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n.format: `'multipart'`\n\n.charset: `utf-8`\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the\n`.media_type` and `.format` properties, and implement the `.render(self, data,\nmedia_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the\nHTTP response.\n\nThe arguments passed to the `.render()` method are:\n\nThe request data, as set by the `Response()` instantiation.\n\nOptional. If provided, this is the accepted media type, as determined by the\ncontent negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the\nrenderer's `media_type` attribute, and may include media type parameters. For\nexample `\"application/json; nested=true\"`.\n\nOptional. If provided, this is a dictionary of contextual information provided\nby the view.\n\nBy default this will include the following keys: `view`, `request`,\n`response`, `args`, `kwargs`.\n\nThe following is an example plaintext renderer that will return a response\nwith the `data` parameter as the content of the response.\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To\nuse a different encoding, set the `charset` attribute on the renderer.\n\nNote that if a renderer class returns a unicode string, then the response\ncontent will be coerced into a bytestring by the `Response` class, with the\n`charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you\nshould set a charset value of `None`, which will ensure the `Content-Type`\nheader of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to\n`'binary'`. Doing so will also ensure that the browsable API will not attempt\nto display the binary content as a string.\n\nYou can do some pretty flexible things using REST framework's renderers. Some\nexamples...\n\nIn some cases you might want your view to use different serialization styles\ndepending on the accepted media type. If you need to do this you can access\n`request.accepted_renderer` to determine the negotiated renderer that will be\nused for the response.\n\nFor example:\n\nIn some cases you might want a renderer to serve a range of media types. In\nthis case you can underspecify the media types it should respond to, by using\na `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify\nthe media type explicitly when you return the response, using the\n`content_type` attribute. For example:\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked\nrelations may be sufficient. If you want to fully embrace RESTful design and\nHATEOAS you'll need to consider the design and usage of your media types in\nmore detail.\n\nIn the words of Roy Fielding, \"A REST API should spend almost all of its\ndescriptive effort in defining the media type(s) used for representing\nresources and driving application state, or in defining extended relation\nnames and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom\napplication/vnd.github+json media type, and Mike Amundsen's IANA approved\napplication/vnd.collection+json JSON-based hypermedia.\n\nTypically a renderer will behave the same regardless of if it's dealing with a\nregular response, or with a response caused by an exception being raised, such\nas an `Http404` or `PermissionDenied` exception, or a subclass of\n`APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer`\nand an exception is raised, the behavior is slightly different, and mirrors\nDjango's default handling of error views.\n\nExceptions raised and handled by an HTML renderer will attempt to render using\none of the following methods, by order of precedence.\n\nTemplates will render with a `RequestContext` which includes the `status_code`\nand `details` keys.\n\nNote: If `DEBUG=True`, Django's standard traceback error page will be\ndisplayed instead of rendering the HTTP status code and text.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST framework JSONP provides JSONP rendering support. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nWarning: If you require cross-domain AJAX requests, you should generally be\nusing the more modern approach of CORS as an alternative to `JSONP`. See the\nCORS documentation for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is only appropriate\nfor globally readable API endpoints, where `GET` requests are unauthenticated\nand do not require any user permissions.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\nXLSX is the world's most popular binary spreadsheet format. Tim Allen of The\nWharton School maintains drf-renderer-xlsx, which renders an endpoint as an\nXLSX spreadsheet using OpenPyXL, and allows the client to download it.\nSpreadsheets can be styled on a per-view basis.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nTo avoid having a file streamed without a filename (which the browser will\noften default to the filename \"download\", with no extension), we need to use a\nmixin to override the `Content-Disposition` header. If no filename is\nprovided, it will default to `export.xlsx`. For example:\n\nComma-separated values are a plain-text tabular data format, that can be\neasily imported into spreadsheet applications. Mjumbe Poe maintains the\ndjangorestframework-csv package which provides CSV renderer support for REST\nframework.\n\nUltraJSON is an optimized C JSON encoder which can give significantly faster\nJSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now\nunmaintained drf-ujson-renderer, which implements JSON rendering using the\nUJSON package.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nDjango REST Pandas provides a serializer and renderers that support additional\ndata processing and output via the Pandas DataFrame API. Django REST Pandas\nincludes renderers for Pandas-style CSV files, Excel workbooks (both `.xls`\nand `.xlsx`), and a number of other formats. It is maintained by S. Andrew\nSheppard as part of the wq Project.\n\nRest Framework Latex provides a renderer that outputs PDFs using Laulatex. It\nis maintained by Pebble (S/F Software).\n\nrenderers.py\n\n"}, {"name": "Caching", "path": "api-guide/caching/index", "type": "API Guide", "text": "\nA certain woman had a very sharp consciousness but almost no memory ... She\nremembered enough to work, and she worked hard. - Lydia Davis\n\nCaching in REST Framework works well with the cache utilities provided in\nDjango.\n\nDjango provides a `method_decorator` to use decorators with class based views.\nThis can be used with other cache decorators such as `cache_page`,\n`vary_on_cookie` and `vary_on_headers`.\n\nNOTE: The `cache_page` decorator only caches the `GET` and `HEAD` responses\nwith status 200.\n\n"}, {"name": "CharField", "path": "api-guide/fields/index#charfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "ChoiceField", "path": "api-guide/fields/index#choicefield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "Class-based Views", "path": "api-guide/views/index", "type": "API Guide", "text": "\nDjango's class-based views are a welcome departure from the old-style views.\n\n\u2014 Reinout van Rees\n\nREST framework provides an `APIView` class, which subclasses Django's `View`\nclass.\n\n`APIView` classes are different from regular `View` classes in the following\nways:\n\nUsing the `APIView` class is pretty much the same as using a regular `View`\nclass, as usual, the incoming request is dispatched to an appropriate handler\nmethod such as `.get()` or `.post()`. Additionally, a number of attributes may\nbe set on the class that control various aspects of the API policy.\n\nFor example:\n\nNote: The full methods, attributes on, and relations between Django REST\nFramework's `APIView`, `GenericAPIView`, various `Mixins`, and `Viewsets` can\nbe initially complex. In addition to the documentation here, the Classy Django\nREST Framework resource provides a browsable reference, with full methods and\nattributes, for each of Django REST Framework's class-based views.\n\nThe following attributes control the pluggable aspects of API views.\n\nThe following methods are used by REST framework to instantiate the various\npluggable API policies. You won't typically need to override these methods.\n\nThe following methods are called before dispatching to the handler method.\n\nThe following methods are called directly by the view's `.dispatch()` method.\nThese perform any actions that need to occur before or after calling the\nhandler methods such as `.get()`, `.post()`, `put()`, `patch()` and\n`.delete()`.\n\nPerforms any actions that need to occur before the handler method gets called.\nThis method is used to enforce permissions and throttling, and perform content\nnegotiation.\n\nYou won't typically need to override this method.\n\nAny exception thrown by the handler method will be passed to this method,\nwhich either returns a `Response` instance, or re-raises the exception.\n\nThe default implementation handles any subclass of\n`rest_framework.exceptions.APIException`, as well as Django's `Http404` and\n`PermissionDenied` exceptions, and returns an appropriate error response.\n\nIf you need to customize the error responses your API returns you should\nsubclass this method.\n\nEnsures that the request object that is passed to the handler method is an\ninstance of `Request`, rather than the usual Django `HttpRequest`.\n\nYou won't typically need to override this method.\n\nEnsures that any `Response` object returned from the handler method will be\nrendered into the correct content type, as determined by the content\nnegotiation.\n\nYou won't typically need to override this method.\n\nSaying [that class-based views] is always the superior solution is a mistake.\n\n\u2014 Nick Coghlan\n\nREST framework also allows you to work with regular function based views. It\nprovides a set of simple decorators that wrap your function based views to\nensure they receive an instance of `Request` (rather than the usual Django\n`HttpRequest`) and allows them to return a `Response` (instead of a Django\n`HttpResponse`), and allow you to configure how the request is processed.\n\nSignature: `@api_view(http_method_names=['GET'])`\n\nThe core of this functionality is the `api_view` decorator, which takes a list\nof HTTP methods that your view should respond to. For example, this is how you\nwould write a very simple view that just manually returns some data:\n\nThis view will use the default renderers, parsers, authentication classes etc\nspecified in the settings.\n\nBy default only `GET` methods will be accepted. Other methods will respond\nwith \"405 Method Not Allowed\". To alter this behaviour, specify which methods\nthe view allows, like so:\n\nTo override the default settings, REST framework provides a set of additional\ndecorators which can be added to your views. These must come after (below) the\n`@api_view` decorator. For example, to create a view that uses a throttle to\nensure it can only be called once per day by a particular user, use the\n`@throttle_classes` decorator, passing a list of throttle classes:\n\nThese decorators correspond to the attributes set on `APIView` subclasses,\ndescribed above.\n\nThe available decorators are:\n\nEach of these decorators takes a single argument which must be a list or tuple\nof classes.\n\nTo override the default schema generation for function based views you may use\nthe `@schema` decorator. This must come after (below) the `@api_view`\ndecorator. For example:\n\nThis decorator takes a single `AutoSchema` instance, an `AutoSchema` subclass\ninstance or `ManualSchema` instance as described in the Schemas documentation.\nYou may pass `None` in order to exclude the view from schema generation.\n\ndecorators.pyviews.py\n\n"}, {"name": "Content negotiation", "path": "api-guide/content-negotiation/index", "type": "API Guide", "text": "\nHTTP has provisions for several mechanisms for \"content negotiation\" - the\nprocess of selecting the best representation for a given response when there\nare multiple representations available.\n\n\u2014 RFC 2616, Fielding et al.\n\nContent negotiation is the process of selecting one of multiple possible\nrepresentations to return to a client, based on client or server preferences.\n\nREST framework uses a simple style of content negotiation to determine which\nmedia type should be returned to a client, based on the available renderers,\nthe priorities of each of those renderers, and the client's `Accept:` header.\nThe style used is partly client-driven, and partly server-driven.\n\nFor example, given the following `Accept` header:\n\nThe priorities for each of the given media types would be:\n\nIf the requested view was only configured with renderers for `YAML` and\n`HTML`, then REST framework would select whichever renderer was listed first\nin the `renderer_classes` list or `DEFAULT_RENDERER_CLASSES` setting.\n\nFor more information on the `HTTP Accept` header, see RFC 2616\n\nNote: \"q\" values are not taken into account by REST framework when determining\npreference. The use of \"q\" values negatively impacts caching, and in the\nauthor's opinion they are an unnecessary and overcomplicated approach to\ncontent negotiation.\n\nThis is a valid approach as the HTTP spec deliberately underspecifies how a\nserver should weight server-based preferences against client-based\npreferences.\n\nIt's unlikely that you'll want to provide a custom content negotiation scheme\nfor REST framework, but you can do so if needed. To implement a custom content\nnegotiation scheme override `BaseContentNegotiation`.\n\nREST framework's content negotiation classes handle selection of both the\nappropriate parser for the request, and the appropriate renderer for the\nresponse, so you should implement both the `.select_parser(request, parsers)`\nand `.select_renderer(request, renderers, format_suffix)` methods.\n\nThe `select_parser()` method should return one of the parser instances from\nthe list of available parsers, or `None` if none of the parsers can handle the\nincoming request.\n\nThe `select_renderer()` method should return a two-tuple of (renderer\ninstance, media type), or raise a `NotAcceptable` exception.\n\nThe following is a custom content negotiation class which ignores the client\nrequest when selecting the appropriate parser or renderer.\n\nThe default content negotiation class may be set globally, using the\n`DEFAULT_CONTENT_NEGOTIATION_CLASS` setting. For example, the following\nsettings would use our example `IgnoreClientContentNegotiation` class.\n\nYou can also set the content negotiation used for an individual view, or\nviewset, using the `APIView` class-based views.\n\nnegotiation.py\n\n"}, {"name": "Content type controls", "path": "api-guide/settings/index#content-type-controls", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "CreateAPIView", "path": "api-guide/generic-views/index#createapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "CreateModelMixin", "path": "api-guide/generic-views/index#createmodelmixin", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "CursorPagination", "path": "api-guide/pagination/index#cursorpagination", "type": "Ref: Pagination", "text": "\nDjango provides a few classes that help you manage paginated data \u2013 that is,\ndata that\u2019s split across several pages, with \u201cPrevious/Next\u201d links.\n\n\u2014 Django documentation\n\nREST framework includes support for customizable pagination styles. This\nallows you to modify how large result sets are split into individual pages of\ndata.\n\nThe pagination API can support either:\n\nThe built-in styles currently all use links included as part of the content of\nthe response. This style is more accessible when using the browsable API.\n\nPagination is only performed automatically if you're using the generic views\nor viewsets. If you're using a regular `APIView`, you'll need to call into the\npagination API yourself to ensure you return a paginated response. See the\nsource code for the `mixins.ListModelMixin` and `generics.GenericAPIView`\nclasses for an example.\n\nPagination can be turned off by setting the pagination class to `None`.\n\nThe pagination style may be set globally, using the `DEFAULT_PAGINATION_CLASS`\nand `PAGE_SIZE` setting keys. For example, to use the built-in limit/offset\npagination, you would do something like this:\n\nNote that you need to set both the pagination class, and the page size that\nshould be used. Both `DEFAULT_PAGINATION_CLASS` and `PAGE_SIZE` are `None` by\ndefault.\n\nYou can also set the pagination class on an individual view by using the\n`pagination_class` attribute. Typically you'll want to use the same pagination\nstyle throughout your API, although you might want to vary individual aspects\nof the pagination, such as default or maximum page size, on a per-view basis.\n\nIf you want to modify particular aspects of the pagination style, you'll want\nto override one of the pagination classes, and set the attributes that you\nwant to change.\n\nYou can then apply your new style to a view using the `pagination_class`\nattribute:\n\nOr apply the style globally, using the `DEFAULT_PAGINATION_CLASS` settings\nkey. For example:\n\nThis pagination style accepts a single number page number in the request query\nparameters.\n\nRequest:\n\nResponse:\n\nTo enable the `PageNumberPagination` style globally, use the following\nconfiguration, and set the `PAGE_SIZE` as desired:\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `PageNumberPagination` on a per-view basis.\n\nThe `PageNumberPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `PageNumberPagination` class,\nand then enable your custom pagination class as above.\n\nThis pagination style mirrors the syntax used when looking up multiple\ndatabase records. The client includes both a \"limit\" and an \"offset\" query\nparameter. The limit indicates the maximum number of items to return, and is\nequivalent to the `page_size` in other styles. The offset indicates the\nstarting position of the query in relation to the complete set of unpaginated\nitems.\n\nRequest:\n\nResponse:\n\nTo enable the `LimitOffsetPagination` style globally, use the following\nconfiguration:\n\nOptionally, you may also set a `PAGE_SIZE` key. If the `PAGE_SIZE` parameter\nis also used then the `limit` query parameter will be optional, and may be\nomitted by the client.\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `LimitOffsetPagination` on a per-view basis.\n\nThe `LimitOffsetPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `LimitOffsetPagination` class,\nand then enable your custom pagination class as above.\n\nThe cursor-based pagination presents an opaque \"cursor\" indicator that the\nclient may use to page through the result set. This pagination style only\npresents forward and reverse controls, and does not allow the client to\nnavigate to arbitrary positions.\n\nCursor based pagination requires that there is a unique, unchanging ordering\nof items in the result set. This ordering might typically be a creation\ntimestamp on the records, as this presents a consistent ordering to paginate\nagainst.\n\nCursor based pagination is more complex than other schemes. It also requires\nthat the result set presents a fixed ordering, and does not allow the client\nto arbitrarily index into the result set. However it does provide the\nfollowing benefits:\n\nProper use of cursor based pagination requires a little attention to detail.\nYou'll need to think about what ordering you want the scheme to be applied\nagainst. The default is to order by `\"-created\"`. This assumes that there must\nbe a 'created' timestamp field on the model instances, and will present a\n\"timeline\" style paginated view, with the most recently added items first.\n\nYou can modify the ordering by overriding the `'ordering'` attribute on the\npagination class, or by using the `OrderingFilter` filter class together with\n`CursorPagination`. When used with `OrderingFilter` you should strongly\nconsider restricting the fields that the user may order by.\n\nProper usage of cursor pagination should have an ordering field that satisfies\nthe following:\n\nUsing an ordering field that does not satisfy these constraints will generally\nstill work, but you'll be losing some of the benefits of cursor pagination.\n\nFor more technical details on the implementation we use for cursor pagination,\nthe \"Building cursors for the Disqus API\" blog post gives a good overview of\nthe basic approach.\n\nTo enable the `CursorPagination` style globally, use the following\nconfiguration, modifying the `PAGE_SIZE` as desired:\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `CursorPagination` on a per-view basis.\n\nThe `CursorPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `CursorPagination` class, and\nthen enable your custom pagination class as above.\n\nTo create a custom pagination serializer class, you should inherit the\nsubclass `pagination.BasePagination`, override the `paginate_queryset(self,\nqueryset, request, view=None)`, and `get_paginated_response(self, data)`\nmethods:\n\nNote that the `paginate_queryset` method may set state on the pagination\ninstance, that may later be used by the `get_paginated_response` method.\n\nSuppose we want to replace the default pagination output style with a modified\nformat that includes the next and previous links under in a nested 'links'\nkey. We could specify a custom pagination class like so:\n\nWe'd then need to setup the custom class in our configuration:\n\nNote that if you care about how the ordering of keys is displayed in responses\nin the browsable API you might choose to use an `OrderedDict` when\nconstructing the body of paginated responses, but this is optional.\n\nTo have your custom pagination class be used by default, use the\n`DEFAULT_PAGINATION_CLASS` setting:\n\nAPI responses for list endpoints will now include a `Link` header, instead of\nincluding the pagination links as part of the body of the response, for\nexample:\n\nA custom pagination style, using the 'Link' header'\n\nYou can also make the pagination controls available to the schema\nautogeneration that REST framework provides, by implementing a\n`get_schema_fields()` method. This method should have the following signature:\n\n`get_schema_fields(self, view)`\n\nThe method should return a list of `coreapi.Field` instances.\n\nBy default using the pagination classes will cause HTML pagination controls to\nbe displayed in the browsable API. There are two built-in display styles. The\n`PageNumberPagination` and `LimitOffsetPagination` classes display a list of\npage numbers with previous and next controls. The `CursorPagination` class\ndisplays a simpler style that only displays a previous and next control.\n\nYou can override the templates that render the HTML pagination controls. The\ntwo built-in styles are:\n\nProviding a template with either of these paths in a global template directory\nwill override the default rendering for the relevant pagination classes.\n\nAlternatively you can disable HTML pagination controls completely by\nsubclassing on of the existing classes, setting `template = None` as an\nattribute on the class. You'll then need to configure your\n`DEFAULT_PAGINATION_CLASS` settings key to use your custom class as the\ndefault pagination style.\n\nThe low-level API for determining if a pagination class should display the\ncontrols or not is exposed as a `display_page_controls` attribute on the\npagination instance. Custom pagination classes should be set to `True` in the\n`paginate_queryset` method if they require the HTML pagination controls to be\ndisplayed.\n\nThe `.to_html()` and `.get_html_context()` methods may also be overridden in a\ncustom pagination class in order to further customize how the controls are\nrendered.\n\nThe following third party packages are also available.\n\nThe `DRF-extensions` package includes a `PaginateByMaxMixin` mixin class that\nallows your API clients to specify `?page_size=max` to obtain the maximum\nallowed page size.\n\nThe `drf-proxy-pagination` package includes a `ProxyPagination` class which\nallows to choose pagination class with a query parameter.\n\nThe `django-rest-framework-link-header-pagination` package includes a\n`LinkHeaderPagination` class which provides pagination via an HTTP `Link`\nheader as described in Github's developer documentation.\n\npagination.py\n\n"}, {"name": "Date and time formatting", "path": "api-guide/settings/index#date-and-time-formatting", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "DateField", "path": "api-guide/fields/index#datefield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "DateTimeField", "path": "api-guide/fields/index#datetimefield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "DecimalField", "path": "api-guide/fields/index#decimalfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "DefaultRouter", "path": "api-guide/routers/index#defaultrouter", "type": "Ref: Routers", "text": "\nResource routing allows you to quickly declare all of the common routes for a\ngiven resourceful controller. Instead of declaring separate routes for your\nindex... a resourceful route declares them in a single line of code.\n\n\u2014 Ruby on Rails Documentation\n\nSome Web frameworks such as Rails provide functionality for automatically\ndetermining how the URLs for an application should be mapped to the logic that\ndeals with handling incoming requests.\n\nREST framework adds support for automatic URL routing to Django, and provides\nyou with a simple, quick and consistent way of wiring your view logic to a set\nof URLs.\n\nHere's an example of a simple URL conf, that uses `SimpleRouter`.\n\nThere are two mandatory arguments to the `register()` method:\n\nOptionally, you may also specify an additional argument:\n\nThe example above would generate the following URL patterns:\n\nNote: The `basename` argument is used to specify the initial part of the view\nname pattern. In the example above, that's the `user` or `account` part.\n\nTypically you won't need to specify the `basename` argument, but if you have a\nviewset where you've defined a custom `get_queryset` method, then the viewset\nmay not have a `.queryset` attribute set. If you try to register that viewset\nyou'll see an error like this:\n\nThis means you'll need to explicitly set the `basename` argument when\nregistering the viewset, as it could not be automatically determined from the\nmodel name.\n\nThe `.urls` attribute on a router instance is simply a standard list of URL\npatterns. There are a number of different styles for how you can include these\nURLs.\n\nFor example, you can append `router.urls` to a list of existing views...\n\nAlternatively you can use Django's `include` function, like so...\n\nYou may use `include` with an application namespace:\n\nOr both an application and instance namespace:\n\nSee Django's URL namespaces docs and the `include` API reference for more\ndetails.\n\nNote: If using namespacing with hyperlinked serializers you'll also need to\nensure that any `view_name` parameters on the serializers correctly reflect\nthe namespace. In the examples above you'd need to include a parameter such as\n`view_name='app_name:user-detail'` for serializer fields hyperlinked to the\nuser detail view.\n\nThe automatic `view_name` generation uses a pattern like\n`%(model_name)-detail`. Unless your models names actually clash you may be\nbetter off not namespacing your Django REST Framework views when using\nhyperlinked serializers.\n\nA viewset may mark extra actions for routing by decorating a method with the\n`@action` decorator. These extra actions will be included in the generated\nroutes. For example, given the `set_password` method on the `UserViewSet`\nclass:\n\nThe following route would be generated:\n\nBy default, the URL pattern is based on the method name, and the URL name is\nthe combination of the `ViewSet.basename` and the hyphenated method name. If\nyou don't want to use the defaults for either of these values, you can instead\nprovide the `url_path` and `url_name` arguments to the `@action` decorator.\n\nFor example, if you want to change the URL for our custom action to\n`^users/{pk}/change-password/$`, you could write:\n\nThe above example would now generate the following URL pattern:\n\nThis router includes routes for the standard set of `list`, `create`,\n`retrieve`, `update`, `partial_update` and `destroy` actions. The viewset can\nalso mark additional methods to be routed, using the `@action` decorator.\n\nBy default the URLs created by `SimpleRouter` are appended with a trailing\nslash. This behavior can be modified by setting the `trailing_slash` argument\nto `False` when instantiating the router. For example:\n\nTrailing slashes are conventional in Django, but are not used by default in\nsome other frameworks such as Rails. Which style you choose to use is largely\na matter of preference, although some javascript frameworks may expect a\nparticular routing style.\n\nThe router will match lookup values containing any characters except slashes\nand period characters. For a more restrictive (or lenient) lookup pattern, set\nthe `lookup_value_regex` attribute on the viewset. For example, you can limit\nthe lookup to valid UUIDs:\n\nThis router is similar to `SimpleRouter` as above, but additionally includes a\ndefault API root view, that returns a response containing hyperlinks to all\nthe list views. It also generates routes for optional `.json` style format\nsuffixes.\n\nAs with `SimpleRouter` the trailing slashes on the URL routes can be removed\nby setting the `trailing_slash` argument to `False` when instantiating the\nrouter.\n\nImplementing a custom router isn't something you'd need to do very often, but\nit can be useful if you have specific requirements about how the URLs for your\nAPI are structured. Doing so allows you to encapsulate the URL structure in a\nreusable way that ensures you don't have to write your URL patterns explicitly\nfor each new view.\n\nThe simplest way to implement a custom router is to subclass one of the\nexisting router classes. The `.routes` attribute is used to template the URL\npatterns that will be mapped to each viewset. The `.routes` attribute is a\nlist of `Route` named tuples.\n\nThe arguments to the `Route` named tuple are:\n\nurl: A string representing the URL to be routed. May include the following\nformat strings:\n\nmapping: A mapping of HTTP method names to the view methods\n\nname: The name of the URL as used in `reverse` calls. May include the\nfollowing format string:\n\ninitkwargs: A dictionary of any additional arguments that should be passed\nwhen instantiating the view. Note that the `detail`, `basename`, and `suffix`\narguments are reserved for viewset introspection and are also used by the\nbrowsable API to generate the view name and breadcrumb links.\n\nYou can also customize how the `@action` decorator is routed. Include the\n`DynamicRoute` named tuple in the `.routes` list, setting the `detail`\nargument as appropriate for the list-based and detail-based routes. In\naddition to `detail`, the arguments to `DynamicRoute` are:\n\nurl: A string representing the URL to be routed. May include the same format\nstrings as `Route`, and additionally accepts the `{url_path}` format string.\n\nname: The name of the URL as used in `reverse` calls. May include the\nfollowing format strings:\n\ninitkwargs: A dictionary of any additional arguments that should be passed\nwhen instantiating the view.\n\nThe following example will only route to the `list` and `retrieve` actions,\nand does not use the trailing slash convention.\n\nLet's take a look at the routes our `CustomReadOnlyRouter` would generate for\na simple viewset.\n\n`views.py`:\n\n`urls.py`:\n\nThe following mappings would be generated...\n\nFor another example of setting the `.routes` attribute, see the source code\nfor the `SimpleRouter` class.\n\nIf you want to provide totally custom behavior, you can override `BaseRouter`\nand override the `get_urls(self)` method. The method should inspect the\nregistered viewsets and return a list of URL patterns. The registered prefix,\nviewset and basename tuples may be inspected by accessing the `self.registry`\nattribute.\n\nYou may also want to override the `get_default_basename(self, viewset)`\nmethod, or else always explicitly set the `basename` argument when registering\nyour viewsets with the router.\n\nThe following third party packages are also available.\n\nThe drf-nested-routers package provides routers and relationship fields for\nworking with nested resources.\n\nThe wq.db package provides an advanced ModelRouter class (and singleton\ninstance) that extends `DefaultRouter` with a `register_model()` API. Much\nlike Django's `admin.site.register`, the only required argument to\n`rest.router.register_model` is a model class. Reasonable defaults for a url\nprefix, serializer, and viewset will be inferred from the model and global\nconfiguration.\n\nThe `DRF-extensions` package provides routers for creating nested viewsets,\ncollection level controllers with customizable endpoint names.\n\nrouters.py\n\n"}, {"name": "DestroyAPIView", "path": "api-guide/generic-views/index#destroyapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "DestroyModelMixin", "path": "api-guide/generic-views/index#destroymodelmixin", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "DictField", "path": "api-guide/fields/index#dictfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "DjangoFilterBackend", "path": "api-guide/filtering/index#djangofilterbackend", "type": "Ref: Filtering", "text": "\nThe root QuerySet provided by the Manager describes all objects in the\ndatabase table. Usually, though, you'll need to select only a subset of the\ncomplete set of objects.\n\n\u2014 Django documentation\n\nThe default behavior of REST framework's generic list views is to return the\nentire queryset for a model manager. Often you will want your API to restrict\nthe items that are returned by the queryset.\n\nThe simplest way to filter the queryset of any view that subclasses\n`GenericAPIView` is to override the `.get_queryset()` method.\n\nOverriding this method allows you to customize the queryset returned by the\nview in a number of different ways.\n\nYou might want to filter the queryset to ensure that only results relevant to\nthe currently authenticated user making the request are returned.\n\nYou can do so by filtering based on the value of `request.user`.\n\nFor example:\n\nAnother style of filtering might involve restricting the queryset based on\nsome part of the URL.\n\nFor example if your URL config contained an entry like this:\n\nYou could then write a view that returned a purchase queryset filtered by the\nusername portion of the URL:\n\nA final example of filtering the initial queryset would be to determine the\ninitial queryset based on query parameters in the url.\n\nWe can override `.get_queryset()` to deal with URLs such as\n`http://example.com/api/purchases?username=denvercoder9`, and filter the\nqueryset only if the `username` parameter is included in the URL:\n\nAs well as being able to override the default queryset, REST framework also\nincludes support for generic filtering backends that allow you to easily\nconstruct complex searches and filters.\n\nGeneric filters can also present themselves as HTML controls in the browsable\nAPI and admin API.\n\nThe default filter backends may be set globally, using the\n`DEFAULT_FILTER_BACKENDS` setting. For example.\n\nYou can also set the filter backends on a per-view, or per-viewset basis,\nusing the `GenericAPIView` class-based views.\n\nNote that if a filter backend is configured for a view, then as well as being\nused to filter list views, it will also be used to filter the querysets used\nfor returning a single object.\n\nFor instance, given the previous example, and a product with an id of `4675`,\nthe following URL would either return the corresponding object, or return a\n404 response, depending on if the filtering conditions were met by the given\nproduct instance:\n\nNote that you can use both an overridden `.get_queryset()` and generic\nfiltering together, and everything will work as expected. For example, if\n`Product` had a many-to-many relationship with `User`, named `purchase`, you\nmight want to write a view like this:\n\nThe `django-filter` library includes a `DjangoFilterBackend` class which\nsupports highly customizable field filtering for REST framework.\n\nTo use `DjangoFilterBackend`, first install `django-filter`.\n\nThen add `'django_filters'` to Django's `INSTALLED_APPS`:\n\nYou should now either add the filter backend to your settings:\n\nOr add the filter backend to an individual View or ViewSet.\n\nIf all you need is simple equality-based filtering, you can set a\n`filterset_fields` attribute on the view, or viewset, listing the set of\nfields you wish to filter against.\n\nThis will automatically create a `FilterSet` class for the given fields, and\nwill allow you to make requests such as:\n\nFor more advanced filtering requirements you can specify a `FilterSet` class\nthat should be used by the view. You can read more about `FilterSet`s in the\ndjango-filter documentation. It's also recommended that you read the section\non DRF integration.\n\nThe `SearchFilter` class supports simple single query parameter based\nsearching, and is based on the Django admin's search functionality.\n\nWhen in use, the browsable API will include a `SearchFilter` control:\n\nThe `SearchFilter` class will only be applied if the view has a\n`search_fields` attribute set. The `search_fields` attribute should be a list\nof names of text type fields on the model, such as `CharField` or `TextField`.\n\nThis will allow the client to filter the items in the list by making queries\nsuch as:\n\nYou can also perform a related lookup on a ForeignKey or ManyToManyField with\nthe lookup API double-underscore notation:\n\nFor JSONField and HStoreField fields you can filter based on nested values\nwithin the data structure using the same double-underscore notation:\n\nBy default, searches will use case-insensitive partial matches. The search\nparameter may contain multiple search terms, which should be whitespace and/or\ncomma separated. If multiple search terms are used then objects will be\nreturned in the list only if all the provided terms are matched.\n\nThe search behavior may be restricted by prepending various characters to the\n`search_fields`.\n\nFor example:\n\nBy default, the search parameter is named `'search'`, but this may be\noverridden with the `SEARCH_PARAM` setting.\n\nTo dynamically change search fields based on request content, it's possible to\nsubclass the `SearchFilter` and override the `get_search_fields()` function.\nFor example, the following subclass will only search on `title` if the query\nparameter `title_only` is in the request:\n\nFor more details, see the Django documentation.\n\nThe `OrderingFilter` class supports simple query parameter controlled ordering\nof results.\n\nBy default, the query parameter is named `'ordering'`, but this may by\noverridden with the `ORDERING_PARAM` setting.\n\nFor example, to order users by username:\n\nThe client may also specify reverse orderings by prefixing the field name with\n'-', like so:\n\nMultiple orderings may also be specified:\n\nIt's recommended that you explicitly specify which fields the API should\nallowing in the ordering filter. You can do this by setting an\n`ordering_fields` attribute on the view, like so:\n\nThis helps prevent unexpected data leakage, such as allowing users to order\nagainst a password hash field or other sensitive data.\n\nIf you don't specify an `ordering_fields` attribute on the view, the filter\nclass will default to allowing the user to filter on any readable fields on\nthe serializer specified by the `serializer_class` attribute.\n\nIf you are confident that the queryset being used by the view doesn't contain\nany sensitive data, you can also explicitly specify that a view should allow\nordering on any model field or queryset aggregate, by using the special value\n`'__all__'`.\n\nIf an `ordering` attribute is set on the view, this will be used as the\ndefault ordering.\n\nTypically you'd instead control this by setting `order_by` on the initial\nqueryset, but using the `ordering` parameter on the view allows you to specify\nthe ordering in a way that it can then be passed automatically as context to a\nrendered template. This makes it possible to automatically render column\nheaders differently if they are being used to order the results.\n\nThe `ordering` attribute may be either a string or a list/tuple of strings.\n\nYou can also provide your own generic filtering backend, or write an\ninstallable app for other developers to use.\n\nTo do so override `BaseFilterBackend`, and override the\n`.filter_queryset(self, request, queryset, view)` method. The method should\nreturn a new, filtered queryset.\n\nAs well as allowing clients to perform searches and filtering, generic filter\nbackends can be useful for restricting which objects should be visible to any\ngiven request or user.\n\nFor example, you might need to restrict users to only being able to see\nobjects they created.\n\nWe could achieve the same behavior by overriding `get_queryset()` on the\nviews, but using a filter backend allows you to more easily add this\nrestriction to multiple views, or to apply it across the entire API.\n\nGeneric filters may also present an interface in the browsable API. To do so\nyou should implement a `to_html()` method which returns a rendered HTML\nrepresentation of the filter. This method should have the following signature:\n\n`to_html(self, request, queryset, view)`\n\nThe method should return a rendered HTML string.\n\nYou can also make the filter controls available to the schema autogeneration\nthat REST framework provides, by implementing a `get_schema_fields()` method.\nThis method should have the following signature:\n\n`get_schema_fields(self, view)`\n\nThe method should return a list of `coreapi.Field` instances.\n\nThe following third party packages provide additional filter implementations.\n\nThe django-rest-framework-filters package works together with the\n`DjangoFilterBackend` class, and allows you to easily create filters across\nrelationships, or create multiple filter lookup types for a given field.\n\nThe djangorestframework-word-filter developed as alternative to\n`filters.SearchFilter` which will search full word in text, or exact match.\n\ndjango-url-filter provides a safe way to filter data via human-friendly URLs.\nIt works very similar to DRF serializers and fields in a sense that they can\nbe nested except they are called filtersets and filters. That provides easy\nway to filter related data. Also this library is generic-purpose so it can be\nused to filter other sources of data and not only Django `QuerySet`s.\n\ndrf-url-filter is a simple Django app to apply filters on drf `ModelViewSet`'s\n`Queryset` in a clean, simple and configurable way. It also supports\nvalidations on incoming query params and their values. A beautiful python\npackage `Voluptuous` is being used for validations on the incoming query\nparameters. The best part about voluptuous is you can define your own\nvalidations as per your query params requirements.\n\nfilters.py\n\n"}, {"name": "DjangoModelPermissions", "path": "api-guide/permissions/index#djangomodelpermissions", "type": "Ref: Permissions", "text": "\nAuthentication or identification by itself is not usually sufficient to gain\naccess to information or code. For that, the entity requesting access must\nhave authorization.\n\n\u2014 Apple Developer Documentation\n\nTogether with authentication and throttling, permissions determine whether a\nrequest should be granted or denied access.\n\nPermission checks are always run at the very start of the view, before any\nother code is allowed to proceed. Permission checks will typically use the\nauthentication information in the `request.user` and `request.auth` properties\nto determine if the incoming request should be permitted.\n\nPermissions are used to grant or deny access for different classes of users to\ndifferent parts of the API.\n\nThe simplest style of permission would be to allow access to any authenticated\nuser, and deny access to any unauthenticated user. This corresponds to the\n`IsAuthenticated` class in REST framework.\n\nA slightly less strict style of permission would be to allow full access to\nauthenticated users, but allow read-only access to unauthenticated users. This\ncorresponds to the `IsAuthenticatedOrReadOnly` class in REST framework.\n\nPermissions in REST framework are always defined as a list of permission\nclasses.\n\nBefore running the main body of the view each permission in the list is\nchecked. If any permission check fails an `exceptions.PermissionDenied` or\n`exceptions.NotAuthenticated` exception will be raised, and the main body of\nthe view will not run.\n\nWhen the permissions checks fail either a \"403 Forbidden\" or a \"401\nUnauthorized\" response will be returned, according to the following rules:\n\nREST framework permissions also support object-level permissioning. Object\nlevel permissions are used to determine if a user should be allowed to act on\na particular object, which will typically be a model instance.\n\nObject level permissions are run by REST framework's generic views when\n`.get_object()` is called. As with view level permissions, an\n`exceptions.PermissionDenied` exception will be raised if the user is not\nallowed to act on the given object.\n\nIf you're writing your own views and want to enforce object level permissions,\nor if you override the `get_object` method on a generic view, then you'll need\nto explicitly call the `.check_object_permissions(request, obj)` method on the\nview at the point at which you've retrieved the object.\n\nThis will either raise a `PermissionDenied` or `NotAuthenticated` exception,\nor simply return if the view has the appropriate permissions.\n\nFor example:\n\nNote: With the exception of `DjangoObjectPermissions`, the provided permission\nclasses in `rest_framework.permissions` do not implement the methods necessary\nto check object permissions.\n\nIf you wish to use the provided permission classes in order to check object\npermissions, you must subclass them and implement the\n`has_object_permission()` method described in the Custom permissions section\n(below).\n\nFor performance reasons the generic views will not automatically apply object\nlevel permissions to each instance in a queryset when returning a list of\nobjects.\n\nOften when you're using object level permissions you'll also want to filter\nthe queryset appropriately, to ensure that users only have visibility onto\ninstances that they are permitted to view.\n\nBecause the `get_object()` method is not called, object level permissions from\nthe `has_object_permission()` method are not applied when creating objects. In\norder to restrict object creation you need to implement the permission check\neither in your Serializer class or override the `perform_create()` method of\nyour ViewSet class.\n\nThe default permission policy may be set globally, using the\n`DEFAULT_PERMISSION_CLASSES` setting. For example.\n\nIf not specified, this setting defaults to allowing unrestricted access:\n\nYou can also set the authentication policy on a per-view, or per-viewset\nbasis, using the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nNote: when you set new permission classes via the class attribute or\ndecorators you're telling the view to ignore the default list set in the\nsettings.py file.\n\nProvided they inherit from `rest_framework.permissions.BasePermission`,\npermissions can be composed using standard Python bitwise operators. For\nexample, `IsAuthenticatedOrReadOnly` could be written:\n\nNote: it supports & (and), | (or) and ~ (not).\n\nThe `AllowAny` permission class will allow unrestricted access, regardless of\nif the request was authenticated or unauthenticated.\n\nThis permission is not strictly required, since you can achieve the same\nresult by using an empty list or tuple for the permissions setting, but you\nmay find it useful to specify this class because it makes the intention\nexplicit.\n\nThe `IsAuthenticated` permission class will deny permission to any\nunauthenticated user, and allow permission otherwise.\n\nThis permission is suitable if you want your API to only be accessible to\nregistered users.\n\nThe `IsAdminUser` permission class will deny permission to any user, unless\n`user.is_staff` is `True` in which case permission will be allowed.\n\nThis permission is suitable if you want your API to only be accessible to a\nsubset of trusted administrators.\n\nThe `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any\nrequest. Requests for unauthorised users will only be permitted if the request\nmethod is one of the \"safe\" methods; `GET`, `HEAD` or `OPTIONS`.\n\nThis permission is suitable if you want to your API to allow read permissions\nto anonymous users, and only allow write permissions to authenticated users.\n\nThis permission class ties into Django's standard `django.contrib.auth` model\npermissions. This permission must only be applied to views that have a\n`.queryset` property or `get_queryset()` method. Authorization will only be\ngranted if the user is authenticated and has the relevant model permissions\nassigned.\n\nThe default behaviour can also be overridden to support custom model\npermissions. For example, you might want to include a `view` model permission\nfor `GET` requests.\n\nTo use custom model permissions, override `DjangoModelPermissions` and set the\n`.perms_map` property. Refer to the source code for details.\n\nSimilar to `DjangoModelPermissions`, but also allows unauthenticated users to\nhave read-only access to the API.\n\nThis permission class ties into Django's standard object permissions framework\nthat allows per-object permissions on models. In order to use this permission\nclass, you'll also need to add a permission backend that supports object-level\npermissions, such as django-guardian.\n\nAs with `DjangoModelPermissions`, this permission must only be applied to\nviews that have a `.queryset` property or `.get_queryset()` method.\nAuthorization will only be granted if the user is authenticated and has the\nrelevant per-object permissions and relevant model permissions assigned.\n\nNote that `DjangoObjectPermissions` does not require the `django-guardian`\npackage, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by\noverriding `DjangoObjectPermissions` and setting the `.perms_map` property.\nRefer to the source code for details.\n\nNote: If you need object level `view` permissions for `GET`, `HEAD` and\n`OPTIONS` requests and are using django-guardian for your object-level\npermissions backend, you'll want to consider using the\n`DjangoObjectPermissionsFilter` class provided by the `djangorestframework-\nguardian` package. It ensures that list endpoints only return results\nincluding objects for which the user has appropriate view permissions.\n\nTo implement a custom permission, override `BasePermission` and implement\neither, or both, of the following methods:\n\nThe methods should return `True` if the request should be granted access, and\n`False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you\nshould check the request method against the constant `SAFE_METHODS`, which is\na tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\nNote: The instance-level `has_object_permission` method will only be called if\nthe view-level `has_permission` checks have already passed. Also note that in\norder for the instance-level checks to run, the view code should explicitly\ncall `.check_object_permissions(request, obj)`. If you are using the generic\nviews then this will be handled for you by default. (Function-based views will\nneed to check object permissions explicitly, raising `PermissionDenied` on\nfailure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test\nfails. To change the error message associated with the exception, implement a\n`message` attribute directly on your custom permission. Otherwise the\n`default_detail` attribute from `PermissionDenied` will be used. Similarly, to\nchange the code identifier associated with the exception, implement a `code`\nattribute directly on your custom permission - otherwise the `default_code`\nattribute from `PermissionDenied` will be used.\n\nThe following is an example of a permission class that checks the incoming\nrequest's IP address against a blocklist, and denies the request if the IP has\nbeen blocked.\n\nAs well as global permissions, that are run against all incoming requests, you\ncan also create object-level permissions, that are only run against operations\nthat affect a particular object instance. For example:\n\nNote that the generic views will check the appropriate object level\npermissions, but if you're writing your own custom views, you'll need to make\nsure you check the object level permission checks yourself. You can do so by\ncalling `self.check_object_permissions(request, obj)` from the view once you\nhave the object instance. This call will raise an appropriate `APIException`\nif any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions\nfor views that retrieve a single model instance. If you require object-level\nfiltering of list views, you'll need to filter the queryset separately. See\nthe filtering documentation for more details.\n\nREST framework offers three different methods to customize access restrictions\non a case-by-case basis. These apply in different scenarios and have different\neffects and limitations.\n\nThe following table lists the access restriction methods and the level of\ncontrol they offer over which actions.\n\n* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.   \n** The `get_*()` methods have access to the current view and can return\ndifferent Serializer or QuerySet instances based on the request or action.\n\nThe following third party packages are also available.\n\nThe Django REST - Access Policy package provides a way to define complex\naccess rules in declarative policy classes that are attached to view sets or\nfunction-based views. The policies are defined in JSON in a format similar to\nAWS' Identity & Access Management policies.\n\nThe Composed Permissions package provides a simple way to define complex and\nmulti-depth (with logic operators) permission objects, using small and\nreusable components.\n\nThe REST Condition package is another extension for building complex\npermissions in a simple and convenient way. The extension allows you to\ncombine permissions with logical operators.\n\nThe DRY Rest Permissions package provides the ability to define different\npermissions for individual default and custom actions. This package is made\nfor apps with permissions that are derived from relationships defined in the\napp's data model. It also supports permission checks being returned to a\nclient app through the API's serializer. Additionally it supports adding\npermissions to the default and custom list actions to restrict the data they\nretrieve per user.\n\nThe Django Rest Framework Roles package makes it easier to parameterize your\nAPI over multiple types of users.\n\nThe Django REST Framework API Key package provides permissions classes, models\nand helpers to add API key authorization to your API. It can be used to\nauthorize internal or third-party backends and services (i.e. machines) which\ndo not have a user account. API keys are stored securely using Django's\npassword hashing infrastructure, and they can be viewed, edited and revoked at\nanytime in the Django admin.\n\nThe Django Rest Framework Role Filters package provides simple filtering over\nmultiple types of roles.\n\nThe Django Rest Framework PSQ package is an extension that gives support for\nhaving action-based permission_classes, serializer_class, and queryset\ndependent on permission-based rules.\n\npermissions.py\n\n"}, {"name": "DjangoModelPermissionsOrAnonReadOnly", "path": "api-guide/permissions/index#djangomodelpermissionsoranonreadonly", "type": "Ref: Permissions", "text": "\nAuthentication or identification by itself is not usually sufficient to gain\naccess to information or code. For that, the entity requesting access must\nhave authorization.\n\n\u2014 Apple Developer Documentation\n\nTogether with authentication and throttling, permissions determine whether a\nrequest should be granted or denied access.\n\nPermission checks are always run at the very start of the view, before any\nother code is allowed to proceed. Permission checks will typically use the\nauthentication information in the `request.user` and `request.auth` properties\nto determine if the incoming request should be permitted.\n\nPermissions are used to grant or deny access for different classes of users to\ndifferent parts of the API.\n\nThe simplest style of permission would be to allow access to any authenticated\nuser, and deny access to any unauthenticated user. This corresponds to the\n`IsAuthenticated` class in REST framework.\n\nA slightly less strict style of permission would be to allow full access to\nauthenticated users, but allow read-only access to unauthenticated users. This\ncorresponds to the `IsAuthenticatedOrReadOnly` class in REST framework.\n\nPermissions in REST framework are always defined as a list of permission\nclasses.\n\nBefore running the main body of the view each permission in the list is\nchecked. If any permission check fails an `exceptions.PermissionDenied` or\n`exceptions.NotAuthenticated` exception will be raised, and the main body of\nthe view will not run.\n\nWhen the permissions checks fail either a \"403 Forbidden\" or a \"401\nUnauthorized\" response will be returned, according to the following rules:\n\nREST framework permissions also support object-level permissioning. Object\nlevel permissions are used to determine if a user should be allowed to act on\na particular object, which will typically be a model instance.\n\nObject level permissions are run by REST framework's generic views when\n`.get_object()` is called. As with view level permissions, an\n`exceptions.PermissionDenied` exception will be raised if the user is not\nallowed to act on the given object.\n\nIf you're writing your own views and want to enforce object level permissions,\nor if you override the `get_object` method on a generic view, then you'll need\nto explicitly call the `.check_object_permissions(request, obj)` method on the\nview at the point at which you've retrieved the object.\n\nThis will either raise a `PermissionDenied` or `NotAuthenticated` exception,\nor simply return if the view has the appropriate permissions.\n\nFor example:\n\nNote: With the exception of `DjangoObjectPermissions`, the provided permission\nclasses in `rest_framework.permissions` do not implement the methods necessary\nto check object permissions.\n\nIf you wish to use the provided permission classes in order to check object\npermissions, you must subclass them and implement the\n`has_object_permission()` method described in the Custom permissions section\n(below).\n\nFor performance reasons the generic views will not automatically apply object\nlevel permissions to each instance in a queryset when returning a list of\nobjects.\n\nOften when you're using object level permissions you'll also want to filter\nthe queryset appropriately, to ensure that users only have visibility onto\ninstances that they are permitted to view.\n\nBecause the `get_object()` method is not called, object level permissions from\nthe `has_object_permission()` method are not applied when creating objects. In\norder to restrict object creation you need to implement the permission check\neither in your Serializer class or override the `perform_create()` method of\nyour ViewSet class.\n\nThe default permission policy may be set globally, using the\n`DEFAULT_PERMISSION_CLASSES` setting. For example.\n\nIf not specified, this setting defaults to allowing unrestricted access:\n\nYou can also set the authentication policy on a per-view, or per-viewset\nbasis, using the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nNote: when you set new permission classes via the class attribute or\ndecorators you're telling the view to ignore the default list set in the\nsettings.py file.\n\nProvided they inherit from `rest_framework.permissions.BasePermission`,\npermissions can be composed using standard Python bitwise operators. For\nexample, `IsAuthenticatedOrReadOnly` could be written:\n\nNote: it supports & (and), | (or) and ~ (not).\n\nThe `AllowAny` permission class will allow unrestricted access, regardless of\nif the request was authenticated or unauthenticated.\n\nThis permission is not strictly required, since you can achieve the same\nresult by using an empty list or tuple for the permissions setting, but you\nmay find it useful to specify this class because it makes the intention\nexplicit.\n\nThe `IsAuthenticated` permission class will deny permission to any\nunauthenticated user, and allow permission otherwise.\n\nThis permission is suitable if you want your API to only be accessible to\nregistered users.\n\nThe `IsAdminUser` permission class will deny permission to any user, unless\n`user.is_staff` is `True` in which case permission will be allowed.\n\nThis permission is suitable if you want your API to only be accessible to a\nsubset of trusted administrators.\n\nThe `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any\nrequest. Requests for unauthorised users will only be permitted if the request\nmethod is one of the \"safe\" methods; `GET`, `HEAD` or `OPTIONS`.\n\nThis permission is suitable if you want to your API to allow read permissions\nto anonymous users, and only allow write permissions to authenticated users.\n\nThis permission class ties into Django's standard `django.contrib.auth` model\npermissions. This permission must only be applied to views that have a\n`.queryset` property or `get_queryset()` method. Authorization will only be\ngranted if the user is authenticated and has the relevant model permissions\nassigned.\n\nThe default behaviour can also be overridden to support custom model\npermissions. For example, you might want to include a `view` model permission\nfor `GET` requests.\n\nTo use custom model permissions, override `DjangoModelPermissions` and set the\n`.perms_map` property. Refer to the source code for details.\n\nSimilar to `DjangoModelPermissions`, but also allows unauthenticated users to\nhave read-only access to the API.\n\nThis permission class ties into Django's standard object permissions framework\nthat allows per-object permissions on models. In order to use this permission\nclass, you'll also need to add a permission backend that supports object-level\npermissions, such as django-guardian.\n\nAs with `DjangoModelPermissions`, this permission must only be applied to\nviews that have a `.queryset` property or `.get_queryset()` method.\nAuthorization will only be granted if the user is authenticated and has the\nrelevant per-object permissions and relevant model permissions assigned.\n\nNote that `DjangoObjectPermissions` does not require the `django-guardian`\npackage, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by\noverriding `DjangoObjectPermissions` and setting the `.perms_map` property.\nRefer to the source code for details.\n\nNote: If you need object level `view` permissions for `GET`, `HEAD` and\n`OPTIONS` requests and are using django-guardian for your object-level\npermissions backend, you'll want to consider using the\n`DjangoObjectPermissionsFilter` class provided by the `djangorestframework-\nguardian` package. It ensures that list endpoints only return results\nincluding objects for which the user has appropriate view permissions.\n\nTo implement a custom permission, override `BasePermission` and implement\neither, or both, of the following methods:\n\nThe methods should return `True` if the request should be granted access, and\n`False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you\nshould check the request method against the constant `SAFE_METHODS`, which is\na tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\nNote: The instance-level `has_object_permission` method will only be called if\nthe view-level `has_permission` checks have already passed. Also note that in\norder for the instance-level checks to run, the view code should explicitly\ncall `.check_object_permissions(request, obj)`. If you are using the generic\nviews then this will be handled for you by default. (Function-based views will\nneed to check object permissions explicitly, raising `PermissionDenied` on\nfailure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test\nfails. To change the error message associated with the exception, implement a\n`message` attribute directly on your custom permission. Otherwise the\n`default_detail` attribute from `PermissionDenied` will be used. Similarly, to\nchange the code identifier associated with the exception, implement a `code`\nattribute directly on your custom permission - otherwise the `default_code`\nattribute from `PermissionDenied` will be used.\n\nThe following is an example of a permission class that checks the incoming\nrequest's IP address against a blocklist, and denies the request if the IP has\nbeen blocked.\n\nAs well as global permissions, that are run against all incoming requests, you\ncan also create object-level permissions, that are only run against operations\nthat affect a particular object instance. For example:\n\nNote that the generic views will check the appropriate object level\npermissions, but if you're writing your own custom views, you'll need to make\nsure you check the object level permission checks yourself. You can do so by\ncalling `self.check_object_permissions(request, obj)` from the view once you\nhave the object instance. This call will raise an appropriate `APIException`\nif any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions\nfor views that retrieve a single model instance. If you require object-level\nfiltering of list views, you'll need to filter the queryset separately. See\nthe filtering documentation for more details.\n\nREST framework offers three different methods to customize access restrictions\non a case-by-case basis. These apply in different scenarios and have different\neffects and limitations.\n\nThe following table lists the access restriction methods and the level of\ncontrol they offer over which actions.\n\n* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.   \n** The `get_*()` methods have access to the current view and can return\ndifferent Serializer or QuerySet instances based on the request or action.\n\nThe following third party packages are also available.\n\nThe Django REST - Access Policy package provides a way to define complex\naccess rules in declarative policy classes that are attached to view sets or\nfunction-based views. The policies are defined in JSON in a format similar to\nAWS' Identity & Access Management policies.\n\nThe Composed Permissions package provides a simple way to define complex and\nmulti-depth (with logic operators) permission objects, using small and\nreusable components.\n\nThe REST Condition package is another extension for building complex\npermissions in a simple and convenient way. The extension allows you to\ncombine permissions with logical operators.\n\nThe DRY Rest Permissions package provides the ability to define different\npermissions for individual default and custom actions. This package is made\nfor apps with permissions that are derived from relationships defined in the\napp's data model. It also supports permission checks being returned to a\nclient app through the API's serializer. Additionally it supports adding\npermissions to the default and custom list actions to restrict the data they\nretrieve per user.\n\nThe Django Rest Framework Roles package makes it easier to parameterize your\nAPI over multiple types of users.\n\nThe Django REST Framework API Key package provides permissions classes, models\nand helpers to add API key authorization to your API. It can be used to\nauthorize internal or third-party backends and services (i.e. machines) which\ndo not have a user account. API keys are stored securely using Django's\npassword hashing infrastructure, and they can be viewed, edited and revoked at\nanytime in the Django admin.\n\nThe Django Rest Framework Role Filters package provides simple filtering over\nmultiple types of roles.\n\nThe Django Rest Framework PSQ package is an extension that gives support for\nhaving action-based permission_classes, serializer_class, and queryset\ndependent on permission-based rules.\n\npermissions.py\n\n"}, {"name": "DjangoObjectPermissions", "path": "api-guide/permissions/index#djangoobjectpermissions", "type": "Ref: Permissions", "text": "\nAuthentication or identification by itself is not usually sufficient to gain\naccess to information or code. For that, the entity requesting access must\nhave authorization.\n\n\u2014 Apple Developer Documentation\n\nTogether with authentication and throttling, permissions determine whether a\nrequest should be granted or denied access.\n\nPermission checks are always run at the very start of the view, before any\nother code is allowed to proceed. Permission checks will typically use the\nauthentication information in the `request.user` and `request.auth` properties\nto determine if the incoming request should be permitted.\n\nPermissions are used to grant or deny access for different classes of users to\ndifferent parts of the API.\n\nThe simplest style of permission would be to allow access to any authenticated\nuser, and deny access to any unauthenticated user. This corresponds to the\n`IsAuthenticated` class in REST framework.\n\nA slightly less strict style of permission would be to allow full access to\nauthenticated users, but allow read-only access to unauthenticated users. This\ncorresponds to the `IsAuthenticatedOrReadOnly` class in REST framework.\n\nPermissions in REST framework are always defined as a list of permission\nclasses.\n\nBefore running the main body of the view each permission in the list is\nchecked. If any permission check fails an `exceptions.PermissionDenied` or\n`exceptions.NotAuthenticated` exception will be raised, and the main body of\nthe view will not run.\n\nWhen the permissions checks fail either a \"403 Forbidden\" or a \"401\nUnauthorized\" response will be returned, according to the following rules:\n\nREST framework permissions also support object-level permissioning. Object\nlevel permissions are used to determine if a user should be allowed to act on\na particular object, which will typically be a model instance.\n\nObject level permissions are run by REST framework's generic views when\n`.get_object()` is called. As with view level permissions, an\n`exceptions.PermissionDenied` exception will be raised if the user is not\nallowed to act on the given object.\n\nIf you're writing your own views and want to enforce object level permissions,\nor if you override the `get_object` method on a generic view, then you'll need\nto explicitly call the `.check_object_permissions(request, obj)` method on the\nview at the point at which you've retrieved the object.\n\nThis will either raise a `PermissionDenied` or `NotAuthenticated` exception,\nor simply return if the view has the appropriate permissions.\n\nFor example:\n\nNote: With the exception of `DjangoObjectPermissions`, the provided permission\nclasses in `rest_framework.permissions` do not implement the methods necessary\nto check object permissions.\n\nIf you wish to use the provided permission classes in order to check object\npermissions, you must subclass them and implement the\n`has_object_permission()` method described in the Custom permissions section\n(below).\n\nFor performance reasons the generic views will not automatically apply object\nlevel permissions to each instance in a queryset when returning a list of\nobjects.\n\nOften when you're using object level permissions you'll also want to filter\nthe queryset appropriately, to ensure that users only have visibility onto\ninstances that they are permitted to view.\n\nBecause the `get_object()` method is not called, object level permissions from\nthe `has_object_permission()` method are not applied when creating objects. In\norder to restrict object creation you need to implement the permission check\neither in your Serializer class or override the `perform_create()` method of\nyour ViewSet class.\n\nThe default permission policy may be set globally, using the\n`DEFAULT_PERMISSION_CLASSES` setting. For example.\n\nIf not specified, this setting defaults to allowing unrestricted access:\n\nYou can also set the authentication policy on a per-view, or per-viewset\nbasis, using the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nNote: when you set new permission classes via the class attribute or\ndecorators you're telling the view to ignore the default list set in the\nsettings.py file.\n\nProvided they inherit from `rest_framework.permissions.BasePermission`,\npermissions can be composed using standard Python bitwise operators. For\nexample, `IsAuthenticatedOrReadOnly` could be written:\n\nNote: it supports & (and), | (or) and ~ (not).\n\nThe `AllowAny` permission class will allow unrestricted access, regardless of\nif the request was authenticated or unauthenticated.\n\nThis permission is not strictly required, since you can achieve the same\nresult by using an empty list or tuple for the permissions setting, but you\nmay find it useful to specify this class because it makes the intention\nexplicit.\n\nThe `IsAuthenticated` permission class will deny permission to any\nunauthenticated user, and allow permission otherwise.\n\nThis permission is suitable if you want your API to only be accessible to\nregistered users.\n\nThe `IsAdminUser` permission class will deny permission to any user, unless\n`user.is_staff` is `True` in which case permission will be allowed.\n\nThis permission is suitable if you want your API to only be accessible to a\nsubset of trusted administrators.\n\nThe `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any\nrequest. Requests for unauthorised users will only be permitted if the request\nmethod is one of the \"safe\" methods; `GET`, `HEAD` or `OPTIONS`.\n\nThis permission is suitable if you want to your API to allow read permissions\nto anonymous users, and only allow write permissions to authenticated users.\n\nThis permission class ties into Django's standard `django.contrib.auth` model\npermissions. This permission must only be applied to views that have a\n`.queryset` property or `get_queryset()` method. Authorization will only be\ngranted if the user is authenticated and has the relevant model permissions\nassigned.\n\nThe default behaviour can also be overridden to support custom model\npermissions. For example, you might want to include a `view` model permission\nfor `GET` requests.\n\nTo use custom model permissions, override `DjangoModelPermissions` and set the\n`.perms_map` property. Refer to the source code for details.\n\nSimilar to `DjangoModelPermissions`, but also allows unauthenticated users to\nhave read-only access to the API.\n\nThis permission class ties into Django's standard object permissions framework\nthat allows per-object permissions on models. In order to use this permission\nclass, you'll also need to add a permission backend that supports object-level\npermissions, such as django-guardian.\n\nAs with `DjangoModelPermissions`, this permission must only be applied to\nviews that have a `.queryset` property or `.get_queryset()` method.\nAuthorization will only be granted if the user is authenticated and has the\nrelevant per-object permissions and relevant model permissions assigned.\n\nNote that `DjangoObjectPermissions` does not require the `django-guardian`\npackage, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by\noverriding `DjangoObjectPermissions` and setting the `.perms_map` property.\nRefer to the source code for details.\n\nNote: If you need object level `view` permissions for `GET`, `HEAD` and\n`OPTIONS` requests and are using django-guardian for your object-level\npermissions backend, you'll want to consider using the\n`DjangoObjectPermissionsFilter` class provided by the `djangorestframework-\nguardian` package. It ensures that list endpoints only return results\nincluding objects for which the user has appropriate view permissions.\n\nTo implement a custom permission, override `BasePermission` and implement\neither, or both, of the following methods:\n\nThe methods should return `True` if the request should be granted access, and\n`False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you\nshould check the request method against the constant `SAFE_METHODS`, which is\na tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\nNote: The instance-level `has_object_permission` method will only be called if\nthe view-level `has_permission` checks have already passed. Also note that in\norder for the instance-level checks to run, the view code should explicitly\ncall `.check_object_permissions(request, obj)`. If you are using the generic\nviews then this will be handled for you by default. (Function-based views will\nneed to check object permissions explicitly, raising `PermissionDenied` on\nfailure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test\nfails. To change the error message associated with the exception, implement a\n`message` attribute directly on your custom permission. Otherwise the\n`default_detail` attribute from `PermissionDenied` will be used. Similarly, to\nchange the code identifier associated with the exception, implement a `code`\nattribute directly on your custom permission - otherwise the `default_code`\nattribute from `PermissionDenied` will be used.\n\nThe following is an example of a permission class that checks the incoming\nrequest's IP address against a blocklist, and denies the request if the IP has\nbeen blocked.\n\nAs well as global permissions, that are run against all incoming requests, you\ncan also create object-level permissions, that are only run against operations\nthat affect a particular object instance. For example:\n\nNote that the generic views will check the appropriate object level\npermissions, but if you're writing your own custom views, you'll need to make\nsure you check the object level permission checks yourself. You can do so by\ncalling `self.check_object_permissions(request, obj)` from the view once you\nhave the object instance. This call will raise an appropriate `APIException`\nif any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions\nfor views that retrieve a single model instance. If you require object-level\nfiltering of list views, you'll need to filter the queryset separately. See\nthe filtering documentation for more details.\n\nREST framework offers three different methods to customize access restrictions\non a case-by-case basis. These apply in different scenarios and have different\neffects and limitations.\n\nThe following table lists the access restriction methods and the level of\ncontrol they offer over which actions.\n\n* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.   \n** The `get_*()` methods have access to the current view and can return\ndifferent Serializer or QuerySet instances based on the request or action.\n\nThe following third party packages are also available.\n\nThe Django REST - Access Policy package provides a way to define complex\naccess rules in declarative policy classes that are attached to view sets or\nfunction-based views. The policies are defined in JSON in a format similar to\nAWS' Identity & Access Management policies.\n\nThe Composed Permissions package provides a simple way to define complex and\nmulti-depth (with logic operators) permission objects, using small and\nreusable components.\n\nThe REST Condition package is another extension for building complex\npermissions in a simple and convenient way. The extension allows you to\ncombine permissions with logical operators.\n\nThe DRY Rest Permissions package provides the ability to define different\npermissions for individual default and custom actions. This package is made\nfor apps with permissions that are derived from relationships defined in the\napp's data model. It also supports permission checks being returned to a\nclient app through the API's serializer. Additionally it supports adding\npermissions to the default and custom list actions to restrict the data they\nretrieve per user.\n\nThe Django Rest Framework Roles package makes it easier to parameterize your\nAPI over multiple types of users.\n\nThe Django REST Framework API Key package provides permissions classes, models\nand helpers to add API key authorization to your API. It can be used to\nauthorize internal or third-party backends and services (i.e. machines) which\ndo not have a user account. API keys are stored securely using Django's\npassword hashing infrastructure, and they can be viewed, edited and revoked at\nanytime in the Django admin.\n\nThe Django Rest Framework Role Filters package provides simple filtering over\nmultiple types of roles.\n\nThe Django Rest Framework PSQ package is an extension that gives support for\nhaving action-based permission_classes, serializer_class, and queryset\ndependent on permission-based rules.\n\npermissions.py\n\n"}, {"name": "DurationField", "path": "api-guide/fields/index#durationfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "EmailField", "path": "api-guide/fields/index#emailfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "Encodings", "path": "api-guide/settings/index#encodings", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "Exceptions", "path": "api-guide/exceptions/index", "type": "API Guide", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "FileField", "path": "api-guide/fields/index#filefield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "FilePathField", "path": "api-guide/fields/index#filepathfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "FileUploadParser", "path": "api-guide/parsers/index#fileuploadparser", "type": "Ref: Parsers", "text": "\nMachine interacting web services tend to use more structured formats for\nsending data than form-encoded, since they're sending more complex data than\nsimple forms\n\n\u2014 Malcom Tredinnick, Django developers group\n\nREST framework includes a number of built in Parser classes, that allow you to\naccept requests with various media types. There is also support for defining\nyour own custom parsers, which gives you the flexibility to design the media\ntypes that your API accepts.\n\nThe set of valid parsers for a view is always defined as a list of classes.\nWhen `request.data` is accessed, REST framework will examine the `Content-\nType` header on the incoming request, and determine which parser to use to\nparse the request content.\n\nNote: When developing client applications always remember to make sure you're\nsetting the `Content-Type` header when sending data in an HTTP request.\n\nIf you don't set the content type, most clients will default to using\n`'application/x-www-form-urlencoded'`, which may not be what you wanted.\n\nAs an example, if you are sending `json` encoded data using jQuery with the\n.ajax() method, you should make sure to include the `contentType:\n'application/json'` setting.\n\nThe default set of parsers may be set globally, using the\n`DEFAULT_PARSER_CLASSES` setting. For example, the following settings would\nallow only requests with `JSON` content, instead of the default of JSON or\nform data.\n\nYou can also set the parsers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nParses `JSON` request content. `request.data` will be populated with a\ndictionary of data.\n\n.media_type: `application/json`\n\nParses HTML form content. `request.data` will be populated with a `QueryDict`\nof data.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `application/x-www-form-urlencoded`\n\nParses multipart HTML form content, which supports file uploads. Both\n`request.data` will be populated with a `QueryDict`.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `multipart/form-data`\n\nParses raw file upload content. The `request.data` property will be a\ndictionary with a single key `'file'` containing the uploaded file.\n\nIf the view used with `FileUploadParser` is called with a `filename` URL\nkeyword argument, then that argument will be used as the filename.\n\nIf it is called without a `filename` URL keyword argument, then the client\nmust set the filename in the `Content-Disposition` HTTP header. For example\n`Content-Disposition: attachment; filename=upload.jpg`.\n\n.media_type: `*/*`\n\nTo implement a custom parser, you should override `BaseParser`, set the\n`.media_type` property, and implement the `.parse(self, stream, media_type,\nparser_context)` method.\n\nThe method should return the data that will be used to populate the\n`request.data` property.\n\nThe arguments passed to `.parse()` are:\n\nA stream-like object representing the body of the request.\n\nOptional. If provided, this is the media type of the incoming request content.\n\nDepending on the request's `Content-Type:` header, this may be more specific\nthan the renderer's `media_type` attribute, and may include media type\nparameters. For example `\"text/plain; charset=utf-8\"`.\n\nOptional. If supplied, this argument will be a dictionary containing any\nadditional context that may be required to parse the request content.\n\nBy default this will include the following keys: `view`, `request`, `args`,\n`kwargs`.\n\nThe following is an example plaintext parser that will populate the\n`request.data` property with a string representing the body of the request.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nparsers.py\n\n"}, {"name": "Filtering", "path": "api-guide/filtering/index", "type": "API Guide", "text": "\nThe root QuerySet provided by the Manager describes all objects in the\ndatabase table. Usually, though, you'll need to select only a subset of the\ncomplete set of objects.\n\n\u2014 Django documentation\n\nThe default behavior of REST framework's generic list views is to return the\nentire queryset for a model manager. Often you will want your API to restrict\nthe items that are returned by the queryset.\n\nThe simplest way to filter the queryset of any view that subclasses\n`GenericAPIView` is to override the `.get_queryset()` method.\n\nOverriding this method allows you to customize the queryset returned by the\nview in a number of different ways.\n\nYou might want to filter the queryset to ensure that only results relevant to\nthe currently authenticated user making the request are returned.\n\nYou can do so by filtering based on the value of `request.user`.\n\nFor example:\n\nAnother style of filtering might involve restricting the queryset based on\nsome part of the URL.\n\nFor example if your URL config contained an entry like this:\n\nYou could then write a view that returned a purchase queryset filtered by the\nusername portion of the URL:\n\nA final example of filtering the initial queryset would be to determine the\ninitial queryset based on query parameters in the url.\n\nWe can override `.get_queryset()` to deal with URLs such as\n`http://example.com/api/purchases?username=denvercoder9`, and filter the\nqueryset only if the `username` parameter is included in the URL:\n\nAs well as being able to override the default queryset, REST framework also\nincludes support for generic filtering backends that allow you to easily\nconstruct complex searches and filters.\n\nGeneric filters can also present themselves as HTML controls in the browsable\nAPI and admin API.\n\nThe default filter backends may be set globally, using the\n`DEFAULT_FILTER_BACKENDS` setting. For example.\n\nYou can also set the filter backends on a per-view, or per-viewset basis,\nusing the `GenericAPIView` class-based views.\n\nNote that if a filter backend is configured for a view, then as well as being\nused to filter list views, it will also be used to filter the querysets used\nfor returning a single object.\n\nFor instance, given the previous example, and a product with an id of `4675`,\nthe following URL would either return the corresponding object, or return a\n404 response, depending on if the filtering conditions were met by the given\nproduct instance:\n\nNote that you can use both an overridden `.get_queryset()` and generic\nfiltering together, and everything will work as expected. For example, if\n`Product` had a many-to-many relationship with `User`, named `purchase`, you\nmight want to write a view like this:\n\nThe `django-filter` library includes a `DjangoFilterBackend` class which\nsupports highly customizable field filtering for REST framework.\n\nTo use `DjangoFilterBackend`, first install `django-filter`.\n\nThen add `'django_filters'` to Django's `INSTALLED_APPS`:\n\nYou should now either add the filter backend to your settings:\n\nOr add the filter backend to an individual View or ViewSet.\n\nIf all you need is simple equality-based filtering, you can set a\n`filterset_fields` attribute on the view, or viewset, listing the set of\nfields you wish to filter against.\n\nThis will automatically create a `FilterSet` class for the given fields, and\nwill allow you to make requests such as:\n\nFor more advanced filtering requirements you can specify a `FilterSet` class\nthat should be used by the view. You can read more about `FilterSet`s in the\ndjango-filter documentation. It's also recommended that you read the section\non DRF integration.\n\nThe `SearchFilter` class supports simple single query parameter based\nsearching, and is based on the Django admin's search functionality.\n\nWhen in use, the browsable API will include a `SearchFilter` control:\n\nThe `SearchFilter` class will only be applied if the view has a\n`search_fields` attribute set. The `search_fields` attribute should be a list\nof names of text type fields on the model, such as `CharField` or `TextField`.\n\nThis will allow the client to filter the items in the list by making queries\nsuch as:\n\nYou can also perform a related lookup on a ForeignKey or ManyToManyField with\nthe lookup API double-underscore notation:\n\nFor JSONField and HStoreField fields you can filter based on nested values\nwithin the data structure using the same double-underscore notation:\n\nBy default, searches will use case-insensitive partial matches. The search\nparameter may contain multiple search terms, which should be whitespace and/or\ncomma separated. If multiple search terms are used then objects will be\nreturned in the list only if all the provided terms are matched.\n\nThe search behavior may be restricted by prepending various characters to the\n`search_fields`.\n\nFor example:\n\nBy default, the search parameter is named `'search'`, but this may be\noverridden with the `SEARCH_PARAM` setting.\n\nTo dynamically change search fields based on request content, it's possible to\nsubclass the `SearchFilter` and override the `get_search_fields()` function.\nFor example, the following subclass will only search on `title` if the query\nparameter `title_only` is in the request:\n\nFor more details, see the Django documentation.\n\nThe `OrderingFilter` class supports simple query parameter controlled ordering\nof results.\n\nBy default, the query parameter is named `'ordering'`, but this may by\noverridden with the `ORDERING_PARAM` setting.\n\nFor example, to order users by username:\n\nThe client may also specify reverse orderings by prefixing the field name with\n'-', like so:\n\nMultiple orderings may also be specified:\n\nIt's recommended that you explicitly specify which fields the API should\nallowing in the ordering filter. You can do this by setting an\n`ordering_fields` attribute on the view, like so:\n\nThis helps prevent unexpected data leakage, such as allowing users to order\nagainst a password hash field or other sensitive data.\n\nIf you don't specify an `ordering_fields` attribute on the view, the filter\nclass will default to allowing the user to filter on any readable fields on\nthe serializer specified by the `serializer_class` attribute.\n\nIf you are confident that the queryset being used by the view doesn't contain\nany sensitive data, you can also explicitly specify that a view should allow\nordering on any model field or queryset aggregate, by using the special value\n`'__all__'`.\n\nIf an `ordering` attribute is set on the view, this will be used as the\ndefault ordering.\n\nTypically you'd instead control this by setting `order_by` on the initial\nqueryset, but using the `ordering` parameter on the view allows you to specify\nthe ordering in a way that it can then be passed automatically as context to a\nrendered template. This makes it possible to automatically render column\nheaders differently if they are being used to order the results.\n\nThe `ordering` attribute may be either a string or a list/tuple of strings.\n\nYou can also provide your own generic filtering backend, or write an\ninstallable app for other developers to use.\n\nTo do so override `BaseFilterBackend`, and override the\n`.filter_queryset(self, request, queryset, view)` method. The method should\nreturn a new, filtered queryset.\n\nAs well as allowing clients to perform searches and filtering, generic filter\nbackends can be useful for restricting which objects should be visible to any\ngiven request or user.\n\nFor example, you might need to restrict users to only being able to see\nobjects they created.\n\nWe could achieve the same behavior by overriding `get_queryset()` on the\nviews, but using a filter backend allows you to more easily add this\nrestriction to multiple views, or to apply it across the entire API.\n\nGeneric filters may also present an interface in the browsable API. To do so\nyou should implement a `to_html()` method which returns a rendered HTML\nrepresentation of the filter. This method should have the following signature:\n\n`to_html(self, request, queryset, view)`\n\nThe method should return a rendered HTML string.\n\nYou can also make the filter controls available to the schema autogeneration\nthat REST framework provides, by implementing a `get_schema_fields()` method.\nThis method should have the following signature:\n\n`get_schema_fields(self, view)`\n\nThe method should return a list of `coreapi.Field` instances.\n\nThe following third party packages provide additional filter implementations.\n\nThe django-rest-framework-filters package works together with the\n`DjangoFilterBackend` class, and allows you to easily create filters across\nrelationships, or create multiple filter lookup types for a given field.\n\nThe djangorestframework-word-filter developed as alternative to\n`filters.SearchFilter` which will search full word in text, or exact match.\n\ndjango-url-filter provides a safe way to filter data via human-friendly URLs.\nIt works very similar to DRF serializers and fields in a sense that they can\nbe nested except they are called filtersets and filters. That provides easy\nway to filter related data. Also this library is generic-purpose so it can be\nused to filter other sources of data and not only Django `QuerySet`s.\n\ndrf-url-filter is a simple Django app to apply filters on drf `ModelViewSet`'s\n`Queryset` in a clean, simple and configurable way. It also supports\nvalidations on incoming query params and their values. A beautiful python\npackage `Voluptuous` is being used for validations on the incoming query\nparameters. The best part about voluptuous is you can define your own\nvalidations as per your query params requirements.\n\nfilters.py\n\n"}, {"name": "FloatField", "path": "api-guide/fields/index#floatfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "Format suffixes", "path": "api-guide/format-suffixes/index", "type": "API Guide", "text": "\nSection 6.2.1 does not say that content negotiation should be used all the\ntime.\n\n\u2014 Roy Fielding, REST discuss mailing list\n\nA common pattern for Web APIs is to use filename extensions on URLs to provide\nan endpoint for a given media type. For example,\n'http://example.com/api/users.json' to serve a JSON representation.\n\nAdding format-suffix patterns to each individual entry in the URLconf for your\nAPI is error-prone and non-DRY, so REST framework provides a shortcut to\nadding these patterns to your URLConf.\n\nSignature: format_suffix_patterns(urlpatterns, suffix_required=False,\nallowed=None)\n\nReturns a URL pattern list which includes format suffix patterns appended to\neach of the URL patterns provided.\n\nArguments:\n\nExample:\n\nWhen using `format_suffix_patterns`, you must make sure to add the `'format'`\nkeyword argument to the corresponding views. For example:\n\nOr with class-based views:\n\nThe name of the kwarg used may be modified by using the `FORMAT_SUFFIX_KWARG`\nsetting.\n\nAlso note that `format_suffix_patterns` does not support descending into\n`include` URL patterns.\n\nIf using the `i18n_patterns` function provided by Django, as well as\n`format_suffix_patterns` you should make sure that the `i18n_patterns`\nfunction is applied as the final, or outermost function. For example:\n\nAn alternative to the format suffixes is to include the requested format in a\nquery parameter. REST framework provides this option by default, and it is\nused in the browsable API to switch between differing available\nrepresentations.\n\nTo select a representation using its short format, use the `format` query\nparameter. For example: `http://example.com/organizations/?format=csv`.\n\nThe name of this query parameter can be modified using the\n`URL_FORMAT_OVERRIDE` setting. Set the value to `None` to disable this\nbehavior.\n\nThere seems to be a view among some of the Web community that filename\nextensions are not a RESTful pattern, and that `HTTP Accept` headers should\nalways be used instead.\n\nIt is actually a misconception. For example, take the following quote from Roy\nFielding discussing the relative merits of query parameter media-type\nindicators vs. file extension media-type indicators:\n\n\u201cThat's why I always prefer extensions. Neither choice has anything to do with\nREST.\u201d \u2014 Roy Fielding, REST discuss mailing list\n\nThe quote does not mention Accept headers, but it does make it clear that\nformat suffixes should be considered an acceptable pattern.\n\nurlpatterns.py\n\n"}, {"name": "FormParser", "path": "api-guide/parsers/index#formparser", "type": "Ref: Parsers", "text": "\nMachine interacting web services tend to use more structured formats for\nsending data than form-encoded, since they're sending more complex data than\nsimple forms\n\n\u2014 Malcom Tredinnick, Django developers group\n\nREST framework includes a number of built in Parser classes, that allow you to\naccept requests with various media types. There is also support for defining\nyour own custom parsers, which gives you the flexibility to design the media\ntypes that your API accepts.\n\nThe set of valid parsers for a view is always defined as a list of classes.\nWhen `request.data` is accessed, REST framework will examine the `Content-\nType` header on the incoming request, and determine which parser to use to\nparse the request content.\n\nNote: When developing client applications always remember to make sure you're\nsetting the `Content-Type` header when sending data in an HTTP request.\n\nIf you don't set the content type, most clients will default to using\n`'application/x-www-form-urlencoded'`, which may not be what you wanted.\n\nAs an example, if you are sending `json` encoded data using jQuery with the\n.ajax() method, you should make sure to include the `contentType:\n'application/json'` setting.\n\nThe default set of parsers may be set globally, using the\n`DEFAULT_PARSER_CLASSES` setting. For example, the following settings would\nallow only requests with `JSON` content, instead of the default of JSON or\nform data.\n\nYou can also set the parsers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nParses `JSON` request content. `request.data` will be populated with a\ndictionary of data.\n\n.media_type: `application/json`\n\nParses HTML form content. `request.data` will be populated with a `QueryDict`\nof data.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `application/x-www-form-urlencoded`\n\nParses multipart HTML form content, which supports file uploads. Both\n`request.data` will be populated with a `QueryDict`.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `multipart/form-data`\n\nParses raw file upload content. The `request.data` property will be a\ndictionary with a single key `'file'` containing the uploaded file.\n\nIf the view used with `FileUploadParser` is called with a `filename` URL\nkeyword argument, then that argument will be used as the filename.\n\nIf it is called without a `filename` URL keyword argument, then the client\nmust set the filename in the `Content-Disposition` HTTP header. For example\n`Content-Disposition: attachment; filename=upload.jpg`.\n\n.media_type: `*/*`\n\nTo implement a custom parser, you should override `BaseParser`, set the\n`.media_type` property, and implement the `.parse(self, stream, media_type,\nparser_context)` method.\n\nThe method should return the data that will be used to populate the\n`request.data` property.\n\nThe arguments passed to `.parse()` are:\n\nA stream-like object representing the body of the request.\n\nOptional. If provided, this is the media type of the incoming request content.\n\nDepending on the request's `Content-Type:` header, this may be more specific\nthan the renderer's `media_type` attribute, and may include media type\nparameters. For example `\"text/plain; charset=utf-8\"`.\n\nOptional. If supplied, this argument will be a dictionary containing any\nadditional context that may be required to parse the request content.\n\nBy default this will include the following keys: `view`, `request`, `args`,\n`kwargs`.\n\nThe following is an example plaintext parser that will populate the\n`request.data` property with a string representing the body of the request.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nparsers.py\n\n"}, {"name": "Generic view settings", "path": "api-guide/settings/index#generic-view-settings", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "Generic views", "path": "api-guide/generic-views/index", "type": "API Guide", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "GenericAPIView", "path": "api-guide/generic-views/index#genericapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "GenericViewSet", "path": "api-guide/viewsets/index#genericviewset", "type": "Ref: ViewSets", "text": "\nAfter routing has determined which controller to use for a request, your\ncontroller is responsible for making sense of the request and producing the\nappropriate output.\n\n\u2014 Ruby on Rails Documentation\n\nDjango REST framework allows you to combine the logic for a set of related\nviews in a single class, called a `ViewSet`. In other frameworks you may also\nfind conceptually similar implementations named something like 'Resources' or\n'Controllers'.\n\nA `ViewSet` class is simply a type of class-based View, that does not provide\nany method handlers such as `.get()` or `.post()`, and instead provides\nactions such as `.list()` and `.create()`.\n\nThe method handlers for a `ViewSet` are only bound to the corresponding\nactions at the point of finalizing the view, using the `.as_view()` method.\n\nTypically, rather than explicitly registering the views in a viewset in the\nurlconf, you'll register the viewset with a router class, that automatically\ndetermines the urlconf for you.\n\nLet's define a simple viewset that can be used to list or retrieve all the\nusers in the system.\n\nIf we need to, we can bind this viewset into two separate views, like so:\n\nTypically we wouldn't do this, but would instead register the viewset with a\nrouter, and allow the urlconf to be automatically generated.\n\nRather than writing your own viewsets, you'll often want to use the existing\nbase classes that provide a default set of behavior. For example:\n\nThere are two main advantages of using a `ViewSet` class over using a `View`\nclass.\n\nBoth of these come with a trade-off. Using regular views and URL confs is more\nexplicit and gives you more control. ViewSets are helpful if you want to get\nup and running quickly, or when you have a large API and you want to enforce a\nconsistent URL configuration throughout.\n\nThe default routers included with REST framework will provide routes for a\nstandard set of create/retrieve/update/destroy style actions, as shown below:\n\nDuring dispatch, the following attributes are available on the `ViewSet`.\n\nYou may inspect these attributes to adjust behaviour based on the current\naction. For example, you could restrict permissions to everything except the\n`list` action similar to this:\n\nIf you have ad-hoc methods that should be routable, you can mark them as such\nwith the `@action` decorator. Like regular actions, extra actions may be\nintended for either a single object, or an entire collection. To indicate\nthis, set the `detail` argument to `True` or `False`. The router will\nconfigure its URL patterns accordingly. e.g., the `DefaultRouter` will\nconfigure detail actions to contain `pk` in their URL patterns.\n\nA more complete example of extra actions:\n\nThe `action` decorator will route `GET` requests by default, but may also\naccept other HTTP methods by setting the `methods` argument. For example:\n\nThe decorator allows you to override any viewset-level configuration such as\n`permission_classes`, `serializer_class`, `filter_backends`...:\n\nThe two new actions will then be available at the urls\n`^users/{pk}/set_password/$` and `^users/{pk}/unset_password/$`. Use the\n`url_path` and `url_name` parameters to change the URL segment and the reverse\nURL name of the action.\n\nTo view all extra actions, call the `.get_extra_actions()` method.\n\nExtra actions can map additional HTTP methods to separate `ViewSet` methods.\nFor example, the above password set/unset methods could be consolidated into a\nsingle route. Note that additional mappings do not accept arguments.\n\nIf you need to get the URL of an action, use the `.reverse_action()` method.\nThis is a convenience wrapper for `reverse()`, automatically passing the\nview's `request` object and prepending the `url_name` with the `.basename`\nattribute.\n\nNote that the `basename` is provided by the router during `ViewSet`\nregistration. If you are not using a router, then you must provide the\n`basename` argument to the `.as_view()` method.\n\nUsing the example from the previous section:\n\nAlternatively, you can use the `url_name` attribute set by the `@action`\ndecorator.\n\nThe `url_name` argument for `.reverse_action()` should match the same argument\nto the `@action` decorator. Additionally, this method can be used to reverse\nthe default actions, such as `list` and `create`.\n\nThe `ViewSet` class inherits from `APIView`. You can use any of the standard\nattributes such as `permission_classes`, `authentication_classes` in order to\ncontrol the API policy on the viewset.\n\nThe `ViewSet` class does not provide any implementations of actions. In order\nto use a `ViewSet` class you'll override the class and define the action\nimplementations explicitly.\n\nThe `GenericViewSet` class inherits from `GenericAPIView`, and provides the\ndefault set of `get_object`, `get_queryset` methods and other generic view\nbase behavior, but does not include any actions by default.\n\nIn order to use a `GenericViewSet` class you'll override the class and either\nmixin the required mixin classes, or define the action implementations\nexplicitly.\n\nThe `ModelViewSet` class inherits from `GenericAPIView` and includes\nimplementations for various actions, by mixing in the behavior of the various\nmixin classes.\n\nThe actions provided by the `ModelViewSet` class are `.list()`, `.retrieve()`,\n`.create()`, `.update()`, `.partial_update()`, and `.destroy()`.\n\nBecause `ModelViewSet` extends `GenericAPIView`, you'll normally need to\nprovide at least the `queryset` and `serializer_class` attributes. For\nexample:\n\nNote that you can use any of the standard attributes or method overrides\nprovided by `GenericAPIView`. For example, to use a `ViewSet` that dynamically\ndetermines the queryset it should operate on, you might do something like\nthis:\n\nNote however that upon removal of the `queryset` property from your `ViewSet`,\nany associated router will be unable to derive the basename of your Model\nautomatically, and so you will have to specify the `basename` kwarg as part of\nyour router registration.\n\nAlso note that although this class provides the complete set of\ncreate/list/retrieve/update/destroy actions by default, you can restrict the\navailable operations by using the standard permission classes.\n\nThe `ReadOnlyModelViewSet` class also inherits from `GenericAPIView`. As with\n`ModelViewSet` it also includes implementations for various actions, but\nunlike `ModelViewSet` only provides the 'read-only' actions, `.list()` and\n`.retrieve()`.\n\nAs with `ModelViewSet`, you'll normally need to provide at least the\n`queryset` and `serializer_class` attributes. For example:\n\nAgain, as with `ModelViewSet`, you can use any of the standard attributes and\nmethod overrides available to `GenericAPIView`.\n\nYou may need to provide custom `ViewSet` classes that do not have the full set\nof `ModelViewSet` actions, or that customize the behavior in some other way.\n\nTo create a base viewset class that provides `create`, `list` and `retrieve`\noperations, inherit from `GenericViewSet`, and mixin the required actions:\n\nBy creating your own base `ViewSet` classes, you can provide common behavior\nthat can be reused in multiple viewsets across your API.\n\nviewsets.py\n\n"}, {"name": "HiddenField", "path": "api-guide/fields/index#hiddenfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "HostNameVersioning", "path": "api-guide/versioning/index#hostnameversioning", "type": "Ref: Versioning", "text": "\nVersioning an interface is just a \"polite\" way to kill deployed clients.\n\n\u2014 Roy Fielding.\n\nAPI versioning allows you to alter behavior between different clients. REST\nframework provides for a number of different versioning schemes.\n\nVersioning is determined by the incoming client request, and may either be\nbased on the request URL, or based on the request headers.\n\nThere are a number of valid approaches to approaching versioning. Non-\nversioned systems can also be appropriate, particularly if you're engineering\nfor very long-term systems with multiple clients outside of your control.\n\nWhen API versioning is enabled, the `request.version` attribute will contain a\nstring that corresponds to the version requested in the incoming client\nrequest.\n\nBy default, versioning is not enabled, and `request.version` will always\nreturn `None`.\n\nHow you vary the API behavior is up to you, but one example you might\ntypically want is to switch to a different serialization style in a newer\nversion. For example:\n\nThe `reverse` function included by REST framework ties in with the versioning\nscheme. You need to make sure to include the current `request` as a keyword\nargument, like so.\n\nThe above function will apply any URL transformations appropriate to the\nrequest version. For example:\n\nWhen using hyperlinked serialization styles together with a URL based\nversioning scheme make sure to include the request as context to the\nserializer.\n\nDoing so will allow any returned URLs to include the appropriate versioning.\n\nThe versioning scheme is defined by the `DEFAULT_VERSIONING_CLASS` settings\nkey.\n\nUnless it is explicitly set, the value for `DEFAULT_VERSIONING_CLASS` will be\n`None`. In this case the `request.version` attribute will always return\n`None`.\n\nYou can also set the versioning scheme on an individual view. Typically you\nwon't need to do this, as it makes more sense to have a single versioning\nscheme used globally. If you do need to do so, use the `versioning_class`\nattribute.\n\nThe following settings keys are also used to control versioning:\n\nYou can also set your versioning class plus those three values on a per-view\nor a per-viewset basis by defining your own versioning scheme and using the\n`default_version`, `allowed_versions` and `version_param` class variables. For\nexample, if you want to use `URLPathVersioning`:\n\nThis scheme requires the client to specify the version as part of the media\ntype in the `Accept` header. The version is included as a media type\nparameter, that supplements the main media type.\n\nHere's an example HTTP request using the accept header versioning style.\n\nIn the example request above `request.version` attribute would return the\nstring `'1.0'`.\n\nVersioning based on accept headers is generally considered as best practice,\nalthough other styles may be suitable depending on your client requirements.\n\nStrictly speaking the `json` media type is not specified as including\nadditional parameters. If you are building a well-specified public API you\nmight consider using a vendor media type. To do so, configure your renderers\nto use a JSON based renderer with a custom media type:\n\nYour client requests would now look like this:\n\nThis scheme requires the client to specify the version as part of the URL\npath.\n\nYour URL conf must include a pattern that matches the version with a\n`'version'` keyword argument, so that this information is available to the\nversioning scheme.\n\nTo the client, this scheme is the same as `URLPathVersioning`. The only\ndifference is how it is configured in your Django application, as it uses URL\nnamespacing, instead of URL keyword arguments.\n\nWith this scheme the `request.version` attribute is determined based on the\n`namespace` that matches the incoming request path.\n\nIn the following example we're giving a set of views two different possible\nURL prefixes, each under a different namespace:\n\nBoth `URLPathVersioning` and `NamespaceVersioning` are reasonable if you just\nneed a simple versioning scheme. The `URLPathVersioning` approach might be\nbetter suitable for small ad-hoc projects, and the `NamespaceVersioning` is\nprobably easier to manage for larger projects.\n\nThe hostname versioning scheme requires the client to specify the requested\nversion as part of the hostname in the URL.\n\nFor example the following is an HTTP request to the\n`http://v1.example.com/bookings/` URL:\n\nBy default this implementation expects the hostname to match this simple\nregular expression:\n\nNote that the first group is enclosed in brackets, indicating that this is the\nmatched portion of the hostname.\n\nThe `HostNameVersioning` scheme can be awkward to use in debug mode as you\nwill typically be accessing a raw IP address such as `127.0.0.1`. There are\nvarious online tutorials on how to access localhost with a custom subdomain\nwhich you may find helpful in this case.\n\nHostname based versioning can be particularly useful if you have requirements\nto route incoming requests to different servers based on the version, as you\ncan configure different DNS records for different API versions.\n\nThis scheme is a simple style that includes the version as a query parameter\nin the URL. For example:\n\nTo implement a custom versioning scheme, subclass `BaseVersioning` and\noverride the `.determine_version` method.\n\nThe following example uses a custom `X-API-Version` header to determine the\nrequested version.\n\nIf your versioning scheme is based on the request URL, you will also want to\nalter how versioned URLs are determined. In order to do so you should override\nthe `.reverse()` method on the class. See the source code for examples.\n\nversioning.py\n\n"}, {"name": "HStoreField", "path": "api-guide/fields/index#hstorefield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "HTML Select Field cutoffs", "path": "api-guide/settings/index#html-select-field-cutoffs", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "HTMLFormRenderer", "path": "api-guide/renderers/index#htmlformrenderer", "type": "Ref: Renderers", "text": "\nBefore a TemplateResponse instance can be returned to the client, it must be\nrendered. The rendering process takes the intermediate representation of\ntemplate and context, and turns it into the final byte stream that can be\nserved to the client.\n\n\u2014 Django documentation\n\nREST framework includes a number of built in Renderer classes, that allow you\nto return responses with various media types. There is also support for\ndefining your own custom renderers, which gives you the flexibility to design\nyour own media types.\n\nThe set of valid renderers for a view is always defined as a list of classes.\nWhen a view is entered REST framework will perform content negotiation on the\nincoming request, and determine the most appropriate renderer to satisfy the\nrequest.\n\nThe basic process of content negotiation involves examining the request's\n`Accept` header, to determine which media types it expects in the response.\nOptionally, format suffixes on the URL may be used to explicitly request a\nparticular representation. For example the URL\n`http://example.com/api/users_count.json` might be an endpoint that always\nreturns JSON data.\n\nFor more information see the documentation on content negotiation.\n\nThe default set of renderers may be set globally, using the\n`DEFAULT_RENDERER_CLASSES` setting. For example, the following settings would\nuse `JSON` as the main media type and also include the self describing API.\n\nYou can also set the renderers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nIt's important when specifying the renderer classes for your API to think\nabout what priority you want to assign to each media type. If a client\nunderspecifies the representations it can accept, such as sending an `Accept:\n*/*` header, or not including an `Accept` header at all, then REST framework\nwill select the first renderer in the list to use for the response.\n\nFor example if your API serves JSON responses and the HTML browsable API, you\nmight want to make `JSONRenderer` your default renderer, in order to send\n`JSON` responses to clients that do not specify an `Accept` header.\n\nIf your API includes views that can serve both regular webpages and API\nresponses depending on the request, then you might consider making\n`TemplateHTMLRenderer` your default renderer, in order to play nicely with\nolder browsers that send broken accept headers.\n\nRenders the request data into `JSON`, using utf-8 encoding.\n\nNote that the default style is to include unicode characters, and render the\nresponse using a compact style with no unnecessary whitespace:\n\nThe client may additionally include an `'indent'` media type parameter, in\nwhich case the returned `JSON` will be indented. For example `Accept:\napplication/json; indent=4`.\n\nThe default JSON encoding style can be altered using the `UNICODE_JSON` and\n`COMPACT_JSON` settings keys.\n\n.media_type: `application/json`\n\n.format: `'json'`\n\n.charset: `None`\n\nRenders data to HTML, using Django's standard template rendering. Unlike other\nrenderers, the data passed to the `Response` does not need to be serialized.\nAlso, unlike other renderers, you may want to include a `template_name`\nargument when creating the `Response`.\n\nThe TemplateHTMLRenderer will create a `RequestContext`, using the\n`response.data` as the context dict, and determine a template name to use to\nrender the context.\n\nNote: When used with a view that makes use of a serializer the `Response` sent\nfor rendering may not be a dictionary and will need to be wrapped in a dict\nbefore returning to allow the TemplateHTMLRenderer to render it. For example:\n\nThe template name is determined by (in order of preference):\n\nAn example of a view that uses `TemplateHTMLRenderer`:\n\nYou can use `TemplateHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\nIf you're building websites that use `TemplateHTMLRenderer` along with other\nrenderer classes, you should consider listing `TemplateHTMLRenderer` as the\nfirst class in the `renderer_classes` list, so that it will be prioritised\nfirst even for browsers that send poorly formed `ACCEPT:` headers.\n\nSee the HTML & Forms Topic Page for further examples of `TemplateHTMLRenderer`\nusage.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `StaticHTMLRenderer`\n\nA simple renderer that simply returns pre-rendered HTML. Unlike other\nrenderers, the data passed to the response object should be a string\nrepresenting the content to be returned.\n\nAn example of a view that uses `StaticHTMLRenderer`:\n\nYou can use `StaticHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `TemplateHTMLRenderer`\n\nRenders data into HTML for the Browsable API:\n\nThis renderer will determine which other renderer would have been given\nhighest priority, and use that to display an API style response within the\nHTML page.\n\n.media_type: `text/html`\n\n.format: `'api'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/api.html'`\n\nBy default the response content will be rendered with the highest priority\nrenderer apart from `BrowsableAPIRenderer`. If you need to customize this\nbehavior, for example to use HTML as the default return format, but use JSON\nin the browsable API, you can do so by overriding the `get_default_renderer()`\nmethod. For example:\n\nRenders data into HTML for an admin-like display:\n\nThis renderer is suitable for CRUD-style web APIs that should also present a\nuser-friendly interface for managing the data.\n\nNote that views that have nested or list serializers for their input won't\nwork well with the `AdminRenderer`, as the HTML forms are unable to properly\nsupport them.\n\nNote: The `AdminRenderer` is only able to include links to detail pages when a\nproperly configured `URL_FIELD_NAME` (`url` by default) attribute is present\nin the data. For `HyperlinkedModelSerializer` this will be the case, but for\n`ModelSerializer` or plain `Serializer` classes you'll need to make sure to\ninclude the field explicitly. For example here we use models\n`get_absolute_url` method:\n\n.media_type: `text/html`\n\n.format: `'admin'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/admin.html'`\n\nRenders data returned by a serializer into an HTML form. The output of this\nrenderer does not include the enclosing `<form>` tags, a hidden CSRF input or\nany submit buttons.\n\nThis renderer is not intended to be used directly, but can instead be used in\ntemplates by passing a serializer instance to the `render_form` template tag.\n\nFor more information see the HTML & Forms documentation.\n\n.media_type: `text/html`\n\n.format: `'form'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/horizontal/form.html'`\n\nThis renderer is used for rendering HTML multipart form data. It is not\nsuitable as a response renderer, but is instead used for creating test\nrequests, using REST framework's test client and test request factory.\n\n.media_type: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n.format: `'multipart'`\n\n.charset: `utf-8`\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the\n`.media_type` and `.format` properties, and implement the `.render(self, data,\nmedia_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the\nHTTP response.\n\nThe arguments passed to the `.render()` method are:\n\nThe request data, as set by the `Response()` instantiation.\n\nOptional. If provided, this is the accepted media type, as determined by the\ncontent negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the\nrenderer's `media_type` attribute, and may include media type parameters. For\nexample `\"application/json; nested=true\"`.\n\nOptional. If provided, this is a dictionary of contextual information provided\nby the view.\n\nBy default this will include the following keys: `view`, `request`,\n`response`, `args`, `kwargs`.\n\nThe following is an example plaintext renderer that will return a response\nwith the `data` parameter as the content of the response.\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To\nuse a different encoding, set the `charset` attribute on the renderer.\n\nNote that if a renderer class returns a unicode string, then the response\ncontent will be coerced into a bytestring by the `Response` class, with the\n`charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you\nshould set a charset value of `None`, which will ensure the `Content-Type`\nheader of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to\n`'binary'`. Doing so will also ensure that the browsable API will not attempt\nto display the binary content as a string.\n\nYou can do some pretty flexible things using REST framework's renderers. Some\nexamples...\n\nIn some cases you might want your view to use different serialization styles\ndepending on the accepted media type. If you need to do this you can access\n`request.accepted_renderer` to determine the negotiated renderer that will be\nused for the response.\n\nFor example:\n\nIn some cases you might want a renderer to serve a range of media types. In\nthis case you can underspecify the media types it should respond to, by using\na `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify\nthe media type explicitly when you return the response, using the\n`content_type` attribute. For example:\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked\nrelations may be sufficient. If you want to fully embrace RESTful design and\nHATEOAS you'll need to consider the design and usage of your media types in\nmore detail.\n\nIn the words of Roy Fielding, \"A REST API should spend almost all of its\ndescriptive effort in defining the media type(s) used for representing\nresources and driving application state, or in defining extended relation\nnames and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom\napplication/vnd.github+json media type, and Mike Amundsen's IANA approved\napplication/vnd.collection+json JSON-based hypermedia.\n\nTypically a renderer will behave the same regardless of if it's dealing with a\nregular response, or with a response caused by an exception being raised, such\nas an `Http404` or `PermissionDenied` exception, or a subclass of\n`APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer`\nand an exception is raised, the behavior is slightly different, and mirrors\nDjango's default handling of error views.\n\nExceptions raised and handled by an HTML renderer will attempt to render using\none of the following methods, by order of precedence.\n\nTemplates will render with a `RequestContext` which includes the `status_code`\nand `details` keys.\n\nNote: If `DEBUG=True`, Django's standard traceback error page will be\ndisplayed instead of rendering the HTTP status code and text.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST framework JSONP provides JSONP rendering support. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nWarning: If you require cross-domain AJAX requests, you should generally be\nusing the more modern approach of CORS as an alternative to `JSONP`. See the\nCORS documentation for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is only appropriate\nfor globally readable API endpoints, where `GET` requests are unauthenticated\nand do not require any user permissions.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\nXLSX is the world's most popular binary spreadsheet format. Tim Allen of The\nWharton School maintains drf-renderer-xlsx, which renders an endpoint as an\nXLSX spreadsheet using OpenPyXL, and allows the client to download it.\nSpreadsheets can be styled on a per-view basis.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nTo avoid having a file streamed without a filename (which the browser will\noften default to the filename \"download\", with no extension), we need to use a\nmixin to override the `Content-Disposition` header. If no filename is\nprovided, it will default to `export.xlsx`. For example:\n\nComma-separated values are a plain-text tabular data format, that can be\neasily imported into spreadsheet applications. Mjumbe Poe maintains the\ndjangorestframework-csv package which provides CSV renderer support for REST\nframework.\n\nUltraJSON is an optimized C JSON encoder which can give significantly faster\nJSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now\nunmaintained drf-ujson-renderer, which implements JSON rendering using the\nUJSON package.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nDjango REST Pandas provides a serializer and renderers that support additional\ndata processing and output via the Pandas DataFrame API. Django REST Pandas\nincludes renderers for Pandas-style CSV files, Excel workbooks (both `.xls`\nand `.xlsx`), and a number of other formats. It is maintained by S. Andrew\nSheppard as part of the wq Project.\n\nRest Framework Latex provides a renderer that outputs PDFs using Laulatex. It\nis maintained by Pebble (S/F Software).\n\nrenderers.py\n\n"}, {"name": "HyperlinkedIdentityField", "path": "api-guide/relations/index#hyperlinkedidentityfield", "type": "Ref: Serializer relations", "text": "\nData structures, not algorithms, are central to programming.\n\n\u2014 Rob Pike\n\nRelational fields are used to represent model relationships. They can be\napplied to `ForeignKey`, `ManyToManyField` and `OneToOneField` relationships,\nas well as to reverse relationships, and custom relationships such as\n`GenericForeignKey`.\n\nNote: The relational fields are declared in `relations.py`, but by convention\nyou should import them from the `serializers` module, using `from\nrest_framework import serializers` and refer to fields as\n`serializers.<FieldName>`.\n\nWhen using the `ModelSerializer` class, serializer fields and relationships\nwill be automatically generated for you. Inspecting these automatically\ngenerated fields can be a useful tool for determining how to customize the\nrelationship style.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIn order to explain the various types of relational fields, we'll use a couple\nof simple models for our examples. Our models will be for music albums, and\nthe tracks listed on each album.\n\n`StringRelatedField` may be used to represent the target of the relationship\nusing its `__str__` method.\n\nFor example, the following serializer:\n\nWould serialize to the following representation:\n\nThis field is read only.\n\nArguments:\n\n`PrimaryKeyRelatedField` may be used to represent the target of the\nrelationship using its primary key.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nArguments:\n\n`HyperlinkedRelatedField` may be used to represent the target of the\nrelationship using a hyperlink.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nNote: This field is designed for objects that map to a URL that accepts a\nsingle URL keyword argument, as set using the `lookup_field` and\n`lookup_url_kwarg` arguments.\n\nThis is suitable for URLs that contain a single primary key or slug argument\nas part of the URL.\n\nIf you require more complex hyperlinked representation you'll need to\ncustomize the field, as described in the custom hyperlinked fields section,\nbelow.\n\nArguments:\n\n`SlugRelatedField` may be used to represent the target of the relationship\nusing a field on the target.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nWhen using `SlugRelatedField` as a read-write field, you will normally want to\nensure that the slug field corresponds to a model field with `unique=True`.\n\nArguments:\n\nThis field can be applied as an identity relationship, such as the `'url'`\nfield on a HyperlinkedModelSerializer. It can also be used for an attribute on\nthe object. For example, the following serializer:\n\nWould serialize to a representation like this:\n\nThis field is always read-only.\n\nArguments:\n\nAs opposed to previously discussed references to another entity, the referred\nentity can instead also be embedded or nested in the representation of the\nobject that refers to it. Such nested relationships can be expressed by using\nserializers as fields.\n\nIf the field is used to represent a to-many relationship, you should add the\n`many=True` flag to the serializer field.\n\nFor example, the following serializer:\n\nWould serialize to a nested representation like this:\n\nBy default nested serializers are read-only. If you want to support write-\noperations to a nested serializer field you'll need to create `create()`\nand/or `update()` methods in order to explicitly specify how the child\nrelationships should be saved:\n\nIn rare cases where none of the existing relational styles fit the\nrepresentation you need, you can implement a completely custom relational\nfield, that describes exactly how the output representation should be\ngenerated from the model instance.\n\nTo implement a custom relational field, you should override `RelatedField`,\nand implement the `.to_representation(self, value)` method. This method takes\nthe target of the field as the `value` argument, and should return the\nrepresentation that should be used to serialize the target. The `value`\nargument will typically be a model instance.\n\nIf you want to implement a read-write relational field, you must also\nimplement the `.to_internal_value(self, data)` method.\n\nTo provide a dynamic queryset based on the `context`, you can also override\n`.get_queryset(self)` instead of specifying `.queryset` on the class or when\ninitializing the field.\n\nFor example, we could define a relational field to serialize a track to a\ncustom string representation, using its ordering, title, and duration:\n\nThis custom field would then serialize to the following representation:\n\nIn some cases you may need to customize the behavior of a hyperlinked field,\nin order to represent URLs that require more than a single lookup field.\n\nYou can achieve this by overriding `HyperlinkedRelatedField`. There are two\nmethods that may be overridden:\n\nget_url(self, obj, view_name, request, format)\n\nThe `get_url` method is used to map the object instance to its URL\nrepresentation.\n\nMay raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes\nare not configured to correctly match the URL conf.\n\nget_object(self, view_name, view_args, view_kwargs)\n\nIf you want to support a writable hyperlinked field then you'll also want to\noverride `get_object`, in order to map incoming URLs back to the object they\nrepresent. For read-only hyperlinked fields there is no need to override this\nmethod.\n\nThe return value of this method should the object that corresponds to the\nmatched URL conf arguments.\n\nMay raise an `ObjectDoesNotExist` exception.\n\nSay we have a URL for a customer object that takes two keyword arguments, like\nso:\n\nThis cannot be represented with the default implementation, which accepts only\na single lookup field.\n\nIn this case we'd need to override `HyperlinkedRelatedField` to get the\nbehavior we want:\n\nNote that if you wanted to use this style together with the generic views then\nyou'd also need to override `.get_object` on the view in order to get the\ncorrect lookup behavior.\n\nGenerally we recommend a flat style for API representations where possible,\nbut the nested URL style can also be reasonable when used in moderation.\n\nThe `queryset` argument is only ever required for writable relationship field,\nin which case it is used for performing the model instance lookup, that maps\nfrom the primitive user input, into a model instance.\n\nIn version 2.x a serializer class could sometimes automatically determine the\n`queryset` argument if a `ModelSerializer` class was being used.\n\nThis behavior is now replaced with always using an explicit `queryset`\nargument for writable relational fields.\n\nDoing so reduces the amount of hidden 'magic' that `ModelSerializer` provides,\nmakes the behavior of the field more clear, and ensures that it is trivial to\nmove between using the `ModelSerializer` shortcut, or using fully explicit\n`Serializer` classes.\n\nThe built-in `__str__` method of the model will be used to generate string\nrepresentations of the objects used to populate the `choices` property. These\nchoices are used to populate select HTML inputs in the browsable API.\n\nTo provide customized representations for such inputs, override\n`display_value()` of a `RelatedField` subclass. This method will receive a\nmodel object, and should return a string suitable for representing it. For\nexample:\n\nWhen rendered in the browsable API relational fields will default to only\ndisplaying a maximum of 1000 selectable items. If more items are present then\na disabled option with \"More than 1000 items\u2026\" will be displayed.\n\nThis behavior is intended to prevent a template from being unable to render in\nan acceptable timespan due to a very large number of relationships being\ndisplayed.\n\nThere are two keyword arguments you can use to control this behavior:\n\nYou can also control these globally using the settings `HTML_SELECT_CUTOFF`\nand `HTML_SELECT_CUTOFF_TEXT`.\n\nIn cases where the cutoff is being enforced you may want to instead use a\nplain input field in the HTML form. You can do so using the `style` keyword\nargument. For example:\n\nNote that reverse relationships are not automatically included by the\n`ModelSerializer` and `HyperlinkedModelSerializer` classes. To include a\nreverse relationship, you must explicitly add it to the fields list. For\nexample:\n\nYou'll normally want to ensure that you've set an appropriate `related_name`\nargument on the relationship, that you can use as the field name. For example:\n\nIf you have not set a related name for the reverse relationship, you'll need\nto use the automatically generated related name in the `fields` argument. For\nexample:\n\nSee the Django documentation on reverse relationships for more details.\n\nIf you want to serialize a generic foreign key, you need to define a custom\nfield, to determine explicitly how you want to serialize the targets of the\nrelationship.\n\nFor example, given the following model for a tag, which has a generic\nrelationship with other arbitrary models:\n\nAnd the following two models, which may have associated tags:\n\nWe could define a custom field that could be used to serialize tagged\ninstances, using the type of each instance to determine how it should be\nserialized:\n\nIf you need the target of the relationship to have a nested representation,\nyou can use the required serializers inside the `.to_representation()` method:\n\nNote that reverse generic keys, expressed using the `GenericRelation` field,\ncan be serialized using the regular relational field types, since the type of\nthe target in the relationship is always known.\n\nFor more information see the Django documentation on generic relations.\n\nBy default, relational fields that target a `ManyToManyField` with a `through`\nmodel specified are set to read-only.\n\nIf you explicitly specify a relational field pointing to a `ManyToManyField`\nwith a through model, be sure to set `read_only` to `True`.\n\nIf you wish to represent extra fields on a through model then you may\nserialize the through model as a nested object.\n\nThe following third party packages are also available.\n\nThe drf-nested-routers package provides routers and relationship fields for\nworking with nested resources.\n\nThe rest-framework-generic-relations library provides read/write serialization\nfor generic foreign keys.\n\nrelations.py\n\n"}, {"name": "HyperlinkedModelSerializer", "path": "api-guide/serializers/index#hyperlinkedmodelserializer", "type": "Ref: Serializers", "text": "\nExpanding the usefulness of the serializers is something that we would like to\naddress. However, it's not a trivial problem, and it will take some serious\ndesign work.\n\n\u2014 Russell Keith-Magee, Django users group\n\nSerializers allow complex data such as querysets and model instances to be\nconverted to native Python datatypes that can then be easily rendered into\n`JSON`, `XML` or other content types. Serializers also provide\ndeserialization, allowing parsed data to be converted back into complex types,\nafter first validating the incoming data.\n\nThe serializers in REST framework work very similarly to Django's `Form` and\n`ModelForm` classes. We provide a `Serializer` class which gives you a\npowerful, generic way to control the output of your responses, as well as a\n`ModelSerializer` class which provides a useful shortcut for creating\nserializers that deal with model instances and querysets.\n\nLet's start by creating a simple object we can use for example purposes:\n\nWe'll declare a serializer that we can use to serialize and deserialize data\nthat corresponds to `Comment` objects.\n\nDeclaring a serializer looks very similar to declaring a form:\n\nWe can now use `CommentSerializer` to serialize a comment, or list of\ncomments. Again, using the `Serializer` class looks a lot like using a `Form`\nclass.\n\nAt this point we've translated the model instance into Python native\ndatatypes. To finalise the serialization process we render the data into\n`json`.\n\nDeserialization is similar. First we parse a stream into Python native\ndatatypes...\n\n...then we restore those native datatypes into a dictionary of validated data.\n\nIf we want to be able to return complete object instances based on the\nvalidated data we need to implement one or both of the `.create()` and\n`.update()` methods. For example:\n\nIf your object instances correspond to Django models you'll also want to\nensure that these methods save the object to the database. For example, if\n`Comment` was a Django model, the methods might look like this:\n\nNow when deserializing data, we can call `.save()` to return an object\ninstance, based on the validated data.\n\nCalling `.save()` will either create a new instance, or update an existing\ninstance, depending on if an existing instance was passed when instantiating\nthe serializer class:\n\nBoth the `.create()` and `.update()` methods are optional. You can implement\neither neither, one, or both of them, depending on the use-case for your\nserializer class.\n\nSometimes you'll want your view code to be able to inject additional data at\nthe point of saving the instance. This additional data might include\ninformation like the current user, the current time, or anything else that is\nnot part of the request data.\n\nYou can do so by including additional keyword arguments when calling\n`.save()`. For example:\n\nAny additional keyword arguments will be included in the `validated_data`\nargument when `.create()` or `.update()` are called.\n\nIn some cases the `.create()` and `.update()` method names may not be\nmeaningful. For example, in a contact form we may not be creating new\ninstances, but instead sending an email or other message.\n\nIn these cases you might instead choose to override `.save()` directly, as\nbeing more readable and meaningful.\n\nFor example:\n\nNote that in the case above we're now having to access the serializer\n`.validated_data` property directly.\n\nWhen deserializing data, you always need to call `is_valid()` before\nattempting to access the validated data, or save an object instance. If any\nvalidation errors occur, the `.errors` property will contain a dictionary\nrepresenting the resulting error messages. For example:\n\nEach key in the dictionary will be the field name, and the values will be\nlists of strings of any error messages corresponding to that field. The\n`non_field_errors` key may also be present, and will list any general\nvalidation errors. The name of the `non_field_errors` key may be customized\nusing the `NON_FIELD_ERRORS_KEY` REST framework setting.\n\nWhen deserializing a list of items, errors will be returned as a list of\ndictionaries representing each of the deserialized items.\n\nThe `.is_valid()` method takes an optional `raise_exception` flag that will\ncause it to raise a `serializers.ValidationError` exception if there are\nvalidation errors.\n\nThese exceptions are automatically dealt with by the default exception handler\nthat REST framework provides, and will return `HTTP 400 Bad Request` responses\nby default.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. These are\nsimilar to the `.clean_<field_name>` methods on Django forms.\n\nThese methods take a single argument, which is the field value that requires\nvalidation.\n\nYour `validate_<field_name>` methods should return the validated value or\nraise a `serializers.ValidationError`. For example:\n\nNote: If your `<field_name>` is declared on your serializer with the parameter\n`required=False` then this validation step will not take place if the field is\nnot included.\n\nTo do any other validation that requires access to multiple fields, add a\nmethod called `.validate()` to your `Serializer` subclass. This method takes a\nsingle argument, which is a dictionary of field values. It should raise a\n`serializers.ValidationError` if necessary, or just return the validated\nvalues. For example:\n\nIndividual fields on a serializer can include validators, by declaring them on\nthe field instance, for example:\n\nSerializer classes can also include reusable validators that are applied to\nthe complete set of field data. These validators are included by declaring\nthem on an inner `Meta` class, like so:\n\nFor more information see the validators documentation.\n\nWhen passing an initial object or queryset to a serializer instance, the\nobject will be made available as `.instance`. If no initial object is passed\nthen the `.instance` attribute will be `None`.\n\nWhen passing data to a serializer instance, the unmodified data will be made\navailable as `.initial_data`. If the `data` keyword argument is not passed\nthen the `.initial_data` attribute will not exist.\n\nBy default, serializers must be passed values for all required fields or they\nwill raise validation errors. You can use the `partial` argument in order to\nallow partial updates.\n\nThe previous examples are fine for dealing with objects that only have simple\ndatatypes, but sometimes we also need to be able to represent more complex\nobjects, where some of the attributes of an object might not be simple\ndatatypes such as strings, dates or integers.\n\nThe `Serializer` class is itself a type of `Field`, and can be used to\nrepresent relationships where one object type is nested inside another.\n\nIf a nested representation may optionally accept the `None` value you should\npass the `required=False` flag to the nested serializer.\n\nSimilarly if a nested representation should be a list of items, you should\npass the `many=True` flag to the nested serializer.\n\nWhen dealing with nested representations that support deserializing the data,\nany errors with nested objects will be nested under the field name of the\nnested object.\n\nSimilarly, the `.validated_data` property will include nested data structures.\n\nIf you're supporting writable nested representations you'll need to write\n`.create()` or `.update()` methods that handle saving multiple objects.\n\nThe following example demonstrates how you might handle creating a user with a\nnested profile object.\n\nFor updates you'll want to think carefully about how to handle updates to\nrelationships. For example if the data for the relationship is `None`, or not\nprovided, which of the following should occur?\n\nHere's an example for an `.update()` method on our previous `UserSerializer`\nclass.\n\nBecause the behavior of nested creates and updates can be ambiguous, and may\nrequire complex dependencies between related models, REST framework 3 requires\nyou to always write these methods explicitly. The default `ModelSerializer`\n`.create()` and `.update()` methods do not include support for writable nested\nrepresentations.\n\nThere are however, third-party packages available such as DRF Writable Nested\nthat support automatic writable nested representations.\n\nAn alternative to saving multiple related instances in the serializer is to\nwrite custom model manager classes that handle creating the correct instances.\n\nFor example, suppose we wanted to ensure that `User` instances and `Profile`\ninstances are always created together as a pair. We might write a custom\nmanager class that looks something like this:\n\nThis manager class now more nicely encapsulates that user instances and\nprofile instances are always created at the same time. Our `.create()` method\non the serializer class can now be re-written to use the new manager method.\n\nFor more details on this approach see the Django documentation on model\nmanagers, and this blogpost on using model and manager classes.\n\nThe `Serializer` class can also handle serializing or deserializing lists of\nobjects.\n\nTo serialize a queryset or list of objects instead of a single object\ninstance, you should pass the `many=True` flag when instantiating the\nserializer. You can then pass a queryset or list of objects to be serialized.\n\nThe default behavior for deserializing multiple objects is to support multiple\nobject creation, but not support multiple object updates. For more information\non how to support or customize either of these cases, see the ListSerializer\ndocumentation below.\n\nThere are some cases where you need to provide extra context to the serializer\nin addition to the object being serialized. One common case is if you're using\na serializer that includes hyperlinked relations, which requires the\nserializer to have access to the current request so that it can properly\ngenerate fully qualified URLs.\n\nYou can provide arbitrary additional context by passing a `context` argument\nwhen instantiating the serializer. For example:\n\nThe context dictionary can be used within any serializer field logic, such as\na custom `.to_representation()` method, by accessing the `self.context`\nattribute.\n\nOften you'll want serializer classes that map closely to Django model\ndefinitions.\n\nThe `ModelSerializer` class provides a shortcut that lets you automatically\ncreate a `Serializer` class with fields that correspond to the Model fields.\n\nThe `ModelSerializer` class is the same as a regular `Serializer` class,\nexcept that:\n\nDeclaring a `ModelSerializer` looks like this:\n\nBy default, all the model fields on the class will be mapped to a\ncorresponding serializer fields.\n\nAny relationships such as foreign keys on the model will be mapped to\n`PrimaryKeyRelatedField`. Reverse relationships are not included by default\nunless explicitly included as specified in the serializer relations\ndocumentation.\n\nSerializer classes generate helpful verbose representation strings, that allow\nyou to fully inspect the state of their fields. This is particularly useful\nwhen working with `ModelSerializers` where you want to determine what set of\nfields and validators are being automatically created for you.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIf you only want a subset of the default fields to be used in a model\nserializer, you can do so using `fields` or `exclude` options, just as you\nwould with a `ModelForm`. It is strongly recommended that you explicitly set\nall fields that should be serialized using the `fields` attribute. This will\nmake it less likely to result in unintentionally exposing data when your\nmodels change.\n\nFor example:\n\nYou can also set the `fields` attribute to the special value `'__all__'` to\nindicate that all fields in the model should be used.\n\nFor example:\n\nYou can set the `exclude` attribute to a list of fields to be excluded from\nthe serializer.\n\nFor example:\n\nIn the example above, if the `Account` model had 3 fields `account_name`,\n`users`, and `created`, this will result in the fields `account_name` and\n`created` to be serialized.\n\nThe names in the `fields` and `exclude` attributes will normally map to model\nfields on the model class.\n\nAlternatively names in the `fields` options can map to properties or methods\nwhich take no arguments that exist on the model class.\n\nSince version 3.3.0, it is mandatory to provide one of the attributes `fields`\nor `exclude`.\n\nThe default `ModelSerializer` uses primary keys for relationships, but you can\nalso easily generate nested representations using the `depth` option:\n\nThe `depth` option should be set to an integer value that indicates the depth\nof relationships that should be traversed before reverting to a flat\nrepresentation.\n\nIf you want to customize the way the serialization is done you'll need to\ndefine the field yourself.\n\nYou can add extra fields to a `ModelSerializer` or override the default fields\nby declaring fields on the class, just as you would for a `Serializer` class.\n\nExtra fields can correspond to any property or callable on the model.\n\nYou may wish to specify multiple fields as read-only. Instead of adding each\nfield explicitly with the `read_only=True` attribute, you may use the shortcut\nMeta option, `read_only_fields`.\n\nThis option should be a list or tuple of field names, and is declared as\nfollows:\n\nModel fields which have `editable=False` set, and `AutoField` fields will be\nset to read-only by default, and do not need to be added to the\n`read_only_fields` option.\n\nNote: There is a special-case where a read-only field is part of a\n`unique_together` constraint at the model level. In this case the field is\nrequired by the serializer class in order to validate the constraint, but\nshould also not be editable by the user.\n\nThe right way to deal with this is to specify the field explicitly on the\nserializer, providing both the `read_only=True` and `default=\u2026` keyword\narguments.\n\nOne example of this is a read-only relation to the currently authenticated\n`User` which is `unique_together` with another identifier. In this case you\nwould declare the user field like so:\n\nPlease review the Validators Documentation for details on the\nUniqueTogetherValidator and CurrentUserDefault classes.\n\nThere is also a shortcut allowing you to specify arbitrary additional keyword\narguments on fields, using the `extra_kwargs` option. As in the case of\n`read_only_fields`, this means you do not need to explicitly declare the field\non the serializer.\n\nThis option is a dictionary, mapping field names to a dictionary of keyword\narguments. For example:\n\nPlease keep in mind that, if the field has already been explicitly declared on\nthe serializer class, then the `extra_kwargs` option will be ignored.\n\nWhen serializing model instances, there are a number of different ways you\nmight choose to represent relationships. The default representation for\n`ModelSerializer` is to use the primary keys of the related instances.\n\nAlternative representations include serializing using hyperlinks, serializing\ncomplete nested representations, or serializing with a custom representation.\n\nFor full details see the serializer relations documentation.\n\nThe ModelSerializer class also exposes an API that you can override in order\nto alter how serializer fields are automatically determined when instantiating\nthe serializer.\n\nNormally if a `ModelSerializer` does not generate the fields you need by\ndefault then you should either add them to the class explicitly, or simply use\na regular `Serializer` class instead. However in some cases you may want to\ncreate a new base class that defines how the serializer fields are created for\nany given model.\n\nA mapping of Django model fields to REST framework serializer fields. You can\noverride this mapping to alter the default serializer fields that should be\nused for each model field.\n\nThis property should be the serializer field class, that is used for\nrelational fields by default.\n\nFor `ModelSerializer` this defaults to `PrimaryKeyRelatedField`.\n\nFor `HyperlinkedModelSerializer` this defaults to\n`serializers.HyperlinkedRelatedField`.\n\nThe serializer field class that should be used for any `url` field on the\nserializer.\n\nDefaults to `serializers.HyperlinkedIdentityField`\n\nThe serializer field class that should be used for any choice fields on the\nserializer.\n\nDefaults to `serializers.ChoiceField`\n\nThe following methods are called to determine the class and keyword arguments\nfor each field that should be automatically included on the serializer. Each\nof these methods should return a two tuple of `(field_class, field_kwargs)`.\n\nCalled to generate a serializer field that maps to a standard model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_field_mapping` attribute.\n\nCalled to generate a serializer field that maps to a relational model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_related_field` attribute.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a relational model field,\nwhen the `depth` option has been set.\n\nThe default implementation dynamically creates a nested serializer class based\non either `ModelSerializer` or `HyperlinkedModelSerializer`.\n\nThe `nested_depth` will be the value of the `depth` option, minus one.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a property or zero-argument\nmethod on the model class.\n\nThe default implementation returns a `ReadOnlyField` class.\n\nCalled to generate a serializer field for the serializer's own `url` field.\nThe default implementation returns a `HyperlinkedIdentityField` class.\n\nCalled when the field name did not map to any model field or model property.\nThe default implementation raises an error, although subclasses may customize\nthis behavior.\n\nThe `HyperlinkedModelSerializer` class is similar to the `ModelSerializer`\nclass except that it uses hyperlinks to represent relationships, rather than\nprimary keys.\n\nBy default the serializer will include a `url` field instead of a primary key\nfield.\n\nThe url field will be represented using a `HyperlinkedIdentityField`\nserializer field, and any relationships on the model will be represented using\na `HyperlinkedRelatedField` serializer field.\n\nYou can explicitly include the primary key by adding it to the `fields`\noption, for example:\n\nWhen instantiating a `HyperlinkedModelSerializer` you must include the current\n`request` in the serializer context, for example:\n\nDoing so will ensure that the hyperlinks can include an appropriate hostname,\nso that the resulting representation uses fully qualified URLs, such as:\n\nRather than relative URLs, such as:\n\nIf you do want to use relative URLs, you should explicitly pass `{'request':\nNone}` in the serializer context.\n\nThere needs to be a way of determining which views should be used for\nhyperlinking to model instances.\n\nBy default hyperlinks are expected to correspond to a view name that matches\nthe style `'{model_name}-detail'`, and looks up the instance by a `pk` keyword\nargument.\n\nYou can override a URL field view name and lookup field by using either, or\nboth of, the `view_name` and `lookup_field` options in the `extra_kwargs`\nsetting, like so:\n\nAlternatively you can set the fields on the serializer explicitly. For\nexample:\n\nTip: Properly matching together hyperlinked representations and your URL conf\ncan sometimes be a bit fiddly. Printing the `repr` of a\n`HyperlinkedModelSerializer` instance is a particularly useful way to inspect\nexactly which view names and lookup fields the relationships are expected to\nmap too.\n\nThe name of the URL field defaults to 'url'. You can override this globally,\nby using the `URL_FIELD_NAME` setting.\n\nThe `ListSerializer` class provides the behavior for serializing and\nvalidating multiple objects at once. You won't typically need to use\n`ListSerializer` directly, but should instead simply pass `many=True` when\ninstantiating a serializer.\n\nWhen a serializer is instantiated and `many=True` is passed, a\n`ListSerializer` instance will be created. The serializer class then becomes a\nchild of the parent `ListSerializer`\n\nThe following argument can also be passed to a `ListSerializer` field or a\nserializer that is passed `many=True`:\n\nThis is `True` by default, but can be set to `False` if you want to disallow\nempty lists as valid input.\n\nThere are a few use cases when you might want to customize the\n`ListSerializer` behavior. For example:\n\nFor these cases you can modify the class that is used when `many=True` is\npassed, by using the `list_serializer_class` option on the serializer `Meta`\nclass.\n\nFor example:\n\nThe default implementation for multiple object creation is to simply call\n`.create()` for each item in the list. If you want to customize this behavior,\nyou'll need to customize the `.create()` method on `ListSerializer` class that\nis used when `many=True` is passed.\n\nFor example:\n\nBy default the `ListSerializer` class does not support multiple updates. This\nis because the behavior that should be expected for insertions and deletions\nis ambiguous.\n\nTo support multiple updates you'll need to do so explicitly. When writing your\nmultiple update code make sure to keep the following in mind:\n\nYou will need to add an explicit `id` field to the instance serializer. The\ndefault implicitly-generated `id` field is marked as `read_only`. This causes\nit to be removed on updates. Once you declare it explicitly, it will be\navailable in the list serializer's `update` method.\n\nHere's an example of how you might choose to implement multiple updates:\n\nIt is possible that a third party package may be included alongside the 3.1\nrelease that provides some automatic support for multiple update operations,\nsimilar to the `allow_add_remove` behavior that was present in REST framework\n2.\n\nWhen a serializer with `many=True` is instantiated, we need to determine which\narguments and keyword arguments should be passed to the `.__init__()` method\nfor both the child `Serializer` class, and for the parent `ListSerializer`\nclass.\n\nThe default implementation is to pass all arguments to both classes, except\nfor `validators`, and any custom keyword arguments, both of which are assumed\nto be intended for the child serializer class.\n\nOccasionally you might need to explicitly specify how the child and parent\nclasses should be instantiated when `many=True` is passed. You can do so by\nusing the `many_init` class method.\n\n`BaseSerializer` class that can be used to easily support alternative\nserialization and deserialization styles.\n\nThis class implements the same basic API as the `Serializer` class:\n\nThere are four methods that can be overridden, depending on what functionality\nyou want the serializer class to support:\n\nBecause this class provides the same interface as the `Serializer` class, you\ncan use it with the existing generic class-based views exactly as you would\nfor a regular `Serializer` or `ModelSerializer`.\n\nThe only difference you'll notice when doing so is the `BaseSerializer`\nclasses will not generate HTML forms in the browsable API. This is because the\ndata they return does not include all the field information that would allow\neach field to be rendered into a suitable HTML input.\n\nTo implement a read-only serializer using the `BaseSerializer` class, we just\nneed to override the `.to_representation()` method. Let's take a look at an\nexample using a simple Django model:\n\nIt's simple to create a read-only serializer for converting `HighScore`\ninstances into primitive data types.\n\nWe can now use this class to serialize single `HighScore` instances:\n\nOr use it to serialize multiple instances:\n\nTo create a read-write serializer we first need to implement a\n`.to_internal_value()` method. This method returns the validated values that\nwill be used to construct the object instance, and may raise a\n`serializers.ValidationError` if the supplied data is in an incorrect format.\n\nOnce you've implemented `.to_internal_value()`, the basic validation API will\nbe available on the serializer, and you will be able to use `.is_valid()`,\n`.validated_data` and `.errors`.\n\nIf you want to also support `.save()` you'll need to also implement either or\nboth of the `.create()` and `.update()` methods.\n\nHere's a complete example of our previous `HighScoreSerializer`, that's been\nupdated to support both read and write operations.\n\nThe `BaseSerializer` class is also useful if you want to implement new generic\nserializer classes for dealing with particular serialization styles, or for\nintegrating with alternative storage backends.\n\nThe following class is an example of a generic serializer that can handle\ncoercing arbitrary objects into primitive representations.\n\nIf you need to alter the serialization or deserialization behavior of a\nserializer class, you can do so by overriding the `.to_representation()` or\n`.to_internal_value()` methods.\n\nSome reasons this might be useful include...\n\nThe signatures for these methods are as follows:\n\nTakes the object instance that requires serialization, and should return a\nprimitive representation. Typically this means returning a structure of built-\nin Python datatypes. The exact types that can be handled will depend on the\nrender classes you have configured for your API.\n\nMay be overridden in order to modify the representation style. For example:\n\nTakes the unvalidated incoming data as input and should return the validated\ndata that will be made available as `serializer.validated_data`. The return\nvalue will also be passed to the `.create()` or `.update()` methods if\n`.save()` is called on the serializer class.\n\nIf any of the validation fails, then the method should raise a\n`serializers.ValidationError(errors)`. The `errors` argument should be a\ndictionary mapping field names (or `settings.NON_FIELD_ERRORS_KEY`) to a list\nof error messages. If you don't need to alter deserialization behavior and\ninstead want to provide object-level validation, it's recommended that you\ninstead override the `.validate()` method.\n\nThe `data` argument passed to this method will normally be the value of\n`request.data`, so the datatype it provides will depend on the parser classes\nyou have configured for your API.\n\nSimilar to Django forms, you can extend and reuse serializers through\ninheritance. This allows you to declare a common set of fields or methods on a\nparent class that can then be used in a number of serializers. For example,\n\nLike Django's `Model` and `ModelForm` classes, the inner `Meta` class on\nserializers does not implicitly inherit from it's parents' inner `Meta`\nclasses. If you want the `Meta` class to inherit from a parent class you must\ndo so explicitly. For example:\n\nTypically we would recommend not using inheritance on inner Meta classes, but\ninstead declaring all options explicitly.\n\nAdditionally, the following caveats apply to serializer inheritance:\n\nIt\u2019s possible to declaratively remove a `Field` inherited from a parent class\nby setting the name to be `None` on the subclass.\n\nHowever, you can only use this technique to opt out from a field defined\ndeclaratively by a parent class; it won\u2019t prevent the `ModelSerializer` from\ngenerating a default field. To opt-out from default fields, see Specifying\nwhich fields to include.\n\nOnce a serializer has been initialized, the dictionary of fields that are set\non the serializer may be accessed using the `.fields` attribute. Accessing and\nmodifying this attribute allows you to dynamically modify the serializer.\n\nModifying the `fields` argument directly allows you to do interesting things\nsuch as changing the arguments on serializer fields at runtime, rather than at\nthe point of declaring the serializer.\n\nFor example, if you wanted to be able to set which fields should be used by a\nserializer at the point of initializing it, you could create a serializer\nclass like so:\n\nThis would then allow you to do the following:\n\nREST framework 2 provided an API to allow developers to override how a\n`ModelSerializer` class would automatically generate the default set of\nfields.\n\nThis API included the `.get_field()`, `.get_pk_field()` and other methods.\n\nBecause the serializers have been fundamentally redesigned with 3.0 this API\nno longer exists. You can still modify the fields that get created but you'll\nneed to refer to the source code, and be aware that if the changes you make\nare against private bits of API then they may be subject to change.\n\nThe following third party packages are also available.\n\nThe django-rest-marshmallow package provides an alternative implementation for\nserializers, using the python marshmallow library. It exposes the same API as\nthe REST framework serializers, and can be used as a drop-in replacement in\nsome use-cases.\n\nThe serpy package is an alternative implementation for serializers that is\nbuilt for speed. Serpy serializes complex datatypes to simple native types.\nThe native types can be easily converted to JSON or any other format needed.\n\nThe django-rest-framework-mongoengine package provides a\n`MongoEngineModelSerializer` serializer class that supports using MongoDB as\nthe storage layer for Django REST framework.\n\nThe django-rest-framework-gis package provides a `GeoFeatureModelSerializer`\nserializer class that supports GeoJSON both for read and write operations.\n\nThe django-rest-framework-hstore package provides an `HStoreSerializer` to\nsupport django-hstore `DictionaryField` model field and its `schema-mode`\nfeature.\n\nThe dynamic-rest package extends the ModelSerializer and ModelViewSet\ninterfaces, adding API query parameters for filtering, sorting, and including\n/ excluding all fields and relationships defined by your serializers.\n\nThe drf-dynamic-fields package provides a mixin to dynamically limit the\nfields per serializer to a subset specified by an URL parameter.\n\nThe drf-flex-fields package extends the ModelSerializer and ModelViewSet to\nprovide commonly used functionality for dynamically setting fields and\nexpanding primitive fields to nested models, both from URL parameters and your\nserializer class definitions.\n\nThe django-rest-framework-serializer-extensions package provides a collection\nof tools to DRY up your serializers, by allowing fields to be defined on a\nper-view/request basis. Fields can be whitelisted, blacklisted and child\nserializers can be optionally expanded.\n\nThe html-json-forms package provides an algorithm and serializer for\nprocessing `<form>` submissions per the (inactive) HTML JSON Form\nspecification. The serializer facilitates processing of arbitrarily nested\nJSON structures within HTML. For example, `<input name=\"items[0][id]\"\nvalue=\"5\">` will be interpreted as `{\"items\": [{\"id\": \"5\"}]}`.\n\nDRF-Base64 provides a set of field and model serializers that handles the\nupload of base64-encoded files.\n\ndjangorestframework-queryfields allows API clients to specify which fields\nwill be sent in the response via inclusion/exclusion query parameters.\n\nThe drf-writable-nested package provides writable nested model serializer\nwhich allows to create/update models with nested related data.\n\nThe drf-encrypt-content package helps you encrypt your data, serialized\nthrough ModelSerializer. It also contains some helper functions. Which helps\nyou to encrypt your data.\n\nserializers.py\n\n"}, {"name": "HyperlinkedRelatedField", "path": "api-guide/relations/index#hyperlinkedrelatedfield", "type": "Ref: Serializer relations", "text": "\nData structures, not algorithms, are central to programming.\n\n\u2014 Rob Pike\n\nRelational fields are used to represent model relationships. They can be\napplied to `ForeignKey`, `ManyToManyField` and `OneToOneField` relationships,\nas well as to reverse relationships, and custom relationships such as\n`GenericForeignKey`.\n\nNote: The relational fields are declared in `relations.py`, but by convention\nyou should import them from the `serializers` module, using `from\nrest_framework import serializers` and refer to fields as\n`serializers.<FieldName>`.\n\nWhen using the `ModelSerializer` class, serializer fields and relationships\nwill be automatically generated for you. Inspecting these automatically\ngenerated fields can be a useful tool for determining how to customize the\nrelationship style.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIn order to explain the various types of relational fields, we'll use a couple\nof simple models for our examples. Our models will be for music albums, and\nthe tracks listed on each album.\n\n`StringRelatedField` may be used to represent the target of the relationship\nusing its `__str__` method.\n\nFor example, the following serializer:\n\nWould serialize to the following representation:\n\nThis field is read only.\n\nArguments:\n\n`PrimaryKeyRelatedField` may be used to represent the target of the\nrelationship using its primary key.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nArguments:\n\n`HyperlinkedRelatedField` may be used to represent the target of the\nrelationship using a hyperlink.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nNote: This field is designed for objects that map to a URL that accepts a\nsingle URL keyword argument, as set using the `lookup_field` and\n`lookup_url_kwarg` arguments.\n\nThis is suitable for URLs that contain a single primary key or slug argument\nas part of the URL.\n\nIf you require more complex hyperlinked representation you'll need to\ncustomize the field, as described in the custom hyperlinked fields section,\nbelow.\n\nArguments:\n\n`SlugRelatedField` may be used to represent the target of the relationship\nusing a field on the target.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nWhen using `SlugRelatedField` as a read-write field, you will normally want to\nensure that the slug field corresponds to a model field with `unique=True`.\n\nArguments:\n\nThis field can be applied as an identity relationship, such as the `'url'`\nfield on a HyperlinkedModelSerializer. It can also be used for an attribute on\nthe object. For example, the following serializer:\n\nWould serialize to a representation like this:\n\nThis field is always read-only.\n\nArguments:\n\nAs opposed to previously discussed references to another entity, the referred\nentity can instead also be embedded or nested in the representation of the\nobject that refers to it. Such nested relationships can be expressed by using\nserializers as fields.\n\nIf the field is used to represent a to-many relationship, you should add the\n`many=True` flag to the serializer field.\n\nFor example, the following serializer:\n\nWould serialize to a nested representation like this:\n\nBy default nested serializers are read-only. If you want to support write-\noperations to a nested serializer field you'll need to create `create()`\nand/or `update()` methods in order to explicitly specify how the child\nrelationships should be saved:\n\nIn rare cases where none of the existing relational styles fit the\nrepresentation you need, you can implement a completely custom relational\nfield, that describes exactly how the output representation should be\ngenerated from the model instance.\n\nTo implement a custom relational field, you should override `RelatedField`,\nand implement the `.to_representation(self, value)` method. This method takes\nthe target of the field as the `value` argument, and should return the\nrepresentation that should be used to serialize the target. The `value`\nargument will typically be a model instance.\n\nIf you want to implement a read-write relational field, you must also\nimplement the `.to_internal_value(self, data)` method.\n\nTo provide a dynamic queryset based on the `context`, you can also override\n`.get_queryset(self)` instead of specifying `.queryset` on the class or when\ninitializing the field.\n\nFor example, we could define a relational field to serialize a track to a\ncustom string representation, using its ordering, title, and duration:\n\nThis custom field would then serialize to the following representation:\n\nIn some cases you may need to customize the behavior of a hyperlinked field,\nin order to represent URLs that require more than a single lookup field.\n\nYou can achieve this by overriding `HyperlinkedRelatedField`. There are two\nmethods that may be overridden:\n\nget_url(self, obj, view_name, request, format)\n\nThe `get_url` method is used to map the object instance to its URL\nrepresentation.\n\nMay raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes\nare not configured to correctly match the URL conf.\n\nget_object(self, view_name, view_args, view_kwargs)\n\nIf you want to support a writable hyperlinked field then you'll also want to\noverride `get_object`, in order to map incoming URLs back to the object they\nrepresent. For read-only hyperlinked fields there is no need to override this\nmethod.\n\nThe return value of this method should the object that corresponds to the\nmatched URL conf arguments.\n\nMay raise an `ObjectDoesNotExist` exception.\n\nSay we have a URL for a customer object that takes two keyword arguments, like\nso:\n\nThis cannot be represented with the default implementation, which accepts only\na single lookup field.\n\nIn this case we'd need to override `HyperlinkedRelatedField` to get the\nbehavior we want:\n\nNote that if you wanted to use this style together with the generic views then\nyou'd also need to override `.get_object` on the view in order to get the\ncorrect lookup behavior.\n\nGenerally we recommend a flat style for API representations where possible,\nbut the nested URL style can also be reasonable when used in moderation.\n\nThe `queryset` argument is only ever required for writable relationship field,\nin which case it is used for performing the model instance lookup, that maps\nfrom the primitive user input, into a model instance.\n\nIn version 2.x a serializer class could sometimes automatically determine the\n`queryset` argument if a `ModelSerializer` class was being used.\n\nThis behavior is now replaced with always using an explicit `queryset`\nargument for writable relational fields.\n\nDoing so reduces the amount of hidden 'magic' that `ModelSerializer` provides,\nmakes the behavior of the field more clear, and ensures that it is trivial to\nmove between using the `ModelSerializer` shortcut, or using fully explicit\n`Serializer` classes.\n\nThe built-in `__str__` method of the model will be used to generate string\nrepresentations of the objects used to populate the `choices` property. These\nchoices are used to populate select HTML inputs in the browsable API.\n\nTo provide customized representations for such inputs, override\n`display_value()` of a `RelatedField` subclass. This method will receive a\nmodel object, and should return a string suitable for representing it. For\nexample:\n\nWhen rendered in the browsable API relational fields will default to only\ndisplaying a maximum of 1000 selectable items. If more items are present then\na disabled option with \"More than 1000 items\u2026\" will be displayed.\n\nThis behavior is intended to prevent a template from being unable to render in\nan acceptable timespan due to a very large number of relationships being\ndisplayed.\n\nThere are two keyword arguments you can use to control this behavior:\n\nYou can also control these globally using the settings `HTML_SELECT_CUTOFF`\nand `HTML_SELECT_CUTOFF_TEXT`.\n\nIn cases where the cutoff is being enforced you may want to instead use a\nplain input field in the HTML form. You can do so using the `style` keyword\nargument. For example:\n\nNote that reverse relationships are not automatically included by the\n`ModelSerializer` and `HyperlinkedModelSerializer` classes. To include a\nreverse relationship, you must explicitly add it to the fields list. For\nexample:\n\nYou'll normally want to ensure that you've set an appropriate `related_name`\nargument on the relationship, that you can use as the field name. For example:\n\nIf you have not set a related name for the reverse relationship, you'll need\nto use the automatically generated related name in the `fields` argument. For\nexample:\n\nSee the Django documentation on reverse relationships for more details.\n\nIf you want to serialize a generic foreign key, you need to define a custom\nfield, to determine explicitly how you want to serialize the targets of the\nrelationship.\n\nFor example, given the following model for a tag, which has a generic\nrelationship with other arbitrary models:\n\nAnd the following two models, which may have associated tags:\n\nWe could define a custom field that could be used to serialize tagged\ninstances, using the type of each instance to determine how it should be\nserialized:\n\nIf you need the target of the relationship to have a nested representation,\nyou can use the required serializers inside the `.to_representation()` method:\n\nNote that reverse generic keys, expressed using the `GenericRelation` field,\ncan be serialized using the regular relational field types, since the type of\nthe target in the relationship is always known.\n\nFor more information see the Django documentation on generic relations.\n\nBy default, relational fields that target a `ManyToManyField` with a `through`\nmodel specified are set to read-only.\n\nIf you explicitly specify a relational field pointing to a `ManyToManyField`\nwith a through model, be sure to set `read_only` to `True`.\n\nIf you wish to represent extra fields on a through model then you may\nserialize the through model as a nested object.\n\nThe following third party packages are also available.\n\nThe drf-nested-routers package provides routers and relationship fields for\nworking with nested resources.\n\nThe rest-framework-generic-relations library provides read/write serialization\nfor generic foreign keys.\n\nrelations.py\n\n"}, {"name": "ImageField", "path": "api-guide/fields/index#imagefield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "IntegerField", "path": "api-guide/fields/index#integerfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "IPAddressField", "path": "api-guide/fields/index#ipaddressfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "IsAdminUser", "path": "api-guide/permissions/index#isadminuser", "type": "Ref: Permissions", "text": "\nAuthentication or identification by itself is not usually sufficient to gain\naccess to information or code. For that, the entity requesting access must\nhave authorization.\n\n\u2014 Apple Developer Documentation\n\nTogether with authentication and throttling, permissions determine whether a\nrequest should be granted or denied access.\n\nPermission checks are always run at the very start of the view, before any\nother code is allowed to proceed. Permission checks will typically use the\nauthentication information in the `request.user` and `request.auth` properties\nto determine if the incoming request should be permitted.\n\nPermissions are used to grant or deny access for different classes of users to\ndifferent parts of the API.\n\nThe simplest style of permission would be to allow access to any authenticated\nuser, and deny access to any unauthenticated user. This corresponds to the\n`IsAuthenticated` class in REST framework.\n\nA slightly less strict style of permission would be to allow full access to\nauthenticated users, but allow read-only access to unauthenticated users. This\ncorresponds to the `IsAuthenticatedOrReadOnly` class in REST framework.\n\nPermissions in REST framework are always defined as a list of permission\nclasses.\n\nBefore running the main body of the view each permission in the list is\nchecked. If any permission check fails an `exceptions.PermissionDenied` or\n`exceptions.NotAuthenticated` exception will be raised, and the main body of\nthe view will not run.\n\nWhen the permissions checks fail either a \"403 Forbidden\" or a \"401\nUnauthorized\" response will be returned, according to the following rules:\n\nREST framework permissions also support object-level permissioning. Object\nlevel permissions are used to determine if a user should be allowed to act on\na particular object, which will typically be a model instance.\n\nObject level permissions are run by REST framework's generic views when\n`.get_object()` is called. As with view level permissions, an\n`exceptions.PermissionDenied` exception will be raised if the user is not\nallowed to act on the given object.\n\nIf you're writing your own views and want to enforce object level permissions,\nor if you override the `get_object` method on a generic view, then you'll need\nto explicitly call the `.check_object_permissions(request, obj)` method on the\nview at the point at which you've retrieved the object.\n\nThis will either raise a `PermissionDenied` or `NotAuthenticated` exception,\nor simply return if the view has the appropriate permissions.\n\nFor example:\n\nNote: With the exception of `DjangoObjectPermissions`, the provided permission\nclasses in `rest_framework.permissions` do not implement the methods necessary\nto check object permissions.\n\nIf you wish to use the provided permission classes in order to check object\npermissions, you must subclass them and implement the\n`has_object_permission()` method described in the Custom permissions section\n(below).\n\nFor performance reasons the generic views will not automatically apply object\nlevel permissions to each instance in a queryset when returning a list of\nobjects.\n\nOften when you're using object level permissions you'll also want to filter\nthe queryset appropriately, to ensure that users only have visibility onto\ninstances that they are permitted to view.\n\nBecause the `get_object()` method is not called, object level permissions from\nthe `has_object_permission()` method are not applied when creating objects. In\norder to restrict object creation you need to implement the permission check\neither in your Serializer class or override the `perform_create()` method of\nyour ViewSet class.\n\nThe default permission policy may be set globally, using the\n`DEFAULT_PERMISSION_CLASSES` setting. For example.\n\nIf not specified, this setting defaults to allowing unrestricted access:\n\nYou can also set the authentication policy on a per-view, or per-viewset\nbasis, using the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nNote: when you set new permission classes via the class attribute or\ndecorators you're telling the view to ignore the default list set in the\nsettings.py file.\n\nProvided they inherit from `rest_framework.permissions.BasePermission`,\npermissions can be composed using standard Python bitwise operators. For\nexample, `IsAuthenticatedOrReadOnly` could be written:\n\nNote: it supports & (and), | (or) and ~ (not).\n\nThe `AllowAny` permission class will allow unrestricted access, regardless of\nif the request was authenticated or unauthenticated.\n\nThis permission is not strictly required, since you can achieve the same\nresult by using an empty list or tuple for the permissions setting, but you\nmay find it useful to specify this class because it makes the intention\nexplicit.\n\nThe `IsAuthenticated` permission class will deny permission to any\nunauthenticated user, and allow permission otherwise.\n\nThis permission is suitable if you want your API to only be accessible to\nregistered users.\n\nThe `IsAdminUser` permission class will deny permission to any user, unless\n`user.is_staff` is `True` in which case permission will be allowed.\n\nThis permission is suitable if you want your API to only be accessible to a\nsubset of trusted administrators.\n\nThe `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any\nrequest. Requests for unauthorised users will only be permitted if the request\nmethod is one of the \"safe\" methods; `GET`, `HEAD` or `OPTIONS`.\n\nThis permission is suitable if you want to your API to allow read permissions\nto anonymous users, and only allow write permissions to authenticated users.\n\nThis permission class ties into Django's standard `django.contrib.auth` model\npermissions. This permission must only be applied to views that have a\n`.queryset` property or `get_queryset()` method. Authorization will only be\ngranted if the user is authenticated and has the relevant model permissions\nassigned.\n\nThe default behaviour can also be overridden to support custom model\npermissions. For example, you might want to include a `view` model permission\nfor `GET` requests.\n\nTo use custom model permissions, override `DjangoModelPermissions` and set the\n`.perms_map` property. Refer to the source code for details.\n\nSimilar to `DjangoModelPermissions`, but also allows unauthenticated users to\nhave read-only access to the API.\n\nThis permission class ties into Django's standard object permissions framework\nthat allows per-object permissions on models. In order to use this permission\nclass, you'll also need to add a permission backend that supports object-level\npermissions, such as django-guardian.\n\nAs with `DjangoModelPermissions`, this permission must only be applied to\nviews that have a `.queryset` property or `.get_queryset()` method.\nAuthorization will only be granted if the user is authenticated and has the\nrelevant per-object permissions and relevant model permissions assigned.\n\nNote that `DjangoObjectPermissions` does not require the `django-guardian`\npackage, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by\noverriding `DjangoObjectPermissions` and setting the `.perms_map` property.\nRefer to the source code for details.\n\nNote: If you need object level `view` permissions for `GET`, `HEAD` and\n`OPTIONS` requests and are using django-guardian for your object-level\npermissions backend, you'll want to consider using the\n`DjangoObjectPermissionsFilter` class provided by the `djangorestframework-\nguardian` package. It ensures that list endpoints only return results\nincluding objects for which the user has appropriate view permissions.\n\nTo implement a custom permission, override `BasePermission` and implement\neither, or both, of the following methods:\n\nThe methods should return `True` if the request should be granted access, and\n`False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you\nshould check the request method against the constant `SAFE_METHODS`, which is\na tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\nNote: The instance-level `has_object_permission` method will only be called if\nthe view-level `has_permission` checks have already passed. Also note that in\norder for the instance-level checks to run, the view code should explicitly\ncall `.check_object_permissions(request, obj)`. If you are using the generic\nviews then this will be handled for you by default. (Function-based views will\nneed to check object permissions explicitly, raising `PermissionDenied` on\nfailure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test\nfails. To change the error message associated with the exception, implement a\n`message` attribute directly on your custom permission. Otherwise the\n`default_detail` attribute from `PermissionDenied` will be used. Similarly, to\nchange the code identifier associated with the exception, implement a `code`\nattribute directly on your custom permission - otherwise the `default_code`\nattribute from `PermissionDenied` will be used.\n\nThe following is an example of a permission class that checks the incoming\nrequest's IP address against a blocklist, and denies the request if the IP has\nbeen blocked.\n\nAs well as global permissions, that are run against all incoming requests, you\ncan also create object-level permissions, that are only run against operations\nthat affect a particular object instance. For example:\n\nNote that the generic views will check the appropriate object level\npermissions, but if you're writing your own custom views, you'll need to make\nsure you check the object level permission checks yourself. You can do so by\ncalling `self.check_object_permissions(request, obj)` from the view once you\nhave the object instance. This call will raise an appropriate `APIException`\nif any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions\nfor views that retrieve a single model instance. If you require object-level\nfiltering of list views, you'll need to filter the queryset separately. See\nthe filtering documentation for more details.\n\nREST framework offers three different methods to customize access restrictions\non a case-by-case basis. These apply in different scenarios and have different\neffects and limitations.\n\nThe following table lists the access restriction methods and the level of\ncontrol they offer over which actions.\n\n* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.   \n** The `get_*()` methods have access to the current view and can return\ndifferent Serializer or QuerySet instances based on the request or action.\n\nThe following third party packages are also available.\n\nThe Django REST - Access Policy package provides a way to define complex\naccess rules in declarative policy classes that are attached to view sets or\nfunction-based views. The policies are defined in JSON in a format similar to\nAWS' Identity & Access Management policies.\n\nThe Composed Permissions package provides a simple way to define complex and\nmulti-depth (with logic operators) permission objects, using small and\nreusable components.\n\nThe REST Condition package is another extension for building complex\npermissions in a simple and convenient way. The extension allows you to\ncombine permissions with logical operators.\n\nThe DRY Rest Permissions package provides the ability to define different\npermissions for individual default and custom actions. This package is made\nfor apps with permissions that are derived from relationships defined in the\napp's data model. It also supports permission checks being returned to a\nclient app through the API's serializer. Additionally it supports adding\npermissions to the default and custom list actions to restrict the data they\nretrieve per user.\n\nThe Django Rest Framework Roles package makes it easier to parameterize your\nAPI over multiple types of users.\n\nThe Django REST Framework API Key package provides permissions classes, models\nand helpers to add API key authorization to your API. It can be used to\nauthorize internal or third-party backends and services (i.e. machines) which\ndo not have a user account. API keys are stored securely using Django's\npassword hashing infrastructure, and they can be viewed, edited and revoked at\nanytime in the Django admin.\n\nThe Django Rest Framework Role Filters package provides simple filtering over\nmultiple types of roles.\n\nThe Django Rest Framework PSQ package is an extension that gives support for\nhaving action-based permission_classes, serializer_class, and queryset\ndependent on permission-based rules.\n\npermissions.py\n\n"}, {"name": "IsAuthenticated", "path": "api-guide/permissions/index#isauthenticated", "type": "Ref: Permissions", "text": "\nAuthentication or identification by itself is not usually sufficient to gain\naccess to information or code. For that, the entity requesting access must\nhave authorization.\n\n\u2014 Apple Developer Documentation\n\nTogether with authentication and throttling, permissions determine whether a\nrequest should be granted or denied access.\n\nPermission checks are always run at the very start of the view, before any\nother code is allowed to proceed. Permission checks will typically use the\nauthentication information in the `request.user` and `request.auth` properties\nto determine if the incoming request should be permitted.\n\nPermissions are used to grant or deny access for different classes of users to\ndifferent parts of the API.\n\nThe simplest style of permission would be to allow access to any authenticated\nuser, and deny access to any unauthenticated user. This corresponds to the\n`IsAuthenticated` class in REST framework.\n\nA slightly less strict style of permission would be to allow full access to\nauthenticated users, but allow read-only access to unauthenticated users. This\ncorresponds to the `IsAuthenticatedOrReadOnly` class in REST framework.\n\nPermissions in REST framework are always defined as a list of permission\nclasses.\n\nBefore running the main body of the view each permission in the list is\nchecked. If any permission check fails an `exceptions.PermissionDenied` or\n`exceptions.NotAuthenticated` exception will be raised, and the main body of\nthe view will not run.\n\nWhen the permissions checks fail either a \"403 Forbidden\" or a \"401\nUnauthorized\" response will be returned, according to the following rules:\n\nREST framework permissions also support object-level permissioning. Object\nlevel permissions are used to determine if a user should be allowed to act on\na particular object, which will typically be a model instance.\n\nObject level permissions are run by REST framework's generic views when\n`.get_object()` is called. As with view level permissions, an\n`exceptions.PermissionDenied` exception will be raised if the user is not\nallowed to act on the given object.\n\nIf you're writing your own views and want to enforce object level permissions,\nor if you override the `get_object` method on a generic view, then you'll need\nto explicitly call the `.check_object_permissions(request, obj)` method on the\nview at the point at which you've retrieved the object.\n\nThis will either raise a `PermissionDenied` or `NotAuthenticated` exception,\nor simply return if the view has the appropriate permissions.\n\nFor example:\n\nNote: With the exception of `DjangoObjectPermissions`, the provided permission\nclasses in `rest_framework.permissions` do not implement the methods necessary\nto check object permissions.\n\nIf you wish to use the provided permission classes in order to check object\npermissions, you must subclass them and implement the\n`has_object_permission()` method described in the Custom permissions section\n(below).\n\nFor performance reasons the generic views will not automatically apply object\nlevel permissions to each instance in a queryset when returning a list of\nobjects.\n\nOften when you're using object level permissions you'll also want to filter\nthe queryset appropriately, to ensure that users only have visibility onto\ninstances that they are permitted to view.\n\nBecause the `get_object()` method is not called, object level permissions from\nthe `has_object_permission()` method are not applied when creating objects. In\norder to restrict object creation you need to implement the permission check\neither in your Serializer class or override the `perform_create()` method of\nyour ViewSet class.\n\nThe default permission policy may be set globally, using the\n`DEFAULT_PERMISSION_CLASSES` setting. For example.\n\nIf not specified, this setting defaults to allowing unrestricted access:\n\nYou can also set the authentication policy on a per-view, or per-viewset\nbasis, using the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nNote: when you set new permission classes via the class attribute or\ndecorators you're telling the view to ignore the default list set in the\nsettings.py file.\n\nProvided they inherit from `rest_framework.permissions.BasePermission`,\npermissions can be composed using standard Python bitwise operators. For\nexample, `IsAuthenticatedOrReadOnly` could be written:\n\nNote: it supports & (and), | (or) and ~ (not).\n\nThe `AllowAny` permission class will allow unrestricted access, regardless of\nif the request was authenticated or unauthenticated.\n\nThis permission is not strictly required, since you can achieve the same\nresult by using an empty list or tuple for the permissions setting, but you\nmay find it useful to specify this class because it makes the intention\nexplicit.\n\nThe `IsAuthenticated` permission class will deny permission to any\nunauthenticated user, and allow permission otherwise.\n\nThis permission is suitable if you want your API to only be accessible to\nregistered users.\n\nThe `IsAdminUser` permission class will deny permission to any user, unless\n`user.is_staff` is `True` in which case permission will be allowed.\n\nThis permission is suitable if you want your API to only be accessible to a\nsubset of trusted administrators.\n\nThe `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any\nrequest. Requests for unauthorised users will only be permitted if the request\nmethod is one of the \"safe\" methods; `GET`, `HEAD` or `OPTIONS`.\n\nThis permission is suitable if you want to your API to allow read permissions\nto anonymous users, and only allow write permissions to authenticated users.\n\nThis permission class ties into Django's standard `django.contrib.auth` model\npermissions. This permission must only be applied to views that have a\n`.queryset` property or `get_queryset()` method. Authorization will only be\ngranted if the user is authenticated and has the relevant model permissions\nassigned.\n\nThe default behaviour can also be overridden to support custom model\npermissions. For example, you might want to include a `view` model permission\nfor `GET` requests.\n\nTo use custom model permissions, override `DjangoModelPermissions` and set the\n`.perms_map` property. Refer to the source code for details.\n\nSimilar to `DjangoModelPermissions`, but also allows unauthenticated users to\nhave read-only access to the API.\n\nThis permission class ties into Django's standard object permissions framework\nthat allows per-object permissions on models. In order to use this permission\nclass, you'll also need to add a permission backend that supports object-level\npermissions, such as django-guardian.\n\nAs with `DjangoModelPermissions`, this permission must only be applied to\nviews that have a `.queryset` property or `.get_queryset()` method.\nAuthorization will only be granted if the user is authenticated and has the\nrelevant per-object permissions and relevant model permissions assigned.\n\nNote that `DjangoObjectPermissions` does not require the `django-guardian`\npackage, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by\noverriding `DjangoObjectPermissions` and setting the `.perms_map` property.\nRefer to the source code for details.\n\nNote: If you need object level `view` permissions for `GET`, `HEAD` and\n`OPTIONS` requests and are using django-guardian for your object-level\npermissions backend, you'll want to consider using the\n`DjangoObjectPermissionsFilter` class provided by the `djangorestframework-\nguardian` package. It ensures that list endpoints only return results\nincluding objects for which the user has appropriate view permissions.\n\nTo implement a custom permission, override `BasePermission` and implement\neither, or both, of the following methods:\n\nThe methods should return `True` if the request should be granted access, and\n`False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you\nshould check the request method against the constant `SAFE_METHODS`, which is\na tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\nNote: The instance-level `has_object_permission` method will only be called if\nthe view-level `has_permission` checks have already passed. Also note that in\norder for the instance-level checks to run, the view code should explicitly\ncall `.check_object_permissions(request, obj)`. If you are using the generic\nviews then this will be handled for you by default. (Function-based views will\nneed to check object permissions explicitly, raising `PermissionDenied` on\nfailure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test\nfails. To change the error message associated with the exception, implement a\n`message` attribute directly on your custom permission. Otherwise the\n`default_detail` attribute from `PermissionDenied` will be used. Similarly, to\nchange the code identifier associated with the exception, implement a `code`\nattribute directly on your custom permission - otherwise the `default_code`\nattribute from `PermissionDenied` will be used.\n\nThe following is an example of a permission class that checks the incoming\nrequest's IP address against a blocklist, and denies the request if the IP has\nbeen blocked.\n\nAs well as global permissions, that are run against all incoming requests, you\ncan also create object-level permissions, that are only run against operations\nthat affect a particular object instance. For example:\n\nNote that the generic views will check the appropriate object level\npermissions, but if you're writing your own custom views, you'll need to make\nsure you check the object level permission checks yourself. You can do so by\ncalling `self.check_object_permissions(request, obj)` from the view once you\nhave the object instance. This call will raise an appropriate `APIException`\nif any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions\nfor views that retrieve a single model instance. If you require object-level\nfiltering of list views, you'll need to filter the queryset separately. See\nthe filtering documentation for more details.\n\nREST framework offers three different methods to customize access restrictions\non a case-by-case basis. These apply in different scenarios and have different\neffects and limitations.\n\nThe following table lists the access restriction methods and the level of\ncontrol they offer over which actions.\n\n* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.   \n** The `get_*()` methods have access to the current view and can return\ndifferent Serializer or QuerySet instances based on the request or action.\n\nThe following third party packages are also available.\n\nThe Django REST - Access Policy package provides a way to define complex\naccess rules in declarative policy classes that are attached to view sets or\nfunction-based views. The policies are defined in JSON in a format similar to\nAWS' Identity & Access Management policies.\n\nThe Composed Permissions package provides a simple way to define complex and\nmulti-depth (with logic operators) permission objects, using small and\nreusable components.\n\nThe REST Condition package is another extension for building complex\npermissions in a simple and convenient way. The extension allows you to\ncombine permissions with logical operators.\n\nThe DRY Rest Permissions package provides the ability to define different\npermissions for individual default and custom actions. This package is made\nfor apps with permissions that are derived from relationships defined in the\napp's data model. It also supports permission checks being returned to a\nclient app through the API's serializer. Additionally it supports adding\npermissions to the default and custom list actions to restrict the data they\nretrieve per user.\n\nThe Django Rest Framework Roles package makes it easier to parameterize your\nAPI over multiple types of users.\n\nThe Django REST Framework API Key package provides permissions classes, models\nand helpers to add API key authorization to your API. It can be used to\nauthorize internal or third-party backends and services (i.e. machines) which\ndo not have a user account. API keys are stored securely using Django's\npassword hashing infrastructure, and they can be viewed, edited and revoked at\nanytime in the Django admin.\n\nThe Django Rest Framework Role Filters package provides simple filtering over\nmultiple types of roles.\n\nThe Django Rest Framework PSQ package is an extension that gives support for\nhaving action-based permission_classes, serializer_class, and queryset\ndependent on permission-based rules.\n\npermissions.py\n\n"}, {"name": "IsAuthenticatedOrReadOnly", "path": "api-guide/permissions/index#isauthenticatedorreadonly", "type": "Ref: Permissions", "text": "\nAuthentication or identification by itself is not usually sufficient to gain\naccess to information or code. For that, the entity requesting access must\nhave authorization.\n\n\u2014 Apple Developer Documentation\n\nTogether with authentication and throttling, permissions determine whether a\nrequest should be granted or denied access.\n\nPermission checks are always run at the very start of the view, before any\nother code is allowed to proceed. Permission checks will typically use the\nauthentication information in the `request.user` and `request.auth` properties\nto determine if the incoming request should be permitted.\n\nPermissions are used to grant or deny access for different classes of users to\ndifferent parts of the API.\n\nThe simplest style of permission would be to allow access to any authenticated\nuser, and deny access to any unauthenticated user. This corresponds to the\n`IsAuthenticated` class in REST framework.\n\nA slightly less strict style of permission would be to allow full access to\nauthenticated users, but allow read-only access to unauthenticated users. This\ncorresponds to the `IsAuthenticatedOrReadOnly` class in REST framework.\n\nPermissions in REST framework are always defined as a list of permission\nclasses.\n\nBefore running the main body of the view each permission in the list is\nchecked. If any permission check fails an `exceptions.PermissionDenied` or\n`exceptions.NotAuthenticated` exception will be raised, and the main body of\nthe view will not run.\n\nWhen the permissions checks fail either a \"403 Forbidden\" or a \"401\nUnauthorized\" response will be returned, according to the following rules:\n\nREST framework permissions also support object-level permissioning. Object\nlevel permissions are used to determine if a user should be allowed to act on\na particular object, which will typically be a model instance.\n\nObject level permissions are run by REST framework's generic views when\n`.get_object()` is called. As with view level permissions, an\n`exceptions.PermissionDenied` exception will be raised if the user is not\nallowed to act on the given object.\n\nIf you're writing your own views and want to enforce object level permissions,\nor if you override the `get_object` method on a generic view, then you'll need\nto explicitly call the `.check_object_permissions(request, obj)` method on the\nview at the point at which you've retrieved the object.\n\nThis will either raise a `PermissionDenied` or `NotAuthenticated` exception,\nor simply return if the view has the appropriate permissions.\n\nFor example:\n\nNote: With the exception of `DjangoObjectPermissions`, the provided permission\nclasses in `rest_framework.permissions` do not implement the methods necessary\nto check object permissions.\n\nIf you wish to use the provided permission classes in order to check object\npermissions, you must subclass them and implement the\n`has_object_permission()` method described in the Custom permissions section\n(below).\n\nFor performance reasons the generic views will not automatically apply object\nlevel permissions to each instance in a queryset when returning a list of\nobjects.\n\nOften when you're using object level permissions you'll also want to filter\nthe queryset appropriately, to ensure that users only have visibility onto\ninstances that they are permitted to view.\n\nBecause the `get_object()` method is not called, object level permissions from\nthe `has_object_permission()` method are not applied when creating objects. In\norder to restrict object creation you need to implement the permission check\neither in your Serializer class or override the `perform_create()` method of\nyour ViewSet class.\n\nThe default permission policy may be set globally, using the\n`DEFAULT_PERMISSION_CLASSES` setting. For example.\n\nIf not specified, this setting defaults to allowing unrestricted access:\n\nYou can also set the authentication policy on a per-view, or per-viewset\nbasis, using the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nNote: when you set new permission classes via the class attribute or\ndecorators you're telling the view to ignore the default list set in the\nsettings.py file.\n\nProvided they inherit from `rest_framework.permissions.BasePermission`,\npermissions can be composed using standard Python bitwise operators. For\nexample, `IsAuthenticatedOrReadOnly` could be written:\n\nNote: it supports & (and), | (or) and ~ (not).\n\nThe `AllowAny` permission class will allow unrestricted access, regardless of\nif the request was authenticated or unauthenticated.\n\nThis permission is not strictly required, since you can achieve the same\nresult by using an empty list or tuple for the permissions setting, but you\nmay find it useful to specify this class because it makes the intention\nexplicit.\n\nThe `IsAuthenticated` permission class will deny permission to any\nunauthenticated user, and allow permission otherwise.\n\nThis permission is suitable if you want your API to only be accessible to\nregistered users.\n\nThe `IsAdminUser` permission class will deny permission to any user, unless\n`user.is_staff` is `True` in which case permission will be allowed.\n\nThis permission is suitable if you want your API to only be accessible to a\nsubset of trusted administrators.\n\nThe `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any\nrequest. Requests for unauthorised users will only be permitted if the request\nmethod is one of the \"safe\" methods; `GET`, `HEAD` or `OPTIONS`.\n\nThis permission is suitable if you want to your API to allow read permissions\nto anonymous users, and only allow write permissions to authenticated users.\n\nThis permission class ties into Django's standard `django.contrib.auth` model\npermissions. This permission must only be applied to views that have a\n`.queryset` property or `get_queryset()` method. Authorization will only be\ngranted if the user is authenticated and has the relevant model permissions\nassigned.\n\nThe default behaviour can also be overridden to support custom model\npermissions. For example, you might want to include a `view` model permission\nfor `GET` requests.\n\nTo use custom model permissions, override `DjangoModelPermissions` and set the\n`.perms_map` property. Refer to the source code for details.\n\nSimilar to `DjangoModelPermissions`, but also allows unauthenticated users to\nhave read-only access to the API.\n\nThis permission class ties into Django's standard object permissions framework\nthat allows per-object permissions on models. In order to use this permission\nclass, you'll also need to add a permission backend that supports object-level\npermissions, such as django-guardian.\n\nAs with `DjangoModelPermissions`, this permission must only be applied to\nviews that have a `.queryset` property or `.get_queryset()` method.\nAuthorization will only be granted if the user is authenticated and has the\nrelevant per-object permissions and relevant model permissions assigned.\n\nNote that `DjangoObjectPermissions` does not require the `django-guardian`\npackage, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by\noverriding `DjangoObjectPermissions` and setting the `.perms_map` property.\nRefer to the source code for details.\n\nNote: If you need object level `view` permissions for `GET`, `HEAD` and\n`OPTIONS` requests and are using django-guardian for your object-level\npermissions backend, you'll want to consider using the\n`DjangoObjectPermissionsFilter` class provided by the `djangorestframework-\nguardian` package. It ensures that list endpoints only return results\nincluding objects for which the user has appropriate view permissions.\n\nTo implement a custom permission, override `BasePermission` and implement\neither, or both, of the following methods:\n\nThe methods should return `True` if the request should be granted access, and\n`False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you\nshould check the request method against the constant `SAFE_METHODS`, which is\na tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\nNote: The instance-level `has_object_permission` method will only be called if\nthe view-level `has_permission` checks have already passed. Also note that in\norder for the instance-level checks to run, the view code should explicitly\ncall `.check_object_permissions(request, obj)`. If you are using the generic\nviews then this will be handled for you by default. (Function-based views will\nneed to check object permissions explicitly, raising `PermissionDenied` on\nfailure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test\nfails. To change the error message associated with the exception, implement a\n`message` attribute directly on your custom permission. Otherwise the\n`default_detail` attribute from `PermissionDenied` will be used. Similarly, to\nchange the code identifier associated with the exception, implement a `code`\nattribute directly on your custom permission - otherwise the `default_code`\nattribute from `PermissionDenied` will be used.\n\nThe following is an example of a permission class that checks the incoming\nrequest's IP address against a blocklist, and denies the request if the IP has\nbeen blocked.\n\nAs well as global permissions, that are run against all incoming requests, you\ncan also create object-level permissions, that are only run against operations\nthat affect a particular object instance. For example:\n\nNote that the generic views will check the appropriate object level\npermissions, but if you're writing your own custom views, you'll need to make\nsure you check the object level permission checks yourself. You can do so by\ncalling `self.check_object_permissions(request, obj)` from the view once you\nhave the object instance. This call will raise an appropriate `APIException`\nif any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions\nfor views that retrieve a single model instance. If you require object-level\nfiltering of list views, you'll need to filter the queryset separately. See\nthe filtering documentation for more details.\n\nREST framework offers three different methods to customize access restrictions\non a case-by-case basis. These apply in different scenarios and have different\neffects and limitations.\n\nThe following table lists the access restriction methods and the level of\ncontrol they offer over which actions.\n\n* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.   \n** The `get_*()` methods have access to the current view and can return\ndifferent Serializer or QuerySet instances based on the request or action.\n\nThe following third party packages are also available.\n\nThe Django REST - Access Policy package provides a way to define complex\naccess rules in declarative policy classes that are attached to view sets or\nfunction-based views. The policies are defined in JSON in a format similar to\nAWS' Identity & Access Management policies.\n\nThe Composed Permissions package provides a simple way to define complex and\nmulti-depth (with logic operators) permission objects, using small and\nreusable components.\n\nThe REST Condition package is another extension for building complex\npermissions in a simple and convenient way. The extension allows you to\ncombine permissions with logical operators.\n\nThe DRY Rest Permissions package provides the ability to define different\npermissions for individual default and custom actions. This package is made\nfor apps with permissions that are derived from relationships defined in the\napp's data model. It also supports permission checks being returned to a\nclient app through the API's serializer. Additionally it supports adding\npermissions to the default and custom list actions to restrict the data they\nretrieve per user.\n\nThe Django Rest Framework Roles package makes it easier to parameterize your\nAPI over multiple types of users.\n\nThe Django REST Framework API Key package provides permissions classes, models\nand helpers to add API key authorization to your API. It can be used to\nauthorize internal or third-party backends and services (i.e. machines) which\ndo not have a user account. API keys are stored securely using Django's\npassword hashing infrastructure, and they can be viewed, edited and revoked at\nanytime in the Django admin.\n\nThe Django Rest Framework Role Filters package provides simple filtering over\nmultiple types of roles.\n\nThe Django Rest Framework PSQ package is an extension that gives support for\nhaving action-based permission_classes, serializer_class, and queryset\ndependent on permission-based rules.\n\npermissions.py\n\n"}, {"name": "JSONField", "path": "api-guide/fields/index#jsonfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "JSONParser", "path": "api-guide/parsers/index#jsonparser", "type": "Ref: Parsers", "text": "\nMachine interacting web services tend to use more structured formats for\nsending data than form-encoded, since they're sending more complex data than\nsimple forms\n\n\u2014 Malcom Tredinnick, Django developers group\n\nREST framework includes a number of built in Parser classes, that allow you to\naccept requests with various media types. There is also support for defining\nyour own custom parsers, which gives you the flexibility to design the media\ntypes that your API accepts.\n\nThe set of valid parsers for a view is always defined as a list of classes.\nWhen `request.data` is accessed, REST framework will examine the `Content-\nType` header on the incoming request, and determine which parser to use to\nparse the request content.\n\nNote: When developing client applications always remember to make sure you're\nsetting the `Content-Type` header when sending data in an HTTP request.\n\nIf you don't set the content type, most clients will default to using\n`'application/x-www-form-urlencoded'`, which may not be what you wanted.\n\nAs an example, if you are sending `json` encoded data using jQuery with the\n.ajax() method, you should make sure to include the `contentType:\n'application/json'` setting.\n\nThe default set of parsers may be set globally, using the\n`DEFAULT_PARSER_CLASSES` setting. For example, the following settings would\nallow only requests with `JSON` content, instead of the default of JSON or\nform data.\n\nYou can also set the parsers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nParses `JSON` request content. `request.data` will be populated with a\ndictionary of data.\n\n.media_type: `application/json`\n\nParses HTML form content. `request.data` will be populated with a `QueryDict`\nof data.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `application/x-www-form-urlencoded`\n\nParses multipart HTML form content, which supports file uploads. Both\n`request.data` will be populated with a `QueryDict`.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `multipart/form-data`\n\nParses raw file upload content. The `request.data` property will be a\ndictionary with a single key `'file'` containing the uploaded file.\n\nIf the view used with `FileUploadParser` is called with a `filename` URL\nkeyword argument, then that argument will be used as the filename.\n\nIf it is called without a `filename` URL keyword argument, then the client\nmust set the filename in the `Content-Disposition` HTTP header. For example\n`Content-Disposition: attachment; filename=upload.jpg`.\n\n.media_type: `*/*`\n\nTo implement a custom parser, you should override `BaseParser`, set the\n`.media_type` property, and implement the `.parse(self, stream, media_type,\nparser_context)` method.\n\nThe method should return the data that will be used to populate the\n`request.data` property.\n\nThe arguments passed to `.parse()` are:\n\nA stream-like object representing the body of the request.\n\nOptional. If provided, this is the media type of the incoming request content.\n\nDepending on the request's `Content-Type:` header, this may be more specific\nthan the renderer's `media_type` attribute, and may include media type\nparameters. For example `\"text/plain; charset=utf-8\"`.\n\nOptional. If supplied, this argument will be a dictionary containing any\nadditional context that may be required to parse the request content.\n\nBy default this will include the following keys: `view`, `request`, `args`,\n`kwargs`.\n\nThe following is an example plaintext parser that will populate the\n`request.data` property with a string representing the body of the request.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nparsers.py\n\n"}, {"name": "JSONRenderer", "path": "api-guide/renderers/index#jsonrenderer", "type": "Ref: Renderers", "text": "\nBefore a TemplateResponse instance can be returned to the client, it must be\nrendered. The rendering process takes the intermediate representation of\ntemplate and context, and turns it into the final byte stream that can be\nserved to the client.\n\n\u2014 Django documentation\n\nREST framework includes a number of built in Renderer classes, that allow you\nto return responses with various media types. There is also support for\ndefining your own custom renderers, which gives you the flexibility to design\nyour own media types.\n\nThe set of valid renderers for a view is always defined as a list of classes.\nWhen a view is entered REST framework will perform content negotiation on the\nincoming request, and determine the most appropriate renderer to satisfy the\nrequest.\n\nThe basic process of content negotiation involves examining the request's\n`Accept` header, to determine which media types it expects in the response.\nOptionally, format suffixes on the URL may be used to explicitly request a\nparticular representation. For example the URL\n`http://example.com/api/users_count.json` might be an endpoint that always\nreturns JSON data.\n\nFor more information see the documentation on content negotiation.\n\nThe default set of renderers may be set globally, using the\n`DEFAULT_RENDERER_CLASSES` setting. For example, the following settings would\nuse `JSON` as the main media type and also include the self describing API.\n\nYou can also set the renderers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nIt's important when specifying the renderer classes for your API to think\nabout what priority you want to assign to each media type. If a client\nunderspecifies the representations it can accept, such as sending an `Accept:\n*/*` header, or not including an `Accept` header at all, then REST framework\nwill select the first renderer in the list to use for the response.\n\nFor example if your API serves JSON responses and the HTML browsable API, you\nmight want to make `JSONRenderer` your default renderer, in order to send\n`JSON` responses to clients that do not specify an `Accept` header.\n\nIf your API includes views that can serve both regular webpages and API\nresponses depending on the request, then you might consider making\n`TemplateHTMLRenderer` your default renderer, in order to play nicely with\nolder browsers that send broken accept headers.\n\nRenders the request data into `JSON`, using utf-8 encoding.\n\nNote that the default style is to include unicode characters, and render the\nresponse using a compact style with no unnecessary whitespace:\n\nThe client may additionally include an `'indent'` media type parameter, in\nwhich case the returned `JSON` will be indented. For example `Accept:\napplication/json; indent=4`.\n\nThe default JSON encoding style can be altered using the `UNICODE_JSON` and\n`COMPACT_JSON` settings keys.\n\n.media_type: `application/json`\n\n.format: `'json'`\n\n.charset: `None`\n\nRenders data to HTML, using Django's standard template rendering. Unlike other\nrenderers, the data passed to the `Response` does not need to be serialized.\nAlso, unlike other renderers, you may want to include a `template_name`\nargument when creating the `Response`.\n\nThe TemplateHTMLRenderer will create a `RequestContext`, using the\n`response.data` as the context dict, and determine a template name to use to\nrender the context.\n\nNote: When used with a view that makes use of a serializer the `Response` sent\nfor rendering may not be a dictionary and will need to be wrapped in a dict\nbefore returning to allow the TemplateHTMLRenderer to render it. For example:\n\nThe template name is determined by (in order of preference):\n\nAn example of a view that uses `TemplateHTMLRenderer`:\n\nYou can use `TemplateHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\nIf you're building websites that use `TemplateHTMLRenderer` along with other\nrenderer classes, you should consider listing `TemplateHTMLRenderer` as the\nfirst class in the `renderer_classes` list, so that it will be prioritised\nfirst even for browsers that send poorly formed `ACCEPT:` headers.\n\nSee the HTML & Forms Topic Page for further examples of `TemplateHTMLRenderer`\nusage.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `StaticHTMLRenderer`\n\nA simple renderer that simply returns pre-rendered HTML. Unlike other\nrenderers, the data passed to the response object should be a string\nrepresenting the content to be returned.\n\nAn example of a view that uses `StaticHTMLRenderer`:\n\nYou can use `StaticHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `TemplateHTMLRenderer`\n\nRenders data into HTML for the Browsable API:\n\nThis renderer will determine which other renderer would have been given\nhighest priority, and use that to display an API style response within the\nHTML page.\n\n.media_type: `text/html`\n\n.format: `'api'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/api.html'`\n\nBy default the response content will be rendered with the highest priority\nrenderer apart from `BrowsableAPIRenderer`. If you need to customize this\nbehavior, for example to use HTML as the default return format, but use JSON\nin the browsable API, you can do so by overriding the `get_default_renderer()`\nmethod. For example:\n\nRenders data into HTML for an admin-like display:\n\nThis renderer is suitable for CRUD-style web APIs that should also present a\nuser-friendly interface for managing the data.\n\nNote that views that have nested or list serializers for their input won't\nwork well with the `AdminRenderer`, as the HTML forms are unable to properly\nsupport them.\n\nNote: The `AdminRenderer` is only able to include links to detail pages when a\nproperly configured `URL_FIELD_NAME` (`url` by default) attribute is present\nin the data. For `HyperlinkedModelSerializer` this will be the case, but for\n`ModelSerializer` or plain `Serializer` classes you'll need to make sure to\ninclude the field explicitly. For example here we use models\n`get_absolute_url` method:\n\n.media_type: `text/html`\n\n.format: `'admin'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/admin.html'`\n\nRenders data returned by a serializer into an HTML form. The output of this\nrenderer does not include the enclosing `<form>` tags, a hidden CSRF input or\nany submit buttons.\n\nThis renderer is not intended to be used directly, but can instead be used in\ntemplates by passing a serializer instance to the `render_form` template tag.\n\nFor more information see the HTML & Forms documentation.\n\n.media_type: `text/html`\n\n.format: `'form'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/horizontal/form.html'`\n\nThis renderer is used for rendering HTML multipart form data. It is not\nsuitable as a response renderer, but is instead used for creating test\nrequests, using REST framework's test client and test request factory.\n\n.media_type: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n.format: `'multipart'`\n\n.charset: `utf-8`\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the\n`.media_type` and `.format` properties, and implement the `.render(self, data,\nmedia_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the\nHTTP response.\n\nThe arguments passed to the `.render()` method are:\n\nThe request data, as set by the `Response()` instantiation.\n\nOptional. If provided, this is the accepted media type, as determined by the\ncontent negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the\nrenderer's `media_type` attribute, and may include media type parameters. For\nexample `\"application/json; nested=true\"`.\n\nOptional. If provided, this is a dictionary of contextual information provided\nby the view.\n\nBy default this will include the following keys: `view`, `request`,\n`response`, `args`, `kwargs`.\n\nThe following is an example plaintext renderer that will return a response\nwith the `data` parameter as the content of the response.\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To\nuse a different encoding, set the `charset` attribute on the renderer.\n\nNote that if a renderer class returns a unicode string, then the response\ncontent will be coerced into a bytestring by the `Response` class, with the\n`charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you\nshould set a charset value of `None`, which will ensure the `Content-Type`\nheader of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to\n`'binary'`. Doing so will also ensure that the browsable API will not attempt\nto display the binary content as a string.\n\nYou can do some pretty flexible things using REST framework's renderers. Some\nexamples...\n\nIn some cases you might want your view to use different serialization styles\ndepending on the accepted media type. If you need to do this you can access\n`request.accepted_renderer` to determine the negotiated renderer that will be\nused for the response.\n\nFor example:\n\nIn some cases you might want a renderer to serve a range of media types. In\nthis case you can underspecify the media types it should respond to, by using\na `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify\nthe media type explicitly when you return the response, using the\n`content_type` attribute. For example:\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked\nrelations may be sufficient. If you want to fully embrace RESTful design and\nHATEOAS you'll need to consider the design and usage of your media types in\nmore detail.\n\nIn the words of Roy Fielding, \"A REST API should spend almost all of its\ndescriptive effort in defining the media type(s) used for representing\nresources and driving application state, or in defining extended relation\nnames and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom\napplication/vnd.github+json media type, and Mike Amundsen's IANA approved\napplication/vnd.collection+json JSON-based hypermedia.\n\nTypically a renderer will behave the same regardless of if it's dealing with a\nregular response, or with a response caused by an exception being raised, such\nas an `Http404` or `PermissionDenied` exception, or a subclass of\n`APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer`\nand an exception is raised, the behavior is slightly different, and mirrors\nDjango's default handling of error views.\n\nExceptions raised and handled by an HTML renderer will attempt to render using\none of the following methods, by order of precedence.\n\nTemplates will render with a `RequestContext` which includes the `status_code`\nand `details` keys.\n\nNote: If `DEBUG=True`, Django's standard traceback error page will be\ndisplayed instead of rendering the HTTP status code and text.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST framework JSONP provides JSONP rendering support. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nWarning: If you require cross-domain AJAX requests, you should generally be\nusing the more modern approach of CORS as an alternative to `JSONP`. See the\nCORS documentation for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is only appropriate\nfor globally readable API endpoints, where `GET` requests are unauthenticated\nand do not require any user permissions.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\nXLSX is the world's most popular binary spreadsheet format. Tim Allen of The\nWharton School maintains drf-renderer-xlsx, which renders an endpoint as an\nXLSX spreadsheet using OpenPyXL, and allows the client to download it.\nSpreadsheets can be styled on a per-view basis.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nTo avoid having a file streamed without a filename (which the browser will\noften default to the filename \"download\", with no extension), we need to use a\nmixin to override the `Content-Disposition` header. If no filename is\nprovided, it will default to `export.xlsx`. For example:\n\nComma-separated values are a plain-text tabular data format, that can be\neasily imported into spreadsheet applications. Mjumbe Poe maintains the\ndjangorestframework-csv package which provides CSV renderer support for REST\nframework.\n\nUltraJSON is an optimized C JSON encoder which can give significantly faster\nJSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now\nunmaintained drf-ujson-renderer, which implements JSON rendering using the\nUJSON package.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nDjango REST Pandas provides a serializer and renderers that support additional\ndata processing and output via the Pandas DataFrame API. Django REST Pandas\nincludes renderers for Pandas-style CSV files, Excel workbooks (both `.xls`\nand `.xlsx`), and a number of other formats. It is maintained by S. Andrew\nSheppard as part of the wq Project.\n\nRest Framework Latex provides a renderer that outputs PDFs using Laulatex. It\nis maintained by Pebble (S/F Software).\n\nrenderers.py\n\n"}, {"name": "LimitOffsetPagination", "path": "api-guide/pagination/index#limitoffsetpagination", "type": "Ref: Pagination", "text": "\nDjango provides a few classes that help you manage paginated data \u2013 that is,\ndata that\u2019s split across several pages, with \u201cPrevious/Next\u201d links.\n\n\u2014 Django documentation\n\nREST framework includes support for customizable pagination styles. This\nallows you to modify how large result sets are split into individual pages of\ndata.\n\nThe pagination API can support either:\n\nThe built-in styles currently all use links included as part of the content of\nthe response. This style is more accessible when using the browsable API.\n\nPagination is only performed automatically if you're using the generic views\nor viewsets. If you're using a regular `APIView`, you'll need to call into the\npagination API yourself to ensure you return a paginated response. See the\nsource code for the `mixins.ListModelMixin` and `generics.GenericAPIView`\nclasses for an example.\n\nPagination can be turned off by setting the pagination class to `None`.\n\nThe pagination style may be set globally, using the `DEFAULT_PAGINATION_CLASS`\nand `PAGE_SIZE` setting keys. For example, to use the built-in limit/offset\npagination, you would do something like this:\n\nNote that you need to set both the pagination class, and the page size that\nshould be used. Both `DEFAULT_PAGINATION_CLASS` and `PAGE_SIZE` are `None` by\ndefault.\n\nYou can also set the pagination class on an individual view by using the\n`pagination_class` attribute. Typically you'll want to use the same pagination\nstyle throughout your API, although you might want to vary individual aspects\nof the pagination, such as default or maximum page size, on a per-view basis.\n\nIf you want to modify particular aspects of the pagination style, you'll want\nto override one of the pagination classes, and set the attributes that you\nwant to change.\n\nYou can then apply your new style to a view using the `pagination_class`\nattribute:\n\nOr apply the style globally, using the `DEFAULT_PAGINATION_CLASS` settings\nkey. For example:\n\nThis pagination style accepts a single number page number in the request query\nparameters.\n\nRequest:\n\nResponse:\n\nTo enable the `PageNumberPagination` style globally, use the following\nconfiguration, and set the `PAGE_SIZE` as desired:\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `PageNumberPagination` on a per-view basis.\n\nThe `PageNumberPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `PageNumberPagination` class,\nand then enable your custom pagination class as above.\n\nThis pagination style mirrors the syntax used when looking up multiple\ndatabase records. The client includes both a \"limit\" and an \"offset\" query\nparameter. The limit indicates the maximum number of items to return, and is\nequivalent to the `page_size` in other styles. The offset indicates the\nstarting position of the query in relation to the complete set of unpaginated\nitems.\n\nRequest:\n\nResponse:\n\nTo enable the `LimitOffsetPagination` style globally, use the following\nconfiguration:\n\nOptionally, you may also set a `PAGE_SIZE` key. If the `PAGE_SIZE` parameter\nis also used then the `limit` query parameter will be optional, and may be\nomitted by the client.\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `LimitOffsetPagination` on a per-view basis.\n\nThe `LimitOffsetPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `LimitOffsetPagination` class,\nand then enable your custom pagination class as above.\n\nThe cursor-based pagination presents an opaque \"cursor\" indicator that the\nclient may use to page through the result set. This pagination style only\npresents forward and reverse controls, and does not allow the client to\nnavigate to arbitrary positions.\n\nCursor based pagination requires that there is a unique, unchanging ordering\nof items in the result set. This ordering might typically be a creation\ntimestamp on the records, as this presents a consistent ordering to paginate\nagainst.\n\nCursor based pagination is more complex than other schemes. It also requires\nthat the result set presents a fixed ordering, and does not allow the client\nto arbitrarily index into the result set. However it does provide the\nfollowing benefits:\n\nProper use of cursor based pagination requires a little attention to detail.\nYou'll need to think about what ordering you want the scheme to be applied\nagainst. The default is to order by `\"-created\"`. This assumes that there must\nbe a 'created' timestamp field on the model instances, and will present a\n\"timeline\" style paginated view, with the most recently added items first.\n\nYou can modify the ordering by overriding the `'ordering'` attribute on the\npagination class, or by using the `OrderingFilter` filter class together with\n`CursorPagination`. When used with `OrderingFilter` you should strongly\nconsider restricting the fields that the user may order by.\n\nProper usage of cursor pagination should have an ordering field that satisfies\nthe following:\n\nUsing an ordering field that does not satisfy these constraints will generally\nstill work, but you'll be losing some of the benefits of cursor pagination.\n\nFor more technical details on the implementation we use for cursor pagination,\nthe \"Building cursors for the Disqus API\" blog post gives a good overview of\nthe basic approach.\n\nTo enable the `CursorPagination` style globally, use the following\nconfiguration, modifying the `PAGE_SIZE` as desired:\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `CursorPagination` on a per-view basis.\n\nThe `CursorPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `CursorPagination` class, and\nthen enable your custom pagination class as above.\n\nTo create a custom pagination serializer class, you should inherit the\nsubclass `pagination.BasePagination`, override the `paginate_queryset(self,\nqueryset, request, view=None)`, and `get_paginated_response(self, data)`\nmethods:\n\nNote that the `paginate_queryset` method may set state on the pagination\ninstance, that may later be used by the `get_paginated_response` method.\n\nSuppose we want to replace the default pagination output style with a modified\nformat that includes the next and previous links under in a nested 'links'\nkey. We could specify a custom pagination class like so:\n\nWe'd then need to setup the custom class in our configuration:\n\nNote that if you care about how the ordering of keys is displayed in responses\nin the browsable API you might choose to use an `OrderedDict` when\nconstructing the body of paginated responses, but this is optional.\n\nTo have your custom pagination class be used by default, use the\n`DEFAULT_PAGINATION_CLASS` setting:\n\nAPI responses for list endpoints will now include a `Link` header, instead of\nincluding the pagination links as part of the body of the response, for\nexample:\n\nA custom pagination style, using the 'Link' header'\n\nYou can also make the pagination controls available to the schema\nautogeneration that REST framework provides, by implementing a\n`get_schema_fields()` method. This method should have the following signature:\n\n`get_schema_fields(self, view)`\n\nThe method should return a list of `coreapi.Field` instances.\n\nBy default using the pagination classes will cause HTML pagination controls to\nbe displayed in the browsable API. There are two built-in display styles. The\n`PageNumberPagination` and `LimitOffsetPagination` classes display a list of\npage numbers with previous and next controls. The `CursorPagination` class\ndisplays a simpler style that only displays a previous and next control.\n\nYou can override the templates that render the HTML pagination controls. The\ntwo built-in styles are:\n\nProviding a template with either of these paths in a global template directory\nwill override the default rendering for the relevant pagination classes.\n\nAlternatively you can disable HTML pagination controls completely by\nsubclassing on of the existing classes, setting `template = None` as an\nattribute on the class. You'll then need to configure your\n`DEFAULT_PAGINATION_CLASS` settings key to use your custom class as the\ndefault pagination style.\n\nThe low-level API for determining if a pagination class should display the\ncontrols or not is exposed as a `display_page_controls` attribute on the\npagination instance. Custom pagination classes should be set to `True` in the\n`paginate_queryset` method if they require the HTML pagination controls to be\ndisplayed.\n\nThe `.to_html()` and `.get_html_context()` methods may also be overridden in a\ncustom pagination class in order to further customize how the controls are\nrendered.\n\nThe following third party packages are also available.\n\nThe `DRF-extensions` package includes a `PaginateByMaxMixin` mixin class that\nallows your API clients to specify `?page_size=max` to obtain the maximum\nallowed page size.\n\nThe `drf-proxy-pagination` package includes a `ProxyPagination` class which\nallows to choose pagination class with a query parameter.\n\nThe `django-rest-framework-link-header-pagination` package includes a\n`LinkHeaderPagination` class which provides pagination via an HTTP `Link`\nheader as described in Github's developer documentation.\n\npagination.py\n\n"}, {"name": "ListAPIView", "path": "api-guide/generic-views/index#listapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "ListCreateAPIView", "path": "api-guide/generic-views/index#listcreateapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "ListField", "path": "api-guide/fields/index#listfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "ListModelMixin", "path": "api-guide/generic-views/index#listmodelmixin", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "ListSerializer", "path": "api-guide/serializers/index#listserializer", "type": "Ref: Serializers", "text": "\nExpanding the usefulness of the serializers is something that we would like to\naddress. However, it's not a trivial problem, and it will take some serious\ndesign work.\n\n\u2014 Russell Keith-Magee, Django users group\n\nSerializers allow complex data such as querysets and model instances to be\nconverted to native Python datatypes that can then be easily rendered into\n`JSON`, `XML` or other content types. Serializers also provide\ndeserialization, allowing parsed data to be converted back into complex types,\nafter first validating the incoming data.\n\nThe serializers in REST framework work very similarly to Django's `Form` and\n`ModelForm` classes. We provide a `Serializer` class which gives you a\npowerful, generic way to control the output of your responses, as well as a\n`ModelSerializer` class which provides a useful shortcut for creating\nserializers that deal with model instances and querysets.\n\nLet's start by creating a simple object we can use for example purposes:\n\nWe'll declare a serializer that we can use to serialize and deserialize data\nthat corresponds to `Comment` objects.\n\nDeclaring a serializer looks very similar to declaring a form:\n\nWe can now use `CommentSerializer` to serialize a comment, or list of\ncomments. Again, using the `Serializer` class looks a lot like using a `Form`\nclass.\n\nAt this point we've translated the model instance into Python native\ndatatypes. To finalise the serialization process we render the data into\n`json`.\n\nDeserialization is similar. First we parse a stream into Python native\ndatatypes...\n\n...then we restore those native datatypes into a dictionary of validated data.\n\nIf we want to be able to return complete object instances based on the\nvalidated data we need to implement one or both of the `.create()` and\n`.update()` methods. For example:\n\nIf your object instances correspond to Django models you'll also want to\nensure that these methods save the object to the database. For example, if\n`Comment` was a Django model, the methods might look like this:\n\nNow when deserializing data, we can call `.save()` to return an object\ninstance, based on the validated data.\n\nCalling `.save()` will either create a new instance, or update an existing\ninstance, depending on if an existing instance was passed when instantiating\nthe serializer class:\n\nBoth the `.create()` and `.update()` methods are optional. You can implement\neither neither, one, or both of them, depending on the use-case for your\nserializer class.\n\nSometimes you'll want your view code to be able to inject additional data at\nthe point of saving the instance. This additional data might include\ninformation like the current user, the current time, or anything else that is\nnot part of the request data.\n\nYou can do so by including additional keyword arguments when calling\n`.save()`. For example:\n\nAny additional keyword arguments will be included in the `validated_data`\nargument when `.create()` or `.update()` are called.\n\nIn some cases the `.create()` and `.update()` method names may not be\nmeaningful. For example, in a contact form we may not be creating new\ninstances, but instead sending an email or other message.\n\nIn these cases you might instead choose to override `.save()` directly, as\nbeing more readable and meaningful.\n\nFor example:\n\nNote that in the case above we're now having to access the serializer\n`.validated_data` property directly.\n\nWhen deserializing data, you always need to call `is_valid()` before\nattempting to access the validated data, or save an object instance. If any\nvalidation errors occur, the `.errors` property will contain a dictionary\nrepresenting the resulting error messages. For example:\n\nEach key in the dictionary will be the field name, and the values will be\nlists of strings of any error messages corresponding to that field. The\n`non_field_errors` key may also be present, and will list any general\nvalidation errors. The name of the `non_field_errors` key may be customized\nusing the `NON_FIELD_ERRORS_KEY` REST framework setting.\n\nWhen deserializing a list of items, errors will be returned as a list of\ndictionaries representing each of the deserialized items.\n\nThe `.is_valid()` method takes an optional `raise_exception` flag that will\ncause it to raise a `serializers.ValidationError` exception if there are\nvalidation errors.\n\nThese exceptions are automatically dealt with by the default exception handler\nthat REST framework provides, and will return `HTTP 400 Bad Request` responses\nby default.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. These are\nsimilar to the `.clean_<field_name>` methods on Django forms.\n\nThese methods take a single argument, which is the field value that requires\nvalidation.\n\nYour `validate_<field_name>` methods should return the validated value or\nraise a `serializers.ValidationError`. For example:\n\nNote: If your `<field_name>` is declared on your serializer with the parameter\n`required=False` then this validation step will not take place if the field is\nnot included.\n\nTo do any other validation that requires access to multiple fields, add a\nmethod called `.validate()` to your `Serializer` subclass. This method takes a\nsingle argument, which is a dictionary of field values. It should raise a\n`serializers.ValidationError` if necessary, or just return the validated\nvalues. For example:\n\nIndividual fields on a serializer can include validators, by declaring them on\nthe field instance, for example:\n\nSerializer classes can also include reusable validators that are applied to\nthe complete set of field data. These validators are included by declaring\nthem on an inner `Meta` class, like so:\n\nFor more information see the validators documentation.\n\nWhen passing an initial object or queryset to a serializer instance, the\nobject will be made available as `.instance`. If no initial object is passed\nthen the `.instance` attribute will be `None`.\n\nWhen passing data to a serializer instance, the unmodified data will be made\navailable as `.initial_data`. If the `data` keyword argument is not passed\nthen the `.initial_data` attribute will not exist.\n\nBy default, serializers must be passed values for all required fields or they\nwill raise validation errors. You can use the `partial` argument in order to\nallow partial updates.\n\nThe previous examples are fine for dealing with objects that only have simple\ndatatypes, but sometimes we also need to be able to represent more complex\nobjects, where some of the attributes of an object might not be simple\ndatatypes such as strings, dates or integers.\n\nThe `Serializer` class is itself a type of `Field`, and can be used to\nrepresent relationships where one object type is nested inside another.\n\nIf a nested representation may optionally accept the `None` value you should\npass the `required=False` flag to the nested serializer.\n\nSimilarly if a nested representation should be a list of items, you should\npass the `many=True` flag to the nested serializer.\n\nWhen dealing with nested representations that support deserializing the data,\nany errors with nested objects will be nested under the field name of the\nnested object.\n\nSimilarly, the `.validated_data` property will include nested data structures.\n\nIf you're supporting writable nested representations you'll need to write\n`.create()` or `.update()` methods that handle saving multiple objects.\n\nThe following example demonstrates how you might handle creating a user with a\nnested profile object.\n\nFor updates you'll want to think carefully about how to handle updates to\nrelationships. For example if the data for the relationship is `None`, or not\nprovided, which of the following should occur?\n\nHere's an example for an `.update()` method on our previous `UserSerializer`\nclass.\n\nBecause the behavior of nested creates and updates can be ambiguous, and may\nrequire complex dependencies between related models, REST framework 3 requires\nyou to always write these methods explicitly. The default `ModelSerializer`\n`.create()` and `.update()` methods do not include support for writable nested\nrepresentations.\n\nThere are however, third-party packages available such as DRF Writable Nested\nthat support automatic writable nested representations.\n\nAn alternative to saving multiple related instances in the serializer is to\nwrite custom model manager classes that handle creating the correct instances.\n\nFor example, suppose we wanted to ensure that `User` instances and `Profile`\ninstances are always created together as a pair. We might write a custom\nmanager class that looks something like this:\n\nThis manager class now more nicely encapsulates that user instances and\nprofile instances are always created at the same time. Our `.create()` method\non the serializer class can now be re-written to use the new manager method.\n\nFor more details on this approach see the Django documentation on model\nmanagers, and this blogpost on using model and manager classes.\n\nThe `Serializer` class can also handle serializing or deserializing lists of\nobjects.\n\nTo serialize a queryset or list of objects instead of a single object\ninstance, you should pass the `many=True` flag when instantiating the\nserializer. You can then pass a queryset or list of objects to be serialized.\n\nThe default behavior for deserializing multiple objects is to support multiple\nobject creation, but not support multiple object updates. For more information\non how to support or customize either of these cases, see the ListSerializer\ndocumentation below.\n\nThere are some cases where you need to provide extra context to the serializer\nin addition to the object being serialized. One common case is if you're using\na serializer that includes hyperlinked relations, which requires the\nserializer to have access to the current request so that it can properly\ngenerate fully qualified URLs.\n\nYou can provide arbitrary additional context by passing a `context` argument\nwhen instantiating the serializer. For example:\n\nThe context dictionary can be used within any serializer field logic, such as\na custom `.to_representation()` method, by accessing the `self.context`\nattribute.\n\nOften you'll want serializer classes that map closely to Django model\ndefinitions.\n\nThe `ModelSerializer` class provides a shortcut that lets you automatically\ncreate a `Serializer` class with fields that correspond to the Model fields.\n\nThe `ModelSerializer` class is the same as a regular `Serializer` class,\nexcept that:\n\nDeclaring a `ModelSerializer` looks like this:\n\nBy default, all the model fields on the class will be mapped to a\ncorresponding serializer fields.\n\nAny relationships such as foreign keys on the model will be mapped to\n`PrimaryKeyRelatedField`. Reverse relationships are not included by default\nunless explicitly included as specified in the serializer relations\ndocumentation.\n\nSerializer classes generate helpful verbose representation strings, that allow\nyou to fully inspect the state of their fields. This is particularly useful\nwhen working with `ModelSerializers` where you want to determine what set of\nfields and validators are being automatically created for you.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIf you only want a subset of the default fields to be used in a model\nserializer, you can do so using `fields` or `exclude` options, just as you\nwould with a `ModelForm`. It is strongly recommended that you explicitly set\nall fields that should be serialized using the `fields` attribute. This will\nmake it less likely to result in unintentionally exposing data when your\nmodels change.\n\nFor example:\n\nYou can also set the `fields` attribute to the special value `'__all__'` to\nindicate that all fields in the model should be used.\n\nFor example:\n\nYou can set the `exclude` attribute to a list of fields to be excluded from\nthe serializer.\n\nFor example:\n\nIn the example above, if the `Account` model had 3 fields `account_name`,\n`users`, and `created`, this will result in the fields `account_name` and\n`created` to be serialized.\n\nThe names in the `fields` and `exclude` attributes will normally map to model\nfields on the model class.\n\nAlternatively names in the `fields` options can map to properties or methods\nwhich take no arguments that exist on the model class.\n\nSince version 3.3.0, it is mandatory to provide one of the attributes `fields`\nor `exclude`.\n\nThe default `ModelSerializer` uses primary keys for relationships, but you can\nalso easily generate nested representations using the `depth` option:\n\nThe `depth` option should be set to an integer value that indicates the depth\nof relationships that should be traversed before reverting to a flat\nrepresentation.\n\nIf you want to customize the way the serialization is done you'll need to\ndefine the field yourself.\n\nYou can add extra fields to a `ModelSerializer` or override the default fields\nby declaring fields on the class, just as you would for a `Serializer` class.\n\nExtra fields can correspond to any property or callable on the model.\n\nYou may wish to specify multiple fields as read-only. Instead of adding each\nfield explicitly with the `read_only=True` attribute, you may use the shortcut\nMeta option, `read_only_fields`.\n\nThis option should be a list or tuple of field names, and is declared as\nfollows:\n\nModel fields which have `editable=False` set, and `AutoField` fields will be\nset to read-only by default, and do not need to be added to the\n`read_only_fields` option.\n\nNote: There is a special-case where a read-only field is part of a\n`unique_together` constraint at the model level. In this case the field is\nrequired by the serializer class in order to validate the constraint, but\nshould also not be editable by the user.\n\nThe right way to deal with this is to specify the field explicitly on the\nserializer, providing both the `read_only=True` and `default=\u2026` keyword\narguments.\n\nOne example of this is a read-only relation to the currently authenticated\n`User` which is `unique_together` with another identifier. In this case you\nwould declare the user field like so:\n\nPlease review the Validators Documentation for details on the\nUniqueTogetherValidator and CurrentUserDefault classes.\n\nThere is also a shortcut allowing you to specify arbitrary additional keyword\narguments on fields, using the `extra_kwargs` option. As in the case of\n`read_only_fields`, this means you do not need to explicitly declare the field\non the serializer.\n\nThis option is a dictionary, mapping field names to a dictionary of keyword\narguments. For example:\n\nPlease keep in mind that, if the field has already been explicitly declared on\nthe serializer class, then the `extra_kwargs` option will be ignored.\n\nWhen serializing model instances, there are a number of different ways you\nmight choose to represent relationships. The default representation for\n`ModelSerializer` is to use the primary keys of the related instances.\n\nAlternative representations include serializing using hyperlinks, serializing\ncomplete nested representations, or serializing with a custom representation.\n\nFor full details see the serializer relations documentation.\n\nThe ModelSerializer class also exposes an API that you can override in order\nto alter how serializer fields are automatically determined when instantiating\nthe serializer.\n\nNormally if a `ModelSerializer` does not generate the fields you need by\ndefault then you should either add them to the class explicitly, or simply use\na regular `Serializer` class instead. However in some cases you may want to\ncreate a new base class that defines how the serializer fields are created for\nany given model.\n\nA mapping of Django model fields to REST framework serializer fields. You can\noverride this mapping to alter the default serializer fields that should be\nused for each model field.\n\nThis property should be the serializer field class, that is used for\nrelational fields by default.\n\nFor `ModelSerializer` this defaults to `PrimaryKeyRelatedField`.\n\nFor `HyperlinkedModelSerializer` this defaults to\n`serializers.HyperlinkedRelatedField`.\n\nThe serializer field class that should be used for any `url` field on the\nserializer.\n\nDefaults to `serializers.HyperlinkedIdentityField`\n\nThe serializer field class that should be used for any choice fields on the\nserializer.\n\nDefaults to `serializers.ChoiceField`\n\nThe following methods are called to determine the class and keyword arguments\nfor each field that should be automatically included on the serializer. Each\nof these methods should return a two tuple of `(field_class, field_kwargs)`.\n\nCalled to generate a serializer field that maps to a standard model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_field_mapping` attribute.\n\nCalled to generate a serializer field that maps to a relational model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_related_field` attribute.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a relational model field,\nwhen the `depth` option has been set.\n\nThe default implementation dynamically creates a nested serializer class based\non either `ModelSerializer` or `HyperlinkedModelSerializer`.\n\nThe `nested_depth` will be the value of the `depth` option, minus one.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a property or zero-argument\nmethod on the model class.\n\nThe default implementation returns a `ReadOnlyField` class.\n\nCalled to generate a serializer field for the serializer's own `url` field.\nThe default implementation returns a `HyperlinkedIdentityField` class.\n\nCalled when the field name did not map to any model field or model property.\nThe default implementation raises an error, although subclasses may customize\nthis behavior.\n\nThe `HyperlinkedModelSerializer` class is similar to the `ModelSerializer`\nclass except that it uses hyperlinks to represent relationships, rather than\nprimary keys.\n\nBy default the serializer will include a `url` field instead of a primary key\nfield.\n\nThe url field will be represented using a `HyperlinkedIdentityField`\nserializer field, and any relationships on the model will be represented using\na `HyperlinkedRelatedField` serializer field.\n\nYou can explicitly include the primary key by adding it to the `fields`\noption, for example:\n\nWhen instantiating a `HyperlinkedModelSerializer` you must include the current\n`request` in the serializer context, for example:\n\nDoing so will ensure that the hyperlinks can include an appropriate hostname,\nso that the resulting representation uses fully qualified URLs, such as:\n\nRather than relative URLs, such as:\n\nIf you do want to use relative URLs, you should explicitly pass `{'request':\nNone}` in the serializer context.\n\nThere needs to be a way of determining which views should be used for\nhyperlinking to model instances.\n\nBy default hyperlinks are expected to correspond to a view name that matches\nthe style `'{model_name}-detail'`, and looks up the instance by a `pk` keyword\nargument.\n\nYou can override a URL field view name and lookup field by using either, or\nboth of, the `view_name` and `lookup_field` options in the `extra_kwargs`\nsetting, like so:\n\nAlternatively you can set the fields on the serializer explicitly. For\nexample:\n\nTip: Properly matching together hyperlinked representations and your URL conf\ncan sometimes be a bit fiddly. Printing the `repr` of a\n`HyperlinkedModelSerializer` instance is a particularly useful way to inspect\nexactly which view names and lookup fields the relationships are expected to\nmap too.\n\nThe name of the URL field defaults to 'url'. You can override this globally,\nby using the `URL_FIELD_NAME` setting.\n\nThe `ListSerializer` class provides the behavior for serializing and\nvalidating multiple objects at once. You won't typically need to use\n`ListSerializer` directly, but should instead simply pass `many=True` when\ninstantiating a serializer.\n\nWhen a serializer is instantiated and `many=True` is passed, a\n`ListSerializer` instance will be created. The serializer class then becomes a\nchild of the parent `ListSerializer`\n\nThe following argument can also be passed to a `ListSerializer` field or a\nserializer that is passed `many=True`:\n\nThis is `True` by default, but can be set to `False` if you want to disallow\nempty lists as valid input.\n\nThere are a few use cases when you might want to customize the\n`ListSerializer` behavior. For example:\n\nFor these cases you can modify the class that is used when `many=True` is\npassed, by using the `list_serializer_class` option on the serializer `Meta`\nclass.\n\nFor example:\n\nThe default implementation for multiple object creation is to simply call\n`.create()` for each item in the list. If you want to customize this behavior,\nyou'll need to customize the `.create()` method on `ListSerializer` class that\nis used when `many=True` is passed.\n\nFor example:\n\nBy default the `ListSerializer` class does not support multiple updates. This\nis because the behavior that should be expected for insertions and deletions\nis ambiguous.\n\nTo support multiple updates you'll need to do so explicitly. When writing your\nmultiple update code make sure to keep the following in mind:\n\nYou will need to add an explicit `id` field to the instance serializer. The\ndefault implicitly-generated `id` field is marked as `read_only`. This causes\nit to be removed on updates. Once you declare it explicitly, it will be\navailable in the list serializer's `update` method.\n\nHere's an example of how you might choose to implement multiple updates:\n\nIt is possible that a third party package may be included alongside the 3.1\nrelease that provides some automatic support for multiple update operations,\nsimilar to the `allow_add_remove` behavior that was present in REST framework\n2.\n\nWhen a serializer with `many=True` is instantiated, we need to determine which\narguments and keyword arguments should be passed to the `.__init__()` method\nfor both the child `Serializer` class, and for the parent `ListSerializer`\nclass.\n\nThe default implementation is to pass all arguments to both classes, except\nfor `validators`, and any custom keyword arguments, both of which are assumed\nto be intended for the child serializer class.\n\nOccasionally you might need to explicitly specify how the child and parent\nclasses should be instantiated when `many=True` is passed. You can do so by\nusing the `many_init` class method.\n\n`BaseSerializer` class that can be used to easily support alternative\nserialization and deserialization styles.\n\nThis class implements the same basic API as the `Serializer` class:\n\nThere are four methods that can be overridden, depending on what functionality\nyou want the serializer class to support:\n\nBecause this class provides the same interface as the `Serializer` class, you\ncan use it with the existing generic class-based views exactly as you would\nfor a regular `Serializer` or `ModelSerializer`.\n\nThe only difference you'll notice when doing so is the `BaseSerializer`\nclasses will not generate HTML forms in the browsable API. This is because the\ndata they return does not include all the field information that would allow\neach field to be rendered into a suitable HTML input.\n\nTo implement a read-only serializer using the `BaseSerializer` class, we just\nneed to override the `.to_representation()` method. Let's take a look at an\nexample using a simple Django model:\n\nIt's simple to create a read-only serializer for converting `HighScore`\ninstances into primitive data types.\n\nWe can now use this class to serialize single `HighScore` instances:\n\nOr use it to serialize multiple instances:\n\nTo create a read-write serializer we first need to implement a\n`.to_internal_value()` method. This method returns the validated values that\nwill be used to construct the object instance, and may raise a\n`serializers.ValidationError` if the supplied data is in an incorrect format.\n\nOnce you've implemented `.to_internal_value()`, the basic validation API will\nbe available on the serializer, and you will be able to use `.is_valid()`,\n`.validated_data` and `.errors`.\n\nIf you want to also support `.save()` you'll need to also implement either or\nboth of the `.create()` and `.update()` methods.\n\nHere's a complete example of our previous `HighScoreSerializer`, that's been\nupdated to support both read and write operations.\n\nThe `BaseSerializer` class is also useful if you want to implement new generic\nserializer classes for dealing with particular serialization styles, or for\nintegrating with alternative storage backends.\n\nThe following class is an example of a generic serializer that can handle\ncoercing arbitrary objects into primitive representations.\n\nIf you need to alter the serialization or deserialization behavior of a\nserializer class, you can do so by overriding the `.to_representation()` or\n`.to_internal_value()` methods.\n\nSome reasons this might be useful include...\n\nThe signatures for these methods are as follows:\n\nTakes the object instance that requires serialization, and should return a\nprimitive representation. Typically this means returning a structure of built-\nin Python datatypes. The exact types that can be handled will depend on the\nrender classes you have configured for your API.\n\nMay be overridden in order to modify the representation style. For example:\n\nTakes the unvalidated incoming data as input and should return the validated\ndata that will be made available as `serializer.validated_data`. The return\nvalue will also be passed to the `.create()` or `.update()` methods if\n`.save()` is called on the serializer class.\n\nIf any of the validation fails, then the method should raise a\n`serializers.ValidationError(errors)`. The `errors` argument should be a\ndictionary mapping field names (or `settings.NON_FIELD_ERRORS_KEY`) to a list\nof error messages. If you don't need to alter deserialization behavior and\ninstead want to provide object-level validation, it's recommended that you\ninstead override the `.validate()` method.\n\nThe `data` argument passed to this method will normally be the value of\n`request.data`, so the datatype it provides will depend on the parser classes\nyou have configured for your API.\n\nSimilar to Django forms, you can extend and reuse serializers through\ninheritance. This allows you to declare a common set of fields or methods on a\nparent class that can then be used in a number of serializers. For example,\n\nLike Django's `Model` and `ModelForm` classes, the inner `Meta` class on\nserializers does not implicitly inherit from it's parents' inner `Meta`\nclasses. If you want the `Meta` class to inherit from a parent class you must\ndo so explicitly. For example:\n\nTypically we would recommend not using inheritance on inner Meta classes, but\ninstead declaring all options explicitly.\n\nAdditionally, the following caveats apply to serializer inheritance:\n\nIt\u2019s possible to declaratively remove a `Field` inherited from a parent class\nby setting the name to be `None` on the subclass.\n\nHowever, you can only use this technique to opt out from a field defined\ndeclaratively by a parent class; it won\u2019t prevent the `ModelSerializer` from\ngenerating a default field. To opt-out from default fields, see Specifying\nwhich fields to include.\n\nOnce a serializer has been initialized, the dictionary of fields that are set\non the serializer may be accessed using the `.fields` attribute. Accessing and\nmodifying this attribute allows you to dynamically modify the serializer.\n\nModifying the `fields` argument directly allows you to do interesting things\nsuch as changing the arguments on serializer fields at runtime, rather than at\nthe point of declaring the serializer.\n\nFor example, if you wanted to be able to set which fields should be used by a\nserializer at the point of initializing it, you could create a serializer\nclass like so:\n\nThis would then allow you to do the following:\n\nREST framework 2 provided an API to allow developers to override how a\n`ModelSerializer` class would automatically generate the default set of\nfields.\n\nThis API included the `.get_field()`, `.get_pk_field()` and other methods.\n\nBecause the serializers have been fundamentally redesigned with 3.0 this API\nno longer exists. You can still modify the fields that get created but you'll\nneed to refer to the source code, and be aware that if the changes you make\nare against private bits of API then they may be subject to change.\n\nThe following third party packages are also available.\n\nThe django-rest-marshmallow package provides an alternative implementation for\nserializers, using the python marshmallow library. It exposes the same API as\nthe REST framework serializers, and can be used as a drop-in replacement in\nsome use-cases.\n\nThe serpy package is an alternative implementation for serializers that is\nbuilt for speed. Serpy serializes complex datatypes to simple native types.\nThe native types can be easily converted to JSON or any other format needed.\n\nThe django-rest-framework-mongoengine package provides a\n`MongoEngineModelSerializer` serializer class that supports using MongoDB as\nthe storage layer for Django REST framework.\n\nThe django-rest-framework-gis package provides a `GeoFeatureModelSerializer`\nserializer class that supports GeoJSON both for read and write operations.\n\nThe django-rest-framework-hstore package provides an `HStoreSerializer` to\nsupport django-hstore `DictionaryField` model field and its `schema-mode`\nfeature.\n\nThe dynamic-rest package extends the ModelSerializer and ModelViewSet\ninterfaces, adding API query parameters for filtering, sorting, and including\n/ excluding all fields and relationships defined by your serializers.\n\nThe drf-dynamic-fields package provides a mixin to dynamically limit the\nfields per serializer to a subset specified by an URL parameter.\n\nThe drf-flex-fields package extends the ModelSerializer and ModelViewSet to\nprovide commonly used functionality for dynamically setting fields and\nexpanding primitive fields to nested models, both from URL parameters and your\nserializer class definitions.\n\nThe django-rest-framework-serializer-extensions package provides a collection\nof tools to DRY up your serializers, by allowing fields to be defined on a\nper-view/request basis. Fields can be whitelisted, blacklisted and child\nserializers can be optionally expanded.\n\nThe html-json-forms package provides an algorithm and serializer for\nprocessing `<form>` submissions per the (inactive) HTML JSON Form\nspecification. The serializer facilitates processing of arbitrarily nested\nJSON structures within HTML. For example, `<input name=\"items[0][id]\"\nvalue=\"5\">` will be interpreted as `{\"items\": [{\"id\": \"5\"}]}`.\n\nDRF-Base64 provides a set of field and model serializers that handles the\nupload of base64-encoded files.\n\ndjangorestframework-queryfields allows API clients to specify which fields\nwill be sent in the response via inclusion/exclusion query parameters.\n\nThe drf-writable-nested package provides writable nested model serializer\nwhich allows to create/update models with nested related data.\n\nThe drf-encrypt-content package helps you encrypt your data, serialized\nthrough ModelSerializer. It also contains some helper functions. Which helps\nyou to encrypt your data.\n\nserializers.py\n\n"}, {"name": "Metadata", "path": "api-guide/metadata/index", "type": "API Guide", "text": "\n[The `OPTIONS`] method allows a client to determine the options and/or\nrequirements associated with a resource, or the capabilities of a server,\nwithout implying a resource action or initiating a resource retrieval.\n\n\u2014 RFC7231, Section 4.3.7.\n\nREST framework includes a configurable mechanism for determining how your API\nshould respond to `OPTIONS` requests. This allows you to return API schema or\nother resource information.\n\nThere are not currently any widely adopted conventions for exactly what style\nof response should be returned for HTTP `OPTIONS` requests, so we provide an\nad-hoc style that returns some useful information.\n\nHere's an example response that demonstrates the information that is returned\nby default.\n\nYou can set the metadata class globally using the `'DEFAULT_METADATA_CLASS'`\nsettings key:\n\nOr you can set the metadata class individually for a view:\n\nThe REST framework package only includes a single metadata class\nimplementation, named `SimpleMetadata`. If you want to use an alternative\nstyle you'll need to implement a custom metadata class.\n\nIf you have specific requirements for creating schema endpoints that are\naccessed with regular `GET` requests, you might consider re-using the metadata\nAPI for doing so.\n\nFor example, the following additional route could be used on a viewset to\nprovide a linkable schema endpoint.\n\nThere are a couple of reasons that you might choose to take this approach,\nincluding that `OPTIONS` responses are not cacheable.\n\nIf you want to provide a custom metadata class you should override\n`BaseMetadata` and implement the `determine_metadata(self, request, view)`\nmethod.\n\nUseful things that you might want to do could include returning schema\ninformation, using a format such as JSON schema, or returning debug\ninformation to admin users.\n\nThe following class could be used to limit the information that is returned to\n`OPTIONS` requests.\n\nThen configure your settings to use this custom class:\n\nThe following third party packages provide additional metadata\nimplementations.\n\ndrf-schema-adapter is a set of tools that makes it easier to provide schema\ninformation to frontend frameworks and libraries. It provides a metadata mixin\nas well as 2 metadata classes and several adapters suitable to generate json-\nschema as well as schema information readable by various libraries.\n\nYou can also write your own adapter to work with your specific frontend. If\nyou wish to do so, it also provides an exporter that can export those schema\ninformation to json files.\n\nmetadata.py\n\n"}, {"name": "MethodNotAllowed", "path": "api-guide/exceptions/index#methodnotallowed", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "Miscellaneous settings", "path": "api-guide/settings/index#miscellaneous-settings", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "ModelField", "path": "api-guide/fields/index#modelfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "ModelSerializer", "path": "api-guide/serializers/index#modelserializer", "type": "Ref: Serializers", "text": "\nExpanding the usefulness of the serializers is something that we would like to\naddress. However, it's not a trivial problem, and it will take some serious\ndesign work.\n\n\u2014 Russell Keith-Magee, Django users group\n\nSerializers allow complex data such as querysets and model instances to be\nconverted to native Python datatypes that can then be easily rendered into\n`JSON`, `XML` or other content types. Serializers also provide\ndeserialization, allowing parsed data to be converted back into complex types,\nafter first validating the incoming data.\n\nThe serializers in REST framework work very similarly to Django's `Form` and\n`ModelForm` classes. We provide a `Serializer` class which gives you a\npowerful, generic way to control the output of your responses, as well as a\n`ModelSerializer` class which provides a useful shortcut for creating\nserializers that deal with model instances and querysets.\n\nLet's start by creating a simple object we can use for example purposes:\n\nWe'll declare a serializer that we can use to serialize and deserialize data\nthat corresponds to `Comment` objects.\n\nDeclaring a serializer looks very similar to declaring a form:\n\nWe can now use `CommentSerializer` to serialize a comment, or list of\ncomments. Again, using the `Serializer` class looks a lot like using a `Form`\nclass.\n\nAt this point we've translated the model instance into Python native\ndatatypes. To finalise the serialization process we render the data into\n`json`.\n\nDeserialization is similar. First we parse a stream into Python native\ndatatypes...\n\n...then we restore those native datatypes into a dictionary of validated data.\n\nIf we want to be able to return complete object instances based on the\nvalidated data we need to implement one or both of the `.create()` and\n`.update()` methods. For example:\n\nIf your object instances correspond to Django models you'll also want to\nensure that these methods save the object to the database. For example, if\n`Comment` was a Django model, the methods might look like this:\n\nNow when deserializing data, we can call `.save()` to return an object\ninstance, based on the validated data.\n\nCalling `.save()` will either create a new instance, or update an existing\ninstance, depending on if an existing instance was passed when instantiating\nthe serializer class:\n\nBoth the `.create()` and `.update()` methods are optional. You can implement\neither neither, one, or both of them, depending on the use-case for your\nserializer class.\n\nSometimes you'll want your view code to be able to inject additional data at\nthe point of saving the instance. This additional data might include\ninformation like the current user, the current time, or anything else that is\nnot part of the request data.\n\nYou can do so by including additional keyword arguments when calling\n`.save()`. For example:\n\nAny additional keyword arguments will be included in the `validated_data`\nargument when `.create()` or `.update()` are called.\n\nIn some cases the `.create()` and `.update()` method names may not be\nmeaningful. For example, in a contact form we may not be creating new\ninstances, but instead sending an email or other message.\n\nIn these cases you might instead choose to override `.save()` directly, as\nbeing more readable and meaningful.\n\nFor example:\n\nNote that in the case above we're now having to access the serializer\n`.validated_data` property directly.\n\nWhen deserializing data, you always need to call `is_valid()` before\nattempting to access the validated data, or save an object instance. If any\nvalidation errors occur, the `.errors` property will contain a dictionary\nrepresenting the resulting error messages. For example:\n\nEach key in the dictionary will be the field name, and the values will be\nlists of strings of any error messages corresponding to that field. The\n`non_field_errors` key may also be present, and will list any general\nvalidation errors. The name of the `non_field_errors` key may be customized\nusing the `NON_FIELD_ERRORS_KEY` REST framework setting.\n\nWhen deserializing a list of items, errors will be returned as a list of\ndictionaries representing each of the deserialized items.\n\nThe `.is_valid()` method takes an optional `raise_exception` flag that will\ncause it to raise a `serializers.ValidationError` exception if there are\nvalidation errors.\n\nThese exceptions are automatically dealt with by the default exception handler\nthat REST framework provides, and will return `HTTP 400 Bad Request` responses\nby default.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. These are\nsimilar to the `.clean_<field_name>` methods on Django forms.\n\nThese methods take a single argument, which is the field value that requires\nvalidation.\n\nYour `validate_<field_name>` methods should return the validated value or\nraise a `serializers.ValidationError`. For example:\n\nNote: If your `<field_name>` is declared on your serializer with the parameter\n`required=False` then this validation step will not take place if the field is\nnot included.\n\nTo do any other validation that requires access to multiple fields, add a\nmethod called `.validate()` to your `Serializer` subclass. This method takes a\nsingle argument, which is a dictionary of field values. It should raise a\n`serializers.ValidationError` if necessary, or just return the validated\nvalues. For example:\n\nIndividual fields on a serializer can include validators, by declaring them on\nthe field instance, for example:\n\nSerializer classes can also include reusable validators that are applied to\nthe complete set of field data. These validators are included by declaring\nthem on an inner `Meta` class, like so:\n\nFor more information see the validators documentation.\n\nWhen passing an initial object or queryset to a serializer instance, the\nobject will be made available as `.instance`. If no initial object is passed\nthen the `.instance` attribute will be `None`.\n\nWhen passing data to a serializer instance, the unmodified data will be made\navailable as `.initial_data`. If the `data` keyword argument is not passed\nthen the `.initial_data` attribute will not exist.\n\nBy default, serializers must be passed values for all required fields or they\nwill raise validation errors. You can use the `partial` argument in order to\nallow partial updates.\n\nThe previous examples are fine for dealing with objects that only have simple\ndatatypes, but sometimes we also need to be able to represent more complex\nobjects, where some of the attributes of an object might not be simple\ndatatypes such as strings, dates or integers.\n\nThe `Serializer` class is itself a type of `Field`, and can be used to\nrepresent relationships where one object type is nested inside another.\n\nIf a nested representation may optionally accept the `None` value you should\npass the `required=False` flag to the nested serializer.\n\nSimilarly if a nested representation should be a list of items, you should\npass the `many=True` flag to the nested serializer.\n\nWhen dealing with nested representations that support deserializing the data,\nany errors with nested objects will be nested under the field name of the\nnested object.\n\nSimilarly, the `.validated_data` property will include nested data structures.\n\nIf you're supporting writable nested representations you'll need to write\n`.create()` or `.update()` methods that handle saving multiple objects.\n\nThe following example demonstrates how you might handle creating a user with a\nnested profile object.\n\nFor updates you'll want to think carefully about how to handle updates to\nrelationships. For example if the data for the relationship is `None`, or not\nprovided, which of the following should occur?\n\nHere's an example for an `.update()` method on our previous `UserSerializer`\nclass.\n\nBecause the behavior of nested creates and updates can be ambiguous, and may\nrequire complex dependencies between related models, REST framework 3 requires\nyou to always write these methods explicitly. The default `ModelSerializer`\n`.create()` and `.update()` methods do not include support for writable nested\nrepresentations.\n\nThere are however, third-party packages available such as DRF Writable Nested\nthat support automatic writable nested representations.\n\nAn alternative to saving multiple related instances in the serializer is to\nwrite custom model manager classes that handle creating the correct instances.\n\nFor example, suppose we wanted to ensure that `User` instances and `Profile`\ninstances are always created together as a pair. We might write a custom\nmanager class that looks something like this:\n\nThis manager class now more nicely encapsulates that user instances and\nprofile instances are always created at the same time. Our `.create()` method\non the serializer class can now be re-written to use the new manager method.\n\nFor more details on this approach see the Django documentation on model\nmanagers, and this blogpost on using model and manager classes.\n\nThe `Serializer` class can also handle serializing or deserializing lists of\nobjects.\n\nTo serialize a queryset or list of objects instead of a single object\ninstance, you should pass the `many=True` flag when instantiating the\nserializer. You can then pass a queryset or list of objects to be serialized.\n\nThe default behavior for deserializing multiple objects is to support multiple\nobject creation, but not support multiple object updates. For more information\non how to support or customize either of these cases, see the ListSerializer\ndocumentation below.\n\nThere are some cases where you need to provide extra context to the serializer\nin addition to the object being serialized. One common case is if you're using\na serializer that includes hyperlinked relations, which requires the\nserializer to have access to the current request so that it can properly\ngenerate fully qualified URLs.\n\nYou can provide arbitrary additional context by passing a `context` argument\nwhen instantiating the serializer. For example:\n\nThe context dictionary can be used within any serializer field logic, such as\na custom `.to_representation()` method, by accessing the `self.context`\nattribute.\n\nOften you'll want serializer classes that map closely to Django model\ndefinitions.\n\nThe `ModelSerializer` class provides a shortcut that lets you automatically\ncreate a `Serializer` class with fields that correspond to the Model fields.\n\nThe `ModelSerializer` class is the same as a regular `Serializer` class,\nexcept that:\n\nDeclaring a `ModelSerializer` looks like this:\n\nBy default, all the model fields on the class will be mapped to a\ncorresponding serializer fields.\n\nAny relationships such as foreign keys on the model will be mapped to\n`PrimaryKeyRelatedField`. Reverse relationships are not included by default\nunless explicitly included as specified in the serializer relations\ndocumentation.\n\nSerializer classes generate helpful verbose representation strings, that allow\nyou to fully inspect the state of their fields. This is particularly useful\nwhen working with `ModelSerializers` where you want to determine what set of\nfields and validators are being automatically created for you.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIf you only want a subset of the default fields to be used in a model\nserializer, you can do so using `fields` or `exclude` options, just as you\nwould with a `ModelForm`. It is strongly recommended that you explicitly set\nall fields that should be serialized using the `fields` attribute. This will\nmake it less likely to result in unintentionally exposing data when your\nmodels change.\n\nFor example:\n\nYou can also set the `fields` attribute to the special value `'__all__'` to\nindicate that all fields in the model should be used.\n\nFor example:\n\nYou can set the `exclude` attribute to a list of fields to be excluded from\nthe serializer.\n\nFor example:\n\nIn the example above, if the `Account` model had 3 fields `account_name`,\n`users`, and `created`, this will result in the fields `account_name` and\n`created` to be serialized.\n\nThe names in the `fields` and `exclude` attributes will normally map to model\nfields on the model class.\n\nAlternatively names in the `fields` options can map to properties or methods\nwhich take no arguments that exist on the model class.\n\nSince version 3.3.0, it is mandatory to provide one of the attributes `fields`\nor `exclude`.\n\nThe default `ModelSerializer` uses primary keys for relationships, but you can\nalso easily generate nested representations using the `depth` option:\n\nThe `depth` option should be set to an integer value that indicates the depth\nof relationships that should be traversed before reverting to a flat\nrepresentation.\n\nIf you want to customize the way the serialization is done you'll need to\ndefine the field yourself.\n\nYou can add extra fields to a `ModelSerializer` or override the default fields\nby declaring fields on the class, just as you would for a `Serializer` class.\n\nExtra fields can correspond to any property or callable on the model.\n\nYou may wish to specify multiple fields as read-only. Instead of adding each\nfield explicitly with the `read_only=True` attribute, you may use the shortcut\nMeta option, `read_only_fields`.\n\nThis option should be a list or tuple of field names, and is declared as\nfollows:\n\nModel fields which have `editable=False` set, and `AutoField` fields will be\nset to read-only by default, and do not need to be added to the\n`read_only_fields` option.\n\nNote: There is a special-case where a read-only field is part of a\n`unique_together` constraint at the model level. In this case the field is\nrequired by the serializer class in order to validate the constraint, but\nshould also not be editable by the user.\n\nThe right way to deal with this is to specify the field explicitly on the\nserializer, providing both the `read_only=True` and `default=\u2026` keyword\narguments.\n\nOne example of this is a read-only relation to the currently authenticated\n`User` which is `unique_together` with another identifier. In this case you\nwould declare the user field like so:\n\nPlease review the Validators Documentation for details on the\nUniqueTogetherValidator and CurrentUserDefault classes.\n\nThere is also a shortcut allowing you to specify arbitrary additional keyword\narguments on fields, using the `extra_kwargs` option. As in the case of\n`read_only_fields`, this means you do not need to explicitly declare the field\non the serializer.\n\nThis option is a dictionary, mapping field names to a dictionary of keyword\narguments. For example:\n\nPlease keep in mind that, if the field has already been explicitly declared on\nthe serializer class, then the `extra_kwargs` option will be ignored.\n\nWhen serializing model instances, there are a number of different ways you\nmight choose to represent relationships. The default representation for\n`ModelSerializer` is to use the primary keys of the related instances.\n\nAlternative representations include serializing using hyperlinks, serializing\ncomplete nested representations, or serializing with a custom representation.\n\nFor full details see the serializer relations documentation.\n\nThe ModelSerializer class also exposes an API that you can override in order\nto alter how serializer fields are automatically determined when instantiating\nthe serializer.\n\nNormally if a `ModelSerializer` does not generate the fields you need by\ndefault then you should either add them to the class explicitly, or simply use\na regular `Serializer` class instead. However in some cases you may want to\ncreate a new base class that defines how the serializer fields are created for\nany given model.\n\nA mapping of Django model fields to REST framework serializer fields. You can\noverride this mapping to alter the default serializer fields that should be\nused for each model field.\n\nThis property should be the serializer field class, that is used for\nrelational fields by default.\n\nFor `ModelSerializer` this defaults to `PrimaryKeyRelatedField`.\n\nFor `HyperlinkedModelSerializer` this defaults to\n`serializers.HyperlinkedRelatedField`.\n\nThe serializer field class that should be used for any `url` field on the\nserializer.\n\nDefaults to `serializers.HyperlinkedIdentityField`\n\nThe serializer field class that should be used for any choice fields on the\nserializer.\n\nDefaults to `serializers.ChoiceField`\n\nThe following methods are called to determine the class and keyword arguments\nfor each field that should be automatically included on the serializer. Each\nof these methods should return a two tuple of `(field_class, field_kwargs)`.\n\nCalled to generate a serializer field that maps to a standard model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_field_mapping` attribute.\n\nCalled to generate a serializer field that maps to a relational model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_related_field` attribute.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a relational model field,\nwhen the `depth` option has been set.\n\nThe default implementation dynamically creates a nested serializer class based\non either `ModelSerializer` or `HyperlinkedModelSerializer`.\n\nThe `nested_depth` will be the value of the `depth` option, minus one.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a property or zero-argument\nmethod on the model class.\n\nThe default implementation returns a `ReadOnlyField` class.\n\nCalled to generate a serializer field for the serializer's own `url` field.\nThe default implementation returns a `HyperlinkedIdentityField` class.\n\nCalled when the field name did not map to any model field or model property.\nThe default implementation raises an error, although subclasses may customize\nthis behavior.\n\nThe `HyperlinkedModelSerializer` class is similar to the `ModelSerializer`\nclass except that it uses hyperlinks to represent relationships, rather than\nprimary keys.\n\nBy default the serializer will include a `url` field instead of a primary key\nfield.\n\nThe url field will be represented using a `HyperlinkedIdentityField`\nserializer field, and any relationships on the model will be represented using\na `HyperlinkedRelatedField` serializer field.\n\nYou can explicitly include the primary key by adding it to the `fields`\noption, for example:\n\nWhen instantiating a `HyperlinkedModelSerializer` you must include the current\n`request` in the serializer context, for example:\n\nDoing so will ensure that the hyperlinks can include an appropriate hostname,\nso that the resulting representation uses fully qualified URLs, such as:\n\nRather than relative URLs, such as:\n\nIf you do want to use relative URLs, you should explicitly pass `{'request':\nNone}` in the serializer context.\n\nThere needs to be a way of determining which views should be used for\nhyperlinking to model instances.\n\nBy default hyperlinks are expected to correspond to a view name that matches\nthe style `'{model_name}-detail'`, and looks up the instance by a `pk` keyword\nargument.\n\nYou can override a URL field view name and lookup field by using either, or\nboth of, the `view_name` and `lookup_field` options in the `extra_kwargs`\nsetting, like so:\n\nAlternatively you can set the fields on the serializer explicitly. For\nexample:\n\nTip: Properly matching together hyperlinked representations and your URL conf\ncan sometimes be a bit fiddly. Printing the `repr` of a\n`HyperlinkedModelSerializer` instance is a particularly useful way to inspect\nexactly which view names and lookup fields the relationships are expected to\nmap too.\n\nThe name of the URL field defaults to 'url'. You can override this globally,\nby using the `URL_FIELD_NAME` setting.\n\nThe `ListSerializer` class provides the behavior for serializing and\nvalidating multiple objects at once. You won't typically need to use\n`ListSerializer` directly, but should instead simply pass `many=True` when\ninstantiating a serializer.\n\nWhen a serializer is instantiated and `many=True` is passed, a\n`ListSerializer` instance will be created. The serializer class then becomes a\nchild of the parent `ListSerializer`\n\nThe following argument can also be passed to a `ListSerializer` field or a\nserializer that is passed `many=True`:\n\nThis is `True` by default, but can be set to `False` if you want to disallow\nempty lists as valid input.\n\nThere are a few use cases when you might want to customize the\n`ListSerializer` behavior. For example:\n\nFor these cases you can modify the class that is used when `many=True` is\npassed, by using the `list_serializer_class` option on the serializer `Meta`\nclass.\n\nFor example:\n\nThe default implementation for multiple object creation is to simply call\n`.create()` for each item in the list. If you want to customize this behavior,\nyou'll need to customize the `.create()` method on `ListSerializer` class that\nis used when `many=True` is passed.\n\nFor example:\n\nBy default the `ListSerializer` class does not support multiple updates. This\nis because the behavior that should be expected for insertions and deletions\nis ambiguous.\n\nTo support multiple updates you'll need to do so explicitly. When writing your\nmultiple update code make sure to keep the following in mind:\n\nYou will need to add an explicit `id` field to the instance serializer. The\ndefault implicitly-generated `id` field is marked as `read_only`. This causes\nit to be removed on updates. Once you declare it explicitly, it will be\navailable in the list serializer's `update` method.\n\nHere's an example of how you might choose to implement multiple updates:\n\nIt is possible that a third party package may be included alongside the 3.1\nrelease that provides some automatic support for multiple update operations,\nsimilar to the `allow_add_remove` behavior that was present in REST framework\n2.\n\nWhen a serializer with `many=True` is instantiated, we need to determine which\narguments and keyword arguments should be passed to the `.__init__()` method\nfor both the child `Serializer` class, and for the parent `ListSerializer`\nclass.\n\nThe default implementation is to pass all arguments to both classes, except\nfor `validators`, and any custom keyword arguments, both of which are assumed\nto be intended for the child serializer class.\n\nOccasionally you might need to explicitly specify how the child and parent\nclasses should be instantiated when `many=True` is passed. You can do so by\nusing the `many_init` class method.\n\n`BaseSerializer` class that can be used to easily support alternative\nserialization and deserialization styles.\n\nThis class implements the same basic API as the `Serializer` class:\n\nThere are four methods that can be overridden, depending on what functionality\nyou want the serializer class to support:\n\nBecause this class provides the same interface as the `Serializer` class, you\ncan use it with the existing generic class-based views exactly as you would\nfor a regular `Serializer` or `ModelSerializer`.\n\nThe only difference you'll notice when doing so is the `BaseSerializer`\nclasses will not generate HTML forms in the browsable API. This is because the\ndata they return does not include all the field information that would allow\neach field to be rendered into a suitable HTML input.\n\nTo implement a read-only serializer using the `BaseSerializer` class, we just\nneed to override the `.to_representation()` method. Let's take a look at an\nexample using a simple Django model:\n\nIt's simple to create a read-only serializer for converting `HighScore`\ninstances into primitive data types.\n\nWe can now use this class to serialize single `HighScore` instances:\n\nOr use it to serialize multiple instances:\n\nTo create a read-write serializer we first need to implement a\n`.to_internal_value()` method. This method returns the validated values that\nwill be used to construct the object instance, and may raise a\n`serializers.ValidationError` if the supplied data is in an incorrect format.\n\nOnce you've implemented `.to_internal_value()`, the basic validation API will\nbe available on the serializer, and you will be able to use `.is_valid()`,\n`.validated_data` and `.errors`.\n\nIf you want to also support `.save()` you'll need to also implement either or\nboth of the `.create()` and `.update()` methods.\n\nHere's a complete example of our previous `HighScoreSerializer`, that's been\nupdated to support both read and write operations.\n\nThe `BaseSerializer` class is also useful if you want to implement new generic\nserializer classes for dealing with particular serialization styles, or for\nintegrating with alternative storage backends.\n\nThe following class is an example of a generic serializer that can handle\ncoercing arbitrary objects into primitive representations.\n\nIf you need to alter the serialization or deserialization behavior of a\nserializer class, you can do so by overriding the `.to_representation()` or\n`.to_internal_value()` methods.\n\nSome reasons this might be useful include...\n\nThe signatures for these methods are as follows:\n\nTakes the object instance that requires serialization, and should return a\nprimitive representation. Typically this means returning a structure of built-\nin Python datatypes. The exact types that can be handled will depend on the\nrender classes you have configured for your API.\n\nMay be overridden in order to modify the representation style. For example:\n\nTakes the unvalidated incoming data as input and should return the validated\ndata that will be made available as `serializer.validated_data`. The return\nvalue will also be passed to the `.create()` or `.update()` methods if\n`.save()` is called on the serializer class.\n\nIf any of the validation fails, then the method should raise a\n`serializers.ValidationError(errors)`. The `errors` argument should be a\ndictionary mapping field names (or `settings.NON_FIELD_ERRORS_KEY`) to a list\nof error messages. If you don't need to alter deserialization behavior and\ninstead want to provide object-level validation, it's recommended that you\ninstead override the `.validate()` method.\n\nThe `data` argument passed to this method will normally be the value of\n`request.data`, so the datatype it provides will depend on the parser classes\nyou have configured for your API.\n\nSimilar to Django forms, you can extend and reuse serializers through\ninheritance. This allows you to declare a common set of fields or methods on a\nparent class that can then be used in a number of serializers. For example,\n\nLike Django's `Model` and `ModelForm` classes, the inner `Meta` class on\nserializers does not implicitly inherit from it's parents' inner `Meta`\nclasses. If you want the `Meta` class to inherit from a parent class you must\ndo so explicitly. For example:\n\nTypically we would recommend not using inheritance on inner Meta classes, but\ninstead declaring all options explicitly.\n\nAdditionally, the following caveats apply to serializer inheritance:\n\nIt\u2019s possible to declaratively remove a `Field` inherited from a parent class\nby setting the name to be `None` on the subclass.\n\nHowever, you can only use this technique to opt out from a field defined\ndeclaratively by a parent class; it won\u2019t prevent the `ModelSerializer` from\ngenerating a default field. To opt-out from default fields, see Specifying\nwhich fields to include.\n\nOnce a serializer has been initialized, the dictionary of fields that are set\non the serializer may be accessed using the `.fields` attribute. Accessing and\nmodifying this attribute allows you to dynamically modify the serializer.\n\nModifying the `fields` argument directly allows you to do interesting things\nsuch as changing the arguments on serializer fields at runtime, rather than at\nthe point of declaring the serializer.\n\nFor example, if you wanted to be able to set which fields should be used by a\nserializer at the point of initializing it, you could create a serializer\nclass like so:\n\nThis would then allow you to do the following:\n\nREST framework 2 provided an API to allow developers to override how a\n`ModelSerializer` class would automatically generate the default set of\nfields.\n\nThis API included the `.get_field()`, `.get_pk_field()` and other methods.\n\nBecause the serializers have been fundamentally redesigned with 3.0 this API\nno longer exists. You can still modify the fields that get created but you'll\nneed to refer to the source code, and be aware that if the changes you make\nare against private bits of API then they may be subject to change.\n\nThe following third party packages are also available.\n\nThe django-rest-marshmallow package provides an alternative implementation for\nserializers, using the python marshmallow library. It exposes the same API as\nthe REST framework serializers, and can be used as a drop-in replacement in\nsome use-cases.\n\nThe serpy package is an alternative implementation for serializers that is\nbuilt for speed. Serpy serializes complex datatypes to simple native types.\nThe native types can be easily converted to JSON or any other format needed.\n\nThe django-rest-framework-mongoengine package provides a\n`MongoEngineModelSerializer` serializer class that supports using MongoDB as\nthe storage layer for Django REST framework.\n\nThe django-rest-framework-gis package provides a `GeoFeatureModelSerializer`\nserializer class that supports GeoJSON both for read and write operations.\n\nThe django-rest-framework-hstore package provides an `HStoreSerializer` to\nsupport django-hstore `DictionaryField` model field and its `schema-mode`\nfeature.\n\nThe dynamic-rest package extends the ModelSerializer and ModelViewSet\ninterfaces, adding API query parameters for filtering, sorting, and including\n/ excluding all fields and relationships defined by your serializers.\n\nThe drf-dynamic-fields package provides a mixin to dynamically limit the\nfields per serializer to a subset specified by an URL parameter.\n\nThe drf-flex-fields package extends the ModelSerializer and ModelViewSet to\nprovide commonly used functionality for dynamically setting fields and\nexpanding primitive fields to nested models, both from URL parameters and your\nserializer class definitions.\n\nThe django-rest-framework-serializer-extensions package provides a collection\nof tools to DRY up your serializers, by allowing fields to be defined on a\nper-view/request basis. Fields can be whitelisted, blacklisted and child\nserializers can be optionally expanded.\n\nThe html-json-forms package provides an algorithm and serializer for\nprocessing `<form>` submissions per the (inactive) HTML JSON Form\nspecification. The serializer facilitates processing of arbitrarily nested\nJSON structures within HTML. For example, `<input name=\"items[0][id]\"\nvalue=\"5\">` will be interpreted as `{\"items\": [{\"id\": \"5\"}]}`.\n\nDRF-Base64 provides a set of field and model serializers that handles the\nupload of base64-encoded files.\n\ndjangorestframework-queryfields allows API clients to specify which fields\nwill be sent in the response via inclusion/exclusion query parameters.\n\nThe drf-writable-nested package provides writable nested model serializer\nwhich allows to create/update models with nested related data.\n\nThe drf-encrypt-content package helps you encrypt your data, serialized\nthrough ModelSerializer. It also contains some helper functions. Which helps\nyou to encrypt your data.\n\nserializers.py\n\n"}, {"name": "ModelViewSet", "path": "api-guide/viewsets/index#modelviewset", "type": "Ref: ViewSets", "text": "\nAfter routing has determined which controller to use for a request, your\ncontroller is responsible for making sense of the request and producing the\nappropriate output.\n\n\u2014 Ruby on Rails Documentation\n\nDjango REST framework allows you to combine the logic for a set of related\nviews in a single class, called a `ViewSet`. In other frameworks you may also\nfind conceptually similar implementations named something like 'Resources' or\n'Controllers'.\n\nA `ViewSet` class is simply a type of class-based View, that does not provide\nany method handlers such as `.get()` or `.post()`, and instead provides\nactions such as `.list()` and `.create()`.\n\nThe method handlers for a `ViewSet` are only bound to the corresponding\nactions at the point of finalizing the view, using the `.as_view()` method.\n\nTypically, rather than explicitly registering the views in a viewset in the\nurlconf, you'll register the viewset with a router class, that automatically\ndetermines the urlconf for you.\n\nLet's define a simple viewset that can be used to list or retrieve all the\nusers in the system.\n\nIf we need to, we can bind this viewset into two separate views, like so:\n\nTypically we wouldn't do this, but would instead register the viewset with a\nrouter, and allow the urlconf to be automatically generated.\n\nRather than writing your own viewsets, you'll often want to use the existing\nbase classes that provide a default set of behavior. For example:\n\nThere are two main advantages of using a `ViewSet` class over using a `View`\nclass.\n\nBoth of these come with a trade-off. Using regular views and URL confs is more\nexplicit and gives you more control. ViewSets are helpful if you want to get\nup and running quickly, or when you have a large API and you want to enforce a\nconsistent URL configuration throughout.\n\nThe default routers included with REST framework will provide routes for a\nstandard set of create/retrieve/update/destroy style actions, as shown below:\n\nDuring dispatch, the following attributes are available on the `ViewSet`.\n\nYou may inspect these attributes to adjust behaviour based on the current\naction. For example, you could restrict permissions to everything except the\n`list` action similar to this:\n\nIf you have ad-hoc methods that should be routable, you can mark them as such\nwith the `@action` decorator. Like regular actions, extra actions may be\nintended for either a single object, or an entire collection. To indicate\nthis, set the `detail` argument to `True` or `False`. The router will\nconfigure its URL patterns accordingly. e.g., the `DefaultRouter` will\nconfigure detail actions to contain `pk` in their URL patterns.\n\nA more complete example of extra actions:\n\nThe `action` decorator will route `GET` requests by default, but may also\naccept other HTTP methods by setting the `methods` argument. For example:\n\nThe decorator allows you to override any viewset-level configuration such as\n`permission_classes`, `serializer_class`, `filter_backends`...:\n\nThe two new actions will then be available at the urls\n`^users/{pk}/set_password/$` and `^users/{pk}/unset_password/$`. Use the\n`url_path` and `url_name` parameters to change the URL segment and the reverse\nURL name of the action.\n\nTo view all extra actions, call the `.get_extra_actions()` method.\n\nExtra actions can map additional HTTP methods to separate `ViewSet` methods.\nFor example, the above password set/unset methods could be consolidated into a\nsingle route. Note that additional mappings do not accept arguments.\n\nIf you need to get the URL of an action, use the `.reverse_action()` method.\nThis is a convenience wrapper for `reverse()`, automatically passing the\nview's `request` object and prepending the `url_name` with the `.basename`\nattribute.\n\nNote that the `basename` is provided by the router during `ViewSet`\nregistration. If you are not using a router, then you must provide the\n`basename` argument to the `.as_view()` method.\n\nUsing the example from the previous section:\n\nAlternatively, you can use the `url_name` attribute set by the `@action`\ndecorator.\n\nThe `url_name` argument for `.reverse_action()` should match the same argument\nto the `@action` decorator. Additionally, this method can be used to reverse\nthe default actions, such as `list` and `create`.\n\nThe `ViewSet` class inherits from `APIView`. You can use any of the standard\nattributes such as `permission_classes`, `authentication_classes` in order to\ncontrol the API policy on the viewset.\n\nThe `ViewSet` class does not provide any implementations of actions. In order\nto use a `ViewSet` class you'll override the class and define the action\nimplementations explicitly.\n\nThe `GenericViewSet` class inherits from `GenericAPIView`, and provides the\ndefault set of `get_object`, `get_queryset` methods and other generic view\nbase behavior, but does not include any actions by default.\n\nIn order to use a `GenericViewSet` class you'll override the class and either\nmixin the required mixin classes, or define the action implementations\nexplicitly.\n\nThe `ModelViewSet` class inherits from `GenericAPIView` and includes\nimplementations for various actions, by mixing in the behavior of the various\nmixin classes.\n\nThe actions provided by the `ModelViewSet` class are `.list()`, `.retrieve()`,\n`.create()`, `.update()`, `.partial_update()`, and `.destroy()`.\n\nBecause `ModelViewSet` extends `GenericAPIView`, you'll normally need to\nprovide at least the `queryset` and `serializer_class` attributes. For\nexample:\n\nNote that you can use any of the standard attributes or method overrides\nprovided by `GenericAPIView`. For example, to use a `ViewSet` that dynamically\ndetermines the queryset it should operate on, you might do something like\nthis:\n\nNote however that upon removal of the `queryset` property from your `ViewSet`,\nany associated router will be unable to derive the basename of your Model\nautomatically, and so you will have to specify the `basename` kwarg as part of\nyour router registration.\n\nAlso note that although this class provides the complete set of\ncreate/list/retrieve/update/destroy actions by default, you can restrict the\navailable operations by using the standard permission classes.\n\nThe `ReadOnlyModelViewSet` class also inherits from `GenericAPIView`. As with\n`ModelViewSet` it also includes implementations for various actions, but\nunlike `ModelViewSet` only provides the 'read-only' actions, `.list()` and\n`.retrieve()`.\n\nAs with `ModelViewSet`, you'll normally need to provide at least the\n`queryset` and `serializer_class` attributes. For example:\n\nAgain, as with `ModelViewSet`, you can use any of the standard attributes and\nmethod overrides available to `GenericAPIView`.\n\nYou may need to provide custom `ViewSet` classes that do not have the full set\nof `ModelViewSet` actions, or that customize the behavior in some other way.\n\nTo create a base viewset class that provides `create`, `list` and `retrieve`\noperations, inherit from `GenericViewSet`, and mixin the required actions:\n\nBy creating your own base `ViewSet` classes, you can provide common behavior\nthat can be reused in multiple viewsets across your API.\n\nviewsets.py\n\n"}, {"name": "MultiPartParser", "path": "api-guide/parsers/index#multipartparser", "type": "Ref: Parsers", "text": "\nMachine interacting web services tend to use more structured formats for\nsending data than form-encoded, since they're sending more complex data than\nsimple forms\n\n\u2014 Malcom Tredinnick, Django developers group\n\nREST framework includes a number of built in Parser classes, that allow you to\naccept requests with various media types. There is also support for defining\nyour own custom parsers, which gives you the flexibility to design the media\ntypes that your API accepts.\n\nThe set of valid parsers for a view is always defined as a list of classes.\nWhen `request.data` is accessed, REST framework will examine the `Content-\nType` header on the incoming request, and determine which parser to use to\nparse the request content.\n\nNote: When developing client applications always remember to make sure you're\nsetting the `Content-Type` header when sending data in an HTTP request.\n\nIf you don't set the content type, most clients will default to using\n`'application/x-www-form-urlencoded'`, which may not be what you wanted.\n\nAs an example, if you are sending `json` encoded data using jQuery with the\n.ajax() method, you should make sure to include the `contentType:\n'application/json'` setting.\n\nThe default set of parsers may be set globally, using the\n`DEFAULT_PARSER_CLASSES` setting. For example, the following settings would\nallow only requests with `JSON` content, instead of the default of JSON or\nform data.\n\nYou can also set the parsers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nParses `JSON` request content. `request.data` will be populated with a\ndictionary of data.\n\n.media_type: `application/json`\n\nParses HTML form content. `request.data` will be populated with a `QueryDict`\nof data.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `application/x-www-form-urlencoded`\n\nParses multipart HTML form content, which supports file uploads. Both\n`request.data` will be populated with a `QueryDict`.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `multipart/form-data`\n\nParses raw file upload content. The `request.data` property will be a\ndictionary with a single key `'file'` containing the uploaded file.\n\nIf the view used with `FileUploadParser` is called with a `filename` URL\nkeyword argument, then that argument will be used as the filename.\n\nIf it is called without a `filename` URL keyword argument, then the client\nmust set the filename in the `Content-Disposition` HTTP header. For example\n`Content-Disposition: attachment; filename=upload.jpg`.\n\n.media_type: `*/*`\n\nTo implement a custom parser, you should override `BaseParser`, set the\n`.media_type` property, and implement the `.parse(self, stream, media_type,\nparser_context)` method.\n\nThe method should return the data that will be used to populate the\n`request.data` property.\n\nThe arguments passed to `.parse()` are:\n\nA stream-like object representing the body of the request.\n\nOptional. If provided, this is the media type of the incoming request content.\n\nDepending on the request's `Content-Type:` header, this may be more specific\nthan the renderer's `media_type` attribute, and may include media type\nparameters. For example `\"text/plain; charset=utf-8\"`.\n\nOptional. If supplied, this argument will be a dictionary containing any\nadditional context that may be required to parse the request content.\n\nBy default this will include the following keys: `view`, `request`, `args`,\n`kwargs`.\n\nThe following is an example plaintext parser that will populate the\n`request.data` property with a string representing the body of the request.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nparsers.py\n\n"}, {"name": "MultiPartRenderer", "path": "api-guide/renderers/index#multipartrenderer", "type": "Ref: Renderers", "text": "\nBefore a TemplateResponse instance can be returned to the client, it must be\nrendered. The rendering process takes the intermediate representation of\ntemplate and context, and turns it into the final byte stream that can be\nserved to the client.\n\n\u2014 Django documentation\n\nREST framework includes a number of built in Renderer classes, that allow you\nto return responses with various media types. There is also support for\ndefining your own custom renderers, which gives you the flexibility to design\nyour own media types.\n\nThe set of valid renderers for a view is always defined as a list of classes.\nWhen a view is entered REST framework will perform content negotiation on the\nincoming request, and determine the most appropriate renderer to satisfy the\nrequest.\n\nThe basic process of content negotiation involves examining the request's\n`Accept` header, to determine which media types it expects in the response.\nOptionally, format suffixes on the URL may be used to explicitly request a\nparticular representation. For example the URL\n`http://example.com/api/users_count.json` might be an endpoint that always\nreturns JSON data.\n\nFor more information see the documentation on content negotiation.\n\nThe default set of renderers may be set globally, using the\n`DEFAULT_RENDERER_CLASSES` setting. For example, the following settings would\nuse `JSON` as the main media type and also include the self describing API.\n\nYou can also set the renderers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nIt's important when specifying the renderer classes for your API to think\nabout what priority you want to assign to each media type. If a client\nunderspecifies the representations it can accept, such as sending an `Accept:\n*/*` header, or not including an `Accept` header at all, then REST framework\nwill select the first renderer in the list to use for the response.\n\nFor example if your API serves JSON responses and the HTML browsable API, you\nmight want to make `JSONRenderer` your default renderer, in order to send\n`JSON` responses to clients that do not specify an `Accept` header.\n\nIf your API includes views that can serve both regular webpages and API\nresponses depending on the request, then you might consider making\n`TemplateHTMLRenderer` your default renderer, in order to play nicely with\nolder browsers that send broken accept headers.\n\nRenders the request data into `JSON`, using utf-8 encoding.\n\nNote that the default style is to include unicode characters, and render the\nresponse using a compact style with no unnecessary whitespace:\n\nThe client may additionally include an `'indent'` media type parameter, in\nwhich case the returned `JSON` will be indented. For example `Accept:\napplication/json; indent=4`.\n\nThe default JSON encoding style can be altered using the `UNICODE_JSON` and\n`COMPACT_JSON` settings keys.\n\n.media_type: `application/json`\n\n.format: `'json'`\n\n.charset: `None`\n\nRenders data to HTML, using Django's standard template rendering. Unlike other\nrenderers, the data passed to the `Response` does not need to be serialized.\nAlso, unlike other renderers, you may want to include a `template_name`\nargument when creating the `Response`.\n\nThe TemplateHTMLRenderer will create a `RequestContext`, using the\n`response.data` as the context dict, and determine a template name to use to\nrender the context.\n\nNote: When used with a view that makes use of a serializer the `Response` sent\nfor rendering may not be a dictionary and will need to be wrapped in a dict\nbefore returning to allow the TemplateHTMLRenderer to render it. For example:\n\nThe template name is determined by (in order of preference):\n\nAn example of a view that uses `TemplateHTMLRenderer`:\n\nYou can use `TemplateHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\nIf you're building websites that use `TemplateHTMLRenderer` along with other\nrenderer classes, you should consider listing `TemplateHTMLRenderer` as the\nfirst class in the `renderer_classes` list, so that it will be prioritised\nfirst even for browsers that send poorly formed `ACCEPT:` headers.\n\nSee the HTML & Forms Topic Page for further examples of `TemplateHTMLRenderer`\nusage.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `StaticHTMLRenderer`\n\nA simple renderer that simply returns pre-rendered HTML. Unlike other\nrenderers, the data passed to the response object should be a string\nrepresenting the content to be returned.\n\nAn example of a view that uses `StaticHTMLRenderer`:\n\nYou can use `StaticHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `TemplateHTMLRenderer`\n\nRenders data into HTML for the Browsable API:\n\nThis renderer will determine which other renderer would have been given\nhighest priority, and use that to display an API style response within the\nHTML page.\n\n.media_type: `text/html`\n\n.format: `'api'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/api.html'`\n\nBy default the response content will be rendered with the highest priority\nrenderer apart from `BrowsableAPIRenderer`. If you need to customize this\nbehavior, for example to use HTML as the default return format, but use JSON\nin the browsable API, you can do so by overriding the `get_default_renderer()`\nmethod. For example:\n\nRenders data into HTML for an admin-like display:\n\nThis renderer is suitable for CRUD-style web APIs that should also present a\nuser-friendly interface for managing the data.\n\nNote that views that have nested or list serializers for their input won't\nwork well with the `AdminRenderer`, as the HTML forms are unable to properly\nsupport them.\n\nNote: The `AdminRenderer` is only able to include links to detail pages when a\nproperly configured `URL_FIELD_NAME` (`url` by default) attribute is present\nin the data. For `HyperlinkedModelSerializer` this will be the case, but for\n`ModelSerializer` or plain `Serializer` classes you'll need to make sure to\ninclude the field explicitly. For example here we use models\n`get_absolute_url` method:\n\n.media_type: `text/html`\n\n.format: `'admin'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/admin.html'`\n\nRenders data returned by a serializer into an HTML form. The output of this\nrenderer does not include the enclosing `<form>` tags, a hidden CSRF input or\nany submit buttons.\n\nThis renderer is not intended to be used directly, but can instead be used in\ntemplates by passing a serializer instance to the `render_form` template tag.\n\nFor more information see the HTML & Forms documentation.\n\n.media_type: `text/html`\n\n.format: `'form'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/horizontal/form.html'`\n\nThis renderer is used for rendering HTML multipart form data. It is not\nsuitable as a response renderer, but is instead used for creating test\nrequests, using REST framework's test client and test request factory.\n\n.media_type: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n.format: `'multipart'`\n\n.charset: `utf-8`\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the\n`.media_type` and `.format` properties, and implement the `.render(self, data,\nmedia_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the\nHTTP response.\n\nThe arguments passed to the `.render()` method are:\n\nThe request data, as set by the `Response()` instantiation.\n\nOptional. If provided, this is the accepted media type, as determined by the\ncontent negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the\nrenderer's `media_type` attribute, and may include media type parameters. For\nexample `\"application/json; nested=true\"`.\n\nOptional. If provided, this is a dictionary of contextual information provided\nby the view.\n\nBy default this will include the following keys: `view`, `request`,\n`response`, `args`, `kwargs`.\n\nThe following is an example plaintext renderer that will return a response\nwith the `data` parameter as the content of the response.\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To\nuse a different encoding, set the `charset` attribute on the renderer.\n\nNote that if a renderer class returns a unicode string, then the response\ncontent will be coerced into a bytestring by the `Response` class, with the\n`charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you\nshould set a charset value of `None`, which will ensure the `Content-Type`\nheader of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to\n`'binary'`. Doing so will also ensure that the browsable API will not attempt\nto display the binary content as a string.\n\nYou can do some pretty flexible things using REST framework's renderers. Some\nexamples...\n\nIn some cases you might want your view to use different serialization styles\ndepending on the accepted media type. If you need to do this you can access\n`request.accepted_renderer` to determine the negotiated renderer that will be\nused for the response.\n\nFor example:\n\nIn some cases you might want a renderer to serve a range of media types. In\nthis case you can underspecify the media types it should respond to, by using\na `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify\nthe media type explicitly when you return the response, using the\n`content_type` attribute. For example:\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked\nrelations may be sufficient. If you want to fully embrace RESTful design and\nHATEOAS you'll need to consider the design and usage of your media types in\nmore detail.\n\nIn the words of Roy Fielding, \"A REST API should spend almost all of its\ndescriptive effort in defining the media type(s) used for representing\nresources and driving application state, or in defining extended relation\nnames and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom\napplication/vnd.github+json media type, and Mike Amundsen's IANA approved\napplication/vnd.collection+json JSON-based hypermedia.\n\nTypically a renderer will behave the same regardless of if it's dealing with a\nregular response, or with a response caused by an exception being raised, such\nas an `Http404` or `PermissionDenied` exception, or a subclass of\n`APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer`\nand an exception is raised, the behavior is slightly different, and mirrors\nDjango's default handling of error views.\n\nExceptions raised and handled by an HTML renderer will attempt to render using\none of the following methods, by order of precedence.\n\nTemplates will render with a `RequestContext` which includes the `status_code`\nand `details` keys.\n\nNote: If `DEBUG=True`, Django's standard traceback error page will be\ndisplayed instead of rendering the HTTP status code and text.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST framework JSONP provides JSONP rendering support. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nWarning: If you require cross-domain AJAX requests, you should generally be\nusing the more modern approach of CORS as an alternative to `JSONP`. See the\nCORS documentation for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is only appropriate\nfor globally readable API endpoints, where `GET` requests are unauthenticated\nand do not require any user permissions.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\nXLSX is the world's most popular binary spreadsheet format. Tim Allen of The\nWharton School maintains drf-renderer-xlsx, which renders an endpoint as an\nXLSX spreadsheet using OpenPyXL, and allows the client to download it.\nSpreadsheets can be styled on a per-view basis.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nTo avoid having a file streamed without a filename (which the browser will\noften default to the filename \"download\", with no extension), we need to use a\nmixin to override the `Content-Disposition` header. If no filename is\nprovided, it will default to `export.xlsx`. For example:\n\nComma-separated values are a plain-text tabular data format, that can be\neasily imported into spreadsheet applications. Mjumbe Poe maintains the\ndjangorestframework-csv package which provides CSV renderer support for REST\nframework.\n\nUltraJSON is an optimized C JSON encoder which can give significantly faster\nJSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now\nunmaintained drf-ujson-renderer, which implements JSON rendering using the\nUJSON package.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nDjango REST Pandas provides a serializer and renderers that support additional\ndata processing and output via the Pandas DataFrame API. Django REST Pandas\nincludes renderers for Pandas-style CSV files, Excel workbooks (both `.xls`\nand `.xlsx`), and a number of other formats. It is maintained by S. Andrew\nSheppard as part of the wq Project.\n\nRest Framework Latex provides a renderer that outputs PDFs using Laulatex. It\nis maintained by Pebble (S/F Software).\n\nrenderers.py\n\n"}, {"name": "MultipleChoiceField", "path": "api-guide/fields/index#multiplechoicefield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "NamespaceVersioning", "path": "api-guide/versioning/index#namespaceversioning", "type": "Ref: Versioning", "text": "\nVersioning an interface is just a \"polite\" way to kill deployed clients.\n\n\u2014 Roy Fielding.\n\nAPI versioning allows you to alter behavior between different clients. REST\nframework provides for a number of different versioning schemes.\n\nVersioning is determined by the incoming client request, and may either be\nbased on the request URL, or based on the request headers.\n\nThere are a number of valid approaches to approaching versioning. Non-\nversioned systems can also be appropriate, particularly if you're engineering\nfor very long-term systems with multiple clients outside of your control.\n\nWhen API versioning is enabled, the `request.version` attribute will contain a\nstring that corresponds to the version requested in the incoming client\nrequest.\n\nBy default, versioning is not enabled, and `request.version` will always\nreturn `None`.\n\nHow you vary the API behavior is up to you, but one example you might\ntypically want is to switch to a different serialization style in a newer\nversion. For example:\n\nThe `reverse` function included by REST framework ties in with the versioning\nscheme. You need to make sure to include the current `request` as a keyword\nargument, like so.\n\nThe above function will apply any URL transformations appropriate to the\nrequest version. For example:\n\nWhen using hyperlinked serialization styles together with a URL based\nversioning scheme make sure to include the request as context to the\nserializer.\n\nDoing so will allow any returned URLs to include the appropriate versioning.\n\nThe versioning scheme is defined by the `DEFAULT_VERSIONING_CLASS` settings\nkey.\n\nUnless it is explicitly set, the value for `DEFAULT_VERSIONING_CLASS` will be\n`None`. In this case the `request.version` attribute will always return\n`None`.\n\nYou can also set the versioning scheme on an individual view. Typically you\nwon't need to do this, as it makes more sense to have a single versioning\nscheme used globally. If you do need to do so, use the `versioning_class`\nattribute.\n\nThe following settings keys are also used to control versioning:\n\nYou can also set your versioning class plus those three values on a per-view\nor a per-viewset basis by defining your own versioning scheme and using the\n`default_version`, `allowed_versions` and `version_param` class variables. For\nexample, if you want to use `URLPathVersioning`:\n\nThis scheme requires the client to specify the version as part of the media\ntype in the `Accept` header. The version is included as a media type\nparameter, that supplements the main media type.\n\nHere's an example HTTP request using the accept header versioning style.\n\nIn the example request above `request.version` attribute would return the\nstring `'1.0'`.\n\nVersioning based on accept headers is generally considered as best practice,\nalthough other styles may be suitable depending on your client requirements.\n\nStrictly speaking the `json` media type is not specified as including\nadditional parameters. If you are building a well-specified public API you\nmight consider using a vendor media type. To do so, configure your renderers\nto use a JSON based renderer with a custom media type:\n\nYour client requests would now look like this:\n\nThis scheme requires the client to specify the version as part of the URL\npath.\n\nYour URL conf must include a pattern that matches the version with a\n`'version'` keyword argument, so that this information is available to the\nversioning scheme.\n\nTo the client, this scheme is the same as `URLPathVersioning`. The only\ndifference is how it is configured in your Django application, as it uses URL\nnamespacing, instead of URL keyword arguments.\n\nWith this scheme the `request.version` attribute is determined based on the\n`namespace` that matches the incoming request path.\n\nIn the following example we're giving a set of views two different possible\nURL prefixes, each under a different namespace:\n\nBoth `URLPathVersioning` and `NamespaceVersioning` are reasonable if you just\nneed a simple versioning scheme. The `URLPathVersioning` approach might be\nbetter suitable for small ad-hoc projects, and the `NamespaceVersioning` is\nprobably easier to manage for larger projects.\n\nThe hostname versioning scheme requires the client to specify the requested\nversion as part of the hostname in the URL.\n\nFor example the following is an HTTP request to the\n`http://v1.example.com/bookings/` URL:\n\nBy default this implementation expects the hostname to match this simple\nregular expression:\n\nNote that the first group is enclosed in brackets, indicating that this is the\nmatched portion of the hostname.\n\nThe `HostNameVersioning` scheme can be awkward to use in debug mode as you\nwill typically be accessing a raw IP address such as `127.0.0.1`. There are\nvarious online tutorials on how to access localhost with a custom subdomain\nwhich you may find helpful in this case.\n\nHostname based versioning can be particularly useful if you have requirements\nto route incoming requests to different servers based on the version, as you\ncan configure different DNS records for different API versions.\n\nThis scheme is a simple style that includes the version as a query parameter\nin the URL. For example:\n\nTo implement a custom versioning scheme, subclass `BaseVersioning` and\noverride the `.determine_version` method.\n\nThe following example uses a custom `X-API-Version` header to determine the\nrequested version.\n\nIf your versioning scheme is based on the request URL, you will also want to\nalter how versioned URLs are determined. In order to do so you should override\nthe `.reverse()` method on the class. See the source code for examples.\n\nversioning.py\n\n"}, {"name": "NotAcceptable", "path": "api-guide/exceptions/index#notacceptable", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "NotAuthenticated", "path": "api-guide/exceptions/index#notauthenticated", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "NotFound", "path": "api-guide/exceptions/index#notfound", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "NullBooleanField", "path": "api-guide/fields/index#nullbooleanfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "OrderingFilter", "path": "api-guide/filtering/index#orderingfilter", "type": "Ref: Filtering", "text": "\nThe root QuerySet provided by the Manager describes all objects in the\ndatabase table. Usually, though, you'll need to select only a subset of the\ncomplete set of objects.\n\n\u2014 Django documentation\n\nThe default behavior of REST framework's generic list views is to return the\nentire queryset for a model manager. Often you will want your API to restrict\nthe items that are returned by the queryset.\n\nThe simplest way to filter the queryset of any view that subclasses\n`GenericAPIView` is to override the `.get_queryset()` method.\n\nOverriding this method allows you to customize the queryset returned by the\nview in a number of different ways.\n\nYou might want to filter the queryset to ensure that only results relevant to\nthe currently authenticated user making the request are returned.\n\nYou can do so by filtering based on the value of `request.user`.\n\nFor example:\n\nAnother style of filtering might involve restricting the queryset based on\nsome part of the URL.\n\nFor example if your URL config contained an entry like this:\n\nYou could then write a view that returned a purchase queryset filtered by the\nusername portion of the URL:\n\nA final example of filtering the initial queryset would be to determine the\ninitial queryset based on query parameters in the url.\n\nWe can override `.get_queryset()` to deal with URLs such as\n`http://example.com/api/purchases?username=denvercoder9`, and filter the\nqueryset only if the `username` parameter is included in the URL:\n\nAs well as being able to override the default queryset, REST framework also\nincludes support for generic filtering backends that allow you to easily\nconstruct complex searches and filters.\n\nGeneric filters can also present themselves as HTML controls in the browsable\nAPI and admin API.\n\nThe default filter backends may be set globally, using the\n`DEFAULT_FILTER_BACKENDS` setting. For example.\n\nYou can also set the filter backends on a per-view, or per-viewset basis,\nusing the `GenericAPIView` class-based views.\n\nNote that if a filter backend is configured for a view, then as well as being\nused to filter list views, it will also be used to filter the querysets used\nfor returning a single object.\n\nFor instance, given the previous example, and a product with an id of `4675`,\nthe following URL would either return the corresponding object, or return a\n404 response, depending on if the filtering conditions were met by the given\nproduct instance:\n\nNote that you can use both an overridden `.get_queryset()` and generic\nfiltering together, and everything will work as expected. For example, if\n`Product` had a many-to-many relationship with `User`, named `purchase`, you\nmight want to write a view like this:\n\nThe `django-filter` library includes a `DjangoFilterBackend` class which\nsupports highly customizable field filtering for REST framework.\n\nTo use `DjangoFilterBackend`, first install `django-filter`.\n\nThen add `'django_filters'` to Django's `INSTALLED_APPS`:\n\nYou should now either add the filter backend to your settings:\n\nOr add the filter backend to an individual View or ViewSet.\n\nIf all you need is simple equality-based filtering, you can set a\n`filterset_fields` attribute on the view, or viewset, listing the set of\nfields you wish to filter against.\n\nThis will automatically create a `FilterSet` class for the given fields, and\nwill allow you to make requests such as:\n\nFor more advanced filtering requirements you can specify a `FilterSet` class\nthat should be used by the view. You can read more about `FilterSet`s in the\ndjango-filter documentation. It's also recommended that you read the section\non DRF integration.\n\nThe `SearchFilter` class supports simple single query parameter based\nsearching, and is based on the Django admin's search functionality.\n\nWhen in use, the browsable API will include a `SearchFilter` control:\n\nThe `SearchFilter` class will only be applied if the view has a\n`search_fields` attribute set. The `search_fields` attribute should be a list\nof names of text type fields on the model, such as `CharField` or `TextField`.\n\nThis will allow the client to filter the items in the list by making queries\nsuch as:\n\nYou can also perform a related lookup on a ForeignKey or ManyToManyField with\nthe lookup API double-underscore notation:\n\nFor JSONField and HStoreField fields you can filter based on nested values\nwithin the data structure using the same double-underscore notation:\n\nBy default, searches will use case-insensitive partial matches. The search\nparameter may contain multiple search terms, which should be whitespace and/or\ncomma separated. If multiple search terms are used then objects will be\nreturned in the list only if all the provided terms are matched.\n\nThe search behavior may be restricted by prepending various characters to the\n`search_fields`.\n\nFor example:\n\nBy default, the search parameter is named `'search'`, but this may be\noverridden with the `SEARCH_PARAM` setting.\n\nTo dynamically change search fields based on request content, it's possible to\nsubclass the `SearchFilter` and override the `get_search_fields()` function.\nFor example, the following subclass will only search on `title` if the query\nparameter `title_only` is in the request:\n\nFor more details, see the Django documentation.\n\nThe `OrderingFilter` class supports simple query parameter controlled ordering\nof results.\n\nBy default, the query parameter is named `'ordering'`, but this may by\noverridden with the `ORDERING_PARAM` setting.\n\nFor example, to order users by username:\n\nThe client may also specify reverse orderings by prefixing the field name with\n'-', like so:\n\nMultiple orderings may also be specified:\n\nIt's recommended that you explicitly specify which fields the API should\nallowing in the ordering filter. You can do this by setting an\n`ordering_fields` attribute on the view, like so:\n\nThis helps prevent unexpected data leakage, such as allowing users to order\nagainst a password hash field or other sensitive data.\n\nIf you don't specify an `ordering_fields` attribute on the view, the filter\nclass will default to allowing the user to filter on any readable fields on\nthe serializer specified by the `serializer_class` attribute.\n\nIf you are confident that the queryset being used by the view doesn't contain\nany sensitive data, you can also explicitly specify that a view should allow\nordering on any model field or queryset aggregate, by using the special value\n`'__all__'`.\n\nIf an `ordering` attribute is set on the view, this will be used as the\ndefault ordering.\n\nTypically you'd instead control this by setting `order_by` on the initial\nqueryset, but using the `ordering` parameter on the view allows you to specify\nthe ordering in a way that it can then be passed automatically as context to a\nrendered template. This makes it possible to automatically render column\nheaders differently if they are being used to order the results.\n\nThe `ordering` attribute may be either a string or a list/tuple of strings.\n\nYou can also provide your own generic filtering backend, or write an\ninstallable app for other developers to use.\n\nTo do so override `BaseFilterBackend`, and override the\n`.filter_queryset(self, request, queryset, view)` method. The method should\nreturn a new, filtered queryset.\n\nAs well as allowing clients to perform searches and filtering, generic filter\nbackends can be useful for restricting which objects should be visible to any\ngiven request or user.\n\nFor example, you might need to restrict users to only being able to see\nobjects they created.\n\nWe could achieve the same behavior by overriding `get_queryset()` on the\nviews, but using a filter backend allows you to more easily add this\nrestriction to multiple views, or to apply it across the entire API.\n\nGeneric filters may also present an interface in the browsable API. To do so\nyou should implement a `to_html()` method which returns a rendered HTML\nrepresentation of the filter. This method should have the following signature:\n\n`to_html(self, request, queryset, view)`\n\nThe method should return a rendered HTML string.\n\nYou can also make the filter controls available to the schema autogeneration\nthat REST framework provides, by implementing a `get_schema_fields()` method.\nThis method should have the following signature:\n\n`get_schema_fields(self, view)`\n\nThe method should return a list of `coreapi.Field` instances.\n\nThe following third party packages provide additional filter implementations.\n\nThe django-rest-framework-filters package works together with the\n`DjangoFilterBackend` class, and allows you to easily create filters across\nrelationships, or create multiple filter lookup types for a given field.\n\nThe djangorestframework-word-filter developed as alternative to\n`filters.SearchFilter` which will search full word in text, or exact match.\n\ndjango-url-filter provides a safe way to filter data via human-friendly URLs.\nIt works very similar to DRF serializers and fields in a sense that they can\nbe nested except they are called filtersets and filters. That provides easy\nway to filter related data. Also this library is generic-purpose so it can be\nused to filter other sources of data and not only Django `QuerySet`s.\n\ndrf-url-filter is a simple Django app to apply filters on drf `ModelViewSet`'s\n`Queryset` in a clean, simple and configurable way. It also supports\nvalidations on incoming query params and their values. A beautiful python\npackage `Voluptuous` is being used for validations on the incoming query\nparameters. The best part about voluptuous is you can define your own\nvalidations as per your query params requirements.\n\nfilters.py\n\n"}, {"name": "PageNumberPagination", "path": "api-guide/pagination/index#pagenumberpagination", "type": "Ref: Pagination", "text": "\nDjango provides a few classes that help you manage paginated data \u2013 that is,\ndata that\u2019s split across several pages, with \u201cPrevious/Next\u201d links.\n\n\u2014 Django documentation\n\nREST framework includes support for customizable pagination styles. This\nallows you to modify how large result sets are split into individual pages of\ndata.\n\nThe pagination API can support either:\n\nThe built-in styles currently all use links included as part of the content of\nthe response. This style is more accessible when using the browsable API.\n\nPagination is only performed automatically if you're using the generic views\nor viewsets. If you're using a regular `APIView`, you'll need to call into the\npagination API yourself to ensure you return a paginated response. See the\nsource code for the `mixins.ListModelMixin` and `generics.GenericAPIView`\nclasses for an example.\n\nPagination can be turned off by setting the pagination class to `None`.\n\nThe pagination style may be set globally, using the `DEFAULT_PAGINATION_CLASS`\nand `PAGE_SIZE` setting keys. For example, to use the built-in limit/offset\npagination, you would do something like this:\n\nNote that you need to set both the pagination class, and the page size that\nshould be used. Both `DEFAULT_PAGINATION_CLASS` and `PAGE_SIZE` are `None` by\ndefault.\n\nYou can also set the pagination class on an individual view by using the\n`pagination_class` attribute. Typically you'll want to use the same pagination\nstyle throughout your API, although you might want to vary individual aspects\nof the pagination, such as default or maximum page size, on a per-view basis.\n\nIf you want to modify particular aspects of the pagination style, you'll want\nto override one of the pagination classes, and set the attributes that you\nwant to change.\n\nYou can then apply your new style to a view using the `pagination_class`\nattribute:\n\nOr apply the style globally, using the `DEFAULT_PAGINATION_CLASS` settings\nkey. For example:\n\nThis pagination style accepts a single number page number in the request query\nparameters.\n\nRequest:\n\nResponse:\n\nTo enable the `PageNumberPagination` style globally, use the following\nconfiguration, and set the `PAGE_SIZE` as desired:\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `PageNumberPagination` on a per-view basis.\n\nThe `PageNumberPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `PageNumberPagination` class,\nand then enable your custom pagination class as above.\n\nThis pagination style mirrors the syntax used when looking up multiple\ndatabase records. The client includes both a \"limit\" and an \"offset\" query\nparameter. The limit indicates the maximum number of items to return, and is\nequivalent to the `page_size` in other styles. The offset indicates the\nstarting position of the query in relation to the complete set of unpaginated\nitems.\n\nRequest:\n\nResponse:\n\nTo enable the `LimitOffsetPagination` style globally, use the following\nconfiguration:\n\nOptionally, you may also set a `PAGE_SIZE` key. If the `PAGE_SIZE` parameter\nis also used then the `limit` query parameter will be optional, and may be\nomitted by the client.\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `LimitOffsetPagination` on a per-view basis.\n\nThe `LimitOffsetPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `LimitOffsetPagination` class,\nand then enable your custom pagination class as above.\n\nThe cursor-based pagination presents an opaque \"cursor\" indicator that the\nclient may use to page through the result set. This pagination style only\npresents forward and reverse controls, and does not allow the client to\nnavigate to arbitrary positions.\n\nCursor based pagination requires that there is a unique, unchanging ordering\nof items in the result set. This ordering might typically be a creation\ntimestamp on the records, as this presents a consistent ordering to paginate\nagainst.\n\nCursor based pagination is more complex than other schemes. It also requires\nthat the result set presents a fixed ordering, and does not allow the client\nto arbitrarily index into the result set. However it does provide the\nfollowing benefits:\n\nProper use of cursor based pagination requires a little attention to detail.\nYou'll need to think about what ordering you want the scheme to be applied\nagainst. The default is to order by `\"-created\"`. This assumes that there must\nbe a 'created' timestamp field on the model instances, and will present a\n\"timeline\" style paginated view, with the most recently added items first.\n\nYou can modify the ordering by overriding the `'ordering'` attribute on the\npagination class, or by using the `OrderingFilter` filter class together with\n`CursorPagination`. When used with `OrderingFilter` you should strongly\nconsider restricting the fields that the user may order by.\n\nProper usage of cursor pagination should have an ordering field that satisfies\nthe following:\n\nUsing an ordering field that does not satisfy these constraints will generally\nstill work, but you'll be losing some of the benefits of cursor pagination.\n\nFor more technical details on the implementation we use for cursor pagination,\nthe \"Building cursors for the Disqus API\" blog post gives a good overview of\nthe basic approach.\n\nTo enable the `CursorPagination` style globally, use the following\nconfiguration, modifying the `PAGE_SIZE` as desired:\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `CursorPagination` on a per-view basis.\n\nThe `CursorPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `CursorPagination` class, and\nthen enable your custom pagination class as above.\n\nTo create a custom pagination serializer class, you should inherit the\nsubclass `pagination.BasePagination`, override the `paginate_queryset(self,\nqueryset, request, view=None)`, and `get_paginated_response(self, data)`\nmethods:\n\nNote that the `paginate_queryset` method may set state on the pagination\ninstance, that may later be used by the `get_paginated_response` method.\n\nSuppose we want to replace the default pagination output style with a modified\nformat that includes the next and previous links under in a nested 'links'\nkey. We could specify a custom pagination class like so:\n\nWe'd then need to setup the custom class in our configuration:\n\nNote that if you care about how the ordering of keys is displayed in responses\nin the browsable API you might choose to use an `OrderedDict` when\nconstructing the body of paginated responses, but this is optional.\n\nTo have your custom pagination class be used by default, use the\n`DEFAULT_PAGINATION_CLASS` setting:\n\nAPI responses for list endpoints will now include a `Link` header, instead of\nincluding the pagination links as part of the body of the response, for\nexample:\n\nA custom pagination style, using the 'Link' header'\n\nYou can also make the pagination controls available to the schema\nautogeneration that REST framework provides, by implementing a\n`get_schema_fields()` method. This method should have the following signature:\n\n`get_schema_fields(self, view)`\n\nThe method should return a list of `coreapi.Field` instances.\n\nBy default using the pagination classes will cause HTML pagination controls to\nbe displayed in the browsable API. There are two built-in display styles. The\n`PageNumberPagination` and `LimitOffsetPagination` classes display a list of\npage numbers with previous and next controls. The `CursorPagination` class\ndisplays a simpler style that only displays a previous and next control.\n\nYou can override the templates that render the HTML pagination controls. The\ntwo built-in styles are:\n\nProviding a template with either of these paths in a global template directory\nwill override the default rendering for the relevant pagination classes.\n\nAlternatively you can disable HTML pagination controls completely by\nsubclassing on of the existing classes, setting `template = None` as an\nattribute on the class. You'll then need to configure your\n`DEFAULT_PAGINATION_CLASS` settings key to use your custom class as the\ndefault pagination style.\n\nThe low-level API for determining if a pagination class should display the\ncontrols or not is exposed as a `display_page_controls` attribute on the\npagination instance. Custom pagination classes should be set to `True` in the\n`paginate_queryset` method if they require the HTML pagination controls to be\ndisplayed.\n\nThe `.to_html()` and `.get_html_context()` methods may also be overridden in a\ncustom pagination class in order to further customize how the controls are\nrendered.\n\nThe following third party packages are also available.\n\nThe `DRF-extensions` package includes a `PaginateByMaxMixin` mixin class that\nallows your API clients to specify `?page_size=max` to obtain the maximum\nallowed page size.\n\nThe `drf-proxy-pagination` package includes a `ProxyPagination` class which\nallows to choose pagination class with a query parameter.\n\nThe `django-rest-framework-link-header-pagination` package includes a\n`LinkHeaderPagination` class which provides pagination via an HTTP `Link`\nheader as described in Github's developer documentation.\n\npagination.py\n\n"}, {"name": "Pagination", "path": "api-guide/pagination/index", "type": "API Guide", "text": "\nDjango provides a few classes that help you manage paginated data \u2013 that is,\ndata that\u2019s split across several pages, with \u201cPrevious/Next\u201d links.\n\n\u2014 Django documentation\n\nREST framework includes support for customizable pagination styles. This\nallows you to modify how large result sets are split into individual pages of\ndata.\n\nThe pagination API can support either:\n\nThe built-in styles currently all use links included as part of the content of\nthe response. This style is more accessible when using the browsable API.\n\nPagination is only performed automatically if you're using the generic views\nor viewsets. If you're using a regular `APIView`, you'll need to call into the\npagination API yourself to ensure you return a paginated response. See the\nsource code for the `mixins.ListModelMixin` and `generics.GenericAPIView`\nclasses for an example.\n\nPagination can be turned off by setting the pagination class to `None`.\n\nThe pagination style may be set globally, using the `DEFAULT_PAGINATION_CLASS`\nand `PAGE_SIZE` setting keys. For example, to use the built-in limit/offset\npagination, you would do something like this:\n\nNote that you need to set both the pagination class, and the page size that\nshould be used. Both `DEFAULT_PAGINATION_CLASS` and `PAGE_SIZE` are `None` by\ndefault.\n\nYou can also set the pagination class on an individual view by using the\n`pagination_class` attribute. Typically you'll want to use the same pagination\nstyle throughout your API, although you might want to vary individual aspects\nof the pagination, such as default or maximum page size, on a per-view basis.\n\nIf you want to modify particular aspects of the pagination style, you'll want\nto override one of the pagination classes, and set the attributes that you\nwant to change.\n\nYou can then apply your new style to a view using the `pagination_class`\nattribute:\n\nOr apply the style globally, using the `DEFAULT_PAGINATION_CLASS` settings\nkey. For example:\n\nThis pagination style accepts a single number page number in the request query\nparameters.\n\nRequest:\n\nResponse:\n\nTo enable the `PageNumberPagination` style globally, use the following\nconfiguration, and set the `PAGE_SIZE` as desired:\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `PageNumberPagination` on a per-view basis.\n\nThe `PageNumberPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `PageNumberPagination` class,\nand then enable your custom pagination class as above.\n\nThis pagination style mirrors the syntax used when looking up multiple\ndatabase records. The client includes both a \"limit\" and an \"offset\" query\nparameter. The limit indicates the maximum number of items to return, and is\nequivalent to the `page_size` in other styles. The offset indicates the\nstarting position of the query in relation to the complete set of unpaginated\nitems.\n\nRequest:\n\nResponse:\n\nTo enable the `LimitOffsetPagination` style globally, use the following\nconfiguration:\n\nOptionally, you may also set a `PAGE_SIZE` key. If the `PAGE_SIZE` parameter\nis also used then the `limit` query parameter will be optional, and may be\nomitted by the client.\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `LimitOffsetPagination` on a per-view basis.\n\nThe `LimitOffsetPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `LimitOffsetPagination` class,\nand then enable your custom pagination class as above.\n\nThe cursor-based pagination presents an opaque \"cursor\" indicator that the\nclient may use to page through the result set. This pagination style only\npresents forward and reverse controls, and does not allow the client to\nnavigate to arbitrary positions.\n\nCursor based pagination requires that there is a unique, unchanging ordering\nof items in the result set. This ordering might typically be a creation\ntimestamp on the records, as this presents a consistent ordering to paginate\nagainst.\n\nCursor based pagination is more complex than other schemes. It also requires\nthat the result set presents a fixed ordering, and does not allow the client\nto arbitrarily index into the result set. However it does provide the\nfollowing benefits:\n\nProper use of cursor based pagination requires a little attention to detail.\nYou'll need to think about what ordering you want the scheme to be applied\nagainst. The default is to order by `\"-created\"`. This assumes that there must\nbe a 'created' timestamp field on the model instances, and will present a\n\"timeline\" style paginated view, with the most recently added items first.\n\nYou can modify the ordering by overriding the `'ordering'` attribute on the\npagination class, or by using the `OrderingFilter` filter class together with\n`CursorPagination`. When used with `OrderingFilter` you should strongly\nconsider restricting the fields that the user may order by.\n\nProper usage of cursor pagination should have an ordering field that satisfies\nthe following:\n\nUsing an ordering field that does not satisfy these constraints will generally\nstill work, but you'll be losing some of the benefits of cursor pagination.\n\nFor more technical details on the implementation we use for cursor pagination,\nthe \"Building cursors for the Disqus API\" blog post gives a good overview of\nthe basic approach.\n\nTo enable the `CursorPagination` style globally, use the following\nconfiguration, modifying the `PAGE_SIZE` as desired:\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class`\nattribute to select `CursorPagination` on a per-view basis.\n\nThe `CursorPagination` class includes a number of attributes that may be\noverridden to modify the pagination style.\n\nTo set these attributes you should override the `CursorPagination` class, and\nthen enable your custom pagination class as above.\n\nTo create a custom pagination serializer class, you should inherit the\nsubclass `pagination.BasePagination`, override the `paginate_queryset(self,\nqueryset, request, view=None)`, and `get_paginated_response(self, data)`\nmethods:\n\nNote that the `paginate_queryset` method may set state on the pagination\ninstance, that may later be used by the `get_paginated_response` method.\n\nSuppose we want to replace the default pagination output style with a modified\nformat that includes the next and previous links under in a nested 'links'\nkey. We could specify a custom pagination class like so:\n\nWe'd then need to setup the custom class in our configuration:\n\nNote that if you care about how the ordering of keys is displayed in responses\nin the browsable API you might choose to use an `OrderedDict` when\nconstructing the body of paginated responses, but this is optional.\n\nTo have your custom pagination class be used by default, use the\n`DEFAULT_PAGINATION_CLASS` setting:\n\nAPI responses for list endpoints will now include a `Link` header, instead of\nincluding the pagination links as part of the body of the response, for\nexample:\n\nA custom pagination style, using the 'Link' header'\n\nYou can also make the pagination controls available to the schema\nautogeneration that REST framework provides, by implementing a\n`get_schema_fields()` method. This method should have the following signature:\n\n`get_schema_fields(self, view)`\n\nThe method should return a list of `coreapi.Field` instances.\n\nBy default using the pagination classes will cause HTML pagination controls to\nbe displayed in the browsable API. There are two built-in display styles. The\n`PageNumberPagination` and `LimitOffsetPagination` classes display a list of\npage numbers with previous and next controls. The `CursorPagination` class\ndisplays a simpler style that only displays a previous and next control.\n\nYou can override the templates that render the HTML pagination controls. The\ntwo built-in styles are:\n\nProviding a template with either of these paths in a global template directory\nwill override the default rendering for the relevant pagination classes.\n\nAlternatively you can disable HTML pagination controls completely by\nsubclassing on of the existing classes, setting `template = None` as an\nattribute on the class. You'll then need to configure your\n`DEFAULT_PAGINATION_CLASS` settings key to use your custom class as the\ndefault pagination style.\n\nThe low-level API for determining if a pagination class should display the\ncontrols or not is exposed as a `display_page_controls` attribute on the\npagination instance. Custom pagination classes should be set to `True` in the\n`paginate_queryset` method if they require the HTML pagination controls to be\ndisplayed.\n\nThe `.to_html()` and `.get_html_context()` methods may also be overridden in a\ncustom pagination class in order to further customize how the controls are\nrendered.\n\nThe following third party packages are also available.\n\nThe `DRF-extensions` package includes a `PaginateByMaxMixin` mixin class that\nallows your API clients to specify `?page_size=max` to obtain the maximum\nallowed page size.\n\nThe `drf-proxy-pagination` package includes a `ProxyPagination` class which\nallows to choose pagination class with a query parameter.\n\nThe `django-rest-framework-link-header-pagination` package includes a\n`LinkHeaderPagination` class which provides pagination via an HTTP `Link`\nheader as described in Github's developer documentation.\n\npagination.py\n\n"}, {"name": "ParseError", "path": "api-guide/exceptions/index#parseerror", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "Parsers", "path": "api-guide/parsers/index", "type": "API Guide", "text": "\nMachine interacting web services tend to use more structured formats for\nsending data than form-encoded, since they're sending more complex data than\nsimple forms\n\n\u2014 Malcom Tredinnick, Django developers group\n\nREST framework includes a number of built in Parser classes, that allow you to\naccept requests with various media types. There is also support for defining\nyour own custom parsers, which gives you the flexibility to design the media\ntypes that your API accepts.\n\nThe set of valid parsers for a view is always defined as a list of classes.\nWhen `request.data` is accessed, REST framework will examine the `Content-\nType` header on the incoming request, and determine which parser to use to\nparse the request content.\n\nNote: When developing client applications always remember to make sure you're\nsetting the `Content-Type` header when sending data in an HTTP request.\n\nIf you don't set the content type, most clients will default to using\n`'application/x-www-form-urlencoded'`, which may not be what you wanted.\n\nAs an example, if you are sending `json` encoded data using jQuery with the\n.ajax() method, you should make sure to include the `contentType:\n'application/json'` setting.\n\nThe default set of parsers may be set globally, using the\n`DEFAULT_PARSER_CLASSES` setting. For example, the following settings would\nallow only requests with `JSON` content, instead of the default of JSON or\nform data.\n\nYou can also set the parsers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nParses `JSON` request content. `request.data` will be populated with a\ndictionary of data.\n\n.media_type: `application/json`\n\nParses HTML form content. `request.data` will be populated with a `QueryDict`\nof data.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `application/x-www-form-urlencoded`\n\nParses multipart HTML form content, which supports file uploads. Both\n`request.data` will be populated with a `QueryDict`.\n\nYou will typically want to use both `FormParser` and `MultiPartParser`\ntogether in order to fully support HTML form data.\n\n.media_type: `multipart/form-data`\n\nParses raw file upload content. The `request.data` property will be a\ndictionary with a single key `'file'` containing the uploaded file.\n\nIf the view used with `FileUploadParser` is called with a `filename` URL\nkeyword argument, then that argument will be used as the filename.\n\nIf it is called without a `filename` URL keyword argument, then the client\nmust set the filename in the `Content-Disposition` HTTP header. For example\n`Content-Disposition: attachment; filename=upload.jpg`.\n\n.media_type: `*/*`\n\nTo implement a custom parser, you should override `BaseParser`, set the\n`.media_type` property, and implement the `.parse(self, stream, media_type,\nparser_context)` method.\n\nThe method should return the data that will be used to populate the\n`request.data` property.\n\nThe arguments passed to `.parse()` are:\n\nA stream-like object representing the body of the request.\n\nOptional. If provided, this is the media type of the incoming request content.\n\nDepending on the request's `Content-Type:` header, this may be more specific\nthan the renderer's `media_type` attribute, and may include media type\nparameters. For example `\"text/plain; charset=utf-8\"`.\n\nOptional. If supplied, this argument will be a dictionary containing any\nadditional context that may be required to parse the request content.\n\nBy default this will include the following keys: `view`, `request`, `args`,\n`kwargs`.\n\nThe following is an example plaintext parser that will populate the\n`request.data` property with a string representing the body of the request.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nparsers.py\n\n"}, {"name": "PermissionDenied", "path": "api-guide/exceptions/index#permissiondenied", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "Permissions", "path": "api-guide/permissions/index", "type": "API Guide", "text": "\nAuthentication or identification by itself is not usually sufficient to gain\naccess to information or code. For that, the entity requesting access must\nhave authorization.\n\n\u2014 Apple Developer Documentation\n\nTogether with authentication and throttling, permissions determine whether a\nrequest should be granted or denied access.\n\nPermission checks are always run at the very start of the view, before any\nother code is allowed to proceed. Permission checks will typically use the\nauthentication information in the `request.user` and `request.auth` properties\nto determine if the incoming request should be permitted.\n\nPermissions are used to grant or deny access for different classes of users to\ndifferent parts of the API.\n\nThe simplest style of permission would be to allow access to any authenticated\nuser, and deny access to any unauthenticated user. This corresponds to the\n`IsAuthenticated` class in REST framework.\n\nA slightly less strict style of permission would be to allow full access to\nauthenticated users, but allow read-only access to unauthenticated users. This\ncorresponds to the `IsAuthenticatedOrReadOnly` class in REST framework.\n\nPermissions in REST framework are always defined as a list of permission\nclasses.\n\nBefore running the main body of the view each permission in the list is\nchecked. If any permission check fails an `exceptions.PermissionDenied` or\n`exceptions.NotAuthenticated` exception will be raised, and the main body of\nthe view will not run.\n\nWhen the permissions checks fail either a \"403 Forbidden\" or a \"401\nUnauthorized\" response will be returned, according to the following rules:\n\nREST framework permissions also support object-level permissioning. Object\nlevel permissions are used to determine if a user should be allowed to act on\na particular object, which will typically be a model instance.\n\nObject level permissions are run by REST framework's generic views when\n`.get_object()` is called. As with view level permissions, an\n`exceptions.PermissionDenied` exception will be raised if the user is not\nallowed to act on the given object.\n\nIf you're writing your own views and want to enforce object level permissions,\nor if you override the `get_object` method on a generic view, then you'll need\nto explicitly call the `.check_object_permissions(request, obj)` method on the\nview at the point at which you've retrieved the object.\n\nThis will either raise a `PermissionDenied` or `NotAuthenticated` exception,\nor simply return if the view has the appropriate permissions.\n\nFor example:\n\nNote: With the exception of `DjangoObjectPermissions`, the provided permission\nclasses in `rest_framework.permissions` do not implement the methods necessary\nto check object permissions.\n\nIf you wish to use the provided permission classes in order to check object\npermissions, you must subclass them and implement the\n`has_object_permission()` method described in the Custom permissions section\n(below).\n\nFor performance reasons the generic views will not automatically apply object\nlevel permissions to each instance in a queryset when returning a list of\nobjects.\n\nOften when you're using object level permissions you'll also want to filter\nthe queryset appropriately, to ensure that users only have visibility onto\ninstances that they are permitted to view.\n\nBecause the `get_object()` method is not called, object level permissions from\nthe `has_object_permission()` method are not applied when creating objects. In\norder to restrict object creation you need to implement the permission check\neither in your Serializer class or override the `perform_create()` method of\nyour ViewSet class.\n\nThe default permission policy may be set globally, using the\n`DEFAULT_PERMISSION_CLASSES` setting. For example.\n\nIf not specified, this setting defaults to allowing unrestricted access:\n\nYou can also set the authentication policy on a per-view, or per-viewset\nbasis, using the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nNote: when you set new permission classes via the class attribute or\ndecorators you're telling the view to ignore the default list set in the\nsettings.py file.\n\nProvided they inherit from `rest_framework.permissions.BasePermission`,\npermissions can be composed using standard Python bitwise operators. For\nexample, `IsAuthenticatedOrReadOnly` could be written:\n\nNote: it supports & (and), | (or) and ~ (not).\n\nThe `AllowAny` permission class will allow unrestricted access, regardless of\nif the request was authenticated or unauthenticated.\n\nThis permission is not strictly required, since you can achieve the same\nresult by using an empty list or tuple for the permissions setting, but you\nmay find it useful to specify this class because it makes the intention\nexplicit.\n\nThe `IsAuthenticated` permission class will deny permission to any\nunauthenticated user, and allow permission otherwise.\n\nThis permission is suitable if you want your API to only be accessible to\nregistered users.\n\nThe `IsAdminUser` permission class will deny permission to any user, unless\n`user.is_staff` is `True` in which case permission will be allowed.\n\nThis permission is suitable if you want your API to only be accessible to a\nsubset of trusted administrators.\n\nThe `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any\nrequest. Requests for unauthorised users will only be permitted if the request\nmethod is one of the \"safe\" methods; `GET`, `HEAD` or `OPTIONS`.\n\nThis permission is suitable if you want to your API to allow read permissions\nto anonymous users, and only allow write permissions to authenticated users.\n\nThis permission class ties into Django's standard `django.contrib.auth` model\npermissions. This permission must only be applied to views that have a\n`.queryset` property or `get_queryset()` method. Authorization will only be\ngranted if the user is authenticated and has the relevant model permissions\nassigned.\n\nThe default behaviour can also be overridden to support custom model\npermissions. For example, you might want to include a `view` model permission\nfor `GET` requests.\n\nTo use custom model permissions, override `DjangoModelPermissions` and set the\n`.perms_map` property. Refer to the source code for details.\n\nSimilar to `DjangoModelPermissions`, but also allows unauthenticated users to\nhave read-only access to the API.\n\nThis permission class ties into Django's standard object permissions framework\nthat allows per-object permissions on models. In order to use this permission\nclass, you'll also need to add a permission backend that supports object-level\npermissions, such as django-guardian.\n\nAs with `DjangoModelPermissions`, this permission must only be applied to\nviews that have a `.queryset` property or `.get_queryset()` method.\nAuthorization will only be granted if the user is authenticated and has the\nrelevant per-object permissions and relevant model permissions assigned.\n\nNote that `DjangoObjectPermissions` does not require the `django-guardian`\npackage, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by\noverriding `DjangoObjectPermissions` and setting the `.perms_map` property.\nRefer to the source code for details.\n\nNote: If you need object level `view` permissions for `GET`, `HEAD` and\n`OPTIONS` requests and are using django-guardian for your object-level\npermissions backend, you'll want to consider using the\n`DjangoObjectPermissionsFilter` class provided by the `djangorestframework-\nguardian` package. It ensures that list endpoints only return results\nincluding objects for which the user has appropriate view permissions.\n\nTo implement a custom permission, override `BasePermission` and implement\neither, or both, of the following methods:\n\nThe methods should return `True` if the request should be granted access, and\n`False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you\nshould check the request method against the constant `SAFE_METHODS`, which is\na tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\nNote: The instance-level `has_object_permission` method will only be called if\nthe view-level `has_permission` checks have already passed. Also note that in\norder for the instance-level checks to run, the view code should explicitly\ncall `.check_object_permissions(request, obj)`. If you are using the generic\nviews then this will be handled for you by default. (Function-based views will\nneed to check object permissions explicitly, raising `PermissionDenied` on\nfailure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test\nfails. To change the error message associated with the exception, implement a\n`message` attribute directly on your custom permission. Otherwise the\n`default_detail` attribute from `PermissionDenied` will be used. Similarly, to\nchange the code identifier associated with the exception, implement a `code`\nattribute directly on your custom permission - otherwise the `default_code`\nattribute from `PermissionDenied` will be used.\n\nThe following is an example of a permission class that checks the incoming\nrequest's IP address against a blocklist, and denies the request if the IP has\nbeen blocked.\n\nAs well as global permissions, that are run against all incoming requests, you\ncan also create object-level permissions, that are only run against operations\nthat affect a particular object instance. For example:\n\nNote that the generic views will check the appropriate object level\npermissions, but if you're writing your own custom views, you'll need to make\nsure you check the object level permission checks yourself. You can do so by\ncalling `self.check_object_permissions(request, obj)` from the view once you\nhave the object instance. This call will raise an appropriate `APIException`\nif any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions\nfor views that retrieve a single model instance. If you require object-level\nfiltering of list views, you'll need to filter the queryset separately. See\nthe filtering documentation for more details.\n\nREST framework offers three different methods to customize access restrictions\non a case-by-case basis. These apply in different scenarios and have different\neffects and limitations.\n\nThe following table lists the access restriction methods and the level of\ncontrol they offer over which actions.\n\n* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.   \n** The `get_*()` methods have access to the current view and can return\ndifferent Serializer or QuerySet instances based on the request or action.\n\nThe following third party packages are also available.\n\nThe Django REST - Access Policy package provides a way to define complex\naccess rules in declarative policy classes that are attached to view sets or\nfunction-based views. The policies are defined in JSON in a format similar to\nAWS' Identity & Access Management policies.\n\nThe Composed Permissions package provides a simple way to define complex and\nmulti-depth (with logic operators) permission objects, using small and\nreusable components.\n\nThe REST Condition package is another extension for building complex\npermissions in a simple and convenient way. The extension allows you to\ncombine permissions with logical operators.\n\nThe DRY Rest Permissions package provides the ability to define different\npermissions for individual default and custom actions. This package is made\nfor apps with permissions that are derived from relationships defined in the\napp's data model. It also supports permission checks being returned to a\nclient app through the API's serializer. Additionally it supports adding\npermissions to the default and custom list actions to restrict the data they\nretrieve per user.\n\nThe Django Rest Framework Roles package makes it easier to parameterize your\nAPI over multiple types of users.\n\nThe Django REST Framework API Key package provides permissions classes, models\nand helpers to add API key authorization to your API. It can be used to\nauthorize internal or third-party backends and services (i.e. machines) which\ndo not have a user account. API keys are stored securely using Django's\npassword hashing infrastructure, and they can be viewed, edited and revoked at\nanytime in the Django admin.\n\nThe Django Rest Framework Role Filters package provides simple filtering over\nmultiple types of roles.\n\nThe Django Rest Framework PSQ package is an extension that gives support for\nhaving action-based permission_classes, serializer_class, and queryset\ndependent on permission-based rules.\n\npermissions.py\n\n"}, {"name": "PrimaryKeyRelatedField", "path": "api-guide/relations/index#primarykeyrelatedfield", "type": "Ref: Serializer relations", "text": "\nData structures, not algorithms, are central to programming.\n\n\u2014 Rob Pike\n\nRelational fields are used to represent model relationships. They can be\napplied to `ForeignKey`, `ManyToManyField` and `OneToOneField` relationships,\nas well as to reverse relationships, and custom relationships such as\n`GenericForeignKey`.\n\nNote: The relational fields are declared in `relations.py`, but by convention\nyou should import them from the `serializers` module, using `from\nrest_framework import serializers` and refer to fields as\n`serializers.<FieldName>`.\n\nWhen using the `ModelSerializer` class, serializer fields and relationships\nwill be automatically generated for you. Inspecting these automatically\ngenerated fields can be a useful tool for determining how to customize the\nrelationship style.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIn order to explain the various types of relational fields, we'll use a couple\nof simple models for our examples. Our models will be for music albums, and\nthe tracks listed on each album.\n\n`StringRelatedField` may be used to represent the target of the relationship\nusing its `__str__` method.\n\nFor example, the following serializer:\n\nWould serialize to the following representation:\n\nThis field is read only.\n\nArguments:\n\n`PrimaryKeyRelatedField` may be used to represent the target of the\nrelationship using its primary key.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nArguments:\n\n`HyperlinkedRelatedField` may be used to represent the target of the\nrelationship using a hyperlink.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nNote: This field is designed for objects that map to a URL that accepts a\nsingle URL keyword argument, as set using the `lookup_field` and\n`lookup_url_kwarg` arguments.\n\nThis is suitable for URLs that contain a single primary key or slug argument\nas part of the URL.\n\nIf you require more complex hyperlinked representation you'll need to\ncustomize the field, as described in the custom hyperlinked fields section,\nbelow.\n\nArguments:\n\n`SlugRelatedField` may be used to represent the target of the relationship\nusing a field on the target.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nWhen using `SlugRelatedField` as a read-write field, you will normally want to\nensure that the slug field corresponds to a model field with `unique=True`.\n\nArguments:\n\nThis field can be applied as an identity relationship, such as the `'url'`\nfield on a HyperlinkedModelSerializer. It can also be used for an attribute on\nthe object. For example, the following serializer:\n\nWould serialize to a representation like this:\n\nThis field is always read-only.\n\nArguments:\n\nAs opposed to previously discussed references to another entity, the referred\nentity can instead also be embedded or nested in the representation of the\nobject that refers to it. Such nested relationships can be expressed by using\nserializers as fields.\n\nIf the field is used to represent a to-many relationship, you should add the\n`many=True` flag to the serializer field.\n\nFor example, the following serializer:\n\nWould serialize to a nested representation like this:\n\nBy default nested serializers are read-only. If you want to support write-\noperations to a nested serializer field you'll need to create `create()`\nand/or `update()` methods in order to explicitly specify how the child\nrelationships should be saved:\n\nIn rare cases where none of the existing relational styles fit the\nrepresentation you need, you can implement a completely custom relational\nfield, that describes exactly how the output representation should be\ngenerated from the model instance.\n\nTo implement a custom relational field, you should override `RelatedField`,\nand implement the `.to_representation(self, value)` method. This method takes\nthe target of the field as the `value` argument, and should return the\nrepresentation that should be used to serialize the target. The `value`\nargument will typically be a model instance.\n\nIf you want to implement a read-write relational field, you must also\nimplement the `.to_internal_value(self, data)` method.\n\nTo provide a dynamic queryset based on the `context`, you can also override\n`.get_queryset(self)` instead of specifying `.queryset` on the class or when\ninitializing the field.\n\nFor example, we could define a relational field to serialize a track to a\ncustom string representation, using its ordering, title, and duration:\n\nThis custom field would then serialize to the following representation:\n\nIn some cases you may need to customize the behavior of a hyperlinked field,\nin order to represent URLs that require more than a single lookup field.\n\nYou can achieve this by overriding `HyperlinkedRelatedField`. There are two\nmethods that may be overridden:\n\nget_url(self, obj, view_name, request, format)\n\nThe `get_url` method is used to map the object instance to its URL\nrepresentation.\n\nMay raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes\nare not configured to correctly match the URL conf.\n\nget_object(self, view_name, view_args, view_kwargs)\n\nIf you want to support a writable hyperlinked field then you'll also want to\noverride `get_object`, in order to map incoming URLs back to the object they\nrepresent. For read-only hyperlinked fields there is no need to override this\nmethod.\n\nThe return value of this method should the object that corresponds to the\nmatched URL conf arguments.\n\nMay raise an `ObjectDoesNotExist` exception.\n\nSay we have a URL for a customer object that takes two keyword arguments, like\nso:\n\nThis cannot be represented with the default implementation, which accepts only\na single lookup field.\n\nIn this case we'd need to override `HyperlinkedRelatedField` to get the\nbehavior we want:\n\nNote that if you wanted to use this style together with the generic views then\nyou'd also need to override `.get_object` on the view in order to get the\ncorrect lookup behavior.\n\nGenerally we recommend a flat style for API representations where possible,\nbut the nested URL style can also be reasonable when used in moderation.\n\nThe `queryset` argument is only ever required for writable relationship field,\nin which case it is used for performing the model instance lookup, that maps\nfrom the primitive user input, into a model instance.\n\nIn version 2.x a serializer class could sometimes automatically determine the\n`queryset` argument if a `ModelSerializer` class was being used.\n\nThis behavior is now replaced with always using an explicit `queryset`\nargument for writable relational fields.\n\nDoing so reduces the amount of hidden 'magic' that `ModelSerializer` provides,\nmakes the behavior of the field more clear, and ensures that it is trivial to\nmove between using the `ModelSerializer` shortcut, or using fully explicit\n`Serializer` classes.\n\nThe built-in `__str__` method of the model will be used to generate string\nrepresentations of the objects used to populate the `choices` property. These\nchoices are used to populate select HTML inputs in the browsable API.\n\nTo provide customized representations for such inputs, override\n`display_value()` of a `RelatedField` subclass. This method will receive a\nmodel object, and should return a string suitable for representing it. For\nexample:\n\nWhen rendered in the browsable API relational fields will default to only\ndisplaying a maximum of 1000 selectable items. If more items are present then\na disabled option with \"More than 1000 items\u2026\" will be displayed.\n\nThis behavior is intended to prevent a template from being unable to render in\nan acceptable timespan due to a very large number of relationships being\ndisplayed.\n\nThere are two keyword arguments you can use to control this behavior:\n\nYou can also control these globally using the settings `HTML_SELECT_CUTOFF`\nand `HTML_SELECT_CUTOFF_TEXT`.\n\nIn cases where the cutoff is being enforced you may want to instead use a\nplain input field in the HTML form. You can do so using the `style` keyword\nargument. For example:\n\nNote that reverse relationships are not automatically included by the\n`ModelSerializer` and `HyperlinkedModelSerializer` classes. To include a\nreverse relationship, you must explicitly add it to the fields list. For\nexample:\n\nYou'll normally want to ensure that you've set an appropriate `related_name`\nargument on the relationship, that you can use as the field name. For example:\n\nIf you have not set a related name for the reverse relationship, you'll need\nto use the automatically generated related name in the `fields` argument. For\nexample:\n\nSee the Django documentation on reverse relationships for more details.\n\nIf you want to serialize a generic foreign key, you need to define a custom\nfield, to determine explicitly how you want to serialize the targets of the\nrelationship.\n\nFor example, given the following model for a tag, which has a generic\nrelationship with other arbitrary models:\n\nAnd the following two models, which may have associated tags:\n\nWe could define a custom field that could be used to serialize tagged\ninstances, using the type of each instance to determine how it should be\nserialized:\n\nIf you need the target of the relationship to have a nested representation,\nyou can use the required serializers inside the `.to_representation()` method:\n\nNote that reverse generic keys, expressed using the `GenericRelation` field,\ncan be serialized using the regular relational field types, since the type of\nthe target in the relationship is always known.\n\nFor more information see the Django documentation on generic relations.\n\nBy default, relational fields that target a `ManyToManyField` with a `through`\nmodel specified are set to read-only.\n\nIf you explicitly specify a relational field pointing to a `ManyToManyField`\nwith a through model, be sure to set `read_only` to `True`.\n\nIf you wish to represent extra fields on a through model then you may\nserialize the through model as a nested object.\n\nThe following third party packages are also available.\n\nThe drf-nested-routers package provides routers and relationship fields for\nworking with nested resources.\n\nThe rest-framework-generic-relations library provides read/write serialization\nfor generic foreign keys.\n\nrelations.py\n\n"}, {"name": "QueryParameterVersioning", "path": "api-guide/versioning/index#queryparameterversioning", "type": "Ref: Versioning", "text": "\nVersioning an interface is just a \"polite\" way to kill deployed clients.\n\n\u2014 Roy Fielding.\n\nAPI versioning allows you to alter behavior between different clients. REST\nframework provides for a number of different versioning schemes.\n\nVersioning is determined by the incoming client request, and may either be\nbased on the request URL, or based on the request headers.\n\nThere are a number of valid approaches to approaching versioning. Non-\nversioned systems can also be appropriate, particularly if you're engineering\nfor very long-term systems with multiple clients outside of your control.\n\nWhen API versioning is enabled, the `request.version` attribute will contain a\nstring that corresponds to the version requested in the incoming client\nrequest.\n\nBy default, versioning is not enabled, and `request.version` will always\nreturn `None`.\n\nHow you vary the API behavior is up to you, but one example you might\ntypically want is to switch to a different serialization style in a newer\nversion. For example:\n\nThe `reverse` function included by REST framework ties in with the versioning\nscheme. You need to make sure to include the current `request` as a keyword\nargument, like so.\n\nThe above function will apply any URL transformations appropriate to the\nrequest version. For example:\n\nWhen using hyperlinked serialization styles together with a URL based\nversioning scheme make sure to include the request as context to the\nserializer.\n\nDoing so will allow any returned URLs to include the appropriate versioning.\n\nThe versioning scheme is defined by the `DEFAULT_VERSIONING_CLASS` settings\nkey.\n\nUnless it is explicitly set, the value for `DEFAULT_VERSIONING_CLASS` will be\n`None`. In this case the `request.version` attribute will always return\n`None`.\n\nYou can also set the versioning scheme on an individual view. Typically you\nwon't need to do this, as it makes more sense to have a single versioning\nscheme used globally. If you do need to do so, use the `versioning_class`\nattribute.\n\nThe following settings keys are also used to control versioning:\n\nYou can also set your versioning class plus those three values on a per-view\nor a per-viewset basis by defining your own versioning scheme and using the\n`default_version`, `allowed_versions` and `version_param` class variables. For\nexample, if you want to use `URLPathVersioning`:\n\nThis scheme requires the client to specify the version as part of the media\ntype in the `Accept` header. The version is included as a media type\nparameter, that supplements the main media type.\n\nHere's an example HTTP request using the accept header versioning style.\n\nIn the example request above `request.version` attribute would return the\nstring `'1.0'`.\n\nVersioning based on accept headers is generally considered as best practice,\nalthough other styles may be suitable depending on your client requirements.\n\nStrictly speaking the `json` media type is not specified as including\nadditional parameters. If you are building a well-specified public API you\nmight consider using a vendor media type. To do so, configure your renderers\nto use a JSON based renderer with a custom media type:\n\nYour client requests would now look like this:\n\nThis scheme requires the client to specify the version as part of the URL\npath.\n\nYour URL conf must include a pattern that matches the version with a\n`'version'` keyword argument, so that this information is available to the\nversioning scheme.\n\nTo the client, this scheme is the same as `URLPathVersioning`. The only\ndifference is how it is configured in your Django application, as it uses URL\nnamespacing, instead of URL keyword arguments.\n\nWith this scheme the `request.version` attribute is determined based on the\n`namespace` that matches the incoming request path.\n\nIn the following example we're giving a set of views two different possible\nURL prefixes, each under a different namespace:\n\nBoth `URLPathVersioning` and `NamespaceVersioning` are reasonable if you just\nneed a simple versioning scheme. The `URLPathVersioning` approach might be\nbetter suitable for small ad-hoc projects, and the `NamespaceVersioning` is\nprobably easier to manage for larger projects.\n\nThe hostname versioning scheme requires the client to specify the requested\nversion as part of the hostname in the URL.\n\nFor example the following is an HTTP request to the\n`http://v1.example.com/bookings/` URL:\n\nBy default this implementation expects the hostname to match this simple\nregular expression:\n\nNote that the first group is enclosed in brackets, indicating that this is the\nmatched portion of the hostname.\n\nThe `HostNameVersioning` scheme can be awkward to use in debug mode as you\nwill typically be accessing a raw IP address such as `127.0.0.1`. There are\nvarious online tutorials on how to access localhost with a custom subdomain\nwhich you may find helpful in this case.\n\nHostname based versioning can be particularly useful if you have requirements\nto route incoming requests to different servers based on the version, as you\ncan configure different DNS records for different API versions.\n\nThis scheme is a simple style that includes the version as a query parameter\nin the URL. For example:\n\nTo implement a custom versioning scheme, subclass `BaseVersioning` and\noverride the `.determine_version` method.\n\nThe following example uses a custom `X-API-Version` header to determine the\nrequested version.\n\nIf your versioning scheme is based on the request URL, you will also want to\nalter how versioned URLs are determined. In order to do so you should override\nthe `.reverse()` method on the class. See the source code for examples.\n\nversioning.py\n\n"}, {"name": "ReadOnlyField", "path": "api-guide/fields/index#readonlyfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "ReadOnlyModelViewSet", "path": "api-guide/viewsets/index#readonlymodelviewset", "type": "Ref: ViewSets", "text": "\nAfter routing has determined which controller to use for a request, your\ncontroller is responsible for making sense of the request and producing the\nappropriate output.\n\n\u2014 Ruby on Rails Documentation\n\nDjango REST framework allows you to combine the logic for a set of related\nviews in a single class, called a `ViewSet`. In other frameworks you may also\nfind conceptually similar implementations named something like 'Resources' or\n'Controllers'.\n\nA `ViewSet` class is simply a type of class-based View, that does not provide\nany method handlers such as `.get()` or `.post()`, and instead provides\nactions such as `.list()` and `.create()`.\n\nThe method handlers for a `ViewSet` are only bound to the corresponding\nactions at the point of finalizing the view, using the `.as_view()` method.\n\nTypically, rather than explicitly registering the views in a viewset in the\nurlconf, you'll register the viewset with a router class, that automatically\ndetermines the urlconf for you.\n\nLet's define a simple viewset that can be used to list or retrieve all the\nusers in the system.\n\nIf we need to, we can bind this viewset into two separate views, like so:\n\nTypically we wouldn't do this, but would instead register the viewset with a\nrouter, and allow the urlconf to be automatically generated.\n\nRather than writing your own viewsets, you'll often want to use the existing\nbase classes that provide a default set of behavior. For example:\n\nThere are two main advantages of using a `ViewSet` class over using a `View`\nclass.\n\nBoth of these come with a trade-off. Using regular views and URL confs is more\nexplicit and gives you more control. ViewSets are helpful if you want to get\nup and running quickly, or when you have a large API and you want to enforce a\nconsistent URL configuration throughout.\n\nThe default routers included with REST framework will provide routes for a\nstandard set of create/retrieve/update/destroy style actions, as shown below:\n\nDuring dispatch, the following attributes are available on the `ViewSet`.\n\nYou may inspect these attributes to adjust behaviour based on the current\naction. For example, you could restrict permissions to everything except the\n`list` action similar to this:\n\nIf you have ad-hoc methods that should be routable, you can mark them as such\nwith the `@action` decorator. Like regular actions, extra actions may be\nintended for either a single object, or an entire collection. To indicate\nthis, set the `detail` argument to `True` or `False`. The router will\nconfigure its URL patterns accordingly. e.g., the `DefaultRouter` will\nconfigure detail actions to contain `pk` in their URL patterns.\n\nA more complete example of extra actions:\n\nThe `action` decorator will route `GET` requests by default, but may also\naccept other HTTP methods by setting the `methods` argument. For example:\n\nThe decorator allows you to override any viewset-level configuration such as\n`permission_classes`, `serializer_class`, `filter_backends`...:\n\nThe two new actions will then be available at the urls\n`^users/{pk}/set_password/$` and `^users/{pk}/unset_password/$`. Use the\n`url_path` and `url_name` parameters to change the URL segment and the reverse\nURL name of the action.\n\nTo view all extra actions, call the `.get_extra_actions()` method.\n\nExtra actions can map additional HTTP methods to separate `ViewSet` methods.\nFor example, the above password set/unset methods could be consolidated into a\nsingle route. Note that additional mappings do not accept arguments.\n\nIf you need to get the URL of an action, use the `.reverse_action()` method.\nThis is a convenience wrapper for `reverse()`, automatically passing the\nview's `request` object and prepending the `url_name` with the `.basename`\nattribute.\n\nNote that the `basename` is provided by the router during `ViewSet`\nregistration. If you are not using a router, then you must provide the\n`basename` argument to the `.as_view()` method.\n\nUsing the example from the previous section:\n\nAlternatively, you can use the `url_name` attribute set by the `@action`\ndecorator.\n\nThe `url_name` argument for `.reverse_action()` should match the same argument\nto the `@action` decorator. Additionally, this method can be used to reverse\nthe default actions, such as `list` and `create`.\n\nThe `ViewSet` class inherits from `APIView`. You can use any of the standard\nattributes such as `permission_classes`, `authentication_classes` in order to\ncontrol the API policy on the viewset.\n\nThe `ViewSet` class does not provide any implementations of actions. In order\nto use a `ViewSet` class you'll override the class and define the action\nimplementations explicitly.\n\nThe `GenericViewSet` class inherits from `GenericAPIView`, and provides the\ndefault set of `get_object`, `get_queryset` methods and other generic view\nbase behavior, but does not include any actions by default.\n\nIn order to use a `GenericViewSet` class you'll override the class and either\nmixin the required mixin classes, or define the action implementations\nexplicitly.\n\nThe `ModelViewSet` class inherits from `GenericAPIView` and includes\nimplementations for various actions, by mixing in the behavior of the various\nmixin classes.\n\nThe actions provided by the `ModelViewSet` class are `.list()`, `.retrieve()`,\n`.create()`, `.update()`, `.partial_update()`, and `.destroy()`.\n\nBecause `ModelViewSet` extends `GenericAPIView`, you'll normally need to\nprovide at least the `queryset` and `serializer_class` attributes. For\nexample:\n\nNote that you can use any of the standard attributes or method overrides\nprovided by `GenericAPIView`. For example, to use a `ViewSet` that dynamically\ndetermines the queryset it should operate on, you might do something like\nthis:\n\nNote however that upon removal of the `queryset` property from your `ViewSet`,\nany associated router will be unable to derive the basename of your Model\nautomatically, and so you will have to specify the `basename` kwarg as part of\nyour router registration.\n\nAlso note that although this class provides the complete set of\ncreate/list/retrieve/update/destroy actions by default, you can restrict the\navailable operations by using the standard permission classes.\n\nThe `ReadOnlyModelViewSet` class also inherits from `GenericAPIView`. As with\n`ModelViewSet` it also includes implementations for various actions, but\nunlike `ModelViewSet` only provides the 'read-only' actions, `.list()` and\n`.retrieve()`.\n\nAs with `ModelViewSet`, you'll normally need to provide at least the\n`queryset` and `serializer_class` attributes. For example:\n\nAgain, as with `ModelViewSet`, you can use any of the standard attributes and\nmethod overrides available to `GenericAPIView`.\n\nYou may need to provide custom `ViewSet` classes that do not have the full set\nof `ModelViewSet` actions, or that customize the behavior in some other way.\n\nTo create a base viewset class that provides `create`, `list` and `retrieve`\noperations, inherit from `GenericViewSet`, and mixin the required actions:\n\nBy creating your own base `ViewSet` classes, you can provide common behavior\nthat can be reused in multiple viewsets across your API.\n\nviewsets.py\n\n"}, {"name": "RegexField", "path": "api-guide/fields/index#regexfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "RemoteUserAuthentication", "path": "api-guide/authentication/index#remoteuserauthentication", "type": "Ref: Authentication", "text": "\nAuth needs to be pluggable.\n\n\u2014 Jacob Kaplan-Moss, \"REST worst practices\"\n\nAuthentication is the mechanism of associating an incoming request with a set\nof identifying credentials, such as the user the request came from, or the\ntoken that it was signed with. The permission and throttling policies can then\nuse those credentials to determine if the request should be permitted.\n\nREST framework provides several authentication schemes out of the box, and\nalso allows you to implement custom schemes.\n\nAuthentication always runs at the very start of the view, before the\npermission and throttling checks occur, and before any other code is allowed\nto proceed.\n\nThe `request.user` property will typically be set to an instance of the\n`contrib.auth` package's `User` class.\n\nThe `request.auth` property is used for any additional authentication\ninformation, for example, it may be used to represent an authentication token\nthat the request was signed with.\n\nNote: Don't forget that authentication by itself won't allow or disallow an\nincoming request, it simply identifies the credentials that the request was\nmade with.\n\nFor information on how to set up the permission policies for your API please\nsee the permissions documentation.\n\nThe authentication schemes are always defined as a list of classes. REST\nframework will attempt to authenticate with each class in the list, and will\nset `request.user` and `request.auth` using the return value of the first\nclass that successfully authenticates.\n\nIf no class authenticates, `request.user` will be set to an instance of\n`django.contrib.auth.models.AnonymousUser`, and `request.auth` will be set to\n`None`.\n\nThe value of `request.user` and `request.auth` for unauthenticated requests\ncan be modified using the `UNAUTHENTICATED_USER` and `UNAUTHENTICATED_TOKEN`\nsettings.\n\nThe default authentication schemes may be set globally, using the\n`DEFAULT_AUTHENTICATION_CLASSES` setting. For example.\n\nYou can also set the authentication scheme on a per-view or per-viewset basis,\nusing the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nWhen an unauthenticated request is denied permission there are two different\nerror codes that may be appropriate.\n\nHTTP 401 responses must always include a `WWW-Authenticate` header, that\ninstructs the client how to authenticate. HTTP 403 responses do not include\nthe `WWW-Authenticate` header.\n\nThe kind of response that will be used depends on the authentication scheme.\nAlthough multiple authentication schemes may be in use, only one scheme may be\nused to determine the type of response. The first authentication class set on\nthe view is used when determining the type of response.\n\nNote that when a request may successfully authenticate, but still be denied\npermission to perform the request, in which case a `403 Permission Denied`\nresponse will always be used, regardless of the authentication scheme.\n\nNote that if deploying to Apache using mod_wsgi, the authorization header is\nnot passed through to a WSGI application by default, as it is assumed that\nauthentication will be handled by Apache, rather than at an application level.\n\nIf you are deploying to Apache, and using any non-session based\nauthentication, you will need to explicitly configure mod_wsgi to pass the\nrequired headers through to the application. This can be done by specifying\nthe `WSGIPassAuthorization` directive in the appropriate context and setting\nit to `'On'`.\n\nThis authentication scheme uses HTTP Basic Authentication, signed against a\nuser's username and password. Basic authentication is generally only\nappropriate for testing.\n\nIf successfully authenticated, `BasicAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nNote: If you use `BasicAuthentication` in production you must ensure that your\nAPI is only available over `https`. You should also ensure that your API\nclients will always re-request the username and password at login, and will\nnever store those details to persistent storage.\n\nThis authentication scheme uses a simple token-based HTTP Authentication\nscheme. Token authentication is appropriate for client-server setups, such as\nnative desktop and mobile clients.\n\nTo use the `TokenAuthentication` scheme you'll need to configure the\nauthentication classes to include `TokenAuthentication`, and additionally\ninclude `rest_framework.authtoken` in your `INSTALLED_APPS` setting:\n\nNote: Make sure to run `manage.py migrate` after changing your settings. The\n`rest_framework.authtoken` app provides Django database migrations.\n\nYou'll also need to create tokens for your users.\n\nFor clients to authenticate, the token key should be included in the\n`Authorization` HTTP header. The key should be prefixed by the string literal\n\"Token\", with whitespace separating the two strings. For example:\n\nNote: If you want to use a different keyword in the header, such as `Bearer`,\nsimply subclass `TokenAuthentication` and set the `keyword` class variable.\n\nIf successfully authenticated, `TokenAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nThe `curl` command line tool may be useful for testing token authenticated\nAPIs. For example:\n\nNote: If you use `TokenAuthentication` in production you must ensure that your\nAPI is only available over `https`.\n\nIf you want every user to have an automatically generated Token, you can\nsimply catch the User's `post_save` signal.\n\nNote that you'll want to ensure you place this code snippet in an installed\n`models.py` module, or some other location that will be imported by Django on\nstartup.\n\nIf you've already created some users, you can generate tokens for all existing\nusers like this:\n\nWhen using `TokenAuthentication`, you may want to provide a mechanism for\nclients to obtain a token given the username and password. REST framework\nprovides a built-in view to provide this behaviour. To use it, add the\n`obtain_auth_token` view to your URLconf:\n\nNote that the URL part of the pattern can be whatever you want to use.\n\nThe `obtain_auth_token` view will return a JSON response when valid `username`\nand `password` fields are POSTed to the view using form data or JSON:\n\nNote that the default `obtain_auth_token` view explicitly uses JSON requests\nand responses, rather than using default renderer and parser classes in your\nsettings.\n\nBy default, there are no permissions or throttling applied to the\n`obtain_auth_token` view. If you do wish to apply to throttle you'll need to\noverride the view class, and include them using the `throttle_classes`\nattribute.\n\nIf you need a customized version of the `obtain_auth_token` view, you can do\nso by subclassing the `ObtainAuthToken` view class, and using that in your url\nconf instead.\n\nFor example, you may return additional user information beyond the `token`\nvalue:\n\nAnd in your `urls.py`:\n\nIt is also possible to create Tokens manually through the admin interface. In\ncase you are using a large user base, we recommend that you monkey patch the\n`TokenAdmin` class customize it to your needs, more specifically by declaring\nthe `user` field as `raw_field`.\n\n`your_app/admin.py`:\n\nSince version 3.6.4 it's possible to generate a user token using the following\ncommand:\n\nthis command will return the API token for the given user, creating it if it\ndoesn't exist:\n\nIn case you want to regenerate the token (for example if it has been\ncompromised or leaked) you can pass an additional parameter:\n\nThis authentication scheme uses Django's default session backend for\nauthentication. Session authentication is appropriate for AJAX clients that\nare running in the same session context as your website.\n\nIf successfully authenticated, `SessionAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n403 Forbidden` response.\n\nIf you're using an AJAX-style API with SessionAuthentication, you'll need to\nmake sure you include a valid CSRF token for any \"unsafe\" HTTP method calls,\nsuch as `PUT`, `PATCH`, `POST` or `DELETE` requests. See the Django CSRF\ndocumentation for more details.\n\nWarning: Always use Django's standard login view when creating login pages.\nThis will ensure your login views are properly protected.\n\nCSRF validation in REST framework works slightly differently from standard\nDjango due to the need to support both session and non-session based\nauthentication to the same views. This means that only authenticated requests\nrequire CSRF tokens, and anonymous requests may be sent without CSRF tokens.\nThis behaviour is not suitable for login views, which should always have CSRF\nvalidation applied.\n\nThis authentication scheme allows you to delegate authentication to your web\nserver, which sets the `REMOTE_USER` environment variable.\n\nTo use it, you must have `django.contrib.auth.backends.RemoteUserBackend` (or\na subclass) in your `AUTHENTICATION_BACKENDS` setting. By default,\n`RemoteUserBackend` creates `User` objects for usernames that don't already\nexist. To change this and other behaviour, consult the Django documentation.\n\nIf successfully authenticated, `RemoteUserAuthentication` provides the\nfollowing credentials:\n\nConsult your web server's documentation for information about configuring an\nauthentication method, e.g.:\n\nTo implement a custom authentication scheme, subclass `BaseAuthentication` and\noverride the `.authenticate(self, request)` method. The method should return a\ntwo-tuple of `(user, auth)` if authentication succeeds, or `None` otherwise.\n\nIn some circumstances instead of returning `None`, you may want to raise an\n`AuthenticationFailed` exception from the `.authenticate()` method.\n\nTypically the approach you should take is:\n\nYou may also override the `.authenticate_header(self, request)` method. If\nimplemented, it should return a string that will be used as the value of the\n`WWW-Authenticate` header in a `HTTP 401 Unauthorized` response.\n\nIf the `.authenticate_header()` method is not overridden, the authentication\nscheme will return `HTTP 403 Forbidden` responses when an unauthenticated\nrequest is denied access.\n\nNote: When your custom authenticator is invoked by the request object's\n`.user` or `.auth` properties, you may see an `AttributeError` re-raised as a\n`WrappedAttributeError`. This is necessary to prevent the original exception\nfrom being suppressed by the outer property access. Python will not recognize\nthat the `AttributeError` originates from your custom authenticator and will\ninstead assume that the request object does not have a `.user` or `.auth`\nproperty. These errors should be fixed or otherwise handled by your\nauthenticator.\n\nThe following example will authenticate any incoming request as the user given\nby the username in a custom request header named 'X-USERNAME'.\n\nThe following third-party packages are also available.\n\nThe Django OAuth Toolkit package provides OAuth 2.0 support and works with\nPython 3.4+. The package is maintained by jazzband and uses the excellent\nOAuthLib. The package is well documented, and well supported and is currently\nour recommended package for OAuth 2.0 support.\n\nInstall using `pip`.\n\nAdd the package to your `INSTALLED_APPS` and modify your REST framework\nsettings.\n\nFor more details see the Django REST framework - Getting started\ndocumentation.\n\nThe Django REST framework OAuth package provides both OAuth1 and OAuth2\nsupport for REST framework.\n\nThis package was previously included directly in the REST framework but is now\nsupported and maintained as a third-party package.\n\nInstall the package using `pip`.\n\nFor details on configuration and usage see the Django REST framework OAuth\ndocumentation for authentication and permissions.\n\nJSON Web Token is a fairly new standard which can be used for token-based\nauthentication. Unlike the built-in TokenAuthentication scheme, JWT\nAuthentication doesn't need to use a database to validate a token. A package\nfor JWT authentication is djangorestframework-simplejwt which provides some\nfeatures as well as a pluggable token blacklist app.\n\nThe HawkREST library builds on the Mohawk library to let you work with Hawk\nsigned requests and responses in your API. Hawk lets two parties securely\ncommunicate with each other using messages signed by a shared key. It is based\non HTTP MAC access authentication (which was based on parts of OAuth 1.0).\n\nHTTP Signature (currently a IETF draft) provides a way to achieve origin\nauthentication and message integrity for HTTP messages. Similar to Amazon's\nHTTP Signature scheme, used by many of its services, it permits stateless,\nper-request authentication. Elvio Toccalino maintains the djangorestframework-\nhttpsignature (outdated) package which provides an easy to use HTTP Signature\nAuthentication mechanism. You can use the updated fork version of\ndjangorestframework-httpsignature, which is drf-httpsig.\n\nDjoser library provides a set of views to handle basic actions such as\nregistration, login, logout, password reset and account activation. The\npackage works with a custom user model and uses token-based authentication.\nThis is ready to use REST implementation of the Django authentication system.\n\nThis library provides a set of REST API endpoints for registration,\nauthentication (including social media authentication), password reset,\nretrieve and update user details, etc. By having these API endpoints, your\nclient apps such as AngularJS, iOS, Android, and others can communicate to\nyour Django backend site independently via REST APIs for user management.\n\nThere are currently two forks of this project.\n\nDjango-rest-framework-social-oauth2 library provides an easy way to integrate\nsocial plugins (facebook, twitter, google, etc.) to your authentication system\nand an easy oauth2 setup. With this library, you will be able to authenticate\nusers based on external tokens (e.g. facebook access token), convert these\ntokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to\nauthenticate your users.\n\nDjango-rest-knox library provides models and views to handle token-based\nauthentication in a more secure and extensible way than the built-in\nTokenAuthentication scheme - with Single Page Applications and Mobile clients\nin mind. It provides per-client tokens, and views to generate them when\nprovided some other authentication (usually basic authentication), to delete\nthe token (providing a server enforced logout) and to delete all tokens (logs\nout all clients that a user is logged into).\n\ndrfpasswordless adds (Medium, Square Cash inspired) passwordless support to\nDjango REST Framework's TokenAuthentication scheme. Users log in and sign up\nwith a token sent to a contact point like an email address or a mobile number.\n\ndjango-rest-authemail provides a RESTful API interface for user signup and\nauthentication. Email addresses are used for authentication, rather than\nusernames. API endpoints are available for signup, signup email verification,\nlogin, logout, password reset, password reset verification, email change,\nemail change verification, password change, and user detail. A fully\nfunctional example project and detailed instructions are included.\n\nDjango-Rest-Durin is built with the idea to have one library that does token\nauth for multiple Web/CLI/Mobile API clients via one interface but allows\ndifferent token configuration for each API Client that consumes the API. It\nprovides support for multiple tokens per user via custom models, views,\npermissions that work with Django-Rest-Framework. The token expiration time\ncan be different per API client and is customizable via the Django Admin\nInterface.\n\nMore information can be found in the Documentation.\n\nauthentication.py\n\n"}, {"name": "Renderers", "path": "api-guide/renderers/index", "type": "API Guide", "text": "\nBefore a TemplateResponse instance can be returned to the client, it must be\nrendered. The rendering process takes the intermediate representation of\ntemplate and context, and turns it into the final byte stream that can be\nserved to the client.\n\n\u2014 Django documentation\n\nREST framework includes a number of built in Renderer classes, that allow you\nto return responses with various media types. There is also support for\ndefining your own custom renderers, which gives you the flexibility to design\nyour own media types.\n\nThe set of valid renderers for a view is always defined as a list of classes.\nWhen a view is entered REST framework will perform content negotiation on the\nincoming request, and determine the most appropriate renderer to satisfy the\nrequest.\n\nThe basic process of content negotiation involves examining the request's\n`Accept` header, to determine which media types it expects in the response.\nOptionally, format suffixes on the URL may be used to explicitly request a\nparticular representation. For example the URL\n`http://example.com/api/users_count.json` might be an endpoint that always\nreturns JSON data.\n\nFor more information see the documentation on content negotiation.\n\nThe default set of renderers may be set globally, using the\n`DEFAULT_RENDERER_CLASSES` setting. For example, the following settings would\nuse `JSON` as the main media type and also include the self describing API.\n\nYou can also set the renderers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nIt's important when specifying the renderer classes for your API to think\nabout what priority you want to assign to each media type. If a client\nunderspecifies the representations it can accept, such as sending an `Accept:\n*/*` header, or not including an `Accept` header at all, then REST framework\nwill select the first renderer in the list to use for the response.\n\nFor example if your API serves JSON responses and the HTML browsable API, you\nmight want to make `JSONRenderer` your default renderer, in order to send\n`JSON` responses to clients that do not specify an `Accept` header.\n\nIf your API includes views that can serve both regular webpages and API\nresponses depending on the request, then you might consider making\n`TemplateHTMLRenderer` your default renderer, in order to play nicely with\nolder browsers that send broken accept headers.\n\nRenders the request data into `JSON`, using utf-8 encoding.\n\nNote that the default style is to include unicode characters, and render the\nresponse using a compact style with no unnecessary whitespace:\n\nThe client may additionally include an `'indent'` media type parameter, in\nwhich case the returned `JSON` will be indented. For example `Accept:\napplication/json; indent=4`.\n\nThe default JSON encoding style can be altered using the `UNICODE_JSON` and\n`COMPACT_JSON` settings keys.\n\n.media_type: `application/json`\n\n.format: `'json'`\n\n.charset: `None`\n\nRenders data to HTML, using Django's standard template rendering. Unlike other\nrenderers, the data passed to the `Response` does not need to be serialized.\nAlso, unlike other renderers, you may want to include a `template_name`\nargument when creating the `Response`.\n\nThe TemplateHTMLRenderer will create a `RequestContext`, using the\n`response.data` as the context dict, and determine a template name to use to\nrender the context.\n\nNote: When used with a view that makes use of a serializer the `Response` sent\nfor rendering may not be a dictionary and will need to be wrapped in a dict\nbefore returning to allow the TemplateHTMLRenderer to render it. For example:\n\nThe template name is determined by (in order of preference):\n\nAn example of a view that uses `TemplateHTMLRenderer`:\n\nYou can use `TemplateHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\nIf you're building websites that use `TemplateHTMLRenderer` along with other\nrenderer classes, you should consider listing `TemplateHTMLRenderer` as the\nfirst class in the `renderer_classes` list, so that it will be prioritised\nfirst even for browsers that send poorly formed `ACCEPT:` headers.\n\nSee the HTML & Forms Topic Page for further examples of `TemplateHTMLRenderer`\nusage.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `StaticHTMLRenderer`\n\nA simple renderer that simply returns pre-rendered HTML. Unlike other\nrenderers, the data passed to the response object should be a string\nrepresenting the content to be returned.\n\nAn example of a view that uses `StaticHTMLRenderer`:\n\nYou can use `StaticHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `TemplateHTMLRenderer`\n\nRenders data into HTML for the Browsable API:\n\nThis renderer will determine which other renderer would have been given\nhighest priority, and use that to display an API style response within the\nHTML page.\n\n.media_type: `text/html`\n\n.format: `'api'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/api.html'`\n\nBy default the response content will be rendered with the highest priority\nrenderer apart from `BrowsableAPIRenderer`. If you need to customize this\nbehavior, for example to use HTML as the default return format, but use JSON\nin the browsable API, you can do so by overriding the `get_default_renderer()`\nmethod. For example:\n\nRenders data into HTML for an admin-like display:\n\nThis renderer is suitable for CRUD-style web APIs that should also present a\nuser-friendly interface for managing the data.\n\nNote that views that have nested or list serializers for their input won't\nwork well with the `AdminRenderer`, as the HTML forms are unable to properly\nsupport them.\n\nNote: The `AdminRenderer` is only able to include links to detail pages when a\nproperly configured `URL_FIELD_NAME` (`url` by default) attribute is present\nin the data. For `HyperlinkedModelSerializer` this will be the case, but for\n`ModelSerializer` or plain `Serializer` classes you'll need to make sure to\ninclude the field explicitly. For example here we use models\n`get_absolute_url` method:\n\n.media_type: `text/html`\n\n.format: `'admin'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/admin.html'`\n\nRenders data returned by a serializer into an HTML form. The output of this\nrenderer does not include the enclosing `<form>` tags, a hidden CSRF input or\nany submit buttons.\n\nThis renderer is not intended to be used directly, but can instead be used in\ntemplates by passing a serializer instance to the `render_form` template tag.\n\nFor more information see the HTML & Forms documentation.\n\n.media_type: `text/html`\n\n.format: `'form'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/horizontal/form.html'`\n\nThis renderer is used for rendering HTML multipart form data. It is not\nsuitable as a response renderer, but is instead used for creating test\nrequests, using REST framework's test client and test request factory.\n\n.media_type: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n.format: `'multipart'`\n\n.charset: `utf-8`\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the\n`.media_type` and `.format` properties, and implement the `.render(self, data,\nmedia_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the\nHTTP response.\n\nThe arguments passed to the `.render()` method are:\n\nThe request data, as set by the `Response()` instantiation.\n\nOptional. If provided, this is the accepted media type, as determined by the\ncontent negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the\nrenderer's `media_type` attribute, and may include media type parameters. For\nexample `\"application/json; nested=true\"`.\n\nOptional. If provided, this is a dictionary of contextual information provided\nby the view.\n\nBy default this will include the following keys: `view`, `request`,\n`response`, `args`, `kwargs`.\n\nThe following is an example plaintext renderer that will return a response\nwith the `data` parameter as the content of the response.\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To\nuse a different encoding, set the `charset` attribute on the renderer.\n\nNote that if a renderer class returns a unicode string, then the response\ncontent will be coerced into a bytestring by the `Response` class, with the\n`charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you\nshould set a charset value of `None`, which will ensure the `Content-Type`\nheader of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to\n`'binary'`. Doing so will also ensure that the browsable API will not attempt\nto display the binary content as a string.\n\nYou can do some pretty flexible things using REST framework's renderers. Some\nexamples...\n\nIn some cases you might want your view to use different serialization styles\ndepending on the accepted media type. If you need to do this you can access\n`request.accepted_renderer` to determine the negotiated renderer that will be\nused for the response.\n\nFor example:\n\nIn some cases you might want a renderer to serve a range of media types. In\nthis case you can underspecify the media types it should respond to, by using\na `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify\nthe media type explicitly when you return the response, using the\n`content_type` attribute. For example:\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked\nrelations may be sufficient. If you want to fully embrace RESTful design and\nHATEOAS you'll need to consider the design and usage of your media types in\nmore detail.\n\nIn the words of Roy Fielding, \"A REST API should spend almost all of its\ndescriptive effort in defining the media type(s) used for representing\nresources and driving application state, or in defining extended relation\nnames and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom\napplication/vnd.github+json media type, and Mike Amundsen's IANA approved\napplication/vnd.collection+json JSON-based hypermedia.\n\nTypically a renderer will behave the same regardless of if it's dealing with a\nregular response, or with a response caused by an exception being raised, such\nas an `Http404` or `PermissionDenied` exception, or a subclass of\n`APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer`\nand an exception is raised, the behavior is slightly different, and mirrors\nDjango's default handling of error views.\n\nExceptions raised and handled by an HTML renderer will attempt to render using\none of the following methods, by order of precedence.\n\nTemplates will render with a `RequestContext` which includes the `status_code`\nand `details` keys.\n\nNote: If `DEBUG=True`, Django's standard traceback error page will be\ndisplayed instead of rendering the HTTP status code and text.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST framework JSONP provides JSONP rendering support. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nWarning: If you require cross-domain AJAX requests, you should generally be\nusing the more modern approach of CORS as an alternative to `JSONP`. See the\nCORS documentation for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is only appropriate\nfor globally readable API endpoints, where `GET` requests are unauthenticated\nand do not require any user permissions.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\nXLSX is the world's most popular binary spreadsheet format. Tim Allen of The\nWharton School maintains drf-renderer-xlsx, which renders an endpoint as an\nXLSX spreadsheet using OpenPyXL, and allows the client to download it.\nSpreadsheets can be styled on a per-view basis.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nTo avoid having a file streamed without a filename (which the browser will\noften default to the filename \"download\", with no extension), we need to use a\nmixin to override the `Content-Disposition` header. If no filename is\nprovided, it will default to `export.xlsx`. For example:\n\nComma-separated values are a plain-text tabular data format, that can be\neasily imported into spreadsheet applications. Mjumbe Poe maintains the\ndjangorestframework-csv package which provides CSV renderer support for REST\nframework.\n\nUltraJSON is an optimized C JSON encoder which can give significantly faster\nJSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now\nunmaintained drf-ujson-renderer, which implements JSON rendering using the\nUJSON package.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nDjango REST Pandas provides a serializer and renderers that support additional\ndata processing and output via the Pandas DataFrame API. Django REST Pandas\nincludes renderers for Pandas-style CSV files, Excel workbooks (both `.xls`\nand `.xlsx`), and a number of other formats. It is maintained by S. Andrew\nSheppard as part of the wq Project.\n\nRest Framework Latex provides a renderer that outputs PDFs using Laulatex. It\nis maintained by Pebble (S/F Software).\n\nrenderers.py\n\n"}, {"name": "Requests", "path": "api-guide/requests/index", "type": "API Guide", "text": "\nIf you're doing REST-based web service stuff ... you should ignore\nrequest.POST.\n\n\u2014 Malcom Tredinnick, Django developers group\n\nREST framework's `Request` class extends the standard `HttpRequest`, adding\nsupport for REST framework's flexible request parsing and request\nauthentication.\n\nREST framework's Request objects provide flexible request parsing that allows\nyou to treat requests with JSON data or other media types in the same way that\nyou would normally deal with form data.\n\n`request.data` returns the parsed content of the request body. This is similar\nto the standard `request.POST` and `request.FILES` attributes except that:\n\nFor more details see the parsers documentation.\n\n`request.query_params` is a more correctly named synonym for `request.GET`.\n\nFor clarity inside your code, we recommend using `request.query_params`\ninstead of the Django's standard `request.GET`. Doing so will help keep your\ncodebase more correct and obvious - any HTTP method type may include query\nparameters, not just `GET` requests.\n\nThe `APIView` class or `@api_view` decorator will ensure that this property is\nautomatically set to a list of `Parser` instances, based on the\n`parser_classes` set on the view or based on the `DEFAULT_PARSER_CLASSES`\nsetting.\n\nYou won't typically need to access this property.\n\nNote: If a client sends malformed content, then accessing `request.data` may\nraise a `ParseError`. By default REST framework's `APIView` class or\n`@api_view` decorator will catch the error and return a `400 Bad Request`\nresponse.\n\nIf a client sends a request with a content-type that cannot be parsed then a\n`UnsupportedMediaType` exception will be raised, which by default will be\ncaught and return a `415 Unsupported Media Type` response.\n\nThe request exposes some properties that allow you to determine the result of\nthe content negotiation stage. This allows you to implement behaviour such as\nselecting a different serialization schemes for different media types.\n\nThe renderer instance that was selected by the content negotiation stage.\n\nA string representing the media type that was accepted by the content\nnegotiation stage.\n\nREST framework provides flexible, per-request authentication, that gives you\nthe ability to:\n\n`request.user` typically returns an instance of\n`django.contrib.auth.models.User`, although the behavior depends on the\nauthentication policy being used.\n\nIf the request is unauthenticated the default value of `request.user` is an\ninstance of `django.contrib.auth.models.AnonymousUser`.\n\nFor more details see the authentication documentation.\n\n`request.auth` returns any additional authentication context. The exact\nbehavior of `request.auth` depends on the authentication policy being used,\nbut it may typically be an instance of the token that the request was\nauthenticated against.\n\nIf the request is unauthenticated, or if no additional context is present, the\ndefault value of `request.auth` is `None`.\n\nFor more details see the authentication documentation.\n\nThe `APIView` class or `@api_view` decorator will ensure that this property is\nautomatically set to a list of `Authentication` instances, based on the\n`authentication_classes` set on the view or based on the\n`DEFAULT_AUTHENTICATORS` setting.\n\nYou won't typically need to access this property.\n\nNote: You may see a `WrappedAttributeError` raised when calling the `.user` or\n`.auth` properties. These errors originate from an authenticator as a standard\n`AttributeError`, however it's necessary that they be re-raised as a different\nexception type in order to prevent them from being suppressed by the outer\nproperty access. Python will not recognize that the `AttributeError`\noriginates from the authenticator and will instead assume that the request\nobject does not have a `.user` or `.auth` property. The authenticator will\nneed to be fixed.\n\nREST framework supports a few browser enhancements such as browser-based\n`PUT`, `PATCH` and `DELETE` forms.\n\n`request.method` returns the uppercased string representation of the request's\nHTTP method.\n\nBrowser-based `PUT`, `PATCH` and `DELETE` forms are transparently supported.\n\nFor more information see the browser enhancements documentation.\n\n`request.content_type`, returns a string object representing the media type of\nthe HTTP request's body, or an empty string if no media type was provided.\n\nYou won't typically need to directly access the request's content type, as\nyou'll normally rely on REST framework's default request parsing behavior.\n\nIf you do need to access the content type of the request you should use the\n`.content_type` property in preference to using\n`request.META.get('HTTP_CONTENT_TYPE')`, as it provides transparent support\nfor browser-based non-form content.\n\nFor more information see the browser enhancements documentation.\n\n`request.stream` returns a stream representing the content of the request\nbody.\n\nYou won't typically need to directly access the request's content, as you'll\nnormally rely on REST framework's default request parsing behavior.\n\nAs REST framework's `Request` extends Django's `HttpRequest`, all the other\nstandard attributes and methods are also available. For example the\n`request.META` and `request.session` dictionaries are available as normal.\n\nNote that due to implementation reasons the `Request` class does not inherit\nfrom `HttpRequest` class, but instead extends the class using composition.\n\nrequest.py\n\n"}, {"name": "Responses", "path": "api-guide/responses/index", "type": "API Guide", "text": "\nUnlike basic HttpResponse objects, TemplateResponse objects retain the details\nof the context that was provided by the view to compute the response. The\nfinal output of the response is not computed until it is needed, later in the\nresponse process.\n\n\u2014 Django documentation\n\nREST framework supports HTTP content negotiation by providing a `Response`\nclass which allows you to return content that can be rendered into multiple\ncontent types, depending on the client request.\n\nThe `Response` class subclasses Django's `SimpleTemplateResponse`. `Response`\nobjects are initialised with data, which should consist of native Python\nprimitives. REST framework then uses standard HTTP content negotiation to\ndetermine how it should render the final response content.\n\nThere's no requirement for you to use the `Response` class, you can also\nreturn regular `HttpResponse` or `StreamingHttpResponse` objects from your\nviews if required. Using the `Response` class simply provides a nicer\ninterface for returning content-negotiated Web API responses, that can be\nrendered to multiple formats.\n\nUnless you want to heavily customize REST framework for some reason, you\nshould always use an `APIView` class or `@api_view` function for views that\nreturn `Response` objects. Doing so ensures that the view can perform content\nnegotiation and select the appropriate renderer for the response, before it is\nreturned from the view.\n\nSignature: `Response(data, status=None, template_name=None, headers=None,\ncontent_type=None)`\n\nUnlike regular `HttpResponse` objects, you do not instantiate `Response`\nobjects with rendered content. Instead you pass in unrendered data, which may\nconsist of any Python primitives.\n\nThe renderers used by the `Response` class cannot natively handle complex\ndatatypes such as Django model instances, so you need to serialize the data\ninto primitive datatypes before creating the `Response` object.\n\nYou can use REST framework's `Serializer` classes to perform this data\nserialization, or use your own custom serialization.\n\nArguments:\n\nThe unrendered, serialized data of the response.\n\nThe numeric status code of the HTTP response.\n\nThe rendered content of the response. The `.render()` method must have been\ncalled before `.content` can be accessed.\n\nThe `template_name`, if supplied. Only required if `HTMLRenderer` or some\nother custom template renderer is the accepted renderer for the response.\n\nThe renderer instance that will be used to render the response.\n\nSet automatically by the `APIView` or `@api_view` immediately before the\nresponse is returned from the view.\n\nThe media type that was selected by the content negotiation stage.\n\nSet automatically by the `APIView` or `@api_view` immediately before the\nresponse is returned from the view.\n\nA dictionary of additional context information that will be passed to the\nrenderer's `.render()` method.\n\nSet automatically by the `APIView` or `@api_view` immediately before the\nresponse is returned from the view.\n\nThe `Response` class extends `SimpleTemplateResponse`, and all the usual\nattributes and methods are also available on the response. For example you can\nset headers on the response in the standard way:\n\nSignature: `.render()`\n\nAs with any other `TemplateResponse`, this method is called to render the\nserialized data of the response into the final response content. When\n`.render()` is called, the response content will be set to the result of\ncalling the `.render(data, accepted_media_type, renderer_context)` method on\nthe `accepted_renderer` instance.\n\nYou won't typically need to call `.render()` yourself, as it's handled by\nDjango's standard response cycle.\n\nresponse.py\n\n"}, {"name": "RetrieveAPIView", "path": "api-guide/generic-views/index#retrieveapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "RetrieveDestroyAPIView", "path": "api-guide/generic-views/index#retrievedestroyapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "RetrieveModelMixin", "path": "api-guide/generic-views/index#retrievemodelmixin", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "RetrieveUpdateAPIView", "path": "api-guide/generic-views/index#retrieveupdateapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "RetrieveUpdateDestroyAPIView", "path": "api-guide/generic-views/index#retrieveupdatedestroyapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "Returning URLs", "path": "api-guide/reverse/index", "type": "API Guide", "text": "\nThe central feature that distinguishes the REST architectural style from other\nnetwork-based styles is its emphasis on a uniform interface between\ncomponents.\n\n\u2014 Roy Fielding, Architectural Styles and the Design of Network-based Software\nArchitectures\n\nAs a rule, it's probably better practice to return absolute URIs from your Web\nAPIs, such as `http://example.com/foobar`, rather than returning relative\nURIs, such as `/foobar`.\n\nThe advantages of doing so are:\n\nREST framework provides two utility functions to make it more simple to return\nabsolute URIs from your Web API.\n\nThere's no requirement for you to use them, but if you do then the self-\ndescribing API will be able to automatically hyperlink its output for you,\nwhich makes browsing the API much easier.\n\nSignature: `reverse(viewname, *args, **kwargs)`\n\nHas the same behavior as `django.urls.reverse`, except that it returns a fully\nqualified URL, using the request to determine the host and port.\n\nYou should include the request as a keyword argument to the function, for\nexample:\n\nSignature: `reverse_lazy(viewname, *args, **kwargs)`\n\nHas the same behavior as `django.urls.reverse_lazy`, except that it returns a\nfully qualified URL, using the request to determine the host and port.\n\nAs with the `reverse` function, you should include the request as a keyword\nargument to the function, for example:\n\nreverse.py\n\n"}, {"name": "Routers", "path": "api-guide/routers/index", "type": "API Guide", "text": "\nResource routing allows you to quickly declare all of the common routes for a\ngiven resourceful controller. Instead of declaring separate routes for your\nindex... a resourceful route declares them in a single line of code.\n\n\u2014 Ruby on Rails Documentation\n\nSome Web frameworks such as Rails provide functionality for automatically\ndetermining how the URLs for an application should be mapped to the logic that\ndeals with handling incoming requests.\n\nREST framework adds support for automatic URL routing to Django, and provides\nyou with a simple, quick and consistent way of wiring your view logic to a set\nof URLs.\n\nHere's an example of a simple URL conf, that uses `SimpleRouter`.\n\nThere are two mandatory arguments to the `register()` method:\n\nOptionally, you may also specify an additional argument:\n\nThe example above would generate the following URL patterns:\n\nNote: The `basename` argument is used to specify the initial part of the view\nname pattern. In the example above, that's the `user` or `account` part.\n\nTypically you won't need to specify the `basename` argument, but if you have a\nviewset where you've defined a custom `get_queryset` method, then the viewset\nmay not have a `.queryset` attribute set. If you try to register that viewset\nyou'll see an error like this:\n\nThis means you'll need to explicitly set the `basename` argument when\nregistering the viewset, as it could not be automatically determined from the\nmodel name.\n\nThe `.urls` attribute on a router instance is simply a standard list of URL\npatterns. There are a number of different styles for how you can include these\nURLs.\n\nFor example, you can append `router.urls` to a list of existing views...\n\nAlternatively you can use Django's `include` function, like so...\n\nYou may use `include` with an application namespace:\n\nOr both an application and instance namespace:\n\nSee Django's URL namespaces docs and the `include` API reference for more\ndetails.\n\nNote: If using namespacing with hyperlinked serializers you'll also need to\nensure that any `view_name` parameters on the serializers correctly reflect\nthe namespace. In the examples above you'd need to include a parameter such as\n`view_name='app_name:user-detail'` for serializer fields hyperlinked to the\nuser detail view.\n\nThe automatic `view_name` generation uses a pattern like\n`%(model_name)-detail`. Unless your models names actually clash you may be\nbetter off not namespacing your Django REST Framework views when using\nhyperlinked serializers.\n\nA viewset may mark extra actions for routing by decorating a method with the\n`@action` decorator. These extra actions will be included in the generated\nroutes. For example, given the `set_password` method on the `UserViewSet`\nclass:\n\nThe following route would be generated:\n\nBy default, the URL pattern is based on the method name, and the URL name is\nthe combination of the `ViewSet.basename` and the hyphenated method name. If\nyou don't want to use the defaults for either of these values, you can instead\nprovide the `url_path` and `url_name` arguments to the `@action` decorator.\n\nFor example, if you want to change the URL for our custom action to\n`^users/{pk}/change-password/$`, you could write:\n\nThe above example would now generate the following URL pattern:\n\nThis router includes routes for the standard set of `list`, `create`,\n`retrieve`, `update`, `partial_update` and `destroy` actions. The viewset can\nalso mark additional methods to be routed, using the `@action` decorator.\n\nBy default the URLs created by `SimpleRouter` are appended with a trailing\nslash. This behavior can be modified by setting the `trailing_slash` argument\nto `False` when instantiating the router. For example:\n\nTrailing slashes are conventional in Django, but are not used by default in\nsome other frameworks such as Rails. Which style you choose to use is largely\na matter of preference, although some javascript frameworks may expect a\nparticular routing style.\n\nThe router will match lookup values containing any characters except slashes\nand period characters. For a more restrictive (or lenient) lookup pattern, set\nthe `lookup_value_regex` attribute on the viewset. For example, you can limit\nthe lookup to valid UUIDs:\n\nThis router is similar to `SimpleRouter` as above, but additionally includes a\ndefault API root view, that returns a response containing hyperlinks to all\nthe list views. It also generates routes for optional `.json` style format\nsuffixes.\n\nAs with `SimpleRouter` the trailing slashes on the URL routes can be removed\nby setting the `trailing_slash` argument to `False` when instantiating the\nrouter.\n\nImplementing a custom router isn't something you'd need to do very often, but\nit can be useful if you have specific requirements about how the URLs for your\nAPI are structured. Doing so allows you to encapsulate the URL structure in a\nreusable way that ensures you don't have to write your URL patterns explicitly\nfor each new view.\n\nThe simplest way to implement a custom router is to subclass one of the\nexisting router classes. The `.routes` attribute is used to template the URL\npatterns that will be mapped to each viewset. The `.routes` attribute is a\nlist of `Route` named tuples.\n\nThe arguments to the `Route` named tuple are:\n\nurl: A string representing the URL to be routed. May include the following\nformat strings:\n\nmapping: A mapping of HTTP method names to the view methods\n\nname: The name of the URL as used in `reverse` calls. May include the\nfollowing format string:\n\ninitkwargs: A dictionary of any additional arguments that should be passed\nwhen instantiating the view. Note that the `detail`, `basename`, and `suffix`\narguments are reserved for viewset introspection and are also used by the\nbrowsable API to generate the view name and breadcrumb links.\n\nYou can also customize how the `@action` decorator is routed. Include the\n`DynamicRoute` named tuple in the `.routes` list, setting the `detail`\nargument as appropriate for the list-based and detail-based routes. In\naddition to `detail`, the arguments to `DynamicRoute` are:\n\nurl: A string representing the URL to be routed. May include the same format\nstrings as `Route`, and additionally accepts the `{url_path}` format string.\n\nname: The name of the URL as used in `reverse` calls. May include the\nfollowing format strings:\n\ninitkwargs: A dictionary of any additional arguments that should be passed\nwhen instantiating the view.\n\nThe following example will only route to the `list` and `retrieve` actions,\nand does not use the trailing slash convention.\n\nLet's take a look at the routes our `CustomReadOnlyRouter` would generate for\na simple viewset.\n\n`views.py`:\n\n`urls.py`:\n\nThe following mappings would be generated...\n\nFor another example of setting the `.routes` attribute, see the source code\nfor the `SimpleRouter` class.\n\nIf you want to provide totally custom behavior, you can override `BaseRouter`\nand override the `get_urls(self)` method. The method should inspect the\nregistered viewsets and return a list of URL patterns. The registered prefix,\nviewset and basename tuples may be inspected by accessing the `self.registry`\nattribute.\n\nYou may also want to override the `get_default_basename(self, viewset)`\nmethod, or else always explicitly set the `basename` argument when registering\nyour viewsets with the router.\n\nThe following third party packages are also available.\n\nThe drf-nested-routers package provides routers and relationship fields for\nworking with nested resources.\n\nThe wq.db package provides an advanced ModelRouter class (and singleton\ninstance) that extends `DefaultRouter` with a `register_model()` API. Much\nlike Django's `admin.site.register`, the only required argument to\n`rest.router.register_model` is a model class. Reasonable defaults for a url\nprefix, serializer, and viewset will be inferred from the model and global\nconfiguration.\n\nThe `DRF-extensions` package provides routers for creating nested viewsets,\ncollection level controllers with customizable endpoint names.\n\nrouters.py\n\n"}, {"name": "Schema", "path": "api-guide/schemas/index", "type": "API Guide", "text": "\nA machine-readable [schema] describes what resources are available via the\nAPI, what their URLs are, how they are represented and what operations they\nsupport.\n\n\u2014 Heroku, JSON Schema for the Heroku Platform API\n\nAPI schemas are a useful tool that allow for a range of use cases, including\ngenerating reference documentation, or driving dynamic client libraries that\ncan interact with your API.\n\nDjango REST Framework provides support for automatic generation of OpenAPI\nschemas.\n\nSchema generation has several moving parts. It's worth having an overview:\n\nThe following sections explain more.\n\nIf your schema is static, you can use the `generateschema` management command:\n\nOnce you've generated a schema in this way you can annotate it with any\nadditional information that cannot be automatically inferred by the schema\ngenerator.\n\nYou might want to check your API schema into version control and update it\nwith each new release, or serve the API schema from your site's static media.\n\nIf you require a dynamic schema, because foreign key choices depend on\ndatabase values, for example, you can route a `SchemaView` that will generate\nand serve your schema on demand.\n\nTo route a `SchemaView`, use the `get_schema_view()` helper.\n\nIn `urls.py`:\n\nThe `get_schema_view()` helper takes the following keyword arguments:\n\n`url`: May be used to pass a canonical base URL for the schema.\n\n`urlconf`: A string representing the import path to the URL conf that you want\nto generate an API schema for. This defaults to the value of Django's\n`ROOT_URLCONF` setting.\n\n`patterns`: List of url patterns to limit the schema introspection to. If you\nonly want the `myproject.api` urls to be exposed in the schema:\n\n`generator_class`: May be used to specify a `SchemaGenerator` subclass to be\npassed to the `SchemaView`.\n\nSchema-level customization\n\n`SchemaGenerator` is a class that walks a list of routed URL patterns,\nrequests the schema for each view and collates the resulting OpenAPI schema.\n\nTypically you won't need to instantiate `SchemaGenerator` yourself, but you\ncan do so like so:\n\nArguments:\n\nIn order to customize the top-level schema, subclass\n`rest_framework.schemas.openapi.SchemaGenerator` and provide your subclass as\nan argument to the `generateschema` command or `get_schema_view()` helper\nfunction.\n\nReturns a dictionary that represents the OpenAPI schema:\n\nThe `request` argument is optional, and may be used if you want to apply per-\nuser permissions to the resulting schema generation.\n\nThis is a good point to override if you want to customize the generated\ndictionary For example you might wish to add terms of service to the top-level\n`info` object:\n\nPer-View Customization\n\nBy default, view introspection is performed by an `AutoSchema` instance\naccessible via the `schema` attribute on `APIView`.\n\n`AutoSchema` provides the OpenAPI elements needed for each view, request\nmethod and path:\n\nIn compiling the schema, `SchemaGenerator` calls `get_components()` and\n`get_operation()` for each view, allowed method, and path.\n\nNote: The automatic introspection of components, and many operation parameters\nrelies on the relevant attributes and methods of `GenericAPIView`:\n`get_serializer()`, `pagination_class`, `filter_backends`, etc. For basic\n`APIView` subclasses, default introspection is essentially limited to the URL\nkwarg path parameters for this reason.\n\n`AutoSchema` encapsulates the view introspection needed for schema generation.\nBecause of this all the schema generation logic is kept in a single place,\nrather than being spread around the already extensive view, serializer and\nfield APIs.\n\nKeeping with this pattern, try not to let schema logic leak into your own\nviews, serializers, or fields when customizing the schema generation. You\nmight be tempted to do something like this:\n\nHere, the `AutoSchema` subclass goes looking for `schema_extra_info` on the\nview. This is OK (it doesn't actually hurt) but it means you'll end up with\nyour schema logic spread out in a number of different places.\n\nInstead try to subclass `AutoSchema` such that the `extra_info` doesn't leak\nout into the view:\n\nThis style is slightly more verbose but maintains the encapsulation of the\nschema related code. It's more cohesive in the parlance. It'll keep the rest\nof your API code more tidy.\n\nIf an option applies to many view classes, rather than creating a specific\nsubclass per-view, you may find it more convenient to allow specifying the\noption as an `__init__()` kwarg to your base `AutoSchema` subclass:\n\nThis saves you having to create a custom subclass per-view for a commonly used\noption.\n\nNot all `AutoSchema` methods expose related `__init__()` kwargs, but those for\nthe more commonly needed options do.\n\nGenerates the OpenAPI components that describe request and response bodies,\nderiving their properties from the serializer.\n\nReturns a dictionary mapping the component name to the generated\nrepresentation. By default this has just a single pair but you may override\n`get_components()` to return multiple pairs if your view uses multiple\nserializers.\n\nComputes the component's name from the serializer.\n\nYou may see warnings if your API has duplicate component names. If so you can\noverride `get_component_name()` or pass the `component_name` `__init__()`\nkwarg (see below) to provide different names.\n\nMaps serializers to their OpenAPI representations.\n\nMost serializers should conform to the standard OpenAPI `object` type, but you\nmay wish to override `map_serializer()` in order to customize this or other\nserializer-level fields.\n\nMaps individual serializer fields to their schema representation. The base\nimplementation will handle the default fields that Django REST Framework\nprovides.\n\nFor `SerializerMethodField` instances, for which the schema is unknown, or\ncustom field subclasses you should override `map_field()` to generate the\ncorrect schema:\n\nAuthors of third-party packages should aim to provide an `AutoSchema`\nsubclass, and a mixin, overriding `map_field()` so that users can easily\ngenerate schemas for their custom fields.\n\nOpenAPI groups operations by tags. By default tags taken from the first path\nsegment of the routed URL. For example, a URL like `/users/{id}/` will\ngenerate the tag `users`.\n\nYou can pass an `__init__()` kwarg to manually specify tags (see below), or\noverride `get_tags()` to provide custom logic.\n\nReturns the OpenAPI operation object that describes the endpoint, including\npath and query parameters for pagination, filtering, and so on.\n\nTogether with `get_components()`, this is the main entry point to the view\nintrospection.\n\nThere must be a unique operationid for each operation. By default the\n`operationId` is deduced from the model name, serializer name or view name.\nThe operationId looks like \"listItems\", \"retrieveItem\", \"updateItem\", etc. The\n`operationId` is camelCase by convention.\n\nIf you have several views with the same model name, you may see duplicate\noperationIds.\n\nIn order to work around this, you can override `get_operation_id_base()` to\nprovide a different base for name part of the ID.\n\nIf the view has implemented `get_serializer()`, returns the result.\n\nBy default returns `get_serializer()` but can be overridden to differentiate\nbetween request and response objects.\n\nBy default returns `get_serializer()` but can be overridden to differentiate\nbetween request and response objects.\n\n`AutoSchema` provides a number of `__init__()` kwargs that can be used for\ncommon customizations, if the default generated values are not appropriate.\n\nThe available kwargs are:\n\nYou pass the kwargs when declaring the `AutoSchema` instance on your view:\n\nAssuming a `Pet` model and `PetSerializer` serializer, the kwargs in this\nexample are probably not needed. Often, though, you'll need to pass the kwargs\nif you have multiple view targeting the same model, or have multiple views\nwith identically named serializers.\n\nIf your views have related customizations that are needed frequently, you can\ncreate a base `AutoSchema` subclass for your project that takes additional\n`__init__()` kwargs to save subclassing `AutoSchema` for each view.\n\nschemas\n\n"}, {"name": "Schema generation controls", "path": "api-guide/settings/index#schema-generation-controls", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "ScopedRateThrottle", "path": "api-guide/throttling/index#scopedratethrottle", "type": "Ref: Throttling", "text": "\nHTTP/1.1 420 Enhance Your Calm\n\nTwitter API rate limiting response\n\nThrottling is similar to permissions, in that it determines if a request\nshould be authorized. Throttles indicate a temporary state, and are used to\ncontrol the rate of requests that clients can make to an API.\n\nAs with permissions, multiple throttles may be used. Your API might have a\nrestrictive throttle for unauthenticated requests, and a less restrictive\nthrottle for authenticated requests.\n\nAnother scenario where you might want to use multiple throttles would be if\nyou need to impose different constraints on different parts of the API, due to\nsome services being particularly resource-intensive.\n\nMultiple throttles can also be used if you want to impose both burst\nthrottling rates, and sustained throttling rates. For example, you might want\nto limit a user to a maximum of 60 requests per minute, and 1000 requests per\nday.\n\nThrottles do not necessarily only refer to rate-limiting requests. For example\na storage service might also need to throttle against bandwidth, and a paid\ndata service might want to throttle against a certain number of a records\nbeing accessed.\n\nAs with permissions and authentication, throttling in REST framework is always\ndefined as a list of classes.\n\nBefore running the main body of the view each throttle in the list is checked.\nIf any throttle check fails an `exceptions.Throttled` exception will be\nraised, and the main body of the view will not run.\n\nThe default throttling policy may be set globally, using the\n`DEFAULT_THROTTLE_CLASSES` and `DEFAULT_THROTTLE_RATES` settings. For example.\n\nThe rate descriptions used in `DEFAULT_THROTTLE_RATES` may include `second`,\n`minute`, `hour` or `day` as the throttle period.\n\nYou can also set the throttling policy on a per-view or per-viewset basis,\nusing the `APIView` class-based views.\n\nIf you're using the `@api_view` decorator with function based views you can\nuse the following decorator.\n\nIt's also possible to set throttle classes for routes that are created using\nthe `@action` decorator. Throttle classes set in this way will override any\nviewset level class settings.\n\nThe `X-Forwarded-For` HTTP header and `REMOTE_ADDR` WSGI variable are used to\nuniquely identify client IP addresses for throttling. If the `X-Forwarded-For`\nheader is present then it will be used, otherwise the value of the\n`REMOTE_ADDR` variable from the WSGI environment will be used.\n\nIf you need to strictly identify unique client IP addresses, you'll need to\nfirst configure the number of application proxies that the API runs behind by\nsetting the `NUM_PROXIES` setting. This setting should be an integer of zero\nor more. If set to non-zero then the client IP will be identified as being the\nlast IP address in the `X-Forwarded-For` header, once any application proxy IP\naddresses have first been excluded. If set to zero, then the `REMOTE_ADDR`\nvalue will always be used as the identifying IP address.\n\nIt is important to understand that if you configure the `NUM_PROXIES` setting,\nthen all clients behind a unique NAT'd gateway will be treated as a single\nclient.\n\nFurther context on how the `X-Forwarded-For` header works, and identifying a\nremote client IP can be found here.\n\nThe throttle classes provided by REST framework use Django's cache backend.\nYou should make sure that you've set appropriate cache settings. The default\nvalue of `LocMemCache` backend should be okay for simple setups. See Django's\ncache documentation for more details.\n\nIf you need to use a cache other than `'default'`, you can do so by creating a\ncustom throttle class and setting the `cache` attribute. For example:\n\nYou'll need to remember to also set your custom throttle class in the\n`'DEFAULT_THROTTLE_CLASSES'` settings key, or using the `throttle_classes`\nview attribute.\n\nThe `AnonRateThrottle` will only ever throttle unauthenticated users. The IP\naddress of the incoming request is used to generate a unique key to throttle\nagainst.\n\nThe allowed request rate is determined from one of the following (in order of\npreference).\n\n`AnonRateThrottle` is suitable if you want to restrict the rate of requests\nfrom unknown sources.\n\nThe `UserRateThrottle` will throttle users to a given rate of requests across\nthe API. The user id is used to generate a unique key to throttle against.\nUnauthenticated requests will fall back to using the IP address of the\nincoming request to generate a unique key to throttle against.\n\nThe allowed request rate is determined from one of the following (in order of\npreference).\n\nAn API may have multiple `UserRateThrottles` in place at the same time. To do\nso, override `UserRateThrottle` and set a unique \"scope\" for each class.\n\nFor example, multiple user throttle rates could be implemented by using the\nfollowing classes...\n\n...and the following settings.\n\n`UserRateThrottle` is suitable if you want simple global rate restrictions\nper-user.\n\nThe `ScopedRateThrottle` class can be used to restrict access to specific\nparts of the API. This throttle will only be applied if the view that is being\naccessed includes a `.throttle_scope` property. The unique throttle key will\nthen be formed by concatenating the \"scope\" of the request with the unique\nuser id or IP address.\n\nThe allowed request rate is determined by the `DEFAULT_THROTTLE_RATES` setting\nusing a key from the request \"scope\".\n\nFor example, given the following views...\n\n...and the following settings.\n\nUser requests to either `ContactListView` or `ContactDetailView` would be\nrestricted to a total of 1000 requests per-day. User requests to `UploadView`\nwould be restricted to 20 requests per day.\n\nTo create a custom throttle, override `BaseThrottle` and implement\n`.allow_request(self, request, view)`. The method should return `True` if the\nrequest should be allowed, and `False` otherwise.\n\nOptionally you may also override the `.wait()` method. If implemented,\n`.wait()` should return a recommended number of seconds to wait before\nattempting the next request, or `None`. The `.wait()` method will only be\ncalled if `.allow_request()` has previously returned `False`.\n\nIf the `.wait()` method is implemented and the request is throttled, then a\n`Retry-After` header will be included in the response.\n\nThe following is an example of a rate throttle, that will randomly throttle 1\nin every 10 requests.\n\nthrottling.py\n\n"}, {"name": "SearchFilter", "path": "api-guide/filtering/index#searchfilter", "type": "Ref: Filtering", "text": "\nThe root QuerySet provided by the Manager describes all objects in the\ndatabase table. Usually, though, you'll need to select only a subset of the\ncomplete set of objects.\n\n\u2014 Django documentation\n\nThe default behavior of REST framework's generic list views is to return the\nentire queryset for a model manager. Often you will want your API to restrict\nthe items that are returned by the queryset.\n\nThe simplest way to filter the queryset of any view that subclasses\n`GenericAPIView` is to override the `.get_queryset()` method.\n\nOverriding this method allows you to customize the queryset returned by the\nview in a number of different ways.\n\nYou might want to filter the queryset to ensure that only results relevant to\nthe currently authenticated user making the request are returned.\n\nYou can do so by filtering based on the value of `request.user`.\n\nFor example:\n\nAnother style of filtering might involve restricting the queryset based on\nsome part of the URL.\n\nFor example if your URL config contained an entry like this:\n\nYou could then write a view that returned a purchase queryset filtered by the\nusername portion of the URL:\n\nA final example of filtering the initial queryset would be to determine the\ninitial queryset based on query parameters in the url.\n\nWe can override `.get_queryset()` to deal with URLs such as\n`http://example.com/api/purchases?username=denvercoder9`, and filter the\nqueryset only if the `username` parameter is included in the URL:\n\nAs well as being able to override the default queryset, REST framework also\nincludes support for generic filtering backends that allow you to easily\nconstruct complex searches and filters.\n\nGeneric filters can also present themselves as HTML controls in the browsable\nAPI and admin API.\n\nThe default filter backends may be set globally, using the\n`DEFAULT_FILTER_BACKENDS` setting. For example.\n\nYou can also set the filter backends on a per-view, or per-viewset basis,\nusing the `GenericAPIView` class-based views.\n\nNote that if a filter backend is configured for a view, then as well as being\nused to filter list views, it will also be used to filter the querysets used\nfor returning a single object.\n\nFor instance, given the previous example, and a product with an id of `4675`,\nthe following URL would either return the corresponding object, or return a\n404 response, depending on if the filtering conditions were met by the given\nproduct instance:\n\nNote that you can use both an overridden `.get_queryset()` and generic\nfiltering together, and everything will work as expected. For example, if\n`Product` had a many-to-many relationship with `User`, named `purchase`, you\nmight want to write a view like this:\n\nThe `django-filter` library includes a `DjangoFilterBackend` class which\nsupports highly customizable field filtering for REST framework.\n\nTo use `DjangoFilterBackend`, first install `django-filter`.\n\nThen add `'django_filters'` to Django's `INSTALLED_APPS`:\n\nYou should now either add the filter backend to your settings:\n\nOr add the filter backend to an individual View or ViewSet.\n\nIf all you need is simple equality-based filtering, you can set a\n`filterset_fields` attribute on the view, or viewset, listing the set of\nfields you wish to filter against.\n\nThis will automatically create a `FilterSet` class for the given fields, and\nwill allow you to make requests such as:\n\nFor more advanced filtering requirements you can specify a `FilterSet` class\nthat should be used by the view. You can read more about `FilterSet`s in the\ndjango-filter documentation. It's also recommended that you read the section\non DRF integration.\n\nThe `SearchFilter` class supports simple single query parameter based\nsearching, and is based on the Django admin's search functionality.\n\nWhen in use, the browsable API will include a `SearchFilter` control:\n\nThe `SearchFilter` class will only be applied if the view has a\n`search_fields` attribute set. The `search_fields` attribute should be a list\nof names of text type fields on the model, such as `CharField` or `TextField`.\n\nThis will allow the client to filter the items in the list by making queries\nsuch as:\n\nYou can also perform a related lookup on a ForeignKey or ManyToManyField with\nthe lookup API double-underscore notation:\n\nFor JSONField and HStoreField fields you can filter based on nested values\nwithin the data structure using the same double-underscore notation:\n\nBy default, searches will use case-insensitive partial matches. The search\nparameter may contain multiple search terms, which should be whitespace and/or\ncomma separated. If multiple search terms are used then objects will be\nreturned in the list only if all the provided terms are matched.\n\nThe search behavior may be restricted by prepending various characters to the\n`search_fields`.\n\nFor example:\n\nBy default, the search parameter is named `'search'`, but this may be\noverridden with the `SEARCH_PARAM` setting.\n\nTo dynamically change search fields based on request content, it's possible to\nsubclass the `SearchFilter` and override the `get_search_fields()` function.\nFor example, the following subclass will only search on `title` if the query\nparameter `title_only` is in the request:\n\nFor more details, see the Django documentation.\n\nThe `OrderingFilter` class supports simple query parameter controlled ordering\nof results.\n\nBy default, the query parameter is named `'ordering'`, but this may by\noverridden with the `ORDERING_PARAM` setting.\n\nFor example, to order users by username:\n\nThe client may also specify reverse orderings by prefixing the field name with\n'-', like so:\n\nMultiple orderings may also be specified:\n\nIt's recommended that you explicitly specify which fields the API should\nallowing in the ordering filter. You can do this by setting an\n`ordering_fields` attribute on the view, like so:\n\nThis helps prevent unexpected data leakage, such as allowing users to order\nagainst a password hash field or other sensitive data.\n\nIf you don't specify an `ordering_fields` attribute on the view, the filter\nclass will default to allowing the user to filter on any readable fields on\nthe serializer specified by the `serializer_class` attribute.\n\nIf you are confident that the queryset being used by the view doesn't contain\nany sensitive data, you can also explicitly specify that a view should allow\nordering on any model field or queryset aggregate, by using the special value\n`'__all__'`.\n\nIf an `ordering` attribute is set on the view, this will be used as the\ndefault ordering.\n\nTypically you'd instead control this by setting `order_by` on the initial\nqueryset, but using the `ordering` parameter on the view allows you to specify\nthe ordering in a way that it can then be passed automatically as context to a\nrendered template. This makes it possible to automatically render column\nheaders differently if they are being used to order the results.\n\nThe `ordering` attribute may be either a string or a list/tuple of strings.\n\nYou can also provide your own generic filtering backend, or write an\ninstallable app for other developers to use.\n\nTo do so override `BaseFilterBackend`, and override the\n`.filter_queryset(self, request, queryset, view)` method. The method should\nreturn a new, filtered queryset.\n\nAs well as allowing clients to perform searches and filtering, generic filter\nbackends can be useful for restricting which objects should be visible to any\ngiven request or user.\n\nFor example, you might need to restrict users to only being able to see\nobjects they created.\n\nWe could achieve the same behavior by overriding `get_queryset()` on the\nviews, but using a filter backend allows you to more easily add this\nrestriction to multiple views, or to apply it across the entire API.\n\nGeneric filters may also present an interface in the browsable API. To do so\nyou should implement a `to_html()` method which returns a rendered HTML\nrepresentation of the filter. This method should have the following signature:\n\n`to_html(self, request, queryset, view)`\n\nThe method should return a rendered HTML string.\n\nYou can also make the filter controls available to the schema autogeneration\nthat REST framework provides, by implementing a `get_schema_fields()` method.\nThis method should have the following signature:\n\n`get_schema_fields(self, view)`\n\nThe method should return a list of `coreapi.Field` instances.\n\nThe following third party packages provide additional filter implementations.\n\nThe django-rest-framework-filters package works together with the\n`DjangoFilterBackend` class, and allows you to easily create filters across\nrelationships, or create multiple filter lookup types for a given field.\n\nThe djangorestframework-word-filter developed as alternative to\n`filters.SearchFilter` which will search full word in text, or exact match.\n\ndjango-url-filter provides a safe way to filter data via human-friendly URLs.\nIt works very similar to DRF serializers and fields in a sense that they can\nbe nested except they are called filtersets and filters. That provides easy\nway to filter related data. Also this library is generic-purpose so it can be\nused to filter other sources of data and not only Django `QuerySet`s.\n\ndrf-url-filter is a simple Django app to apply filters on drf `ModelViewSet`'s\n`Queryset` in a clean, simple and configurable way. It also supports\nvalidations on incoming query params and their values. A beautiful python\npackage `Voluptuous` is being used for validations on the incoming query\nparameters. The best part about voluptuous is you can define your own\nvalidations as per your query params requirements.\n\nfilters.py\n\n"}, {"name": "Serializer fields", "path": "api-guide/fields/index", "type": "API Guide", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "Serializer relations", "path": "api-guide/relations/index", "type": "API Guide", "text": "\nData structures, not algorithms, are central to programming.\n\n\u2014 Rob Pike\n\nRelational fields are used to represent model relationships. They can be\napplied to `ForeignKey`, `ManyToManyField` and `OneToOneField` relationships,\nas well as to reverse relationships, and custom relationships such as\n`GenericForeignKey`.\n\nNote: The relational fields are declared in `relations.py`, but by convention\nyou should import them from the `serializers` module, using `from\nrest_framework import serializers` and refer to fields as\n`serializers.<FieldName>`.\n\nWhen using the `ModelSerializer` class, serializer fields and relationships\nwill be automatically generated for you. Inspecting these automatically\ngenerated fields can be a useful tool for determining how to customize the\nrelationship style.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIn order to explain the various types of relational fields, we'll use a couple\nof simple models for our examples. Our models will be for music albums, and\nthe tracks listed on each album.\n\n`StringRelatedField` may be used to represent the target of the relationship\nusing its `__str__` method.\n\nFor example, the following serializer:\n\nWould serialize to the following representation:\n\nThis field is read only.\n\nArguments:\n\n`PrimaryKeyRelatedField` may be used to represent the target of the\nrelationship using its primary key.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nArguments:\n\n`HyperlinkedRelatedField` may be used to represent the target of the\nrelationship using a hyperlink.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nNote: This field is designed for objects that map to a URL that accepts a\nsingle URL keyword argument, as set using the `lookup_field` and\n`lookup_url_kwarg` arguments.\n\nThis is suitable for URLs that contain a single primary key or slug argument\nas part of the URL.\n\nIf you require more complex hyperlinked representation you'll need to\ncustomize the field, as described in the custom hyperlinked fields section,\nbelow.\n\nArguments:\n\n`SlugRelatedField` may be used to represent the target of the relationship\nusing a field on the target.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nWhen using `SlugRelatedField` as a read-write field, you will normally want to\nensure that the slug field corresponds to a model field with `unique=True`.\n\nArguments:\n\nThis field can be applied as an identity relationship, such as the `'url'`\nfield on a HyperlinkedModelSerializer. It can also be used for an attribute on\nthe object. For example, the following serializer:\n\nWould serialize to a representation like this:\n\nThis field is always read-only.\n\nArguments:\n\nAs opposed to previously discussed references to another entity, the referred\nentity can instead also be embedded or nested in the representation of the\nobject that refers to it. Such nested relationships can be expressed by using\nserializers as fields.\n\nIf the field is used to represent a to-many relationship, you should add the\n`many=True` flag to the serializer field.\n\nFor example, the following serializer:\n\nWould serialize to a nested representation like this:\n\nBy default nested serializers are read-only. If you want to support write-\noperations to a nested serializer field you'll need to create `create()`\nand/or `update()` methods in order to explicitly specify how the child\nrelationships should be saved:\n\nIn rare cases where none of the existing relational styles fit the\nrepresentation you need, you can implement a completely custom relational\nfield, that describes exactly how the output representation should be\ngenerated from the model instance.\n\nTo implement a custom relational field, you should override `RelatedField`,\nand implement the `.to_representation(self, value)` method. This method takes\nthe target of the field as the `value` argument, and should return the\nrepresentation that should be used to serialize the target. The `value`\nargument will typically be a model instance.\n\nIf you want to implement a read-write relational field, you must also\nimplement the `.to_internal_value(self, data)` method.\n\nTo provide a dynamic queryset based on the `context`, you can also override\n`.get_queryset(self)` instead of specifying `.queryset` on the class or when\ninitializing the field.\n\nFor example, we could define a relational field to serialize a track to a\ncustom string representation, using its ordering, title, and duration:\n\nThis custom field would then serialize to the following representation:\n\nIn some cases you may need to customize the behavior of a hyperlinked field,\nin order to represent URLs that require more than a single lookup field.\n\nYou can achieve this by overriding `HyperlinkedRelatedField`. There are two\nmethods that may be overridden:\n\nget_url(self, obj, view_name, request, format)\n\nThe `get_url` method is used to map the object instance to its URL\nrepresentation.\n\nMay raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes\nare not configured to correctly match the URL conf.\n\nget_object(self, view_name, view_args, view_kwargs)\n\nIf you want to support a writable hyperlinked field then you'll also want to\noverride `get_object`, in order to map incoming URLs back to the object they\nrepresent. For read-only hyperlinked fields there is no need to override this\nmethod.\n\nThe return value of this method should the object that corresponds to the\nmatched URL conf arguments.\n\nMay raise an `ObjectDoesNotExist` exception.\n\nSay we have a URL for a customer object that takes two keyword arguments, like\nso:\n\nThis cannot be represented with the default implementation, which accepts only\na single lookup field.\n\nIn this case we'd need to override `HyperlinkedRelatedField` to get the\nbehavior we want:\n\nNote that if you wanted to use this style together with the generic views then\nyou'd also need to override `.get_object` on the view in order to get the\ncorrect lookup behavior.\n\nGenerally we recommend a flat style for API representations where possible,\nbut the nested URL style can also be reasonable when used in moderation.\n\nThe `queryset` argument is only ever required for writable relationship field,\nin which case it is used for performing the model instance lookup, that maps\nfrom the primitive user input, into a model instance.\n\nIn version 2.x a serializer class could sometimes automatically determine the\n`queryset` argument if a `ModelSerializer` class was being used.\n\nThis behavior is now replaced with always using an explicit `queryset`\nargument for writable relational fields.\n\nDoing so reduces the amount of hidden 'magic' that `ModelSerializer` provides,\nmakes the behavior of the field more clear, and ensures that it is trivial to\nmove between using the `ModelSerializer` shortcut, or using fully explicit\n`Serializer` classes.\n\nThe built-in `__str__` method of the model will be used to generate string\nrepresentations of the objects used to populate the `choices` property. These\nchoices are used to populate select HTML inputs in the browsable API.\n\nTo provide customized representations for such inputs, override\n`display_value()` of a `RelatedField` subclass. This method will receive a\nmodel object, and should return a string suitable for representing it. For\nexample:\n\nWhen rendered in the browsable API relational fields will default to only\ndisplaying a maximum of 1000 selectable items. If more items are present then\na disabled option with \"More than 1000 items\u2026\" will be displayed.\n\nThis behavior is intended to prevent a template from being unable to render in\nan acceptable timespan due to a very large number of relationships being\ndisplayed.\n\nThere are two keyword arguments you can use to control this behavior:\n\nYou can also control these globally using the settings `HTML_SELECT_CUTOFF`\nand `HTML_SELECT_CUTOFF_TEXT`.\n\nIn cases where the cutoff is being enforced you may want to instead use a\nplain input field in the HTML form. You can do so using the `style` keyword\nargument. For example:\n\nNote that reverse relationships are not automatically included by the\n`ModelSerializer` and `HyperlinkedModelSerializer` classes. To include a\nreverse relationship, you must explicitly add it to the fields list. For\nexample:\n\nYou'll normally want to ensure that you've set an appropriate `related_name`\nargument on the relationship, that you can use as the field name. For example:\n\nIf you have not set a related name for the reverse relationship, you'll need\nto use the automatically generated related name in the `fields` argument. For\nexample:\n\nSee the Django documentation on reverse relationships for more details.\n\nIf you want to serialize a generic foreign key, you need to define a custom\nfield, to determine explicitly how you want to serialize the targets of the\nrelationship.\n\nFor example, given the following model for a tag, which has a generic\nrelationship with other arbitrary models:\n\nAnd the following two models, which may have associated tags:\n\nWe could define a custom field that could be used to serialize tagged\ninstances, using the type of each instance to determine how it should be\nserialized:\n\nIf you need the target of the relationship to have a nested representation,\nyou can use the required serializers inside the `.to_representation()` method:\n\nNote that reverse generic keys, expressed using the `GenericRelation` field,\ncan be serialized using the regular relational field types, since the type of\nthe target in the relationship is always known.\n\nFor more information see the Django documentation on generic relations.\n\nBy default, relational fields that target a `ManyToManyField` with a `through`\nmodel specified are set to read-only.\n\nIf you explicitly specify a relational field pointing to a `ManyToManyField`\nwith a through model, be sure to set `read_only` to `True`.\n\nIf you wish to represent extra fields on a through model then you may\nserialize the through model as a nested object.\n\nThe following third party packages are also available.\n\nThe drf-nested-routers package provides routers and relationship fields for\nworking with nested resources.\n\nThe rest-framework-generic-relations library provides read/write serialization\nfor generic foreign keys.\n\nrelations.py\n\n"}, {"name": "SerializerMethodField", "path": "api-guide/fields/index#serializermethodfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "Serializers", "path": "api-guide/serializers/index", "type": "API Guide", "text": "\nExpanding the usefulness of the serializers is something that we would like to\naddress. However, it's not a trivial problem, and it will take some serious\ndesign work.\n\n\u2014 Russell Keith-Magee, Django users group\n\nSerializers allow complex data such as querysets and model instances to be\nconverted to native Python datatypes that can then be easily rendered into\n`JSON`, `XML` or other content types. Serializers also provide\ndeserialization, allowing parsed data to be converted back into complex types,\nafter first validating the incoming data.\n\nThe serializers in REST framework work very similarly to Django's `Form` and\n`ModelForm` classes. We provide a `Serializer` class which gives you a\npowerful, generic way to control the output of your responses, as well as a\n`ModelSerializer` class which provides a useful shortcut for creating\nserializers that deal with model instances and querysets.\n\nLet's start by creating a simple object we can use for example purposes:\n\nWe'll declare a serializer that we can use to serialize and deserialize data\nthat corresponds to `Comment` objects.\n\nDeclaring a serializer looks very similar to declaring a form:\n\nWe can now use `CommentSerializer` to serialize a comment, or list of\ncomments. Again, using the `Serializer` class looks a lot like using a `Form`\nclass.\n\nAt this point we've translated the model instance into Python native\ndatatypes. To finalise the serialization process we render the data into\n`json`.\n\nDeserialization is similar. First we parse a stream into Python native\ndatatypes...\n\n...then we restore those native datatypes into a dictionary of validated data.\n\nIf we want to be able to return complete object instances based on the\nvalidated data we need to implement one or both of the `.create()` and\n`.update()` methods. For example:\n\nIf your object instances correspond to Django models you'll also want to\nensure that these methods save the object to the database. For example, if\n`Comment` was a Django model, the methods might look like this:\n\nNow when deserializing data, we can call `.save()` to return an object\ninstance, based on the validated data.\n\nCalling `.save()` will either create a new instance, or update an existing\ninstance, depending on if an existing instance was passed when instantiating\nthe serializer class:\n\nBoth the `.create()` and `.update()` methods are optional. You can implement\neither neither, one, or both of them, depending on the use-case for your\nserializer class.\n\nSometimes you'll want your view code to be able to inject additional data at\nthe point of saving the instance. This additional data might include\ninformation like the current user, the current time, or anything else that is\nnot part of the request data.\n\nYou can do so by including additional keyword arguments when calling\n`.save()`. For example:\n\nAny additional keyword arguments will be included in the `validated_data`\nargument when `.create()` or `.update()` are called.\n\nIn some cases the `.create()` and `.update()` method names may not be\nmeaningful. For example, in a contact form we may not be creating new\ninstances, but instead sending an email or other message.\n\nIn these cases you might instead choose to override `.save()` directly, as\nbeing more readable and meaningful.\n\nFor example:\n\nNote that in the case above we're now having to access the serializer\n`.validated_data` property directly.\n\nWhen deserializing data, you always need to call `is_valid()` before\nattempting to access the validated data, or save an object instance. If any\nvalidation errors occur, the `.errors` property will contain a dictionary\nrepresenting the resulting error messages. For example:\n\nEach key in the dictionary will be the field name, and the values will be\nlists of strings of any error messages corresponding to that field. The\n`non_field_errors` key may also be present, and will list any general\nvalidation errors. The name of the `non_field_errors` key may be customized\nusing the `NON_FIELD_ERRORS_KEY` REST framework setting.\n\nWhen deserializing a list of items, errors will be returned as a list of\ndictionaries representing each of the deserialized items.\n\nThe `.is_valid()` method takes an optional `raise_exception` flag that will\ncause it to raise a `serializers.ValidationError` exception if there are\nvalidation errors.\n\nThese exceptions are automatically dealt with by the default exception handler\nthat REST framework provides, and will return `HTTP 400 Bad Request` responses\nby default.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. These are\nsimilar to the `.clean_<field_name>` methods on Django forms.\n\nThese methods take a single argument, which is the field value that requires\nvalidation.\n\nYour `validate_<field_name>` methods should return the validated value or\nraise a `serializers.ValidationError`. For example:\n\nNote: If your `<field_name>` is declared on your serializer with the parameter\n`required=False` then this validation step will not take place if the field is\nnot included.\n\nTo do any other validation that requires access to multiple fields, add a\nmethod called `.validate()` to your `Serializer` subclass. This method takes a\nsingle argument, which is a dictionary of field values. It should raise a\n`serializers.ValidationError` if necessary, or just return the validated\nvalues. For example:\n\nIndividual fields on a serializer can include validators, by declaring them on\nthe field instance, for example:\n\nSerializer classes can also include reusable validators that are applied to\nthe complete set of field data. These validators are included by declaring\nthem on an inner `Meta` class, like so:\n\nFor more information see the validators documentation.\n\nWhen passing an initial object or queryset to a serializer instance, the\nobject will be made available as `.instance`. If no initial object is passed\nthen the `.instance` attribute will be `None`.\n\nWhen passing data to a serializer instance, the unmodified data will be made\navailable as `.initial_data`. If the `data` keyword argument is not passed\nthen the `.initial_data` attribute will not exist.\n\nBy default, serializers must be passed values for all required fields or they\nwill raise validation errors. You can use the `partial` argument in order to\nallow partial updates.\n\nThe previous examples are fine for dealing with objects that only have simple\ndatatypes, but sometimes we also need to be able to represent more complex\nobjects, where some of the attributes of an object might not be simple\ndatatypes such as strings, dates or integers.\n\nThe `Serializer` class is itself a type of `Field`, and can be used to\nrepresent relationships where one object type is nested inside another.\n\nIf a nested representation may optionally accept the `None` value you should\npass the `required=False` flag to the nested serializer.\n\nSimilarly if a nested representation should be a list of items, you should\npass the `many=True` flag to the nested serializer.\n\nWhen dealing with nested representations that support deserializing the data,\nany errors with nested objects will be nested under the field name of the\nnested object.\n\nSimilarly, the `.validated_data` property will include nested data structures.\n\nIf you're supporting writable nested representations you'll need to write\n`.create()` or `.update()` methods that handle saving multiple objects.\n\nThe following example demonstrates how you might handle creating a user with a\nnested profile object.\n\nFor updates you'll want to think carefully about how to handle updates to\nrelationships. For example if the data for the relationship is `None`, or not\nprovided, which of the following should occur?\n\nHere's an example for an `.update()` method on our previous `UserSerializer`\nclass.\n\nBecause the behavior of nested creates and updates can be ambiguous, and may\nrequire complex dependencies between related models, REST framework 3 requires\nyou to always write these methods explicitly. The default `ModelSerializer`\n`.create()` and `.update()` methods do not include support for writable nested\nrepresentations.\n\nThere are however, third-party packages available such as DRF Writable Nested\nthat support automatic writable nested representations.\n\nAn alternative to saving multiple related instances in the serializer is to\nwrite custom model manager classes that handle creating the correct instances.\n\nFor example, suppose we wanted to ensure that `User` instances and `Profile`\ninstances are always created together as a pair. We might write a custom\nmanager class that looks something like this:\n\nThis manager class now more nicely encapsulates that user instances and\nprofile instances are always created at the same time. Our `.create()` method\non the serializer class can now be re-written to use the new manager method.\n\nFor more details on this approach see the Django documentation on model\nmanagers, and this blogpost on using model and manager classes.\n\nThe `Serializer` class can also handle serializing or deserializing lists of\nobjects.\n\nTo serialize a queryset or list of objects instead of a single object\ninstance, you should pass the `many=True` flag when instantiating the\nserializer. You can then pass a queryset or list of objects to be serialized.\n\nThe default behavior for deserializing multiple objects is to support multiple\nobject creation, but not support multiple object updates. For more information\non how to support or customize either of these cases, see the ListSerializer\ndocumentation below.\n\nThere are some cases where you need to provide extra context to the serializer\nin addition to the object being serialized. One common case is if you're using\na serializer that includes hyperlinked relations, which requires the\nserializer to have access to the current request so that it can properly\ngenerate fully qualified URLs.\n\nYou can provide arbitrary additional context by passing a `context` argument\nwhen instantiating the serializer. For example:\n\nThe context dictionary can be used within any serializer field logic, such as\na custom `.to_representation()` method, by accessing the `self.context`\nattribute.\n\nOften you'll want serializer classes that map closely to Django model\ndefinitions.\n\nThe `ModelSerializer` class provides a shortcut that lets you automatically\ncreate a `Serializer` class with fields that correspond to the Model fields.\n\nThe `ModelSerializer` class is the same as a regular `Serializer` class,\nexcept that:\n\nDeclaring a `ModelSerializer` looks like this:\n\nBy default, all the model fields on the class will be mapped to a\ncorresponding serializer fields.\n\nAny relationships such as foreign keys on the model will be mapped to\n`PrimaryKeyRelatedField`. Reverse relationships are not included by default\nunless explicitly included as specified in the serializer relations\ndocumentation.\n\nSerializer classes generate helpful verbose representation strings, that allow\nyou to fully inspect the state of their fields. This is particularly useful\nwhen working with `ModelSerializers` where you want to determine what set of\nfields and validators are being automatically created for you.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIf you only want a subset of the default fields to be used in a model\nserializer, you can do so using `fields` or `exclude` options, just as you\nwould with a `ModelForm`. It is strongly recommended that you explicitly set\nall fields that should be serialized using the `fields` attribute. This will\nmake it less likely to result in unintentionally exposing data when your\nmodels change.\n\nFor example:\n\nYou can also set the `fields` attribute to the special value `'__all__'` to\nindicate that all fields in the model should be used.\n\nFor example:\n\nYou can set the `exclude` attribute to a list of fields to be excluded from\nthe serializer.\n\nFor example:\n\nIn the example above, if the `Account` model had 3 fields `account_name`,\n`users`, and `created`, this will result in the fields `account_name` and\n`created` to be serialized.\n\nThe names in the `fields` and `exclude` attributes will normally map to model\nfields on the model class.\n\nAlternatively names in the `fields` options can map to properties or methods\nwhich take no arguments that exist on the model class.\n\nSince version 3.3.0, it is mandatory to provide one of the attributes `fields`\nor `exclude`.\n\nThe default `ModelSerializer` uses primary keys for relationships, but you can\nalso easily generate nested representations using the `depth` option:\n\nThe `depth` option should be set to an integer value that indicates the depth\nof relationships that should be traversed before reverting to a flat\nrepresentation.\n\nIf you want to customize the way the serialization is done you'll need to\ndefine the field yourself.\n\nYou can add extra fields to a `ModelSerializer` or override the default fields\nby declaring fields on the class, just as you would for a `Serializer` class.\n\nExtra fields can correspond to any property or callable on the model.\n\nYou may wish to specify multiple fields as read-only. Instead of adding each\nfield explicitly with the `read_only=True` attribute, you may use the shortcut\nMeta option, `read_only_fields`.\n\nThis option should be a list or tuple of field names, and is declared as\nfollows:\n\nModel fields which have `editable=False` set, and `AutoField` fields will be\nset to read-only by default, and do not need to be added to the\n`read_only_fields` option.\n\nNote: There is a special-case where a read-only field is part of a\n`unique_together` constraint at the model level. In this case the field is\nrequired by the serializer class in order to validate the constraint, but\nshould also not be editable by the user.\n\nThe right way to deal with this is to specify the field explicitly on the\nserializer, providing both the `read_only=True` and `default=\u2026` keyword\narguments.\n\nOne example of this is a read-only relation to the currently authenticated\n`User` which is `unique_together` with another identifier. In this case you\nwould declare the user field like so:\n\nPlease review the Validators Documentation for details on the\nUniqueTogetherValidator and CurrentUserDefault classes.\n\nThere is also a shortcut allowing you to specify arbitrary additional keyword\narguments on fields, using the `extra_kwargs` option. As in the case of\n`read_only_fields`, this means you do not need to explicitly declare the field\non the serializer.\n\nThis option is a dictionary, mapping field names to a dictionary of keyword\narguments. For example:\n\nPlease keep in mind that, if the field has already been explicitly declared on\nthe serializer class, then the `extra_kwargs` option will be ignored.\n\nWhen serializing model instances, there are a number of different ways you\nmight choose to represent relationships. The default representation for\n`ModelSerializer` is to use the primary keys of the related instances.\n\nAlternative representations include serializing using hyperlinks, serializing\ncomplete nested representations, or serializing with a custom representation.\n\nFor full details see the serializer relations documentation.\n\nThe ModelSerializer class also exposes an API that you can override in order\nto alter how serializer fields are automatically determined when instantiating\nthe serializer.\n\nNormally if a `ModelSerializer` does not generate the fields you need by\ndefault then you should either add them to the class explicitly, or simply use\na regular `Serializer` class instead. However in some cases you may want to\ncreate a new base class that defines how the serializer fields are created for\nany given model.\n\nA mapping of Django model fields to REST framework serializer fields. You can\noverride this mapping to alter the default serializer fields that should be\nused for each model field.\n\nThis property should be the serializer field class, that is used for\nrelational fields by default.\n\nFor `ModelSerializer` this defaults to `PrimaryKeyRelatedField`.\n\nFor `HyperlinkedModelSerializer` this defaults to\n`serializers.HyperlinkedRelatedField`.\n\nThe serializer field class that should be used for any `url` field on the\nserializer.\n\nDefaults to `serializers.HyperlinkedIdentityField`\n\nThe serializer field class that should be used for any choice fields on the\nserializer.\n\nDefaults to `serializers.ChoiceField`\n\nThe following methods are called to determine the class and keyword arguments\nfor each field that should be automatically included on the serializer. Each\nof these methods should return a two tuple of `(field_class, field_kwargs)`.\n\nCalled to generate a serializer field that maps to a standard model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_field_mapping` attribute.\n\nCalled to generate a serializer field that maps to a relational model field.\n\nThe default implementation returns a serializer class based on the\n`serializer_related_field` attribute.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a relational model field,\nwhen the `depth` option has been set.\n\nThe default implementation dynamically creates a nested serializer class based\non either `ModelSerializer` or `HyperlinkedModelSerializer`.\n\nThe `nested_depth` will be the value of the `depth` option, minus one.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`,\n`related_model`, `to_many` and `has_through_model` properties.\n\nCalled to generate a serializer field that maps to a property or zero-argument\nmethod on the model class.\n\nThe default implementation returns a `ReadOnlyField` class.\n\nCalled to generate a serializer field for the serializer's own `url` field.\nThe default implementation returns a `HyperlinkedIdentityField` class.\n\nCalled when the field name did not map to any model field or model property.\nThe default implementation raises an error, although subclasses may customize\nthis behavior.\n\nThe `HyperlinkedModelSerializer` class is similar to the `ModelSerializer`\nclass except that it uses hyperlinks to represent relationships, rather than\nprimary keys.\n\nBy default the serializer will include a `url` field instead of a primary key\nfield.\n\nThe url field will be represented using a `HyperlinkedIdentityField`\nserializer field, and any relationships on the model will be represented using\na `HyperlinkedRelatedField` serializer field.\n\nYou can explicitly include the primary key by adding it to the `fields`\noption, for example:\n\nWhen instantiating a `HyperlinkedModelSerializer` you must include the current\n`request` in the serializer context, for example:\n\nDoing so will ensure that the hyperlinks can include an appropriate hostname,\nso that the resulting representation uses fully qualified URLs, such as:\n\nRather than relative URLs, such as:\n\nIf you do want to use relative URLs, you should explicitly pass `{'request':\nNone}` in the serializer context.\n\nThere needs to be a way of determining which views should be used for\nhyperlinking to model instances.\n\nBy default hyperlinks are expected to correspond to a view name that matches\nthe style `'{model_name}-detail'`, and looks up the instance by a `pk` keyword\nargument.\n\nYou can override a URL field view name and lookup field by using either, or\nboth of, the `view_name` and `lookup_field` options in the `extra_kwargs`\nsetting, like so:\n\nAlternatively you can set the fields on the serializer explicitly. For\nexample:\n\nTip: Properly matching together hyperlinked representations and your URL conf\ncan sometimes be a bit fiddly. Printing the `repr` of a\n`HyperlinkedModelSerializer` instance is a particularly useful way to inspect\nexactly which view names and lookup fields the relationships are expected to\nmap too.\n\nThe name of the URL field defaults to 'url'. You can override this globally,\nby using the `URL_FIELD_NAME` setting.\n\nThe `ListSerializer` class provides the behavior for serializing and\nvalidating multiple objects at once. You won't typically need to use\n`ListSerializer` directly, but should instead simply pass `many=True` when\ninstantiating a serializer.\n\nWhen a serializer is instantiated and `many=True` is passed, a\n`ListSerializer` instance will be created. The serializer class then becomes a\nchild of the parent `ListSerializer`\n\nThe following argument can also be passed to a `ListSerializer` field or a\nserializer that is passed `many=True`:\n\nThis is `True` by default, but can be set to `False` if you want to disallow\nempty lists as valid input.\n\nThere are a few use cases when you might want to customize the\n`ListSerializer` behavior. For example:\n\nFor these cases you can modify the class that is used when `many=True` is\npassed, by using the `list_serializer_class` option on the serializer `Meta`\nclass.\n\nFor example:\n\nThe default implementation for multiple object creation is to simply call\n`.create()` for each item in the list. If you want to customize this behavior,\nyou'll need to customize the `.create()` method on `ListSerializer` class that\nis used when `many=True` is passed.\n\nFor example:\n\nBy default the `ListSerializer` class does not support multiple updates. This\nis because the behavior that should be expected for insertions and deletions\nis ambiguous.\n\nTo support multiple updates you'll need to do so explicitly. When writing your\nmultiple update code make sure to keep the following in mind:\n\nYou will need to add an explicit `id` field to the instance serializer. The\ndefault implicitly-generated `id` field is marked as `read_only`. This causes\nit to be removed on updates. Once you declare it explicitly, it will be\navailable in the list serializer's `update` method.\n\nHere's an example of how you might choose to implement multiple updates:\n\nIt is possible that a third party package may be included alongside the 3.1\nrelease that provides some automatic support for multiple update operations,\nsimilar to the `allow_add_remove` behavior that was present in REST framework\n2.\n\nWhen a serializer with `many=True` is instantiated, we need to determine which\narguments and keyword arguments should be passed to the `.__init__()` method\nfor both the child `Serializer` class, and for the parent `ListSerializer`\nclass.\n\nThe default implementation is to pass all arguments to both classes, except\nfor `validators`, and any custom keyword arguments, both of which are assumed\nto be intended for the child serializer class.\n\nOccasionally you might need to explicitly specify how the child and parent\nclasses should be instantiated when `many=True` is passed. You can do so by\nusing the `many_init` class method.\n\n`BaseSerializer` class that can be used to easily support alternative\nserialization and deserialization styles.\n\nThis class implements the same basic API as the `Serializer` class:\n\nThere are four methods that can be overridden, depending on what functionality\nyou want the serializer class to support:\n\nBecause this class provides the same interface as the `Serializer` class, you\ncan use it with the existing generic class-based views exactly as you would\nfor a regular `Serializer` or `ModelSerializer`.\n\nThe only difference you'll notice when doing so is the `BaseSerializer`\nclasses will not generate HTML forms in the browsable API. This is because the\ndata they return does not include all the field information that would allow\neach field to be rendered into a suitable HTML input.\n\nTo implement a read-only serializer using the `BaseSerializer` class, we just\nneed to override the `.to_representation()` method. Let's take a look at an\nexample using a simple Django model:\n\nIt's simple to create a read-only serializer for converting `HighScore`\ninstances into primitive data types.\n\nWe can now use this class to serialize single `HighScore` instances:\n\nOr use it to serialize multiple instances:\n\nTo create a read-write serializer we first need to implement a\n`.to_internal_value()` method. This method returns the validated values that\nwill be used to construct the object instance, and may raise a\n`serializers.ValidationError` if the supplied data is in an incorrect format.\n\nOnce you've implemented `.to_internal_value()`, the basic validation API will\nbe available on the serializer, and you will be able to use `.is_valid()`,\n`.validated_data` and `.errors`.\n\nIf you want to also support `.save()` you'll need to also implement either or\nboth of the `.create()` and `.update()` methods.\n\nHere's a complete example of our previous `HighScoreSerializer`, that's been\nupdated to support both read and write operations.\n\nThe `BaseSerializer` class is also useful if you want to implement new generic\nserializer classes for dealing with particular serialization styles, or for\nintegrating with alternative storage backends.\n\nThe following class is an example of a generic serializer that can handle\ncoercing arbitrary objects into primitive representations.\n\nIf you need to alter the serialization or deserialization behavior of a\nserializer class, you can do so by overriding the `.to_representation()` or\n`.to_internal_value()` methods.\n\nSome reasons this might be useful include...\n\nThe signatures for these methods are as follows:\n\nTakes the object instance that requires serialization, and should return a\nprimitive representation. Typically this means returning a structure of built-\nin Python datatypes. The exact types that can be handled will depend on the\nrender classes you have configured for your API.\n\nMay be overridden in order to modify the representation style. For example:\n\nTakes the unvalidated incoming data as input and should return the validated\ndata that will be made available as `serializer.validated_data`. The return\nvalue will also be passed to the `.create()` or `.update()` methods if\n`.save()` is called on the serializer class.\n\nIf any of the validation fails, then the method should raise a\n`serializers.ValidationError(errors)`. The `errors` argument should be a\ndictionary mapping field names (or `settings.NON_FIELD_ERRORS_KEY`) to a list\nof error messages. If you don't need to alter deserialization behavior and\ninstead want to provide object-level validation, it's recommended that you\ninstead override the `.validate()` method.\n\nThe `data` argument passed to this method will normally be the value of\n`request.data`, so the datatype it provides will depend on the parser classes\nyou have configured for your API.\n\nSimilar to Django forms, you can extend and reuse serializers through\ninheritance. This allows you to declare a common set of fields or methods on a\nparent class that can then be used in a number of serializers. For example,\n\nLike Django's `Model` and `ModelForm` classes, the inner `Meta` class on\nserializers does not implicitly inherit from it's parents' inner `Meta`\nclasses. If you want the `Meta` class to inherit from a parent class you must\ndo so explicitly. For example:\n\nTypically we would recommend not using inheritance on inner Meta classes, but\ninstead declaring all options explicitly.\n\nAdditionally, the following caveats apply to serializer inheritance:\n\nIt\u2019s possible to declaratively remove a `Field` inherited from a parent class\nby setting the name to be `None` on the subclass.\n\nHowever, you can only use this technique to opt out from a field defined\ndeclaratively by a parent class; it won\u2019t prevent the `ModelSerializer` from\ngenerating a default field. To opt-out from default fields, see Specifying\nwhich fields to include.\n\nOnce a serializer has been initialized, the dictionary of fields that are set\non the serializer may be accessed using the `.fields` attribute. Accessing and\nmodifying this attribute allows you to dynamically modify the serializer.\n\nModifying the `fields` argument directly allows you to do interesting things\nsuch as changing the arguments on serializer fields at runtime, rather than at\nthe point of declaring the serializer.\n\nFor example, if you wanted to be able to set which fields should be used by a\nserializer at the point of initializing it, you could create a serializer\nclass like so:\n\nThis would then allow you to do the following:\n\nREST framework 2 provided an API to allow developers to override how a\n`ModelSerializer` class would automatically generate the default set of\nfields.\n\nThis API included the `.get_field()`, `.get_pk_field()` and other methods.\n\nBecause the serializers have been fundamentally redesigned with 3.0 this API\nno longer exists. You can still modify the fields that get created but you'll\nneed to refer to the source code, and be aware that if the changes you make\nare against private bits of API then they may be subject to change.\n\nThe following third party packages are also available.\n\nThe django-rest-marshmallow package provides an alternative implementation for\nserializers, using the python marshmallow library. It exposes the same API as\nthe REST framework serializers, and can be used as a drop-in replacement in\nsome use-cases.\n\nThe serpy package is an alternative implementation for serializers that is\nbuilt for speed. Serpy serializes complex datatypes to simple native types.\nThe native types can be easily converted to JSON or any other format needed.\n\nThe django-rest-framework-mongoengine package provides a\n`MongoEngineModelSerializer` serializer class that supports using MongoDB as\nthe storage layer for Django REST framework.\n\nThe django-rest-framework-gis package provides a `GeoFeatureModelSerializer`\nserializer class that supports GeoJSON both for read and write operations.\n\nThe django-rest-framework-hstore package provides an `HStoreSerializer` to\nsupport django-hstore `DictionaryField` model field and its `schema-mode`\nfeature.\n\nThe dynamic-rest package extends the ModelSerializer and ModelViewSet\ninterfaces, adding API query parameters for filtering, sorting, and including\n/ excluding all fields and relationships defined by your serializers.\n\nThe drf-dynamic-fields package provides a mixin to dynamically limit the\nfields per serializer to a subset specified by an URL parameter.\n\nThe drf-flex-fields package extends the ModelSerializer and ModelViewSet to\nprovide commonly used functionality for dynamically setting fields and\nexpanding primitive fields to nested models, both from URL parameters and your\nserializer class definitions.\n\nThe django-rest-framework-serializer-extensions package provides a collection\nof tools to DRY up your serializers, by allowing fields to be defined on a\nper-view/request basis. Fields can be whitelisted, blacklisted and child\nserializers can be optionally expanded.\n\nThe html-json-forms package provides an algorithm and serializer for\nprocessing `<form>` submissions per the (inactive) HTML JSON Form\nspecification. The serializer facilitates processing of arbitrarily nested\nJSON structures within HTML. For example, `<input name=\"items[0][id]\"\nvalue=\"5\">` will be interpreted as `{\"items\": [{\"id\": \"5\"}]}`.\n\nDRF-Base64 provides a set of field and model serializers that handles the\nupload of base64-encoded files.\n\ndjangorestframework-queryfields allows API clients to specify which fields\nwill be sent in the response via inclusion/exclusion query parameters.\n\nThe drf-writable-nested package provides writable nested model serializer\nwhich allows to create/update models with nested related data.\n\nThe drf-encrypt-content package helps you encrypt your data, serialized\nthrough ModelSerializer. It also contains some helper functions. Which helps\nyou to encrypt your data.\n\nserializers.py\n\n"}, {"name": "SessionAuthentication", "path": "api-guide/authentication/index#sessionauthentication", "type": "Ref: Authentication", "text": "\nAuth needs to be pluggable.\n\n\u2014 Jacob Kaplan-Moss, \"REST worst practices\"\n\nAuthentication is the mechanism of associating an incoming request with a set\nof identifying credentials, such as the user the request came from, or the\ntoken that it was signed with. The permission and throttling policies can then\nuse those credentials to determine if the request should be permitted.\n\nREST framework provides several authentication schemes out of the box, and\nalso allows you to implement custom schemes.\n\nAuthentication always runs at the very start of the view, before the\npermission and throttling checks occur, and before any other code is allowed\nto proceed.\n\nThe `request.user` property will typically be set to an instance of the\n`contrib.auth` package's `User` class.\n\nThe `request.auth` property is used for any additional authentication\ninformation, for example, it may be used to represent an authentication token\nthat the request was signed with.\n\nNote: Don't forget that authentication by itself won't allow or disallow an\nincoming request, it simply identifies the credentials that the request was\nmade with.\n\nFor information on how to set up the permission policies for your API please\nsee the permissions documentation.\n\nThe authentication schemes are always defined as a list of classes. REST\nframework will attempt to authenticate with each class in the list, and will\nset `request.user` and `request.auth` using the return value of the first\nclass that successfully authenticates.\n\nIf no class authenticates, `request.user` will be set to an instance of\n`django.contrib.auth.models.AnonymousUser`, and `request.auth` will be set to\n`None`.\n\nThe value of `request.user` and `request.auth` for unauthenticated requests\ncan be modified using the `UNAUTHENTICATED_USER` and `UNAUTHENTICATED_TOKEN`\nsettings.\n\nThe default authentication schemes may be set globally, using the\n`DEFAULT_AUTHENTICATION_CLASSES` setting. For example.\n\nYou can also set the authentication scheme on a per-view or per-viewset basis,\nusing the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nWhen an unauthenticated request is denied permission there are two different\nerror codes that may be appropriate.\n\nHTTP 401 responses must always include a `WWW-Authenticate` header, that\ninstructs the client how to authenticate. HTTP 403 responses do not include\nthe `WWW-Authenticate` header.\n\nThe kind of response that will be used depends on the authentication scheme.\nAlthough multiple authentication schemes may be in use, only one scheme may be\nused to determine the type of response. The first authentication class set on\nthe view is used when determining the type of response.\n\nNote that when a request may successfully authenticate, but still be denied\npermission to perform the request, in which case a `403 Permission Denied`\nresponse will always be used, regardless of the authentication scheme.\n\nNote that if deploying to Apache using mod_wsgi, the authorization header is\nnot passed through to a WSGI application by default, as it is assumed that\nauthentication will be handled by Apache, rather than at an application level.\n\nIf you are deploying to Apache, and using any non-session based\nauthentication, you will need to explicitly configure mod_wsgi to pass the\nrequired headers through to the application. This can be done by specifying\nthe `WSGIPassAuthorization` directive in the appropriate context and setting\nit to `'On'`.\n\nThis authentication scheme uses HTTP Basic Authentication, signed against a\nuser's username and password. Basic authentication is generally only\nappropriate for testing.\n\nIf successfully authenticated, `BasicAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nNote: If you use `BasicAuthentication` in production you must ensure that your\nAPI is only available over `https`. You should also ensure that your API\nclients will always re-request the username and password at login, and will\nnever store those details to persistent storage.\n\nThis authentication scheme uses a simple token-based HTTP Authentication\nscheme. Token authentication is appropriate for client-server setups, such as\nnative desktop and mobile clients.\n\nTo use the `TokenAuthentication` scheme you'll need to configure the\nauthentication classes to include `TokenAuthentication`, and additionally\ninclude `rest_framework.authtoken` in your `INSTALLED_APPS` setting:\n\nNote: Make sure to run `manage.py migrate` after changing your settings. The\n`rest_framework.authtoken` app provides Django database migrations.\n\nYou'll also need to create tokens for your users.\n\nFor clients to authenticate, the token key should be included in the\n`Authorization` HTTP header. The key should be prefixed by the string literal\n\"Token\", with whitespace separating the two strings. For example:\n\nNote: If you want to use a different keyword in the header, such as `Bearer`,\nsimply subclass `TokenAuthentication` and set the `keyword` class variable.\n\nIf successfully authenticated, `TokenAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nThe `curl` command line tool may be useful for testing token authenticated\nAPIs. For example:\n\nNote: If you use `TokenAuthentication` in production you must ensure that your\nAPI is only available over `https`.\n\nIf you want every user to have an automatically generated Token, you can\nsimply catch the User's `post_save` signal.\n\nNote that you'll want to ensure you place this code snippet in an installed\n`models.py` module, or some other location that will be imported by Django on\nstartup.\n\nIf you've already created some users, you can generate tokens for all existing\nusers like this:\n\nWhen using `TokenAuthentication`, you may want to provide a mechanism for\nclients to obtain a token given the username and password. REST framework\nprovides a built-in view to provide this behaviour. To use it, add the\n`obtain_auth_token` view to your URLconf:\n\nNote that the URL part of the pattern can be whatever you want to use.\n\nThe `obtain_auth_token` view will return a JSON response when valid `username`\nand `password` fields are POSTed to the view using form data or JSON:\n\nNote that the default `obtain_auth_token` view explicitly uses JSON requests\nand responses, rather than using default renderer and parser classes in your\nsettings.\n\nBy default, there are no permissions or throttling applied to the\n`obtain_auth_token` view. If you do wish to apply to throttle you'll need to\noverride the view class, and include them using the `throttle_classes`\nattribute.\n\nIf you need a customized version of the `obtain_auth_token` view, you can do\nso by subclassing the `ObtainAuthToken` view class, and using that in your url\nconf instead.\n\nFor example, you may return additional user information beyond the `token`\nvalue:\n\nAnd in your `urls.py`:\n\nIt is also possible to create Tokens manually through the admin interface. In\ncase you are using a large user base, we recommend that you monkey patch the\n`TokenAdmin` class customize it to your needs, more specifically by declaring\nthe `user` field as `raw_field`.\n\n`your_app/admin.py`:\n\nSince version 3.6.4 it's possible to generate a user token using the following\ncommand:\n\nthis command will return the API token for the given user, creating it if it\ndoesn't exist:\n\nIn case you want to regenerate the token (for example if it has been\ncompromised or leaked) you can pass an additional parameter:\n\nThis authentication scheme uses Django's default session backend for\nauthentication. Session authentication is appropriate for AJAX clients that\nare running in the same session context as your website.\n\nIf successfully authenticated, `SessionAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n403 Forbidden` response.\n\nIf you're using an AJAX-style API with SessionAuthentication, you'll need to\nmake sure you include a valid CSRF token for any \"unsafe\" HTTP method calls,\nsuch as `PUT`, `PATCH`, `POST` or `DELETE` requests. See the Django CSRF\ndocumentation for more details.\n\nWarning: Always use Django's standard login view when creating login pages.\nThis will ensure your login views are properly protected.\n\nCSRF validation in REST framework works slightly differently from standard\nDjango due to the need to support both session and non-session based\nauthentication to the same views. This means that only authenticated requests\nrequire CSRF tokens, and anonymous requests may be sent without CSRF tokens.\nThis behaviour is not suitable for login views, which should always have CSRF\nvalidation applied.\n\nThis authentication scheme allows you to delegate authentication to your web\nserver, which sets the `REMOTE_USER` environment variable.\n\nTo use it, you must have `django.contrib.auth.backends.RemoteUserBackend` (or\na subclass) in your `AUTHENTICATION_BACKENDS` setting. By default,\n`RemoteUserBackend` creates `User` objects for usernames that don't already\nexist. To change this and other behaviour, consult the Django documentation.\n\nIf successfully authenticated, `RemoteUserAuthentication` provides the\nfollowing credentials:\n\nConsult your web server's documentation for information about configuring an\nauthentication method, e.g.:\n\nTo implement a custom authentication scheme, subclass `BaseAuthentication` and\noverride the `.authenticate(self, request)` method. The method should return a\ntwo-tuple of `(user, auth)` if authentication succeeds, or `None` otherwise.\n\nIn some circumstances instead of returning `None`, you may want to raise an\n`AuthenticationFailed` exception from the `.authenticate()` method.\n\nTypically the approach you should take is:\n\nYou may also override the `.authenticate_header(self, request)` method. If\nimplemented, it should return a string that will be used as the value of the\n`WWW-Authenticate` header in a `HTTP 401 Unauthorized` response.\n\nIf the `.authenticate_header()` method is not overridden, the authentication\nscheme will return `HTTP 403 Forbidden` responses when an unauthenticated\nrequest is denied access.\n\nNote: When your custom authenticator is invoked by the request object's\n`.user` or `.auth` properties, you may see an `AttributeError` re-raised as a\n`WrappedAttributeError`. This is necessary to prevent the original exception\nfrom being suppressed by the outer property access. Python will not recognize\nthat the `AttributeError` originates from your custom authenticator and will\ninstead assume that the request object does not have a `.user` or `.auth`\nproperty. These errors should be fixed or otherwise handled by your\nauthenticator.\n\nThe following example will authenticate any incoming request as the user given\nby the username in a custom request header named 'X-USERNAME'.\n\nThe following third-party packages are also available.\n\nThe Django OAuth Toolkit package provides OAuth 2.0 support and works with\nPython 3.4+. The package is maintained by jazzband and uses the excellent\nOAuthLib. The package is well documented, and well supported and is currently\nour recommended package for OAuth 2.0 support.\n\nInstall using `pip`.\n\nAdd the package to your `INSTALLED_APPS` and modify your REST framework\nsettings.\n\nFor more details see the Django REST framework - Getting started\ndocumentation.\n\nThe Django REST framework OAuth package provides both OAuth1 and OAuth2\nsupport for REST framework.\n\nThis package was previously included directly in the REST framework but is now\nsupported and maintained as a third-party package.\n\nInstall the package using `pip`.\n\nFor details on configuration and usage see the Django REST framework OAuth\ndocumentation for authentication and permissions.\n\nJSON Web Token is a fairly new standard which can be used for token-based\nauthentication. Unlike the built-in TokenAuthentication scheme, JWT\nAuthentication doesn't need to use a database to validate a token. A package\nfor JWT authentication is djangorestframework-simplejwt which provides some\nfeatures as well as a pluggable token blacklist app.\n\nThe HawkREST library builds on the Mohawk library to let you work with Hawk\nsigned requests and responses in your API. Hawk lets two parties securely\ncommunicate with each other using messages signed by a shared key. It is based\non HTTP MAC access authentication (which was based on parts of OAuth 1.0).\n\nHTTP Signature (currently a IETF draft) provides a way to achieve origin\nauthentication and message integrity for HTTP messages. Similar to Amazon's\nHTTP Signature scheme, used by many of its services, it permits stateless,\nper-request authentication. Elvio Toccalino maintains the djangorestframework-\nhttpsignature (outdated) package which provides an easy to use HTTP Signature\nAuthentication mechanism. You can use the updated fork version of\ndjangorestframework-httpsignature, which is drf-httpsig.\n\nDjoser library provides a set of views to handle basic actions such as\nregistration, login, logout, password reset and account activation. The\npackage works with a custom user model and uses token-based authentication.\nThis is ready to use REST implementation of the Django authentication system.\n\nThis library provides a set of REST API endpoints for registration,\nauthentication (including social media authentication), password reset,\nretrieve and update user details, etc. By having these API endpoints, your\nclient apps such as AngularJS, iOS, Android, and others can communicate to\nyour Django backend site independently via REST APIs for user management.\n\nThere are currently two forks of this project.\n\nDjango-rest-framework-social-oauth2 library provides an easy way to integrate\nsocial plugins (facebook, twitter, google, etc.) to your authentication system\nand an easy oauth2 setup. With this library, you will be able to authenticate\nusers based on external tokens (e.g. facebook access token), convert these\ntokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to\nauthenticate your users.\n\nDjango-rest-knox library provides models and views to handle token-based\nauthentication in a more secure and extensible way than the built-in\nTokenAuthentication scheme - with Single Page Applications and Mobile clients\nin mind. It provides per-client tokens, and views to generate them when\nprovided some other authentication (usually basic authentication), to delete\nthe token (providing a server enforced logout) and to delete all tokens (logs\nout all clients that a user is logged into).\n\ndrfpasswordless adds (Medium, Square Cash inspired) passwordless support to\nDjango REST Framework's TokenAuthentication scheme. Users log in and sign up\nwith a token sent to a contact point like an email address or a mobile number.\n\ndjango-rest-authemail provides a RESTful API interface for user signup and\nauthentication. Email addresses are used for authentication, rather than\nusernames. API endpoints are available for signup, signup email verification,\nlogin, logout, password reset, password reset verification, email change,\nemail change verification, password change, and user detail. A fully\nfunctional example project and detailed instructions are included.\n\nDjango-Rest-Durin is built with the idea to have one library that does token\nauth for multiple Web/CLI/Mobile API clients via one interface but allows\ndifferent token configuration for each API Client that consumes the API. It\nprovides support for multiple tokens per user via custom models, views,\npermissions that work with Django-Rest-Framework. The token expiration time\ncan be different per API client and is customizable via the Django Admin\nInterface.\n\nMore information can be found in the Documentation.\n\nauthentication.py\n\n"}, {"name": "Settings", "path": "api-guide/settings/index", "type": "API Guide", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "SimpleRouter", "path": "api-guide/routers/index#simplerouter", "type": "Ref: Routers", "text": "\nResource routing allows you to quickly declare all of the common routes for a\ngiven resourceful controller. Instead of declaring separate routes for your\nindex... a resourceful route declares them in a single line of code.\n\n\u2014 Ruby on Rails Documentation\n\nSome Web frameworks such as Rails provide functionality for automatically\ndetermining how the URLs for an application should be mapped to the logic that\ndeals with handling incoming requests.\n\nREST framework adds support for automatic URL routing to Django, and provides\nyou with a simple, quick and consistent way of wiring your view logic to a set\nof URLs.\n\nHere's an example of a simple URL conf, that uses `SimpleRouter`.\n\nThere are two mandatory arguments to the `register()` method:\n\nOptionally, you may also specify an additional argument:\n\nThe example above would generate the following URL patterns:\n\nNote: The `basename` argument is used to specify the initial part of the view\nname pattern. In the example above, that's the `user` or `account` part.\n\nTypically you won't need to specify the `basename` argument, but if you have a\nviewset where you've defined a custom `get_queryset` method, then the viewset\nmay not have a `.queryset` attribute set. If you try to register that viewset\nyou'll see an error like this:\n\nThis means you'll need to explicitly set the `basename` argument when\nregistering the viewset, as it could not be automatically determined from the\nmodel name.\n\nThe `.urls` attribute on a router instance is simply a standard list of URL\npatterns. There are a number of different styles for how you can include these\nURLs.\n\nFor example, you can append `router.urls` to a list of existing views...\n\nAlternatively you can use Django's `include` function, like so...\n\nYou may use `include` with an application namespace:\n\nOr both an application and instance namespace:\n\nSee Django's URL namespaces docs and the `include` API reference for more\ndetails.\n\nNote: If using namespacing with hyperlinked serializers you'll also need to\nensure that any `view_name` parameters on the serializers correctly reflect\nthe namespace. In the examples above you'd need to include a parameter such as\n`view_name='app_name:user-detail'` for serializer fields hyperlinked to the\nuser detail view.\n\nThe automatic `view_name` generation uses a pattern like\n`%(model_name)-detail`. Unless your models names actually clash you may be\nbetter off not namespacing your Django REST Framework views when using\nhyperlinked serializers.\n\nA viewset may mark extra actions for routing by decorating a method with the\n`@action` decorator. These extra actions will be included in the generated\nroutes. For example, given the `set_password` method on the `UserViewSet`\nclass:\n\nThe following route would be generated:\n\nBy default, the URL pattern is based on the method name, and the URL name is\nthe combination of the `ViewSet.basename` and the hyphenated method name. If\nyou don't want to use the defaults for either of these values, you can instead\nprovide the `url_path` and `url_name` arguments to the `@action` decorator.\n\nFor example, if you want to change the URL for our custom action to\n`^users/{pk}/change-password/$`, you could write:\n\nThe above example would now generate the following URL pattern:\n\nThis router includes routes for the standard set of `list`, `create`,\n`retrieve`, `update`, `partial_update` and `destroy` actions. The viewset can\nalso mark additional methods to be routed, using the `@action` decorator.\n\nBy default the URLs created by `SimpleRouter` are appended with a trailing\nslash. This behavior can be modified by setting the `trailing_slash` argument\nto `False` when instantiating the router. For example:\n\nTrailing slashes are conventional in Django, but are not used by default in\nsome other frameworks such as Rails. Which style you choose to use is largely\na matter of preference, although some javascript frameworks may expect a\nparticular routing style.\n\nThe router will match lookup values containing any characters except slashes\nand period characters. For a more restrictive (or lenient) lookup pattern, set\nthe `lookup_value_regex` attribute on the viewset. For example, you can limit\nthe lookup to valid UUIDs:\n\nThis router is similar to `SimpleRouter` as above, but additionally includes a\ndefault API root view, that returns a response containing hyperlinks to all\nthe list views. It also generates routes for optional `.json` style format\nsuffixes.\n\nAs with `SimpleRouter` the trailing slashes on the URL routes can be removed\nby setting the `trailing_slash` argument to `False` when instantiating the\nrouter.\n\nImplementing a custom router isn't something you'd need to do very often, but\nit can be useful if you have specific requirements about how the URLs for your\nAPI are structured. Doing so allows you to encapsulate the URL structure in a\nreusable way that ensures you don't have to write your URL patterns explicitly\nfor each new view.\n\nThe simplest way to implement a custom router is to subclass one of the\nexisting router classes. The `.routes` attribute is used to template the URL\npatterns that will be mapped to each viewset. The `.routes` attribute is a\nlist of `Route` named tuples.\n\nThe arguments to the `Route` named tuple are:\n\nurl: A string representing the URL to be routed. May include the following\nformat strings:\n\nmapping: A mapping of HTTP method names to the view methods\n\nname: The name of the URL as used in `reverse` calls. May include the\nfollowing format string:\n\ninitkwargs: A dictionary of any additional arguments that should be passed\nwhen instantiating the view. Note that the `detail`, `basename`, and `suffix`\narguments are reserved for viewset introspection and are also used by the\nbrowsable API to generate the view name and breadcrumb links.\n\nYou can also customize how the `@action` decorator is routed. Include the\n`DynamicRoute` named tuple in the `.routes` list, setting the `detail`\nargument as appropriate for the list-based and detail-based routes. In\naddition to `detail`, the arguments to `DynamicRoute` are:\n\nurl: A string representing the URL to be routed. May include the same format\nstrings as `Route`, and additionally accepts the `{url_path}` format string.\n\nname: The name of the URL as used in `reverse` calls. May include the\nfollowing format strings:\n\ninitkwargs: A dictionary of any additional arguments that should be passed\nwhen instantiating the view.\n\nThe following example will only route to the `list` and `retrieve` actions,\nand does not use the trailing slash convention.\n\nLet's take a look at the routes our `CustomReadOnlyRouter` would generate for\na simple viewset.\n\n`views.py`:\n\n`urls.py`:\n\nThe following mappings would be generated...\n\nFor another example of setting the `.routes` attribute, see the source code\nfor the `SimpleRouter` class.\n\nIf you want to provide totally custom behavior, you can override `BaseRouter`\nand override the `get_urls(self)` method. The method should inspect the\nregistered viewsets and return a list of URL patterns. The registered prefix,\nviewset and basename tuples may be inspected by accessing the `self.registry`\nattribute.\n\nYou may also want to override the `get_default_basename(self, viewset)`\nmethod, or else always explicitly set the `basename` argument when registering\nyour viewsets with the router.\n\nThe following third party packages are also available.\n\nThe drf-nested-routers package provides routers and relationship fields for\nworking with nested resources.\n\nThe wq.db package provides an advanced ModelRouter class (and singleton\ninstance) that extends `DefaultRouter` with a `register_model()` API. Much\nlike Django's `admin.site.register`, the only required argument to\n`rest.router.register_model` is a model class. Reasonable defaults for a url\nprefix, serializer, and viewset will be inferred from the model and global\nconfiguration.\n\nThe `DRF-extensions` package provides routers for creating nested viewsets,\ncollection level controllers with customizable endpoint names.\n\nrouters.py\n\n"}, {"name": "SlugField", "path": "api-guide/fields/index#slugfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "SlugRelatedField", "path": "api-guide/relations/index#slugrelatedfield", "type": "Ref: Serializer relations", "text": "\nData structures, not algorithms, are central to programming.\n\n\u2014 Rob Pike\n\nRelational fields are used to represent model relationships. They can be\napplied to `ForeignKey`, `ManyToManyField` and `OneToOneField` relationships,\nas well as to reverse relationships, and custom relationships such as\n`GenericForeignKey`.\n\nNote: The relational fields are declared in `relations.py`, but by convention\nyou should import them from the `serializers` module, using `from\nrest_framework import serializers` and refer to fields as\n`serializers.<FieldName>`.\n\nWhen using the `ModelSerializer` class, serializer fields and relationships\nwill be automatically generated for you. Inspecting these automatically\ngenerated fields can be a useful tool for determining how to customize the\nrelationship style.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIn order to explain the various types of relational fields, we'll use a couple\nof simple models for our examples. Our models will be for music albums, and\nthe tracks listed on each album.\n\n`StringRelatedField` may be used to represent the target of the relationship\nusing its `__str__` method.\n\nFor example, the following serializer:\n\nWould serialize to the following representation:\n\nThis field is read only.\n\nArguments:\n\n`PrimaryKeyRelatedField` may be used to represent the target of the\nrelationship using its primary key.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nArguments:\n\n`HyperlinkedRelatedField` may be used to represent the target of the\nrelationship using a hyperlink.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nNote: This field is designed for objects that map to a URL that accepts a\nsingle URL keyword argument, as set using the `lookup_field` and\n`lookup_url_kwarg` arguments.\n\nThis is suitable for URLs that contain a single primary key or slug argument\nas part of the URL.\n\nIf you require more complex hyperlinked representation you'll need to\ncustomize the field, as described in the custom hyperlinked fields section,\nbelow.\n\nArguments:\n\n`SlugRelatedField` may be used to represent the target of the relationship\nusing a field on the target.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nWhen using `SlugRelatedField` as a read-write field, you will normally want to\nensure that the slug field corresponds to a model field with `unique=True`.\n\nArguments:\n\nThis field can be applied as an identity relationship, such as the `'url'`\nfield on a HyperlinkedModelSerializer. It can also be used for an attribute on\nthe object. For example, the following serializer:\n\nWould serialize to a representation like this:\n\nThis field is always read-only.\n\nArguments:\n\nAs opposed to previously discussed references to another entity, the referred\nentity can instead also be embedded or nested in the representation of the\nobject that refers to it. Such nested relationships can be expressed by using\nserializers as fields.\n\nIf the field is used to represent a to-many relationship, you should add the\n`many=True` flag to the serializer field.\n\nFor example, the following serializer:\n\nWould serialize to a nested representation like this:\n\nBy default nested serializers are read-only. If you want to support write-\noperations to a nested serializer field you'll need to create `create()`\nand/or `update()` methods in order to explicitly specify how the child\nrelationships should be saved:\n\nIn rare cases where none of the existing relational styles fit the\nrepresentation you need, you can implement a completely custom relational\nfield, that describes exactly how the output representation should be\ngenerated from the model instance.\n\nTo implement a custom relational field, you should override `RelatedField`,\nand implement the `.to_representation(self, value)` method. This method takes\nthe target of the field as the `value` argument, and should return the\nrepresentation that should be used to serialize the target. The `value`\nargument will typically be a model instance.\n\nIf you want to implement a read-write relational field, you must also\nimplement the `.to_internal_value(self, data)` method.\n\nTo provide a dynamic queryset based on the `context`, you can also override\n`.get_queryset(self)` instead of specifying `.queryset` on the class or when\ninitializing the field.\n\nFor example, we could define a relational field to serialize a track to a\ncustom string representation, using its ordering, title, and duration:\n\nThis custom field would then serialize to the following representation:\n\nIn some cases you may need to customize the behavior of a hyperlinked field,\nin order to represent URLs that require more than a single lookup field.\n\nYou can achieve this by overriding `HyperlinkedRelatedField`. There are two\nmethods that may be overridden:\n\nget_url(self, obj, view_name, request, format)\n\nThe `get_url` method is used to map the object instance to its URL\nrepresentation.\n\nMay raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes\nare not configured to correctly match the URL conf.\n\nget_object(self, view_name, view_args, view_kwargs)\n\nIf you want to support a writable hyperlinked field then you'll also want to\noverride `get_object`, in order to map incoming URLs back to the object they\nrepresent. For read-only hyperlinked fields there is no need to override this\nmethod.\n\nThe return value of this method should the object that corresponds to the\nmatched URL conf arguments.\n\nMay raise an `ObjectDoesNotExist` exception.\n\nSay we have a URL for a customer object that takes two keyword arguments, like\nso:\n\nThis cannot be represented with the default implementation, which accepts only\na single lookup field.\n\nIn this case we'd need to override `HyperlinkedRelatedField` to get the\nbehavior we want:\n\nNote that if you wanted to use this style together with the generic views then\nyou'd also need to override `.get_object` on the view in order to get the\ncorrect lookup behavior.\n\nGenerally we recommend a flat style for API representations where possible,\nbut the nested URL style can also be reasonable when used in moderation.\n\nThe `queryset` argument is only ever required for writable relationship field,\nin which case it is used for performing the model instance lookup, that maps\nfrom the primitive user input, into a model instance.\n\nIn version 2.x a serializer class could sometimes automatically determine the\n`queryset` argument if a `ModelSerializer` class was being used.\n\nThis behavior is now replaced with always using an explicit `queryset`\nargument for writable relational fields.\n\nDoing so reduces the amount of hidden 'magic' that `ModelSerializer` provides,\nmakes the behavior of the field more clear, and ensures that it is trivial to\nmove between using the `ModelSerializer` shortcut, or using fully explicit\n`Serializer` classes.\n\nThe built-in `__str__` method of the model will be used to generate string\nrepresentations of the objects used to populate the `choices` property. These\nchoices are used to populate select HTML inputs in the browsable API.\n\nTo provide customized representations for such inputs, override\n`display_value()` of a `RelatedField` subclass. This method will receive a\nmodel object, and should return a string suitable for representing it. For\nexample:\n\nWhen rendered in the browsable API relational fields will default to only\ndisplaying a maximum of 1000 selectable items. If more items are present then\na disabled option with \"More than 1000 items\u2026\" will be displayed.\n\nThis behavior is intended to prevent a template from being unable to render in\nan acceptable timespan due to a very large number of relationships being\ndisplayed.\n\nThere are two keyword arguments you can use to control this behavior:\n\nYou can also control these globally using the settings `HTML_SELECT_CUTOFF`\nand `HTML_SELECT_CUTOFF_TEXT`.\n\nIn cases where the cutoff is being enforced you may want to instead use a\nplain input field in the HTML form. You can do so using the `style` keyword\nargument. For example:\n\nNote that reverse relationships are not automatically included by the\n`ModelSerializer` and `HyperlinkedModelSerializer` classes. To include a\nreverse relationship, you must explicitly add it to the fields list. For\nexample:\n\nYou'll normally want to ensure that you've set an appropriate `related_name`\nargument on the relationship, that you can use as the field name. For example:\n\nIf you have not set a related name for the reverse relationship, you'll need\nto use the automatically generated related name in the `fields` argument. For\nexample:\n\nSee the Django documentation on reverse relationships for more details.\n\nIf you want to serialize a generic foreign key, you need to define a custom\nfield, to determine explicitly how you want to serialize the targets of the\nrelationship.\n\nFor example, given the following model for a tag, which has a generic\nrelationship with other arbitrary models:\n\nAnd the following two models, which may have associated tags:\n\nWe could define a custom field that could be used to serialize tagged\ninstances, using the type of each instance to determine how it should be\nserialized:\n\nIf you need the target of the relationship to have a nested representation,\nyou can use the required serializers inside the `.to_representation()` method:\n\nNote that reverse generic keys, expressed using the `GenericRelation` field,\ncan be serialized using the regular relational field types, since the type of\nthe target in the relationship is always known.\n\nFor more information see the Django documentation on generic relations.\n\nBy default, relational fields that target a `ManyToManyField` with a `through`\nmodel specified are set to read-only.\n\nIf you explicitly specify a relational field pointing to a `ManyToManyField`\nwith a through model, be sure to set `read_only` to `True`.\n\nIf you wish to represent extra fields on a through model then you may\nserialize the through model as a nested object.\n\nThe following third party packages are also available.\n\nThe drf-nested-routers package provides routers and relationship fields for\nworking with nested resources.\n\nThe rest-framework-generic-relations library provides read/write serialization\nfor generic foreign keys.\n\nrelations.py\n\n"}, {"name": "StaticHTMLRenderer", "path": "api-guide/renderers/index#statichtmlrenderer", "type": "Ref: Renderers", "text": "\nBefore a TemplateResponse instance can be returned to the client, it must be\nrendered. The rendering process takes the intermediate representation of\ntemplate and context, and turns it into the final byte stream that can be\nserved to the client.\n\n\u2014 Django documentation\n\nREST framework includes a number of built in Renderer classes, that allow you\nto return responses with various media types. There is also support for\ndefining your own custom renderers, which gives you the flexibility to design\nyour own media types.\n\nThe set of valid renderers for a view is always defined as a list of classes.\nWhen a view is entered REST framework will perform content negotiation on the\nincoming request, and determine the most appropriate renderer to satisfy the\nrequest.\n\nThe basic process of content negotiation involves examining the request's\n`Accept` header, to determine which media types it expects in the response.\nOptionally, format suffixes on the URL may be used to explicitly request a\nparticular representation. For example the URL\n`http://example.com/api/users_count.json` might be an endpoint that always\nreturns JSON data.\n\nFor more information see the documentation on content negotiation.\n\nThe default set of renderers may be set globally, using the\n`DEFAULT_RENDERER_CLASSES` setting. For example, the following settings would\nuse `JSON` as the main media type and also include the self describing API.\n\nYou can also set the renderers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nIt's important when specifying the renderer classes for your API to think\nabout what priority you want to assign to each media type. If a client\nunderspecifies the representations it can accept, such as sending an `Accept:\n*/*` header, or not including an `Accept` header at all, then REST framework\nwill select the first renderer in the list to use for the response.\n\nFor example if your API serves JSON responses and the HTML browsable API, you\nmight want to make `JSONRenderer` your default renderer, in order to send\n`JSON` responses to clients that do not specify an `Accept` header.\n\nIf your API includes views that can serve both regular webpages and API\nresponses depending on the request, then you might consider making\n`TemplateHTMLRenderer` your default renderer, in order to play nicely with\nolder browsers that send broken accept headers.\n\nRenders the request data into `JSON`, using utf-8 encoding.\n\nNote that the default style is to include unicode characters, and render the\nresponse using a compact style with no unnecessary whitespace:\n\nThe client may additionally include an `'indent'` media type parameter, in\nwhich case the returned `JSON` will be indented. For example `Accept:\napplication/json; indent=4`.\n\nThe default JSON encoding style can be altered using the `UNICODE_JSON` and\n`COMPACT_JSON` settings keys.\n\n.media_type: `application/json`\n\n.format: `'json'`\n\n.charset: `None`\n\nRenders data to HTML, using Django's standard template rendering. Unlike other\nrenderers, the data passed to the `Response` does not need to be serialized.\nAlso, unlike other renderers, you may want to include a `template_name`\nargument when creating the `Response`.\n\nThe TemplateHTMLRenderer will create a `RequestContext`, using the\n`response.data` as the context dict, and determine a template name to use to\nrender the context.\n\nNote: When used with a view that makes use of a serializer the `Response` sent\nfor rendering may not be a dictionary and will need to be wrapped in a dict\nbefore returning to allow the TemplateHTMLRenderer to render it. For example:\n\nThe template name is determined by (in order of preference):\n\nAn example of a view that uses `TemplateHTMLRenderer`:\n\nYou can use `TemplateHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\nIf you're building websites that use `TemplateHTMLRenderer` along with other\nrenderer classes, you should consider listing `TemplateHTMLRenderer` as the\nfirst class in the `renderer_classes` list, so that it will be prioritised\nfirst even for browsers that send poorly formed `ACCEPT:` headers.\n\nSee the HTML & Forms Topic Page for further examples of `TemplateHTMLRenderer`\nusage.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `StaticHTMLRenderer`\n\nA simple renderer that simply returns pre-rendered HTML. Unlike other\nrenderers, the data passed to the response object should be a string\nrepresenting the content to be returned.\n\nAn example of a view that uses `StaticHTMLRenderer`:\n\nYou can use `StaticHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `TemplateHTMLRenderer`\n\nRenders data into HTML for the Browsable API:\n\nThis renderer will determine which other renderer would have been given\nhighest priority, and use that to display an API style response within the\nHTML page.\n\n.media_type: `text/html`\n\n.format: `'api'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/api.html'`\n\nBy default the response content will be rendered with the highest priority\nrenderer apart from `BrowsableAPIRenderer`. If you need to customize this\nbehavior, for example to use HTML as the default return format, but use JSON\nin the browsable API, you can do so by overriding the `get_default_renderer()`\nmethod. For example:\n\nRenders data into HTML for an admin-like display:\n\nThis renderer is suitable for CRUD-style web APIs that should also present a\nuser-friendly interface for managing the data.\n\nNote that views that have nested or list serializers for their input won't\nwork well with the `AdminRenderer`, as the HTML forms are unable to properly\nsupport them.\n\nNote: The `AdminRenderer` is only able to include links to detail pages when a\nproperly configured `URL_FIELD_NAME` (`url` by default) attribute is present\nin the data. For `HyperlinkedModelSerializer` this will be the case, but for\n`ModelSerializer` or plain `Serializer` classes you'll need to make sure to\ninclude the field explicitly. For example here we use models\n`get_absolute_url` method:\n\n.media_type: `text/html`\n\n.format: `'admin'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/admin.html'`\n\nRenders data returned by a serializer into an HTML form. The output of this\nrenderer does not include the enclosing `<form>` tags, a hidden CSRF input or\nany submit buttons.\n\nThis renderer is not intended to be used directly, but can instead be used in\ntemplates by passing a serializer instance to the `render_form` template tag.\n\nFor more information see the HTML & Forms documentation.\n\n.media_type: `text/html`\n\n.format: `'form'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/horizontal/form.html'`\n\nThis renderer is used for rendering HTML multipart form data. It is not\nsuitable as a response renderer, but is instead used for creating test\nrequests, using REST framework's test client and test request factory.\n\n.media_type: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n.format: `'multipart'`\n\n.charset: `utf-8`\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the\n`.media_type` and `.format` properties, and implement the `.render(self, data,\nmedia_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the\nHTTP response.\n\nThe arguments passed to the `.render()` method are:\n\nThe request data, as set by the `Response()` instantiation.\n\nOptional. If provided, this is the accepted media type, as determined by the\ncontent negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the\nrenderer's `media_type` attribute, and may include media type parameters. For\nexample `\"application/json; nested=true\"`.\n\nOptional. If provided, this is a dictionary of contextual information provided\nby the view.\n\nBy default this will include the following keys: `view`, `request`,\n`response`, `args`, `kwargs`.\n\nThe following is an example plaintext renderer that will return a response\nwith the `data` parameter as the content of the response.\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To\nuse a different encoding, set the `charset` attribute on the renderer.\n\nNote that if a renderer class returns a unicode string, then the response\ncontent will be coerced into a bytestring by the `Response` class, with the\n`charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you\nshould set a charset value of `None`, which will ensure the `Content-Type`\nheader of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to\n`'binary'`. Doing so will also ensure that the browsable API will not attempt\nto display the binary content as a string.\n\nYou can do some pretty flexible things using REST framework's renderers. Some\nexamples...\n\nIn some cases you might want your view to use different serialization styles\ndepending on the accepted media type. If you need to do this you can access\n`request.accepted_renderer` to determine the negotiated renderer that will be\nused for the response.\n\nFor example:\n\nIn some cases you might want a renderer to serve a range of media types. In\nthis case you can underspecify the media types it should respond to, by using\na `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify\nthe media type explicitly when you return the response, using the\n`content_type` attribute. For example:\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked\nrelations may be sufficient. If you want to fully embrace RESTful design and\nHATEOAS you'll need to consider the design and usage of your media types in\nmore detail.\n\nIn the words of Roy Fielding, \"A REST API should spend almost all of its\ndescriptive effort in defining the media type(s) used for representing\nresources and driving application state, or in defining extended relation\nnames and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom\napplication/vnd.github+json media type, and Mike Amundsen's IANA approved\napplication/vnd.collection+json JSON-based hypermedia.\n\nTypically a renderer will behave the same regardless of if it's dealing with a\nregular response, or with a response caused by an exception being raised, such\nas an `Http404` or `PermissionDenied` exception, or a subclass of\n`APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer`\nand an exception is raised, the behavior is slightly different, and mirrors\nDjango's default handling of error views.\n\nExceptions raised and handled by an HTML renderer will attempt to render using\none of the following methods, by order of precedence.\n\nTemplates will render with a `RequestContext` which includes the `status_code`\nand `details` keys.\n\nNote: If `DEBUG=True`, Django's standard traceback error page will be\ndisplayed instead of rendering the HTTP status code and text.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST framework JSONP provides JSONP rendering support. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nWarning: If you require cross-domain AJAX requests, you should generally be\nusing the more modern approach of CORS as an alternative to `JSONP`. See the\nCORS documentation for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is only appropriate\nfor globally readable API endpoints, where `GET` requests are unauthenticated\nand do not require any user permissions.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\nXLSX is the world's most popular binary spreadsheet format. Tim Allen of The\nWharton School maintains drf-renderer-xlsx, which renders an endpoint as an\nXLSX spreadsheet using OpenPyXL, and allows the client to download it.\nSpreadsheets can be styled on a per-view basis.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nTo avoid having a file streamed without a filename (which the browser will\noften default to the filename \"download\", with no extension), we need to use a\nmixin to override the `Content-Disposition` header. If no filename is\nprovided, it will default to `export.xlsx`. For example:\n\nComma-separated values are a plain-text tabular data format, that can be\neasily imported into spreadsheet applications. Mjumbe Poe maintains the\ndjangorestframework-csv package which provides CSV renderer support for REST\nframework.\n\nUltraJSON is an optimized C JSON encoder which can give significantly faster\nJSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now\nunmaintained drf-ujson-renderer, which implements JSON rendering using the\nUJSON package.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nDjango REST Pandas provides a serializer and renderers that support additional\ndata processing and output via the Pandas DataFrame API. Django REST Pandas\nincludes renderers for Pandas-style CSV files, Excel workbooks (both `.xls`\nand `.xlsx`), and a number of other formats. It is maintained by S. Andrew\nSheppard as part of the wq Project.\n\nRest Framework Latex provides a renderer that outputs PDFs using Laulatex. It\nis maintained by Pebble (S/F Software).\n\nrenderers.py\n\n"}, {"name": "Status Codes", "path": "api-guide/status-codes/index", "type": "API Guide", "text": "\n418 I'm a teapot - Any attempt to brew coffee with a teapot should result in\nthe error code \"418 I'm a teapot\". The resulting entity body MAY be short and\nstout.\n\n\u2014 RFC 2324, Hyper Text Coffee Pot Control Protocol\n\nUsing bare status codes in your responses isn't recommended. REST framework\nincludes a set of named constants that you can use to make your code more\nobvious and readable.\n\nThe full set of HTTP status codes included in the `status` module is listed\nbelow.\n\nThe module also includes a set of helper functions for testing if a status\ncode is in a given range.\n\nFor more information on proper usage of HTTP status codes see RFC 2616 and RFC\n6585.\n\nThis class of status code indicates a provisional response. There are no 1xx\nstatus codes used in REST framework by default.\n\nThis class of status code indicates that the client's request was successfully\nreceived, understood, and accepted.\n\nThis class of status code indicates that further action needs to be taken by\nthe user agent in order to fulfill the request.\n\nThe 4xx class of status code is intended for cases in which the client seems\nto have erred. Except when responding to a HEAD request, the server SHOULD\ninclude an entity containing an explanation of the error situation, and\nwhether it is a temporary or permanent condition.\n\nResponse status codes beginning with the digit \"5\" indicate cases in which the\nserver is aware that it has erred or is incapable of performing the request.\nExcept when responding to a HEAD request, the server SHOULD include an entity\ncontaining an explanation of the error situation, and whether it is a\ntemporary or permanent condition.\n\nThe following helper functions are available for identifying the category of\nthe response code.\n\nstatus.py\n\n"}, {"name": "StringRelatedField", "path": "api-guide/relations/index#stringrelatedfield", "type": "Ref: Serializer relations", "text": "\nData structures, not algorithms, are central to programming.\n\n\u2014 Rob Pike\n\nRelational fields are used to represent model relationships. They can be\napplied to `ForeignKey`, `ManyToManyField` and `OneToOneField` relationships,\nas well as to reverse relationships, and custom relationships such as\n`GenericForeignKey`.\n\nNote: The relational fields are declared in `relations.py`, but by convention\nyou should import them from the `serializers` module, using `from\nrest_framework import serializers` and refer to fields as\n`serializers.<FieldName>`.\n\nWhen using the `ModelSerializer` class, serializer fields and relationships\nwill be automatically generated for you. Inspecting these automatically\ngenerated fields can be a useful tool for determining how to customize the\nrelationship style.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import\nthe serializer class, instantiate it, and print the object representation\u2026\n\nIn order to explain the various types of relational fields, we'll use a couple\nof simple models for our examples. Our models will be for music albums, and\nthe tracks listed on each album.\n\n`StringRelatedField` may be used to represent the target of the relationship\nusing its `__str__` method.\n\nFor example, the following serializer:\n\nWould serialize to the following representation:\n\nThis field is read only.\n\nArguments:\n\n`PrimaryKeyRelatedField` may be used to represent the target of the\nrelationship using its primary key.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nArguments:\n\n`HyperlinkedRelatedField` may be used to represent the target of the\nrelationship using a hyperlink.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nNote: This field is designed for objects that map to a URL that accepts a\nsingle URL keyword argument, as set using the `lookup_field` and\n`lookup_url_kwarg` arguments.\n\nThis is suitable for URLs that contain a single primary key or slug argument\nas part of the URL.\n\nIf you require more complex hyperlinked representation you'll need to\ncustomize the field, as described in the custom hyperlinked fields section,\nbelow.\n\nArguments:\n\n`SlugRelatedField` may be used to represent the target of the relationship\nusing a field on the target.\n\nFor example, the following serializer:\n\nWould serialize to a representation like this:\n\nBy default this field is read-write, although you can change this behavior\nusing the `read_only` flag.\n\nWhen using `SlugRelatedField` as a read-write field, you will normally want to\nensure that the slug field corresponds to a model field with `unique=True`.\n\nArguments:\n\nThis field can be applied as an identity relationship, such as the `'url'`\nfield on a HyperlinkedModelSerializer. It can also be used for an attribute on\nthe object. For example, the following serializer:\n\nWould serialize to a representation like this:\n\nThis field is always read-only.\n\nArguments:\n\nAs opposed to previously discussed references to another entity, the referred\nentity can instead also be embedded or nested in the representation of the\nobject that refers to it. Such nested relationships can be expressed by using\nserializers as fields.\n\nIf the field is used to represent a to-many relationship, you should add the\n`many=True` flag to the serializer field.\n\nFor example, the following serializer:\n\nWould serialize to a nested representation like this:\n\nBy default nested serializers are read-only. If you want to support write-\noperations to a nested serializer field you'll need to create `create()`\nand/or `update()` methods in order to explicitly specify how the child\nrelationships should be saved:\n\nIn rare cases where none of the existing relational styles fit the\nrepresentation you need, you can implement a completely custom relational\nfield, that describes exactly how the output representation should be\ngenerated from the model instance.\n\nTo implement a custom relational field, you should override `RelatedField`,\nand implement the `.to_representation(self, value)` method. This method takes\nthe target of the field as the `value` argument, and should return the\nrepresentation that should be used to serialize the target. The `value`\nargument will typically be a model instance.\n\nIf you want to implement a read-write relational field, you must also\nimplement the `.to_internal_value(self, data)` method.\n\nTo provide a dynamic queryset based on the `context`, you can also override\n`.get_queryset(self)` instead of specifying `.queryset` on the class or when\ninitializing the field.\n\nFor example, we could define a relational field to serialize a track to a\ncustom string representation, using its ordering, title, and duration:\n\nThis custom field would then serialize to the following representation:\n\nIn some cases you may need to customize the behavior of a hyperlinked field,\nin order to represent URLs that require more than a single lookup field.\n\nYou can achieve this by overriding `HyperlinkedRelatedField`. There are two\nmethods that may be overridden:\n\nget_url(self, obj, view_name, request, format)\n\nThe `get_url` method is used to map the object instance to its URL\nrepresentation.\n\nMay raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes\nare not configured to correctly match the URL conf.\n\nget_object(self, view_name, view_args, view_kwargs)\n\nIf you want to support a writable hyperlinked field then you'll also want to\noverride `get_object`, in order to map incoming URLs back to the object they\nrepresent. For read-only hyperlinked fields there is no need to override this\nmethod.\n\nThe return value of this method should the object that corresponds to the\nmatched URL conf arguments.\n\nMay raise an `ObjectDoesNotExist` exception.\n\nSay we have a URL for a customer object that takes two keyword arguments, like\nso:\n\nThis cannot be represented with the default implementation, which accepts only\na single lookup field.\n\nIn this case we'd need to override `HyperlinkedRelatedField` to get the\nbehavior we want:\n\nNote that if you wanted to use this style together with the generic views then\nyou'd also need to override `.get_object` on the view in order to get the\ncorrect lookup behavior.\n\nGenerally we recommend a flat style for API representations where possible,\nbut the nested URL style can also be reasonable when used in moderation.\n\nThe `queryset` argument is only ever required for writable relationship field,\nin which case it is used for performing the model instance lookup, that maps\nfrom the primitive user input, into a model instance.\n\nIn version 2.x a serializer class could sometimes automatically determine the\n`queryset` argument if a `ModelSerializer` class was being used.\n\nThis behavior is now replaced with always using an explicit `queryset`\nargument for writable relational fields.\n\nDoing so reduces the amount of hidden 'magic' that `ModelSerializer` provides,\nmakes the behavior of the field more clear, and ensures that it is trivial to\nmove between using the `ModelSerializer` shortcut, or using fully explicit\n`Serializer` classes.\n\nThe built-in `__str__` method of the model will be used to generate string\nrepresentations of the objects used to populate the `choices` property. These\nchoices are used to populate select HTML inputs in the browsable API.\n\nTo provide customized representations for such inputs, override\n`display_value()` of a `RelatedField` subclass. This method will receive a\nmodel object, and should return a string suitable for representing it. For\nexample:\n\nWhen rendered in the browsable API relational fields will default to only\ndisplaying a maximum of 1000 selectable items. If more items are present then\na disabled option with \"More than 1000 items\u2026\" will be displayed.\n\nThis behavior is intended to prevent a template from being unable to render in\nan acceptable timespan due to a very large number of relationships being\ndisplayed.\n\nThere are two keyword arguments you can use to control this behavior:\n\nYou can also control these globally using the settings `HTML_SELECT_CUTOFF`\nand `HTML_SELECT_CUTOFF_TEXT`.\n\nIn cases where the cutoff is being enforced you may want to instead use a\nplain input field in the HTML form. You can do so using the `style` keyword\nargument. For example:\n\nNote that reverse relationships are not automatically included by the\n`ModelSerializer` and `HyperlinkedModelSerializer` classes. To include a\nreverse relationship, you must explicitly add it to the fields list. For\nexample:\n\nYou'll normally want to ensure that you've set an appropriate `related_name`\nargument on the relationship, that you can use as the field name. For example:\n\nIf you have not set a related name for the reverse relationship, you'll need\nto use the automatically generated related name in the `fields` argument. For\nexample:\n\nSee the Django documentation on reverse relationships for more details.\n\nIf you want to serialize a generic foreign key, you need to define a custom\nfield, to determine explicitly how you want to serialize the targets of the\nrelationship.\n\nFor example, given the following model for a tag, which has a generic\nrelationship with other arbitrary models:\n\nAnd the following two models, which may have associated tags:\n\nWe could define a custom field that could be used to serialize tagged\ninstances, using the type of each instance to determine how it should be\nserialized:\n\nIf you need the target of the relationship to have a nested representation,\nyou can use the required serializers inside the `.to_representation()` method:\n\nNote that reverse generic keys, expressed using the `GenericRelation` field,\ncan be serialized using the regular relational field types, since the type of\nthe target in the relationship is always known.\n\nFor more information see the Django documentation on generic relations.\n\nBy default, relational fields that target a `ManyToManyField` with a `through`\nmodel specified are set to read-only.\n\nIf you explicitly specify a relational field pointing to a `ManyToManyField`\nwith a through model, be sure to set `read_only` to `True`.\n\nIf you wish to represent extra fields on a through model then you may\nserialize the through model as a nested object.\n\nThe following third party packages are also available.\n\nThe drf-nested-routers package provides routers and relationship fields for\nworking with nested resources.\n\nThe rest-framework-generic-relations library provides read/write serialization\nfor generic foreign keys.\n\nrelations.py\n\n"}, {"name": "TemplateHTMLRenderer", "path": "api-guide/renderers/index#templatehtmlrenderer", "type": "Ref: Renderers", "text": "\nBefore a TemplateResponse instance can be returned to the client, it must be\nrendered. The rendering process takes the intermediate representation of\ntemplate and context, and turns it into the final byte stream that can be\nserved to the client.\n\n\u2014 Django documentation\n\nREST framework includes a number of built in Renderer classes, that allow you\nto return responses with various media types. There is also support for\ndefining your own custom renderers, which gives you the flexibility to design\nyour own media types.\n\nThe set of valid renderers for a view is always defined as a list of classes.\nWhen a view is entered REST framework will perform content negotiation on the\nincoming request, and determine the most appropriate renderer to satisfy the\nrequest.\n\nThe basic process of content negotiation involves examining the request's\n`Accept` header, to determine which media types it expects in the response.\nOptionally, format suffixes on the URL may be used to explicitly request a\nparticular representation. For example the URL\n`http://example.com/api/users_count.json` might be an endpoint that always\nreturns JSON data.\n\nFor more information see the documentation on content negotiation.\n\nThe default set of renderers may be set globally, using the\n`DEFAULT_RENDERER_CLASSES` setting. For example, the following settings would\nuse `JSON` as the main media type and also include the self describing API.\n\nYou can also set the renderers used for an individual view, or viewset, using\nthe `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nIt's important when specifying the renderer classes for your API to think\nabout what priority you want to assign to each media type. If a client\nunderspecifies the representations it can accept, such as sending an `Accept:\n*/*` header, or not including an `Accept` header at all, then REST framework\nwill select the first renderer in the list to use for the response.\n\nFor example if your API serves JSON responses and the HTML browsable API, you\nmight want to make `JSONRenderer` your default renderer, in order to send\n`JSON` responses to clients that do not specify an `Accept` header.\n\nIf your API includes views that can serve both regular webpages and API\nresponses depending on the request, then you might consider making\n`TemplateHTMLRenderer` your default renderer, in order to play nicely with\nolder browsers that send broken accept headers.\n\nRenders the request data into `JSON`, using utf-8 encoding.\n\nNote that the default style is to include unicode characters, and render the\nresponse using a compact style with no unnecessary whitespace:\n\nThe client may additionally include an `'indent'` media type parameter, in\nwhich case the returned `JSON` will be indented. For example `Accept:\napplication/json; indent=4`.\n\nThe default JSON encoding style can be altered using the `UNICODE_JSON` and\n`COMPACT_JSON` settings keys.\n\n.media_type: `application/json`\n\n.format: `'json'`\n\n.charset: `None`\n\nRenders data to HTML, using Django's standard template rendering. Unlike other\nrenderers, the data passed to the `Response` does not need to be serialized.\nAlso, unlike other renderers, you may want to include a `template_name`\nargument when creating the `Response`.\n\nThe TemplateHTMLRenderer will create a `RequestContext`, using the\n`response.data` as the context dict, and determine a template name to use to\nrender the context.\n\nNote: When used with a view that makes use of a serializer the `Response` sent\nfor rendering may not be a dictionary and will need to be wrapped in a dict\nbefore returning to allow the TemplateHTMLRenderer to render it. For example:\n\nThe template name is determined by (in order of preference):\n\nAn example of a view that uses `TemplateHTMLRenderer`:\n\nYou can use `TemplateHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\nIf you're building websites that use `TemplateHTMLRenderer` along with other\nrenderer classes, you should consider listing `TemplateHTMLRenderer` as the\nfirst class in the `renderer_classes` list, so that it will be prioritised\nfirst even for browsers that send poorly formed `ACCEPT:` headers.\n\nSee the HTML & Forms Topic Page for further examples of `TemplateHTMLRenderer`\nusage.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `StaticHTMLRenderer`\n\nA simple renderer that simply returns pre-rendered HTML. Unlike other\nrenderers, the data passed to the response object should be a string\nrepresenting the content to be returned.\n\nAn example of a view that uses `StaticHTMLRenderer`:\n\nYou can use `StaticHTMLRenderer` either to return regular HTML pages using\nREST framework, or to return both HTML and API responses from a single\nendpoint.\n\n.media_type: `text/html`\n\n.format: `'html'`\n\n.charset: `utf-8`\n\nSee also: `TemplateHTMLRenderer`\n\nRenders data into HTML for the Browsable API:\n\nThis renderer will determine which other renderer would have been given\nhighest priority, and use that to display an API style response within the\nHTML page.\n\n.media_type: `text/html`\n\n.format: `'api'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/api.html'`\n\nBy default the response content will be rendered with the highest priority\nrenderer apart from `BrowsableAPIRenderer`. If you need to customize this\nbehavior, for example to use HTML as the default return format, but use JSON\nin the browsable API, you can do so by overriding the `get_default_renderer()`\nmethod. For example:\n\nRenders data into HTML for an admin-like display:\n\nThis renderer is suitable for CRUD-style web APIs that should also present a\nuser-friendly interface for managing the data.\n\nNote that views that have nested or list serializers for their input won't\nwork well with the `AdminRenderer`, as the HTML forms are unable to properly\nsupport them.\n\nNote: The `AdminRenderer` is only able to include links to detail pages when a\nproperly configured `URL_FIELD_NAME` (`url` by default) attribute is present\nin the data. For `HyperlinkedModelSerializer` this will be the case, but for\n`ModelSerializer` or plain `Serializer` classes you'll need to make sure to\ninclude the field explicitly. For example here we use models\n`get_absolute_url` method:\n\n.media_type: `text/html`\n\n.format: `'admin'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/admin.html'`\n\nRenders data returned by a serializer into an HTML form. The output of this\nrenderer does not include the enclosing `<form>` tags, a hidden CSRF input or\nany submit buttons.\n\nThis renderer is not intended to be used directly, but can instead be used in\ntemplates by passing a serializer instance to the `render_form` template tag.\n\nFor more information see the HTML & Forms documentation.\n\n.media_type: `text/html`\n\n.format: `'form'`\n\n.charset: `utf-8`\n\n.template: `'rest_framework/horizontal/form.html'`\n\nThis renderer is used for rendering HTML multipart form data. It is not\nsuitable as a response renderer, but is instead used for creating test\nrequests, using REST framework's test client and test request factory.\n\n.media_type: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n.format: `'multipart'`\n\n.charset: `utf-8`\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the\n`.media_type` and `.format` properties, and implement the `.render(self, data,\nmedia_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the\nHTTP response.\n\nThe arguments passed to the `.render()` method are:\n\nThe request data, as set by the `Response()` instantiation.\n\nOptional. If provided, this is the accepted media type, as determined by the\ncontent negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the\nrenderer's `media_type` attribute, and may include media type parameters. For\nexample `\"application/json; nested=true\"`.\n\nOptional. If provided, this is a dictionary of contextual information provided\nby the view.\n\nBy default this will include the following keys: `view`, `request`,\n`response`, `args`, `kwargs`.\n\nThe following is an example plaintext renderer that will return a response\nwith the `data` parameter as the content of the response.\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To\nuse a different encoding, set the `charset` attribute on the renderer.\n\nNote that if a renderer class returns a unicode string, then the response\ncontent will be coerced into a bytestring by the `Response` class, with the\n`charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you\nshould set a charset value of `None`, which will ensure the `Content-Type`\nheader of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to\n`'binary'`. Doing so will also ensure that the browsable API will not attempt\nto display the binary content as a string.\n\nYou can do some pretty flexible things using REST framework's renderers. Some\nexamples...\n\nIn some cases you might want your view to use different serialization styles\ndepending on the accepted media type. If you need to do this you can access\n`request.accepted_renderer` to determine the negotiated renderer that will be\nused for the response.\n\nFor example:\n\nIn some cases you might want a renderer to serve a range of media types. In\nthis case you can underspecify the media types it should respond to, by using\na `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify\nthe media type explicitly when you return the response, using the\n`content_type` attribute. For example:\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked\nrelations may be sufficient. If you want to fully embrace RESTful design and\nHATEOAS you'll need to consider the design and usage of your media types in\nmore detail.\n\nIn the words of Roy Fielding, \"A REST API should spend almost all of its\ndescriptive effort in defining the media type(s) used for representing\nresources and driving application state, or in defining extended relation\nnames and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom\napplication/vnd.github+json media type, and Mike Amundsen's IANA approved\napplication/vnd.collection+json JSON-based hypermedia.\n\nTypically a renderer will behave the same regardless of if it's dealing with a\nregular response, or with a response caused by an exception being raised, such\nas an `Http404` or `PermissionDenied` exception, or a subclass of\n`APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer`\nand an exception is raised, the behavior is slightly different, and mirrors\nDjango's default handling of error views.\n\nExceptions raised and handled by an HTML renderer will attempt to render using\none of the following methods, by order of precedence.\n\nTemplates will render with a `RequestContext` which includes the `status_code`\nand `details` keys.\n\nNote: If `DEBUG=True`, Django's standard traceback error page will be\ndisplayed instead of rendering the HTTP status code and text.\n\nThe following third party packages are also available.\n\nREST framework YAML provides YAML parsing and rendering support. It was\npreviously included directly in the REST framework package, and is now instead\nsupported as a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST Framework XML provides a simple informal XML format. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nREST framework JSONP provides JSONP rendering support. It was previously\nincluded directly in the REST framework package, and is now instead supported\nas a third-party package.\n\nWarning: If you require cross-domain AJAX requests, you should generally be\nusing the more modern approach of CORS as an alternative to `JSONP`. See the\nCORS documentation for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is only appropriate\nfor globally readable API endpoints, where `GET` requests are unauthenticated\nand do not require any user permissions.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nMessagePack is a fast, efficient binary serialization format. Juan Riaza\nmaintains the djangorestframework-msgpack package which provides MessagePack\nrenderer and parser support for REST framework.\n\nXLSX is the world's most popular binary spreadsheet format. Tim Allen of The\nWharton School maintains drf-renderer-xlsx, which renders an endpoint as an\nXLSX spreadsheet using OpenPyXL, and allows the client to download it.\nSpreadsheets can be styled on a per-view basis.\n\nInstall using pip.\n\nModify your REST framework settings.\n\nTo avoid having a file streamed without a filename (which the browser will\noften default to the filename \"download\", with no extension), we need to use a\nmixin to override the `Content-Disposition` header. If no filename is\nprovided, it will default to `export.xlsx`. For example:\n\nComma-separated values are a plain-text tabular data format, that can be\neasily imported into spreadsheet applications. Mjumbe Poe maintains the\ndjangorestframework-csv package which provides CSV renderer support for REST\nframework.\n\nUltraJSON is an optimized C JSON encoder which can give significantly faster\nJSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now\nunmaintained drf-ujson-renderer, which implements JSON rendering using the\nUJSON package.\n\ndjangorestframework-camel-case provides camel case JSON renderers and parsers\nfor REST framework. This allows serializers to use Python-style underscored\nfield names, but be exposed in the API as Javascript-style camel case field\nnames. It is maintained by Vitaly Babiy.\n\nDjango REST Pandas provides a serializer and renderers that support additional\ndata processing and output via the Pandas DataFrame API. Django REST Pandas\nincludes renderers for Pandas-style CSV files, Excel workbooks (both `.xls`\nand `.xlsx`), and a number of other formats. It is maintained by S. Andrew\nSheppard as part of the wq Project.\n\nRest Framework Latex provides a renderer that outputs PDFs using Laulatex. It\nis maintained by Pebble (S/F Software).\n\nrenderers.py\n\n"}, {"name": "Test settings", "path": "api-guide/settings/index#test-settings", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "Testing", "path": "api-guide/testing/index", "type": "API Guide", "text": "\nCode without tests is broken as designed.\n\n\u2014 Jacob Kaplan-Moss\n\nREST framework includes a few helper classes that extend Django's existing\ntest framework, and improve support for making API requests.\n\nExtends Django's existing `RequestFactory` class.\n\nThe `APIRequestFactory` class supports an almost identical API to Django's\nstandard `RequestFactory` class. This means that the standard `.get()`,\n`.post()`, `.put()`, `.patch()`, `.delete()`, `.head()` and `.options()`\nmethods are all available.\n\nMethods which create a request body, such as `post`, `put` and `patch`,\ninclude a `format` argument, which make it easy to generate requests using a\ncontent type other than multipart form data. For example:\n\nBy default the available formats are `'multipart'` and `'json'`. For\ncompatibility with Django's existing `RequestFactory` the default format is\n`'multipart'`.\n\nTo support a wider set of request formats, or change the default format, see\nthe configuration section.\n\nIf you need to explicitly encode the request body, you can do so by setting\nthe `content_type` flag. For example:\n\nOne difference worth noting between Django's `RequestFactory` and REST\nframework's `APIRequestFactory` is that multipart form data will be encoded\nfor methods other than just `.post()`.\n\nFor example, using `APIRequestFactory`, you can make a form PUT request like\nso:\n\nUsing Django's `RequestFactory`, you'd need to explicitly encode the data\nyourself:\n\nWhen testing views directly using a request factory, it's often convenient to\nbe able to directly authenticate the request, rather than having to construct\nthe correct authentication credentials.\n\nTo forcibly authenticate a request, use the `force_authenticate()` method.\n\nThe signature for the method is `force_authenticate(request, user=None,\ntoken=None)`. When making the call, either or both of the user and token may\nbe set.\n\nFor example, when forcibly authenticating using a token, you might do\nsomething like the following:\n\nNote: `force_authenticate` directly sets `request.user` to the in-memory\n`user` instance. If you are re-using the same `user` instance across multiple\ntests that update the saved `user` state, you may need to call\n`refresh_from_db()` between tests.\n\nNote: When using `APIRequestFactory`, the object that is returned is Django's\nstandard `HttpRequest`, and not REST framework's `Request` object, which is\nonly generated once the view is called.\n\nThis means that setting attributes directly on the request object may not\nalways have the effect you expect. For example, setting `.token` directly will\nhave no effect, and setting `.user` directly will only work if session\nauthentication is being used.\n\nBy default, requests created with `APIRequestFactory` will not have CSRF\nvalidation applied when passed to a REST framework view. If you need to\nexplicitly turn CSRF validation on, you can do so by setting the\n`enforce_csrf_checks` flag when instantiating the factory.\n\nNote: It's worth noting that Django's standard `RequestFactory` doesn't need\nto include this option, because when using regular Django the CSRF validation\ntakes place in middleware, which is not run when testing views directly. When\nusing REST framework, CSRF validation takes place inside the view, so the\nrequest factory needs to disable view-level CSRF checks.\n\nExtends Django's existing `Client` class.\n\nThe `APIClient` class supports the same request interface as Django's standard\n`Client` class. This means that the standard `.get()`, `.post()`, `.put()`,\n`.patch()`, `.delete()`, `.head()` and `.options()` methods are all available.\nFor example:\n\nTo support a wider set of request formats, or change the default format, see\nthe configuration section.\n\nThe `login` method functions exactly as it does with Django's regular `Client`\nclass. This allows you to authenticate requests against any views which\ninclude `SessionAuthentication`.\n\nTo logout, call the `logout` method as usual.\n\nThe `login` method is appropriate for testing APIs that use session\nauthentication, for example web sites which include AJAX interaction with the\nAPI.\n\nThe `credentials` method can be used to set headers that will then be included\non all subsequent requests by the test client.\n\nNote that calling `credentials` a second time overwrites any existing\ncredentials. You can unset any existing credentials by calling the method with\nno arguments.\n\nThe `credentials` method is appropriate for testing APIs that require\nauthentication headers, such as basic authentication, OAuth1a and OAuth2\nauthentication, and simple token authentication schemes.\n\nSometimes you may want to bypass authentication entirely and force all\nrequests by the test client to be automatically treated as authenticated.\n\nThis can be a useful shortcut if you're testing the API but don't want to have\nto construct valid authentication credentials in order to make test requests.\n\nTo unauthenticate subsequent requests, call `force_authenticate` setting the\nuser and/or token to `None`.\n\nBy default CSRF validation is not applied when using `APIClient`. If you need\nto explicitly enable CSRF validation, you can do so by setting the\n`enforce_csrf_checks` flag when instantiating the client.\n\nAs usual CSRF validation will only apply to any session authenticated views.\nThis means CSRF validation will only occur if the client has been logged in by\ncalling `login()`.\n\nREST framework also includes a client for interacting with your application\nusing the popular Python library, `requests`. This may be useful if:\n\nThis exposes exactly the same interface as if you were using a requests\nsession directly.\n\nNote that the requests client requires you to pass fully qualified URLs.\n\nThe `RequestsClient` class is useful if you want to write tests that solely\ninteract with the service interface. This is a little stricter than using the\nstandard Django test client, as it means that all interactions should be via\nthe API.\n\nIf you're using `RequestsClient` you'll want to ensure that test setup, and\nresults assertions are performed as regular API calls, rather than interacting\nwith the database models directly. For example, rather than checking that\n`Customer.objects.count() == 3` you would list the customers endpoint, and\nensure that it contains three records.\n\nCustom headers and authentication credentials can be provided in the same way\nas when using a standard `requests.Session` instance.\n\nIf you're using `SessionAuthentication` then you'll need to include a CSRF\ntoken for any `POST`, `PUT`, `PATCH` or `DELETE` requests.\n\nYou can do so by following the same flow that a JavaScript based client would\nuse. First make a `GET` request in order to obtain a CRSF token, then present\nthat token in the following request.\n\nFor example...\n\nWith careful usage both the `RequestsClient` and the `CoreAPIClient` provide\nthe ability to write test cases that can run either in development, or be run\ndirectly against your staging server or production environment.\n\nUsing this style to create basic tests of a few core piece of functionality is\na powerful way to validate your live service. Doing so may require some\ncareful attention to setup and teardown to ensure that the tests run in a way\nthat they do not directly affect customer data.\n\nThe CoreAPIClient allows you to interact with your API using the Python\n`coreapi` client library.\n\nCustom headers and authentication may be used with `CoreAPIClient` in a\nsimilar way as with `RequestsClient`.\n\nREST framework includes the following test case classes, that mirror the\nexisting Django test case classes, but use `APIClient` instead of Django's\ndefault `Client`.\n\nYou can use any of REST framework's test case classes as you would for the\nregular Django test case classes. The `self.client` attribute will be an\n`APIClient` instance.\n\nREST framework also provides a test case class for isolating `urlpatterns` on\na per-class basis. Note that this inherits from Django's `SimpleTestCase`, and\nwill most likely need to be mixed with another test case class.\n\nWhen checking the validity of test responses it's often more convenient to\ninspect the data that the response was created with, rather than inspecting\nthe fully rendered response.\n\nFor example, it's easier to inspect `response.data`:\n\nInstead of inspecting the result of parsing `response.content`:\n\nIf you're testing views directly using `APIRequestFactory`, the responses that\nare returned will not yet be rendered, as rendering of template responses is\nperformed by Django's internal request-response cycle. In order to access\n`response.content`, you'll first need to render the response.\n\nThe default format used to make test requests may be set using the\n`TEST_REQUEST_DEFAULT_FORMAT` setting key. For example, to always use JSON for\ntest requests by default instead of standard multipart form requests, set the\nfollowing in your `settings.py` file:\n\nIf you need to test requests using something other than multipart or json\nrequests, you can do so by setting the `TEST_REQUEST_RENDERER_CLASSES`\nsetting.\n\nFor example, to add support for using `format='html'` in test requests, you\nmight have something like this in your `settings.py` file.\n\ntest.py\n\n"}, {"name": "Throttled", "path": "api-guide/exceptions/index#throttled", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "Throttling", "path": "api-guide/throttling/index", "type": "API Guide", "text": "\nHTTP/1.1 420 Enhance Your Calm\n\nTwitter API rate limiting response\n\nThrottling is similar to permissions, in that it determines if a request\nshould be authorized. Throttles indicate a temporary state, and are used to\ncontrol the rate of requests that clients can make to an API.\n\nAs with permissions, multiple throttles may be used. Your API might have a\nrestrictive throttle for unauthenticated requests, and a less restrictive\nthrottle for authenticated requests.\n\nAnother scenario where you might want to use multiple throttles would be if\nyou need to impose different constraints on different parts of the API, due to\nsome services being particularly resource-intensive.\n\nMultiple throttles can also be used if you want to impose both burst\nthrottling rates, and sustained throttling rates. For example, you might want\nto limit a user to a maximum of 60 requests per minute, and 1000 requests per\nday.\n\nThrottles do not necessarily only refer to rate-limiting requests. For example\na storage service might also need to throttle against bandwidth, and a paid\ndata service might want to throttle against a certain number of a records\nbeing accessed.\n\nAs with permissions and authentication, throttling in REST framework is always\ndefined as a list of classes.\n\nBefore running the main body of the view each throttle in the list is checked.\nIf any throttle check fails an `exceptions.Throttled` exception will be\nraised, and the main body of the view will not run.\n\nThe default throttling policy may be set globally, using the\n`DEFAULT_THROTTLE_CLASSES` and `DEFAULT_THROTTLE_RATES` settings. For example.\n\nThe rate descriptions used in `DEFAULT_THROTTLE_RATES` may include `second`,\n`minute`, `hour` or `day` as the throttle period.\n\nYou can also set the throttling policy on a per-view or per-viewset basis,\nusing the `APIView` class-based views.\n\nIf you're using the `@api_view` decorator with function based views you can\nuse the following decorator.\n\nIt's also possible to set throttle classes for routes that are created using\nthe `@action` decorator. Throttle classes set in this way will override any\nviewset level class settings.\n\nThe `X-Forwarded-For` HTTP header and `REMOTE_ADDR` WSGI variable are used to\nuniquely identify client IP addresses for throttling. If the `X-Forwarded-For`\nheader is present then it will be used, otherwise the value of the\n`REMOTE_ADDR` variable from the WSGI environment will be used.\n\nIf you need to strictly identify unique client IP addresses, you'll need to\nfirst configure the number of application proxies that the API runs behind by\nsetting the `NUM_PROXIES` setting. This setting should be an integer of zero\nor more. If set to non-zero then the client IP will be identified as being the\nlast IP address in the `X-Forwarded-For` header, once any application proxy IP\naddresses have first been excluded. If set to zero, then the `REMOTE_ADDR`\nvalue will always be used as the identifying IP address.\n\nIt is important to understand that if you configure the `NUM_PROXIES` setting,\nthen all clients behind a unique NAT'd gateway will be treated as a single\nclient.\n\nFurther context on how the `X-Forwarded-For` header works, and identifying a\nremote client IP can be found here.\n\nThe throttle classes provided by REST framework use Django's cache backend.\nYou should make sure that you've set appropriate cache settings. The default\nvalue of `LocMemCache` backend should be okay for simple setups. See Django's\ncache documentation for more details.\n\nIf you need to use a cache other than `'default'`, you can do so by creating a\ncustom throttle class and setting the `cache` attribute. For example:\n\nYou'll need to remember to also set your custom throttle class in the\n`'DEFAULT_THROTTLE_CLASSES'` settings key, or using the `throttle_classes`\nview attribute.\n\nThe `AnonRateThrottle` will only ever throttle unauthenticated users. The IP\naddress of the incoming request is used to generate a unique key to throttle\nagainst.\n\nThe allowed request rate is determined from one of the following (in order of\npreference).\n\n`AnonRateThrottle` is suitable if you want to restrict the rate of requests\nfrom unknown sources.\n\nThe `UserRateThrottle` will throttle users to a given rate of requests across\nthe API. The user id is used to generate a unique key to throttle against.\nUnauthenticated requests will fall back to using the IP address of the\nincoming request to generate a unique key to throttle against.\n\nThe allowed request rate is determined from one of the following (in order of\npreference).\n\nAn API may have multiple `UserRateThrottles` in place at the same time. To do\nso, override `UserRateThrottle` and set a unique \"scope\" for each class.\n\nFor example, multiple user throttle rates could be implemented by using the\nfollowing classes...\n\n...and the following settings.\n\n`UserRateThrottle` is suitable if you want simple global rate restrictions\nper-user.\n\nThe `ScopedRateThrottle` class can be used to restrict access to specific\nparts of the API. This throttle will only be applied if the view that is being\naccessed includes a `.throttle_scope` property. The unique throttle key will\nthen be formed by concatenating the \"scope\" of the request with the unique\nuser id or IP address.\n\nThe allowed request rate is determined by the `DEFAULT_THROTTLE_RATES` setting\nusing a key from the request \"scope\".\n\nFor example, given the following views...\n\n...and the following settings.\n\nUser requests to either `ContactListView` or `ContactDetailView` would be\nrestricted to a total of 1000 requests per-day. User requests to `UploadView`\nwould be restricted to 20 requests per day.\n\nTo create a custom throttle, override `BaseThrottle` and implement\n`.allow_request(self, request, view)`. The method should return `True` if the\nrequest should be allowed, and `False` otherwise.\n\nOptionally you may also override the `.wait()` method. If implemented,\n`.wait()` should return a recommended number of seconds to wait before\nattempting the next request, or `None`. The `.wait()` method will only be\ncalled if `.allow_request()` has previously returned `False`.\n\nIf the `.wait()` method is implemented and the request is throttled, then a\n`Retry-After` header will be included in the response.\n\nThe following is an example of a rate throttle, that will randomly throttle 1\nin every 10 requests.\n\nthrottling.py\n\n"}, {"name": "TimeField", "path": "api-guide/fields/index#timefield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "TokenAuthentication", "path": "api-guide/authentication/index#tokenauthentication", "type": "Ref: Authentication", "text": "\nAuth needs to be pluggable.\n\n\u2014 Jacob Kaplan-Moss, \"REST worst practices\"\n\nAuthentication is the mechanism of associating an incoming request with a set\nof identifying credentials, such as the user the request came from, or the\ntoken that it was signed with. The permission and throttling policies can then\nuse those credentials to determine if the request should be permitted.\n\nREST framework provides several authentication schemes out of the box, and\nalso allows you to implement custom schemes.\n\nAuthentication always runs at the very start of the view, before the\npermission and throttling checks occur, and before any other code is allowed\nto proceed.\n\nThe `request.user` property will typically be set to an instance of the\n`contrib.auth` package's `User` class.\n\nThe `request.auth` property is used for any additional authentication\ninformation, for example, it may be used to represent an authentication token\nthat the request was signed with.\n\nNote: Don't forget that authentication by itself won't allow or disallow an\nincoming request, it simply identifies the credentials that the request was\nmade with.\n\nFor information on how to set up the permission policies for your API please\nsee the permissions documentation.\n\nThe authentication schemes are always defined as a list of classes. REST\nframework will attempt to authenticate with each class in the list, and will\nset `request.user` and `request.auth` using the return value of the first\nclass that successfully authenticates.\n\nIf no class authenticates, `request.user` will be set to an instance of\n`django.contrib.auth.models.AnonymousUser`, and `request.auth` will be set to\n`None`.\n\nThe value of `request.user` and `request.auth` for unauthenticated requests\ncan be modified using the `UNAUTHENTICATED_USER` and `UNAUTHENTICATED_TOKEN`\nsettings.\n\nThe default authentication schemes may be set globally, using the\n`DEFAULT_AUTHENTICATION_CLASSES` setting. For example.\n\nYou can also set the authentication scheme on a per-view or per-viewset basis,\nusing the `APIView` class-based views.\n\nOr, if you're using the `@api_view` decorator with function based views.\n\nWhen an unauthenticated request is denied permission there are two different\nerror codes that may be appropriate.\n\nHTTP 401 responses must always include a `WWW-Authenticate` header, that\ninstructs the client how to authenticate. HTTP 403 responses do not include\nthe `WWW-Authenticate` header.\n\nThe kind of response that will be used depends on the authentication scheme.\nAlthough multiple authentication schemes may be in use, only one scheme may be\nused to determine the type of response. The first authentication class set on\nthe view is used when determining the type of response.\n\nNote that when a request may successfully authenticate, but still be denied\npermission to perform the request, in which case a `403 Permission Denied`\nresponse will always be used, regardless of the authentication scheme.\n\nNote that if deploying to Apache using mod_wsgi, the authorization header is\nnot passed through to a WSGI application by default, as it is assumed that\nauthentication will be handled by Apache, rather than at an application level.\n\nIf you are deploying to Apache, and using any non-session based\nauthentication, you will need to explicitly configure mod_wsgi to pass the\nrequired headers through to the application. This can be done by specifying\nthe `WSGIPassAuthorization` directive in the appropriate context and setting\nit to `'On'`.\n\nThis authentication scheme uses HTTP Basic Authentication, signed against a\nuser's username and password. Basic authentication is generally only\nappropriate for testing.\n\nIf successfully authenticated, `BasicAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nNote: If you use `BasicAuthentication` in production you must ensure that your\nAPI is only available over `https`. You should also ensure that your API\nclients will always re-request the username and password at login, and will\nnever store those details to persistent storage.\n\nThis authentication scheme uses a simple token-based HTTP Authentication\nscheme. Token authentication is appropriate for client-server setups, such as\nnative desktop and mobile clients.\n\nTo use the `TokenAuthentication` scheme you'll need to configure the\nauthentication classes to include `TokenAuthentication`, and additionally\ninclude `rest_framework.authtoken` in your `INSTALLED_APPS` setting:\n\nNote: Make sure to run `manage.py migrate` after changing your settings. The\n`rest_framework.authtoken` app provides Django database migrations.\n\nYou'll also need to create tokens for your users.\n\nFor clients to authenticate, the token key should be included in the\n`Authorization` HTTP header. The key should be prefixed by the string literal\n\"Token\", with whitespace separating the two strings. For example:\n\nNote: If you want to use a different keyword in the header, such as `Bearer`,\nsimply subclass `TokenAuthentication` and set the `keyword` class variable.\n\nIf successfully authenticated, `TokenAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n401 Unauthorized` response with an appropriate WWW-Authenticate header. For\nexample:\n\nThe `curl` command line tool may be useful for testing token authenticated\nAPIs. For example:\n\nNote: If you use `TokenAuthentication` in production you must ensure that your\nAPI is only available over `https`.\n\nIf you want every user to have an automatically generated Token, you can\nsimply catch the User's `post_save` signal.\n\nNote that you'll want to ensure you place this code snippet in an installed\n`models.py` module, or some other location that will be imported by Django on\nstartup.\n\nIf you've already created some users, you can generate tokens for all existing\nusers like this:\n\nWhen using `TokenAuthentication`, you may want to provide a mechanism for\nclients to obtain a token given the username and password. REST framework\nprovides a built-in view to provide this behaviour. To use it, add the\n`obtain_auth_token` view to your URLconf:\n\nNote that the URL part of the pattern can be whatever you want to use.\n\nThe `obtain_auth_token` view will return a JSON response when valid `username`\nand `password` fields are POSTed to the view using form data or JSON:\n\nNote that the default `obtain_auth_token` view explicitly uses JSON requests\nand responses, rather than using default renderer and parser classes in your\nsettings.\n\nBy default, there are no permissions or throttling applied to the\n`obtain_auth_token` view. If you do wish to apply to throttle you'll need to\noverride the view class, and include them using the `throttle_classes`\nattribute.\n\nIf you need a customized version of the `obtain_auth_token` view, you can do\nso by subclassing the `ObtainAuthToken` view class, and using that in your url\nconf instead.\n\nFor example, you may return additional user information beyond the `token`\nvalue:\n\nAnd in your `urls.py`:\n\nIt is also possible to create Tokens manually through the admin interface. In\ncase you are using a large user base, we recommend that you monkey patch the\n`TokenAdmin` class customize it to your needs, more specifically by declaring\nthe `user` field as `raw_field`.\n\n`your_app/admin.py`:\n\nSince version 3.6.4 it's possible to generate a user token using the following\ncommand:\n\nthis command will return the API token for the given user, creating it if it\ndoesn't exist:\n\nIn case you want to regenerate the token (for example if it has been\ncompromised or leaked) you can pass an additional parameter:\n\nThis authentication scheme uses Django's default session backend for\nauthentication. Session authentication is appropriate for AJAX clients that\nare running in the same session context as your website.\n\nIf successfully authenticated, `SessionAuthentication` provides the following\ncredentials.\n\nUnauthenticated responses that are denied permission will result in an `HTTP\n403 Forbidden` response.\n\nIf you're using an AJAX-style API with SessionAuthentication, you'll need to\nmake sure you include a valid CSRF token for any \"unsafe\" HTTP method calls,\nsuch as `PUT`, `PATCH`, `POST` or `DELETE` requests. See the Django CSRF\ndocumentation for more details.\n\nWarning: Always use Django's standard login view when creating login pages.\nThis will ensure your login views are properly protected.\n\nCSRF validation in REST framework works slightly differently from standard\nDjango due to the need to support both session and non-session based\nauthentication to the same views. This means that only authenticated requests\nrequire CSRF tokens, and anonymous requests may be sent without CSRF tokens.\nThis behaviour is not suitable for login views, which should always have CSRF\nvalidation applied.\n\nThis authentication scheme allows you to delegate authentication to your web\nserver, which sets the `REMOTE_USER` environment variable.\n\nTo use it, you must have `django.contrib.auth.backends.RemoteUserBackend` (or\na subclass) in your `AUTHENTICATION_BACKENDS` setting. By default,\n`RemoteUserBackend` creates `User` objects for usernames that don't already\nexist. To change this and other behaviour, consult the Django documentation.\n\nIf successfully authenticated, `RemoteUserAuthentication` provides the\nfollowing credentials:\n\nConsult your web server's documentation for information about configuring an\nauthentication method, e.g.:\n\nTo implement a custom authentication scheme, subclass `BaseAuthentication` and\noverride the `.authenticate(self, request)` method. The method should return a\ntwo-tuple of `(user, auth)` if authentication succeeds, or `None` otherwise.\n\nIn some circumstances instead of returning `None`, you may want to raise an\n`AuthenticationFailed` exception from the `.authenticate()` method.\n\nTypically the approach you should take is:\n\nYou may also override the `.authenticate_header(self, request)` method. If\nimplemented, it should return a string that will be used as the value of the\n`WWW-Authenticate` header in a `HTTP 401 Unauthorized` response.\n\nIf the `.authenticate_header()` method is not overridden, the authentication\nscheme will return `HTTP 403 Forbidden` responses when an unauthenticated\nrequest is denied access.\n\nNote: When your custom authenticator is invoked by the request object's\n`.user` or `.auth` properties, you may see an `AttributeError` re-raised as a\n`WrappedAttributeError`. This is necessary to prevent the original exception\nfrom being suppressed by the outer property access. Python will not recognize\nthat the `AttributeError` originates from your custom authenticator and will\ninstead assume that the request object does not have a `.user` or `.auth`\nproperty. These errors should be fixed or otherwise handled by your\nauthenticator.\n\nThe following example will authenticate any incoming request as the user given\nby the username in a custom request header named 'X-USERNAME'.\n\nThe following third-party packages are also available.\n\nThe Django OAuth Toolkit package provides OAuth 2.0 support and works with\nPython 3.4+. The package is maintained by jazzband and uses the excellent\nOAuthLib. The package is well documented, and well supported and is currently\nour recommended package for OAuth 2.0 support.\n\nInstall using `pip`.\n\nAdd the package to your `INSTALLED_APPS` and modify your REST framework\nsettings.\n\nFor more details see the Django REST framework - Getting started\ndocumentation.\n\nThe Django REST framework OAuth package provides both OAuth1 and OAuth2\nsupport for REST framework.\n\nThis package was previously included directly in the REST framework but is now\nsupported and maintained as a third-party package.\n\nInstall the package using `pip`.\n\nFor details on configuration and usage see the Django REST framework OAuth\ndocumentation for authentication and permissions.\n\nJSON Web Token is a fairly new standard which can be used for token-based\nauthentication. Unlike the built-in TokenAuthentication scheme, JWT\nAuthentication doesn't need to use a database to validate a token. A package\nfor JWT authentication is djangorestframework-simplejwt which provides some\nfeatures as well as a pluggable token blacklist app.\n\nThe HawkREST library builds on the Mohawk library to let you work with Hawk\nsigned requests and responses in your API. Hawk lets two parties securely\ncommunicate with each other using messages signed by a shared key. It is based\non HTTP MAC access authentication (which was based on parts of OAuth 1.0).\n\nHTTP Signature (currently a IETF draft) provides a way to achieve origin\nauthentication and message integrity for HTTP messages. Similar to Amazon's\nHTTP Signature scheme, used by many of its services, it permits stateless,\nper-request authentication. Elvio Toccalino maintains the djangorestframework-\nhttpsignature (outdated) package which provides an easy to use HTTP Signature\nAuthentication mechanism. You can use the updated fork version of\ndjangorestframework-httpsignature, which is drf-httpsig.\n\nDjoser library provides a set of views to handle basic actions such as\nregistration, login, logout, password reset and account activation. The\npackage works with a custom user model and uses token-based authentication.\nThis is ready to use REST implementation of the Django authentication system.\n\nThis library provides a set of REST API endpoints for registration,\nauthentication (including social media authentication), password reset,\nretrieve and update user details, etc. By having these API endpoints, your\nclient apps such as AngularJS, iOS, Android, and others can communicate to\nyour Django backend site independently via REST APIs for user management.\n\nThere are currently two forks of this project.\n\nDjango-rest-framework-social-oauth2 library provides an easy way to integrate\nsocial plugins (facebook, twitter, google, etc.) to your authentication system\nand an easy oauth2 setup. With this library, you will be able to authenticate\nusers based on external tokens (e.g. facebook access token), convert these\ntokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to\nauthenticate your users.\n\nDjango-rest-knox library provides models and views to handle token-based\nauthentication in a more secure and extensible way than the built-in\nTokenAuthentication scheme - with Single Page Applications and Mobile clients\nin mind. It provides per-client tokens, and views to generate them when\nprovided some other authentication (usually basic authentication), to delete\nthe token (providing a server enforced logout) and to delete all tokens (logs\nout all clients that a user is logged into).\n\ndrfpasswordless adds (Medium, Square Cash inspired) passwordless support to\nDjango REST Framework's TokenAuthentication scheme. Users log in and sign up\nwith a token sent to a contact point like an email address or a mobile number.\n\ndjango-rest-authemail provides a RESTful API interface for user signup and\nauthentication. Email addresses are used for authentication, rather than\nusernames. API endpoints are available for signup, signup email verification,\nlogin, logout, password reset, password reset verification, email change,\nemail change verification, password change, and user detail. A fully\nfunctional example project and detailed instructions are included.\n\nDjango-Rest-Durin is built with the idea to have one library that does token\nauth for multiple Web/CLI/Mobile API clients via one interface but allows\ndifferent token configuration for each API Client that consumes the API. It\nprovides support for multiple tokens per user via custom models, views,\npermissions that work with Django-Rest-Framework. The token expiration time\ncan be different per API client and is customizable via the Django Admin\nInterface.\n\nMore information can be found in the Documentation.\n\nauthentication.py\n\n"}, {"name": "UniqueForDateValidator", "path": "api-guide/validators/index#uniquefordatevalidator", "type": "Ref: Validators", "text": "\nValidators can be useful for re-using validation logic between different types\nof fields.\n\n\u2014 Django documentation\n\nMost of the time you're dealing with validation in REST framework you'll\nsimply be relying on the default field validation, or writing explicit\nvalidation methods on serializer or field classes.\n\nHowever, sometimes you'll want to place your validation logic into reusable\ncomponents, so that it can easily be reused throughout your codebase. This can\nbe achieved by using validator functions and validator classes.\n\nValidation in Django REST framework serializers is handled a little\ndifferently to how validation works in Django's `ModelForm` class.\n\nWith `ModelForm` the validation is performed partially on the form, and\npartially on the model instance. With REST framework the validation is\nperformed entirely on the serializer class. This is advantageous for the\nfollowing reasons:\n\nWhen you're using `ModelSerializer` all of this is handled automatically for\nyou. If you want to drop down to using `Serializer` classes instead, then you\nneed to define the validation rules explicitly.\n\nAs an example of how REST framework uses explicit validation, we'll take a\nsimple model class that has a field with a uniqueness constraint.\n\nHere's a basic `ModelSerializer` that we can use for creating or updating\ninstances of `CustomerReportRecord`:\n\nIf we open up the Django shell using `manage.py shell` we can now\n\nThe interesting bit here is the `reference` field. We can see that the\nuniqueness constraint is being explicitly enforced by a validator on the\nserializer field.\n\nBecause of this more explicit style REST framework includes a few validator\nclasses that are not available in core Django. These classes are detailed\nbelow.\n\nThis validator can be used to enforce the `unique=True` constraint on model\nfields. It takes a single required argument, and an optional `messages`\nargument:\n\nThis validator should be applied to serializer fields, like so:\n\nThis validator can be used to enforce `unique_together` constraints on model\ninstances. It has two required arguments, and a single optional `messages`\nargument:\n\nThe validator should be applied to serializer classes, like so:\n\nNote: The `UniqueTogetherValidator` class always imposes an implicit\nconstraint that all the fields it applies to are always treated as required.\nFields with `default` values are an exception to this as they always supply a\nvalue even when omitted from user input.\n\nThese validators can be used to enforce the `unique_for_date`,\n`unique_for_month` and `unique_for_year` constraints on model instances. They\ntake the following arguments:\n\nThe validator should be applied to serializer classes, like so:\n\nThe date field that is used for the validation is always required to be\npresent on the serializer class. You can't simply rely on a model class\n`default=...`, because the value being used for the default wouldn't be\ngenerated until after the validation has run.\n\nThere are a couple of styles you may want to use for this depending on how you\nwant your API to behave. If you're using `ModelSerializer` you'll probably\nsimply rely on the defaults that REST framework generates for you, but if you\nare using `Serializer` or simply want more explicit control, use on of the\nstyles demonstrated below.\n\nIf you want the date field to be writable the only thing worth noting is that\nyou should ensure that it is always available in the input data, either by\nsetting a `default` argument, or by setting `required=True`.\n\nIf you want the date field to be visible, but not editable by the user, then\nset `read_only=True` and additionally set a `default=...` argument.\n\nIf you want the date field to be entirely hidden from the user, then use\n`HiddenField`. This field type does not accept user input, but instead always\nreturns its default value to the `validated_data` in the serializer.\n\nNote: The `UniqueFor<Range>Validator` classes impose an implicit constraint\nthat the fields they are applied to are always treated as required. Fields\nwith `default` values are an exception to this as they always supply a value\neven when omitted from user input.\n\nValidators that are applied across multiple fields in the serializer can\nsometimes require a field input that should not be provided by the API client,\nbut that is available as input to the validator.\n\nTwo patterns that you may want to use for this sort of validation include:\n\nREST framework includes a couple of defaults that may be useful in this\ncontext.\n\nA default class that can be used to represent the current user. In order to\nuse this, the 'request' must have been provided as part of the context\ndictionary when instantiating the serializer.\n\nA default class that can be used to only set a default argument during create\noperations. During updates the field is omitted.\n\nIt takes a single argument, which is the default value or callable that should\nbe used during create operations.\n\nThere are some ambiguous cases where you'll need to instead handle validation\nexplicitly, rather than relying on the default serializer classes that\n`ModelSerializer` generates.\n\nIn these cases you may want to disable the automatically generated validators,\nby specifying an empty list for the serializer `Meta.validators` attribute.\n\nBy default \"unique together\" validation enforces that all fields be\n`required=True`. In some cases, you might want to explicit apply\n`required=False` to one of the fields, in which case the desired behaviour of\nthe validation is ambiguous.\n\nIn this case you will typically need to exclude the validator from the\nserializer class, and instead write any validation logic explicitly, either in\nthe `.validate()` method, or else in the view.\n\nFor example:\n\nWhen applying an update to an existing instance, uniqueness validators will\nexclude the current instance from the uniqueness check. The current instance\nis available in the context of the uniqueness check, because it exists as an\nattribute on the serializer, having initially been passed using `instance=...`\nwhen instantiating the serializer.\n\nIn the case of update operations on nested serializers there's no way of\napplying this exclusion, because the instance is not available.\n\nAgain, you'll probably want to explicitly remove the validator from the\nserializer class, and write the code for the validation constraint explicitly,\nin a `.validate()` method, or in the view.\n\nIf you're not sure exactly what behavior a `ModelSerializer` class will\ngenerate it is usually a good idea to run `manage.py shell`, and print an\ninstance of the serializer, so that you can inspect the fields and validators\nthat it automatically generates for you.\n\nAlso keep in mind that with complex cases it can often be better to explicitly\ndefine your serializer classes, rather than relying on the default\n`ModelSerializer` behavior. This involves a little more code, but ensures that\nthe resulting behavior is more transparent.\n\nYou can use any of Django's existing validators, or write your own custom\nvalidators.\n\nA validator may be any callable that raises a `serializers.ValidationError` on\nfailure.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. This is\ndocumented in the Serializer docs\n\nTo write a class-based validator, use the `__call__` method. Class-based\nvalidators are useful as they allow you to parameterize and reuse behavior.\n\nIn some advanced cases you might want a validator to be passed the serializer\nfield it is being used with as additional context. You can do so by setting a\n`requires_context = True` attribute on the validator. The `__call__` method\nwill then be called with the `serializer_field` or `serializer` as an\nadditional argument.\n\nvalidators.py\n\n"}, {"name": "UniqueForMonthValidator", "path": "api-guide/validators/index#uniqueformonthvalidator", "type": "Ref: Validators", "text": "\nValidators can be useful for re-using validation logic between different types\nof fields.\n\n\u2014 Django documentation\n\nMost of the time you're dealing with validation in REST framework you'll\nsimply be relying on the default field validation, or writing explicit\nvalidation methods on serializer or field classes.\n\nHowever, sometimes you'll want to place your validation logic into reusable\ncomponents, so that it can easily be reused throughout your codebase. This can\nbe achieved by using validator functions and validator classes.\n\nValidation in Django REST framework serializers is handled a little\ndifferently to how validation works in Django's `ModelForm` class.\n\nWith `ModelForm` the validation is performed partially on the form, and\npartially on the model instance. With REST framework the validation is\nperformed entirely on the serializer class. This is advantageous for the\nfollowing reasons:\n\nWhen you're using `ModelSerializer` all of this is handled automatically for\nyou. If you want to drop down to using `Serializer` classes instead, then you\nneed to define the validation rules explicitly.\n\nAs an example of how REST framework uses explicit validation, we'll take a\nsimple model class that has a field with a uniqueness constraint.\n\nHere's a basic `ModelSerializer` that we can use for creating or updating\ninstances of `CustomerReportRecord`:\n\nIf we open up the Django shell using `manage.py shell` we can now\n\nThe interesting bit here is the `reference` field. We can see that the\nuniqueness constraint is being explicitly enforced by a validator on the\nserializer field.\n\nBecause of this more explicit style REST framework includes a few validator\nclasses that are not available in core Django. These classes are detailed\nbelow.\n\nThis validator can be used to enforce the `unique=True` constraint on model\nfields. It takes a single required argument, and an optional `messages`\nargument:\n\nThis validator should be applied to serializer fields, like so:\n\nThis validator can be used to enforce `unique_together` constraints on model\ninstances. It has two required arguments, and a single optional `messages`\nargument:\n\nThe validator should be applied to serializer classes, like so:\n\nNote: The `UniqueTogetherValidator` class always imposes an implicit\nconstraint that all the fields it applies to are always treated as required.\nFields with `default` values are an exception to this as they always supply a\nvalue even when omitted from user input.\n\nThese validators can be used to enforce the `unique_for_date`,\n`unique_for_month` and `unique_for_year` constraints on model instances. They\ntake the following arguments:\n\nThe validator should be applied to serializer classes, like so:\n\nThe date field that is used for the validation is always required to be\npresent on the serializer class. You can't simply rely on a model class\n`default=...`, because the value being used for the default wouldn't be\ngenerated until after the validation has run.\n\nThere are a couple of styles you may want to use for this depending on how you\nwant your API to behave. If you're using `ModelSerializer` you'll probably\nsimply rely on the defaults that REST framework generates for you, but if you\nare using `Serializer` or simply want more explicit control, use on of the\nstyles demonstrated below.\n\nIf you want the date field to be writable the only thing worth noting is that\nyou should ensure that it is always available in the input data, either by\nsetting a `default` argument, or by setting `required=True`.\n\nIf you want the date field to be visible, but not editable by the user, then\nset `read_only=True` and additionally set a `default=...` argument.\n\nIf you want the date field to be entirely hidden from the user, then use\n`HiddenField`. This field type does not accept user input, but instead always\nreturns its default value to the `validated_data` in the serializer.\n\nNote: The `UniqueFor<Range>Validator` classes impose an implicit constraint\nthat the fields they are applied to are always treated as required. Fields\nwith `default` values are an exception to this as they always supply a value\neven when omitted from user input.\n\nValidators that are applied across multiple fields in the serializer can\nsometimes require a field input that should not be provided by the API client,\nbut that is available as input to the validator.\n\nTwo patterns that you may want to use for this sort of validation include:\n\nREST framework includes a couple of defaults that may be useful in this\ncontext.\n\nA default class that can be used to represent the current user. In order to\nuse this, the 'request' must have been provided as part of the context\ndictionary when instantiating the serializer.\n\nA default class that can be used to only set a default argument during create\noperations. During updates the field is omitted.\n\nIt takes a single argument, which is the default value or callable that should\nbe used during create operations.\n\nThere are some ambiguous cases where you'll need to instead handle validation\nexplicitly, rather than relying on the default serializer classes that\n`ModelSerializer` generates.\n\nIn these cases you may want to disable the automatically generated validators,\nby specifying an empty list for the serializer `Meta.validators` attribute.\n\nBy default \"unique together\" validation enforces that all fields be\n`required=True`. In some cases, you might want to explicit apply\n`required=False` to one of the fields, in which case the desired behaviour of\nthe validation is ambiguous.\n\nIn this case you will typically need to exclude the validator from the\nserializer class, and instead write any validation logic explicitly, either in\nthe `.validate()` method, or else in the view.\n\nFor example:\n\nWhen applying an update to an existing instance, uniqueness validators will\nexclude the current instance from the uniqueness check. The current instance\nis available in the context of the uniqueness check, because it exists as an\nattribute on the serializer, having initially been passed using `instance=...`\nwhen instantiating the serializer.\n\nIn the case of update operations on nested serializers there's no way of\napplying this exclusion, because the instance is not available.\n\nAgain, you'll probably want to explicitly remove the validator from the\nserializer class, and write the code for the validation constraint explicitly,\nin a `.validate()` method, or in the view.\n\nIf you're not sure exactly what behavior a `ModelSerializer` class will\ngenerate it is usually a good idea to run `manage.py shell`, and print an\ninstance of the serializer, so that you can inspect the fields and validators\nthat it automatically generates for you.\n\nAlso keep in mind that with complex cases it can often be better to explicitly\ndefine your serializer classes, rather than relying on the default\n`ModelSerializer` behavior. This involves a little more code, but ensures that\nthe resulting behavior is more transparent.\n\nYou can use any of Django's existing validators, or write your own custom\nvalidators.\n\nA validator may be any callable that raises a `serializers.ValidationError` on\nfailure.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. This is\ndocumented in the Serializer docs\n\nTo write a class-based validator, use the `__call__` method. Class-based\nvalidators are useful as they allow you to parameterize and reuse behavior.\n\nIn some advanced cases you might want a validator to be passed the serializer\nfield it is being used with as additional context. You can do so by setting a\n`requires_context = True` attribute on the validator. The `__call__` method\nwill then be called with the `serializer_field` or `serializer` as an\nadditional argument.\n\nvalidators.py\n\n"}, {"name": "UniqueForYearValidator", "path": "api-guide/validators/index#uniqueforyearvalidator", "type": "Ref: Validators", "text": "\nValidators can be useful for re-using validation logic between different types\nof fields.\n\n\u2014 Django documentation\n\nMost of the time you're dealing with validation in REST framework you'll\nsimply be relying on the default field validation, or writing explicit\nvalidation methods on serializer or field classes.\n\nHowever, sometimes you'll want to place your validation logic into reusable\ncomponents, so that it can easily be reused throughout your codebase. This can\nbe achieved by using validator functions and validator classes.\n\nValidation in Django REST framework serializers is handled a little\ndifferently to how validation works in Django's `ModelForm` class.\n\nWith `ModelForm` the validation is performed partially on the form, and\npartially on the model instance. With REST framework the validation is\nperformed entirely on the serializer class. This is advantageous for the\nfollowing reasons:\n\nWhen you're using `ModelSerializer` all of this is handled automatically for\nyou. If you want to drop down to using `Serializer` classes instead, then you\nneed to define the validation rules explicitly.\n\nAs an example of how REST framework uses explicit validation, we'll take a\nsimple model class that has a field with a uniqueness constraint.\n\nHere's a basic `ModelSerializer` that we can use for creating or updating\ninstances of `CustomerReportRecord`:\n\nIf we open up the Django shell using `manage.py shell` we can now\n\nThe interesting bit here is the `reference` field. We can see that the\nuniqueness constraint is being explicitly enforced by a validator on the\nserializer field.\n\nBecause of this more explicit style REST framework includes a few validator\nclasses that are not available in core Django. These classes are detailed\nbelow.\n\nThis validator can be used to enforce the `unique=True` constraint on model\nfields. It takes a single required argument, and an optional `messages`\nargument:\n\nThis validator should be applied to serializer fields, like so:\n\nThis validator can be used to enforce `unique_together` constraints on model\ninstances. It has two required arguments, and a single optional `messages`\nargument:\n\nThe validator should be applied to serializer classes, like so:\n\nNote: The `UniqueTogetherValidator` class always imposes an implicit\nconstraint that all the fields it applies to are always treated as required.\nFields with `default` values are an exception to this as they always supply a\nvalue even when omitted from user input.\n\nThese validators can be used to enforce the `unique_for_date`,\n`unique_for_month` and `unique_for_year` constraints on model instances. They\ntake the following arguments:\n\nThe validator should be applied to serializer classes, like so:\n\nThe date field that is used for the validation is always required to be\npresent on the serializer class. You can't simply rely on a model class\n`default=...`, because the value being used for the default wouldn't be\ngenerated until after the validation has run.\n\nThere are a couple of styles you may want to use for this depending on how you\nwant your API to behave. If you're using `ModelSerializer` you'll probably\nsimply rely on the defaults that REST framework generates for you, but if you\nare using `Serializer` or simply want more explicit control, use on of the\nstyles demonstrated below.\n\nIf you want the date field to be writable the only thing worth noting is that\nyou should ensure that it is always available in the input data, either by\nsetting a `default` argument, or by setting `required=True`.\n\nIf you want the date field to be visible, but not editable by the user, then\nset `read_only=True` and additionally set a `default=...` argument.\n\nIf you want the date field to be entirely hidden from the user, then use\n`HiddenField`. This field type does not accept user input, but instead always\nreturns its default value to the `validated_data` in the serializer.\n\nNote: The `UniqueFor<Range>Validator` classes impose an implicit constraint\nthat the fields they are applied to are always treated as required. Fields\nwith `default` values are an exception to this as they always supply a value\neven when omitted from user input.\n\nValidators that are applied across multiple fields in the serializer can\nsometimes require a field input that should not be provided by the API client,\nbut that is available as input to the validator.\n\nTwo patterns that you may want to use for this sort of validation include:\n\nREST framework includes a couple of defaults that may be useful in this\ncontext.\n\nA default class that can be used to represent the current user. In order to\nuse this, the 'request' must have been provided as part of the context\ndictionary when instantiating the serializer.\n\nA default class that can be used to only set a default argument during create\noperations. During updates the field is omitted.\n\nIt takes a single argument, which is the default value or callable that should\nbe used during create operations.\n\nThere are some ambiguous cases where you'll need to instead handle validation\nexplicitly, rather than relying on the default serializer classes that\n`ModelSerializer` generates.\n\nIn these cases you may want to disable the automatically generated validators,\nby specifying an empty list for the serializer `Meta.validators` attribute.\n\nBy default \"unique together\" validation enforces that all fields be\n`required=True`. In some cases, you might want to explicit apply\n`required=False` to one of the fields, in which case the desired behaviour of\nthe validation is ambiguous.\n\nIn this case you will typically need to exclude the validator from the\nserializer class, and instead write any validation logic explicitly, either in\nthe `.validate()` method, or else in the view.\n\nFor example:\n\nWhen applying an update to an existing instance, uniqueness validators will\nexclude the current instance from the uniqueness check. The current instance\nis available in the context of the uniqueness check, because it exists as an\nattribute on the serializer, having initially been passed using `instance=...`\nwhen instantiating the serializer.\n\nIn the case of update operations on nested serializers there's no way of\napplying this exclusion, because the instance is not available.\n\nAgain, you'll probably want to explicitly remove the validator from the\nserializer class, and write the code for the validation constraint explicitly,\nin a `.validate()` method, or in the view.\n\nIf you're not sure exactly what behavior a `ModelSerializer` class will\ngenerate it is usually a good idea to run `manage.py shell`, and print an\ninstance of the serializer, so that you can inspect the fields and validators\nthat it automatically generates for you.\n\nAlso keep in mind that with complex cases it can often be better to explicitly\ndefine your serializer classes, rather than relying on the default\n`ModelSerializer` behavior. This involves a little more code, but ensures that\nthe resulting behavior is more transparent.\n\nYou can use any of Django's existing validators, or write your own custom\nvalidators.\n\nA validator may be any callable that raises a `serializers.ValidationError` on\nfailure.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. This is\ndocumented in the Serializer docs\n\nTo write a class-based validator, use the `__call__` method. Class-based\nvalidators are useful as they allow you to parameterize and reuse behavior.\n\nIn some advanced cases you might want a validator to be passed the serializer\nfield it is being used with as additional context. You can do so by setting a\n`requires_context = True` attribute on the validator. The `__call__` method\nwill then be called with the `serializer_field` or `serializer` as an\nadditional argument.\n\nvalidators.py\n\n"}, {"name": "UniqueTogetherValidator", "path": "api-guide/validators/index#uniquetogethervalidator", "type": "Ref: Validators", "text": "\nValidators can be useful for re-using validation logic between different types\nof fields.\n\n\u2014 Django documentation\n\nMost of the time you're dealing with validation in REST framework you'll\nsimply be relying on the default field validation, or writing explicit\nvalidation methods on serializer or field classes.\n\nHowever, sometimes you'll want to place your validation logic into reusable\ncomponents, so that it can easily be reused throughout your codebase. This can\nbe achieved by using validator functions and validator classes.\n\nValidation in Django REST framework serializers is handled a little\ndifferently to how validation works in Django's `ModelForm` class.\n\nWith `ModelForm` the validation is performed partially on the form, and\npartially on the model instance. With REST framework the validation is\nperformed entirely on the serializer class. This is advantageous for the\nfollowing reasons:\n\nWhen you're using `ModelSerializer` all of this is handled automatically for\nyou. If you want to drop down to using `Serializer` classes instead, then you\nneed to define the validation rules explicitly.\n\nAs an example of how REST framework uses explicit validation, we'll take a\nsimple model class that has a field with a uniqueness constraint.\n\nHere's a basic `ModelSerializer` that we can use for creating or updating\ninstances of `CustomerReportRecord`:\n\nIf we open up the Django shell using `manage.py shell` we can now\n\nThe interesting bit here is the `reference` field. We can see that the\nuniqueness constraint is being explicitly enforced by a validator on the\nserializer field.\n\nBecause of this more explicit style REST framework includes a few validator\nclasses that are not available in core Django. These classes are detailed\nbelow.\n\nThis validator can be used to enforce the `unique=True` constraint on model\nfields. It takes a single required argument, and an optional `messages`\nargument:\n\nThis validator should be applied to serializer fields, like so:\n\nThis validator can be used to enforce `unique_together` constraints on model\ninstances. It has two required arguments, and a single optional `messages`\nargument:\n\nThe validator should be applied to serializer classes, like so:\n\nNote: The `UniqueTogetherValidator` class always imposes an implicit\nconstraint that all the fields it applies to are always treated as required.\nFields with `default` values are an exception to this as they always supply a\nvalue even when omitted from user input.\n\nThese validators can be used to enforce the `unique_for_date`,\n`unique_for_month` and `unique_for_year` constraints on model instances. They\ntake the following arguments:\n\nThe validator should be applied to serializer classes, like so:\n\nThe date field that is used for the validation is always required to be\npresent on the serializer class. You can't simply rely on a model class\n`default=...`, because the value being used for the default wouldn't be\ngenerated until after the validation has run.\n\nThere are a couple of styles you may want to use for this depending on how you\nwant your API to behave. If you're using `ModelSerializer` you'll probably\nsimply rely on the defaults that REST framework generates for you, but if you\nare using `Serializer` or simply want more explicit control, use on of the\nstyles demonstrated below.\n\nIf you want the date field to be writable the only thing worth noting is that\nyou should ensure that it is always available in the input data, either by\nsetting a `default` argument, or by setting `required=True`.\n\nIf you want the date field to be visible, but not editable by the user, then\nset `read_only=True` and additionally set a `default=...` argument.\n\nIf you want the date field to be entirely hidden from the user, then use\n`HiddenField`. This field type does not accept user input, but instead always\nreturns its default value to the `validated_data` in the serializer.\n\nNote: The `UniqueFor<Range>Validator` classes impose an implicit constraint\nthat the fields they are applied to are always treated as required. Fields\nwith `default` values are an exception to this as they always supply a value\neven when omitted from user input.\n\nValidators that are applied across multiple fields in the serializer can\nsometimes require a field input that should not be provided by the API client,\nbut that is available as input to the validator.\n\nTwo patterns that you may want to use for this sort of validation include:\n\nREST framework includes a couple of defaults that may be useful in this\ncontext.\n\nA default class that can be used to represent the current user. In order to\nuse this, the 'request' must have been provided as part of the context\ndictionary when instantiating the serializer.\n\nA default class that can be used to only set a default argument during create\noperations. During updates the field is omitted.\n\nIt takes a single argument, which is the default value or callable that should\nbe used during create operations.\n\nThere are some ambiguous cases where you'll need to instead handle validation\nexplicitly, rather than relying on the default serializer classes that\n`ModelSerializer` generates.\n\nIn these cases you may want to disable the automatically generated validators,\nby specifying an empty list for the serializer `Meta.validators` attribute.\n\nBy default \"unique together\" validation enforces that all fields be\n`required=True`. In some cases, you might want to explicit apply\n`required=False` to one of the fields, in which case the desired behaviour of\nthe validation is ambiguous.\n\nIn this case you will typically need to exclude the validator from the\nserializer class, and instead write any validation logic explicitly, either in\nthe `.validate()` method, or else in the view.\n\nFor example:\n\nWhen applying an update to an existing instance, uniqueness validators will\nexclude the current instance from the uniqueness check. The current instance\nis available in the context of the uniqueness check, because it exists as an\nattribute on the serializer, having initially been passed using `instance=...`\nwhen instantiating the serializer.\n\nIn the case of update operations on nested serializers there's no way of\napplying this exclusion, because the instance is not available.\n\nAgain, you'll probably want to explicitly remove the validator from the\nserializer class, and write the code for the validation constraint explicitly,\nin a `.validate()` method, or in the view.\n\nIf you're not sure exactly what behavior a `ModelSerializer` class will\ngenerate it is usually a good idea to run `manage.py shell`, and print an\ninstance of the serializer, so that you can inspect the fields and validators\nthat it automatically generates for you.\n\nAlso keep in mind that with complex cases it can often be better to explicitly\ndefine your serializer classes, rather than relying on the default\n`ModelSerializer` behavior. This involves a little more code, but ensures that\nthe resulting behavior is more transparent.\n\nYou can use any of Django's existing validators, or write your own custom\nvalidators.\n\nA validator may be any callable that raises a `serializers.ValidationError` on\nfailure.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. This is\ndocumented in the Serializer docs\n\nTo write a class-based validator, use the `__call__` method. Class-based\nvalidators are useful as they allow you to parameterize and reuse behavior.\n\nIn some advanced cases you might want a validator to be passed the serializer\nfield it is being used with as additional context. You can do so by setting a\n`requires_context = True` attribute on the validator. The `__call__` method\nwill then be called with the `serializer_field` or `serializer` as an\nadditional argument.\n\nvalidators.py\n\n"}, {"name": "UniqueValidator", "path": "api-guide/validators/index#uniquevalidator", "type": "Ref: Validators", "text": "\nValidators can be useful for re-using validation logic between different types\nof fields.\n\n\u2014 Django documentation\n\nMost of the time you're dealing with validation in REST framework you'll\nsimply be relying on the default field validation, or writing explicit\nvalidation methods on serializer or field classes.\n\nHowever, sometimes you'll want to place your validation logic into reusable\ncomponents, so that it can easily be reused throughout your codebase. This can\nbe achieved by using validator functions and validator classes.\n\nValidation in Django REST framework serializers is handled a little\ndifferently to how validation works in Django's `ModelForm` class.\n\nWith `ModelForm` the validation is performed partially on the form, and\npartially on the model instance. With REST framework the validation is\nperformed entirely on the serializer class. This is advantageous for the\nfollowing reasons:\n\nWhen you're using `ModelSerializer` all of this is handled automatically for\nyou. If you want to drop down to using `Serializer` classes instead, then you\nneed to define the validation rules explicitly.\n\nAs an example of how REST framework uses explicit validation, we'll take a\nsimple model class that has a field with a uniqueness constraint.\n\nHere's a basic `ModelSerializer` that we can use for creating or updating\ninstances of `CustomerReportRecord`:\n\nIf we open up the Django shell using `manage.py shell` we can now\n\nThe interesting bit here is the `reference` field. We can see that the\nuniqueness constraint is being explicitly enforced by a validator on the\nserializer field.\n\nBecause of this more explicit style REST framework includes a few validator\nclasses that are not available in core Django. These classes are detailed\nbelow.\n\nThis validator can be used to enforce the `unique=True` constraint on model\nfields. It takes a single required argument, and an optional `messages`\nargument:\n\nThis validator should be applied to serializer fields, like so:\n\nThis validator can be used to enforce `unique_together` constraints on model\ninstances. It has two required arguments, and a single optional `messages`\nargument:\n\nThe validator should be applied to serializer classes, like so:\n\nNote: The `UniqueTogetherValidator` class always imposes an implicit\nconstraint that all the fields it applies to are always treated as required.\nFields with `default` values are an exception to this as they always supply a\nvalue even when omitted from user input.\n\nThese validators can be used to enforce the `unique_for_date`,\n`unique_for_month` and `unique_for_year` constraints on model instances. They\ntake the following arguments:\n\nThe validator should be applied to serializer classes, like so:\n\nThe date field that is used for the validation is always required to be\npresent on the serializer class. You can't simply rely on a model class\n`default=...`, because the value being used for the default wouldn't be\ngenerated until after the validation has run.\n\nThere are a couple of styles you may want to use for this depending on how you\nwant your API to behave. If you're using `ModelSerializer` you'll probably\nsimply rely on the defaults that REST framework generates for you, but if you\nare using `Serializer` or simply want more explicit control, use on of the\nstyles demonstrated below.\n\nIf you want the date field to be writable the only thing worth noting is that\nyou should ensure that it is always available in the input data, either by\nsetting a `default` argument, or by setting `required=True`.\n\nIf you want the date field to be visible, but not editable by the user, then\nset `read_only=True` and additionally set a `default=...` argument.\n\nIf you want the date field to be entirely hidden from the user, then use\n`HiddenField`. This field type does not accept user input, but instead always\nreturns its default value to the `validated_data` in the serializer.\n\nNote: The `UniqueFor<Range>Validator` classes impose an implicit constraint\nthat the fields they are applied to are always treated as required. Fields\nwith `default` values are an exception to this as they always supply a value\neven when omitted from user input.\n\nValidators that are applied across multiple fields in the serializer can\nsometimes require a field input that should not be provided by the API client,\nbut that is available as input to the validator.\n\nTwo patterns that you may want to use for this sort of validation include:\n\nREST framework includes a couple of defaults that may be useful in this\ncontext.\n\nA default class that can be used to represent the current user. In order to\nuse this, the 'request' must have been provided as part of the context\ndictionary when instantiating the serializer.\n\nA default class that can be used to only set a default argument during create\noperations. During updates the field is omitted.\n\nIt takes a single argument, which is the default value or callable that should\nbe used during create operations.\n\nThere are some ambiguous cases where you'll need to instead handle validation\nexplicitly, rather than relying on the default serializer classes that\n`ModelSerializer` generates.\n\nIn these cases you may want to disable the automatically generated validators,\nby specifying an empty list for the serializer `Meta.validators` attribute.\n\nBy default \"unique together\" validation enforces that all fields be\n`required=True`. In some cases, you might want to explicit apply\n`required=False` to one of the fields, in which case the desired behaviour of\nthe validation is ambiguous.\n\nIn this case you will typically need to exclude the validator from the\nserializer class, and instead write any validation logic explicitly, either in\nthe `.validate()` method, or else in the view.\n\nFor example:\n\nWhen applying an update to an existing instance, uniqueness validators will\nexclude the current instance from the uniqueness check. The current instance\nis available in the context of the uniqueness check, because it exists as an\nattribute on the serializer, having initially been passed using `instance=...`\nwhen instantiating the serializer.\n\nIn the case of update operations on nested serializers there's no way of\napplying this exclusion, because the instance is not available.\n\nAgain, you'll probably want to explicitly remove the validator from the\nserializer class, and write the code for the validation constraint explicitly,\nin a `.validate()` method, or in the view.\n\nIf you're not sure exactly what behavior a `ModelSerializer` class will\ngenerate it is usually a good idea to run `manage.py shell`, and print an\ninstance of the serializer, so that you can inspect the fields and validators\nthat it automatically generates for you.\n\nAlso keep in mind that with complex cases it can often be better to explicitly\ndefine your serializer classes, rather than relying on the default\n`ModelSerializer` behavior. This involves a little more code, but ensures that\nthe resulting behavior is more transparent.\n\nYou can use any of Django's existing validators, or write your own custom\nvalidators.\n\nA validator may be any callable that raises a `serializers.ValidationError` on\nfailure.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. This is\ndocumented in the Serializer docs\n\nTo write a class-based validator, use the `__call__` method. Class-based\nvalidators are useful as they allow you to parameterize and reuse behavior.\n\nIn some advanced cases you might want a validator to be passed the serializer\nfield it is being used with as additional context. You can do so by setting a\n`requires_context = True` attribute on the validator. The `__call__` method\nwill then be called with the `serializer_field` or `serializer` as an\nadditional argument.\n\nvalidators.py\n\n"}, {"name": "UnsupportedMediaType", "path": "api-guide/exceptions/index#unsupportedmediatype", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "UpdateAPIView", "path": "api-guide/generic-views/index#updateapiview", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "UpdateModelMixin", "path": "api-guide/generic-views/index#updatemodelmixin", "type": "Ref: Generic views", "text": "\nDjango\u2019s generic views... were developed as a shortcut for common usage\npatterns... They take certain common idioms and patterns found in view\ndevelopment and abstract them so that you can quickly write common views of\ndata without having to repeat yourself.\n\n\u2014 Django Documentation\n\nOne of the key benefits of class-based views is the way they allow you to\ncompose bits of reusable behavior. REST framework takes advantage of this by\nproviding a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API\nviews that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to\nusing the regular `APIView` class, or reuse the mixins and base classes used\nby the generic views to compose your own set of reusable generic views.\n\nTypically when using the generic views, you'll override the view, and set\nseveral class attributes.\n\nFor more complex cases you might also want to override various methods on the\nview class. For example.\n\nFor very simple cases you might want to pass through any class attributes\nusing the `.as_view()` method. For example, your URLconf might include\nsomething like the following entry:\n\nThis class extends REST framework's `APIView` class, adding commonly required\nbehavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining\n`GenericAPIView`, with one or more mixin classes.\n\nBasic settings:\n\nThe following attributes control the basic view behavior.\n\nPagination:\n\nThe following attributes are used to control pagination when used with list\nviews.\n\nFiltering:\n\nBase methods:\n\nReturns the queryset that should be used for list views, and that should be\nused as the base for lookups in detail views. Defaults to returning the\nqueryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset`\ndirectly, as `self.queryset` gets evaluated only once, and those results are\ncached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset,\nthat is specific to the user making the request.\n\nFor example:\n\nReturns an object instance that should be used for detail views. Defaults to\nusing the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups\nbased on more than one URL kwarg.\n\nFor example:\n\nNote that if your API doesn't include any object level permissions, you may\noptionally exclude the `self.check_object_permissions`, and simply return the\nobject from the `get_object_or_404` lookup.\n\nGiven a queryset, filter it with whichever filter backends are in use,\nreturning a new queryset.\n\nFor example:\n\nReturns the class that should be used for the serializer. Defaults to\nreturning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different\nserializers for read and write operations, or providing different serializers\nto different types of users.\n\nFor example:\n\nSave and deletion hooks:\n\nThe following methods are provided by the mixin classes, and provide easy\noverriding of the object save or deletion behavior.\n\nThese hooks are particularly useful for setting attributes that are implicit\nin the request, but are not part of the request data. For instance, you might\nset an attribute on the object based on the request user, or based on a URL\nkeyword argument.\n\nThese override points are also particularly useful for adding behavior that\noccurs before or after saving an object, such as emailing a confirmation, or\nlogging the update.\n\nYou can also use these hooks to provide additional validation, by raising a\n`ValidationError()`. This can be useful if you need some validation logic to\napply at the point of database save. For example:\n\nOther methods:\n\nYou won't typically need to override the following methods, although you might\nneed to call into them if you're writing custom views using `GenericAPIView`.\n\nThe mixin classes provide the actions that are used to provide the basic view\nbehavior. Note that the mixin classes provide action methods rather than\ndefining the handler methods, such as `.get()` and `.post()`, directly. This\nallows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a\nqueryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a\nserialized representation of the queryset as the body of the response. The\nresponse data may optionally be paginated.\n\nProvides a `.create(request, *args, **kwargs)` method, that implements\ncreating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a\nserialized representation of the object as the body of the response. If the\nrepresentation contains a key named `url`, then the `Location` header of the\nresponse will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements\nreturning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a\nserialized representation of the object as the body of the response. Otherwise\nit will return a `404 Not Found`.\n\nProvides a `.update(request, *args, **kwargs)` method, that implements\nupdating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is\nsimilar to the `update` method, except that all fields for the update will be\noptional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized\nrepresentation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad\nRequest` response will be returned, with the error details as the body of the\nresponse.\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements\ndeletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it\nwill return a `404 Not Found`.\n\nThe following classes are the concrete generic views. If you're using generic\nviews this is normally the level you'll be working at unless you need heavily\ncustomized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\nUsed for create-only endpoints.\n\nProvides a `post` method handler.\n\nExtends: GenericAPIView, CreateModelMixin\n\nUsed for read-only endpoints to represent a collection of model instances.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, ListModelMixin\n\nUsed for read-only endpoints to represent a single model instance.\n\nProvides a `get` method handler.\n\nExtends: GenericAPIView, RetrieveModelMixin\n\nUsed for delete-only endpoints for a single model instance.\n\nProvides a `delete` method handler.\n\nExtends: GenericAPIView, DestroyModelMixin\n\nUsed for update-only endpoints for a single model instance.\n\nProvides `put` and `patch` method handlers.\n\nExtends: GenericAPIView, UpdateModelMixin\n\nUsed for read-write endpoints to represent a collection of model instances.\n\nProvides `get` and `post` method handlers.\n\nExtends: GenericAPIView, ListModelMixin, CreateModelMixin\n\nUsed for read or update endpoints to represent a single model instance.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin\n\nUsed for read or delete endpoints to represent a single model instance.\n\nProvides `get` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin\n\nUsed for read-write-delete endpoints to represent a single model instance.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin,\nDestroyModelMixin\n\nOften you'll want to use the existing generic views, but use some slightly\ncustomized behavior. If you find yourself reusing some bit of customized\nbehavior in multiple places, you might want to refactor the behavior into a\ncommon class that you can then just apply to any view or viewset as needed.\n\nFor example, if you need to lookup objects based on multiple fields in the URL\nconf, you could create a mixin class like the following:\n\nYou can then simply apply this mixin to a view or viewset anytime you need to\napply the custom behavior.\n\nUsing custom mixins is a good option if you have custom behavior that needs to\nbe used.\n\nIf you are using a mixin across multiple views, you can take this a step\nfurther and create your own set of base views that can then be used throughout\nyour project. For example:\n\nUsing custom base classes is a good option if you have custom behavior that\nconsistently needs to be repeated across a large number of views throughout\nyour project.\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an\nupdate or a create operation, depending on if the object already existed or\nnot.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes\ninformation about the existence or non-existence of objects. It's also not\nobvious that transparently allowing re-creating of previously deleted\ninstances is necessarily a better default behavior than simply returning `404`\nresponses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different\ncircumstances, but from version 3.0 onwards we now use 404 behavior as the\ndefault, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include\nsomething like this `AllowPUTAsCreateMixin` class as a mixin to your views.\n\nThe following third party packages provide additional generic view\nimplementations.\n\nDjango Rest Multiple Models provides a generic view (and mixin) for sending\nmultiple serialized models and/or querysets via a single API request.\n\nmixins.pygenerics.py\n\n"}, {"name": "URLField", "path": "api-guide/fields/index#urlfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "URLPathVersioning", "path": "api-guide/versioning/index#urlpathversioning", "type": "Ref: Versioning", "text": "\nVersioning an interface is just a \"polite\" way to kill deployed clients.\n\n\u2014 Roy Fielding.\n\nAPI versioning allows you to alter behavior between different clients. REST\nframework provides for a number of different versioning schemes.\n\nVersioning is determined by the incoming client request, and may either be\nbased on the request URL, or based on the request headers.\n\nThere are a number of valid approaches to approaching versioning. Non-\nversioned systems can also be appropriate, particularly if you're engineering\nfor very long-term systems with multiple clients outside of your control.\n\nWhen API versioning is enabled, the `request.version` attribute will contain a\nstring that corresponds to the version requested in the incoming client\nrequest.\n\nBy default, versioning is not enabled, and `request.version` will always\nreturn `None`.\n\nHow you vary the API behavior is up to you, but one example you might\ntypically want is to switch to a different serialization style in a newer\nversion. For example:\n\nThe `reverse` function included by REST framework ties in with the versioning\nscheme. You need to make sure to include the current `request` as a keyword\nargument, like so.\n\nThe above function will apply any URL transformations appropriate to the\nrequest version. For example:\n\nWhen using hyperlinked serialization styles together with a URL based\nversioning scheme make sure to include the request as context to the\nserializer.\n\nDoing so will allow any returned URLs to include the appropriate versioning.\n\nThe versioning scheme is defined by the `DEFAULT_VERSIONING_CLASS` settings\nkey.\n\nUnless it is explicitly set, the value for `DEFAULT_VERSIONING_CLASS` will be\n`None`. In this case the `request.version` attribute will always return\n`None`.\n\nYou can also set the versioning scheme on an individual view. Typically you\nwon't need to do this, as it makes more sense to have a single versioning\nscheme used globally. If you do need to do so, use the `versioning_class`\nattribute.\n\nThe following settings keys are also used to control versioning:\n\nYou can also set your versioning class plus those three values on a per-view\nor a per-viewset basis by defining your own versioning scheme and using the\n`default_version`, `allowed_versions` and `version_param` class variables. For\nexample, if you want to use `URLPathVersioning`:\n\nThis scheme requires the client to specify the version as part of the media\ntype in the `Accept` header. The version is included as a media type\nparameter, that supplements the main media type.\n\nHere's an example HTTP request using the accept header versioning style.\n\nIn the example request above `request.version` attribute would return the\nstring `'1.0'`.\n\nVersioning based on accept headers is generally considered as best practice,\nalthough other styles may be suitable depending on your client requirements.\n\nStrictly speaking the `json` media type is not specified as including\nadditional parameters. If you are building a well-specified public API you\nmight consider using a vendor media type. To do so, configure your renderers\nto use a JSON based renderer with a custom media type:\n\nYour client requests would now look like this:\n\nThis scheme requires the client to specify the version as part of the URL\npath.\n\nYour URL conf must include a pattern that matches the version with a\n`'version'` keyword argument, so that this information is available to the\nversioning scheme.\n\nTo the client, this scheme is the same as `URLPathVersioning`. The only\ndifference is how it is configured in your Django application, as it uses URL\nnamespacing, instead of URL keyword arguments.\n\nWith this scheme the `request.version` attribute is determined based on the\n`namespace` that matches the incoming request path.\n\nIn the following example we're giving a set of views two different possible\nURL prefixes, each under a different namespace:\n\nBoth `URLPathVersioning` and `NamespaceVersioning` are reasonable if you just\nneed a simple versioning scheme. The `URLPathVersioning` approach might be\nbetter suitable for small ad-hoc projects, and the `NamespaceVersioning` is\nprobably easier to manage for larger projects.\n\nThe hostname versioning scheme requires the client to specify the requested\nversion as part of the hostname in the URL.\n\nFor example the following is an HTTP request to the\n`http://v1.example.com/bookings/` URL:\n\nBy default this implementation expects the hostname to match this simple\nregular expression:\n\nNote that the first group is enclosed in brackets, indicating that this is the\nmatched portion of the hostname.\n\nThe `HostNameVersioning` scheme can be awkward to use in debug mode as you\nwill typically be accessing a raw IP address such as `127.0.0.1`. There are\nvarious online tutorials on how to access localhost with a custom subdomain\nwhich you may find helpful in this case.\n\nHostname based versioning can be particularly useful if you have requirements\nto route incoming requests to different servers based on the version, as you\ncan configure different DNS records for different API versions.\n\nThis scheme is a simple style that includes the version as a query parameter\nin the URL. For example:\n\nTo implement a custom versioning scheme, subclass `BaseVersioning` and\noverride the `.determine_version` method.\n\nThe following example uses a custom `X-API-Version` header to determine the\nrequested version.\n\nIf your versioning scheme is based on the request URL, you will also want to\nalter how versioned URLs are determined. In order to do so you should override\nthe `.reverse()` method on the class. See the source code for examples.\n\nversioning.py\n\n"}, {"name": "UserRateThrottle", "path": "api-guide/throttling/index#userratethrottle", "type": "Ref: Throttling", "text": "\nHTTP/1.1 420 Enhance Your Calm\n\nTwitter API rate limiting response\n\nThrottling is similar to permissions, in that it determines if a request\nshould be authorized. Throttles indicate a temporary state, and are used to\ncontrol the rate of requests that clients can make to an API.\n\nAs with permissions, multiple throttles may be used. Your API might have a\nrestrictive throttle for unauthenticated requests, and a less restrictive\nthrottle for authenticated requests.\n\nAnother scenario where you might want to use multiple throttles would be if\nyou need to impose different constraints on different parts of the API, due to\nsome services being particularly resource-intensive.\n\nMultiple throttles can also be used if you want to impose both burst\nthrottling rates, and sustained throttling rates. For example, you might want\nto limit a user to a maximum of 60 requests per minute, and 1000 requests per\nday.\n\nThrottles do not necessarily only refer to rate-limiting requests. For example\na storage service might also need to throttle against bandwidth, and a paid\ndata service might want to throttle against a certain number of a records\nbeing accessed.\n\nAs with permissions and authentication, throttling in REST framework is always\ndefined as a list of classes.\n\nBefore running the main body of the view each throttle in the list is checked.\nIf any throttle check fails an `exceptions.Throttled` exception will be\nraised, and the main body of the view will not run.\n\nThe default throttling policy may be set globally, using the\n`DEFAULT_THROTTLE_CLASSES` and `DEFAULT_THROTTLE_RATES` settings. For example.\n\nThe rate descriptions used in `DEFAULT_THROTTLE_RATES` may include `second`,\n`minute`, `hour` or `day` as the throttle period.\n\nYou can also set the throttling policy on a per-view or per-viewset basis,\nusing the `APIView` class-based views.\n\nIf you're using the `@api_view` decorator with function based views you can\nuse the following decorator.\n\nIt's also possible to set throttle classes for routes that are created using\nthe `@action` decorator. Throttle classes set in this way will override any\nviewset level class settings.\n\nThe `X-Forwarded-For` HTTP header and `REMOTE_ADDR` WSGI variable are used to\nuniquely identify client IP addresses for throttling. If the `X-Forwarded-For`\nheader is present then it will be used, otherwise the value of the\n`REMOTE_ADDR` variable from the WSGI environment will be used.\n\nIf you need to strictly identify unique client IP addresses, you'll need to\nfirst configure the number of application proxies that the API runs behind by\nsetting the `NUM_PROXIES` setting. This setting should be an integer of zero\nor more. If set to non-zero then the client IP will be identified as being the\nlast IP address in the `X-Forwarded-For` header, once any application proxy IP\naddresses have first been excluded. If set to zero, then the `REMOTE_ADDR`\nvalue will always be used as the identifying IP address.\n\nIt is important to understand that if you configure the `NUM_PROXIES` setting,\nthen all clients behind a unique NAT'd gateway will be treated as a single\nclient.\n\nFurther context on how the `X-Forwarded-For` header works, and identifying a\nremote client IP can be found here.\n\nThe throttle classes provided by REST framework use Django's cache backend.\nYou should make sure that you've set appropriate cache settings. The default\nvalue of `LocMemCache` backend should be okay for simple setups. See Django's\ncache documentation for more details.\n\nIf you need to use a cache other than `'default'`, you can do so by creating a\ncustom throttle class and setting the `cache` attribute. For example:\n\nYou'll need to remember to also set your custom throttle class in the\n`'DEFAULT_THROTTLE_CLASSES'` settings key, or using the `throttle_classes`\nview attribute.\n\nThe `AnonRateThrottle` will only ever throttle unauthenticated users. The IP\naddress of the incoming request is used to generate a unique key to throttle\nagainst.\n\nThe allowed request rate is determined from one of the following (in order of\npreference).\n\n`AnonRateThrottle` is suitable if you want to restrict the rate of requests\nfrom unknown sources.\n\nThe `UserRateThrottle` will throttle users to a given rate of requests across\nthe API. The user id is used to generate a unique key to throttle against.\nUnauthenticated requests will fall back to using the IP address of the\nincoming request to generate a unique key to throttle against.\n\nThe allowed request rate is determined from one of the following (in order of\npreference).\n\nAn API may have multiple `UserRateThrottles` in place at the same time. To do\nso, override `UserRateThrottle` and set a unique \"scope\" for each class.\n\nFor example, multiple user throttle rates could be implemented by using the\nfollowing classes...\n\n...and the following settings.\n\n`UserRateThrottle` is suitable if you want simple global rate restrictions\nper-user.\n\nThe `ScopedRateThrottle` class can be used to restrict access to specific\nparts of the API. This throttle will only be applied if the view that is being\naccessed includes a `.throttle_scope` property. The unique throttle key will\nthen be formed by concatenating the \"scope\" of the request with the unique\nuser id or IP address.\n\nThe allowed request rate is determined by the `DEFAULT_THROTTLE_RATES` setting\nusing a key from the request \"scope\".\n\nFor example, given the following views...\n\n...and the following settings.\n\nUser requests to either `ContactListView` or `ContactDetailView` would be\nrestricted to a total of 1000 requests per-day. User requests to `UploadView`\nwould be restricted to 20 requests per day.\n\nTo create a custom throttle, override `BaseThrottle` and implement\n`.allow_request(self, request, view)`. The method should return `True` if the\nrequest should be allowed, and `False` otherwise.\n\nOptionally you may also override the `.wait()` method. If implemented,\n`.wait()` should return a recommended number of seconds to wait before\nattempting the next request, or `None`. The `.wait()` method will only be\ncalled if `.allow_request()` has previously returned `False`.\n\nIf the `.wait()` method is implemented and the request is throttled, then a\n`Retry-After` header will be included in the response.\n\nThe following is an example of a rate throttle, that will randomly throttle 1\nin every 10 requests.\n\nthrottling.py\n\n"}, {"name": "UUIDField", "path": "api-guide/fields/index#uuidfield", "type": "Ref: Serializer fields", "text": "\nEach field in a Form class is responsible not only for validating data, but\nalso for \"cleaning\" it \u2014 normalizing it to a consistent format.\n\n\u2014 Django documentation\n\nSerializer fields handle converting between primitive values and internal\ndatatypes. They also deal with validating input values, as well as retrieving\nand setting the values from their parent objects.\n\nNote: The serializer fields are declared in `fields.py`, but by convention you\nshould import them using `from rest_framework import serializers` and refer to\nfields as `serializers.<FieldName>`.\n\nEach serializer field class constructor takes at least these arguments. Some\nField classes take additional, field-specific arguments, but the following\nshould always be accepted:\n\nRead-only fields are included in the API output, but should not be included in\nthe input during create or update operations. Any 'read_only' fields that are\nincorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a\nrepresentation, but is not used when creating or updating an instance during\ndeserialization.\n\nDefaults to `False`\n\nSet this to `True` to ensure that the field may be used when updating or\ncreating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\nNormally an error will be raised if a field is not supplied during\ndeserialization. Set to false if this field is not required to be present\nduring deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to\nbe omitted from output when serializing the instance. If the key is not\npresent it will simply not be included in the output representation.\n\nDefaults to `True`.\n\nIf set, this gives the default value that will be used for the field if no\ninput value is supplied. If not set the default behaviour is to not populate\nthe attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial\nupdate case only fields that are provided in the incoming data will have a\nvalidated value returned.\n\nMay be set to a function or other callable, in which case the value will be\nevaluated each time it is used. When called, it will receive no arguments. If\nthe callable has a `requires_context = True` attribute, then the serializer\nfield will be passed as an argument.\n\nFor example:\n\nWhen serializing the instance, default will be used if the object attribute or\ndictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required.\nIncluding both the `default` and `required` keyword arguments is invalid and\nwill raise an error.\n\nNormally an error will be raised if `None` is passed to a serializer field.\nSet this keyword argument to `True` if `None` should be considered a valid\nvalue.\n\nNote that, without an explicit `default`, setting this argument to `True` will\nimply a `default` value of `null` for serialization output, but does not imply\na default for input deserialization.\n\nDefaults to `False`\n\nThe name of the attribute that will be used to populate the field. May be a\nmethod that only takes a `self` argument, such as\n`URLField(source='get_absolute_url')`, or may use dotted notation to traverse\nattributes, such as `EmailField(source='user.email')`. When serializing fields\nwith dotted notation, it may be necessary to provide a `default` value if any\nobject is not present or is empty during attribute traversal.\n\nThe value `source='*'` has a special meaning, and is used to indicate that the\nentire object should be passed through to the field. This can be useful for\ncreating nested representations, or for fields which require access to the\ncomplete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\nA list of validator functions which should be applied to the incoming field\ninput, and which either raise a validation error or simply return. Validator\nfunctions should typically raise `serializers.ValidationError`, but Django's\nbuilt-in `ValidationError` is also supported for compatibility with validators\ndefined in the Django codebase or third party Django packages.\n\nA dictionary of error codes to error messages.\n\nA short text string that may be used as the name of the field in HTML form\nfields or other descriptive elements.\n\nA text string that may be used as a description of the field in HTML form\nfields or other descriptive elements.\n\nA value that should be used for pre-populating the value of HTML form fields.\nYou may pass a callable to it, just as you may do with any regular Django\n`Field`:\n\nA dictionary of key-value pairs that can be used to control how renderers\nshould render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\nFor more details see the HTML & Forms documentation.\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always\nbe treated as setting a field to `False`, even if it has a `default=True`\noption specified. This is because HTML checkbox inputs represent the unchecked\nstate by omitting the value, so REST framework treats omission as if it is an\nempty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`.\nPrior to Django 2.1 `models.BooleanField` fields were always `blank=True`.\nThus since Django 2.1 default `serializers.BooleanField` instances will be\ngenerated without the `required` kwarg (i.e. equivalent to `required=True`)\nwhereas with previous versions of Django, default `BooleanField` instances\nwill be generated with a `required=False` option. If you want to control this\nbehaviour manually, explicitly declare the `BooleanField` on the serializer\nclass, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\nSignature: `BooleanField()`\n\nA boolean representation that also accepts `None` as a valid value.\n\nCorresponds to `django.db.models.fields.NullBooleanField`.\n\nSignature: `NullBooleanField()`\n\nA text representation. Optionally validates the text to be shorter than\n`max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or\n`django.db.models.fields.TextField`.\n\nSignature: `CharField(max_length=None, min_length=None, allow_blank=False,\ntrim_whitespace=True)`\n\nThe `allow_null` option is also available for string fields, although its\nusage is discouraged in favor of `allow_blank`. It is valid to set both\n`allow_blank=True` and `allow_null=True`, but doing so means that there will\nbe two differing types of empty value permissible for string representations,\nwhich can lead to data inconsistencies and subtle application bugs.\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\nSignature: `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\nA text representation, that validates the given value matches against a\ncertain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\nSignature: `RegexField(regex, max_length=None, min_length=None,\nallow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python\nregular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\nSignature: `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\nA `RegexField` that validates the input against a URL matching pattern.\nExpects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's\n`django.core.validators.URLValidator` for validation.\n\nSignature: `URLField(max_length=200, min_length=None, allow_blank=False)`\n\nA field that ensures the input is a valid UUID string. The `to_internal_value`\nmethod will return a `uuid.UUID` instance. On output the field will return a\nstring in the canonical hyphenated format, for example:\n\nSignature: `UUIDField(format='hex_verbose')`\n\nA field whose choices are limited to the filenames in a certain directory on\nthe filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\nSignature: `FilePathField(path, match=None, recursive=False, allow_files=True,\nallow_folders=False, required=None, **kwargs)`\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and\n`django.forms.fields.GenericIPAddressField`.\n\nSignature: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`,\n`django.db.models.fields.SmallIntegerField`,\n`django.db.models.fields.PositiveIntegerField` and\n`django.db.models.fields.PositiveSmallIntegerField`.\n\nSignature: `IntegerField(max_value=None, min_value=None)`\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\nSignature: `FloatField(max_value=None, min_value=None)`\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\nSignature: `DecimalField(max_digits, decimal_places, coerce_to_string=None,\nmax_value=None, min_value=None)`\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would\nuse:\n\nAnd to validate numbers up to anything less than one billion with a resolution\nof 10 decimal places:\n\nThis field also takes an optional argument, `coerce_to_string`. If set to\n`True` the representation will be output as a string. If set to `False` the\nrepresentation will be left as a `Decimal` instance and the final\nrepresentation will be determined by the renderer.\n\nIf unset, this will default to the same value as the\n`COERCE_DECIMAL_TO_STRING` setting, which is `True` unless set otherwise.\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\nSignature: `DateTimeField(format=api_settings.DATETIME_FORMAT,\ninput_formats=None, default_timezone=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be\nreturned by `to_representation` and the final output representation will\ndetermined by the renderer class.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any\nmodel fields with `auto_now=True` or `auto_now_add=True` will use serializer\nfields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the\n`DateTimeField` explicitly on the serializer. For example:\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\nSignature: `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle dates should be used. (eg `'2013-01-29'`)\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\nSignature: `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\nFormat strings may either be Python strftime formats which explicitly specify\nthe format, or the special string `'iso-8601'`, which indicates that ISO 8601\nstyle times should be used. (eg `'12:34:56.000000'`)\n\nA Duration representation. Corresponds to\n`django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta`\ninstance. The representation is a string following this format `'[DD]\n[HH:[MM:]]ss[.uuuuuu]'`.\n\nSignature: `DurationField(max_value=None, min_value=None)`\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the\ncorresponding model field includes a `choices=\u2026` argument.\n\nSignature: `ChoiceField(choices)`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`,\nalthough it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nA field that can accept a set of zero, one or many values, chosen from a\nlimited set of choices. Takes a single mandatory argument. `to_internal_value`\nreturns a `set` containing the selected values.\n\nSignature: `MultipleChoiceField(choices)`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are\nvalid, although it is highly recommended that you only use one and not both.\n`allow_blank` should be preferred for textual choices, and `allow_null` should\nbe preferred for numeric or other non-textual choices.\n\nThe `FileField` and `ImageField` classes are only suitable for use with\n`MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't\nsupport file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for\nhandling uploaded files.\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\nSignature: `FileField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nAn image representation. Validates the uploaded file content as matching a\nknown image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\nSignature: `ImageField(max_length=None, allow_empty_file=False,\nuse_url=UPLOADED_FILES_USE_URL)`\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is\nrecommended, as `PIL` is no longer actively maintained.\n\nA field class that validates a list of objects.\n\nSignature: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True,\nmin_length=None, max_length=None)`\n\nFor example, to validate a list of integers you might use something like the\nfollowing:\n\nThe `ListField` class also supports a declarative style that allows you to\nwrite reusable list field classes.\n\nWe can now reuse our custom `StringListField` class throughout our\napplication, without having to provide a `child` argument to it.\n\nA field class that validates a dictionary of objects. The keys in `DictField`\nare always assumed to be string values.\n\nSignature: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nFor example, to create a field that validates a mapping of strings to strings,\nyou would write something like this:\n\nYou can also use the declarative style, as with `ListField`. For example:\n\nA preconfigured `DictField` that is compatible with Django's postgres\n`HStoreField`.\n\nSignature: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\nNote that the child field must be an instance of `CharField`, as the hstore\nextension stores values as strings.\n\nA field class that validates that the incoming data structure consists of\nvalid JSON primitives. In its alternate binary mode, it will represent and\nvalidate JSON-encoded binary strings.\n\nSignature: `JSONField(binary, encoder)`\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field\nnames that relate to an attribute rather than a model field.\n\nSignature: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the\nfollowing serializer would automatically generate it as a `ReadOnlyField`:\n\nA field class that does not take a value based on user input, but instead\ntakes its value from a default value or callable.\n\nSignature: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part\nof the serializer validated data, you would use the following:\n\nThe `HiddenField` class is usually only needed if you have some validation\nthat needs to run based on some pre-provided field values, but you do not want\nto expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the validators documentation.\n\nA generic field that can be tied to any arbitrary model field. The\n`ModelField` class delegates the task of serialization/deserialization to its\nassociated model field. This field can be used to create serializer fields for\ncustom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field\nclasses.\n\nSignature: `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used\nby your API if needed. In order to properly instantiate a `ModelField`, it\nmust be passed a field that is attached to an instantiated model. For example:\n`ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\nThis is a read-only field. It gets its value by calling a method on the\nserializer class it is attached to. It can be used to add any sort of data to\nthe serialized representation of your object.\n\nSignature: `SerializerMethodField(method_name=None)`\n\nThe serializer method referred to by the `method_name` argument should accept\na single argument (in addition to `self`), which is the object being\nserialized. It should return whatever you want to be included in the\nserialized representation of the object. For example:\n\nIf you want to create a custom field, you'll need to subclass `Field` and then\noverride either one or both of the `.to_representation()` and\n`.to_internal_value()` methods. These two methods are used to convert between\nthe initial datatype, and a primitive, serializable datatype. Primitive\ndatatypes will typically be any of a number, string, boolean,\n`date`/`time`/`datetime` or `None`. They may also be any list or dictionary\nlike object that only contains other primitive objects. Other types might be\nsupported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype\ninto a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype\ninto its internal python representation. This method should raise a\n`serializers.ValidationError` if the data is invalid.\n\nLet's look at an example of serializing a class that represents an RGB color\nvalue:\n\nBy default field values are treated as mapping to an attribute on the object.\nIf you need to customize how the field value is accessed and set you need to\noverride `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class\nname of the object being serialized:\n\nOur `ColorField` class above currently does not perform any data validation.\nTo indicate invalid data, we should raise a `serializers.ValidationError`,\nlike so:\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a\nmessage string from the `error_messages` dictionary. For example:\n\nThis style keeps your error messages cleaner and more separated from your\ncode, and should be preferred.\n\nHere we'll take an example of a flat `DataPoint` model with `x_coordinate` and\n`y_coordinate` attributes.\n\nUsing a custom field and `source='*'` we can provide a nested representation\nof the coordinate pair:\n\nNote that this example doesn't handle validation. Partly for that reason, in a\nreal project, the coordinate nesting might be better handled with a nested\nserializer using `source='*'`, with two `IntegerField` instances, each with\ntheir own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n`to_representation` is passed the entire `DataPoint` object and must map from\nthat to the desired output.\n\nUnless our field is to be read-only, `to_internal_value` must map back to a\ndict suitable for updating our target object. With `source='*'`, the return\nfrom `to_internal_value` will update the root validated data dictionary,\nrather than a single key.\n\nFor completeness lets do the same thing again but with the nested serializer\napproach suggested above:\n\nHere the mapping between the target and source attribute pairs (`x` and\n`x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField`\ndeclarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behaviour as the custom field\napproach.\n\nSerializing:\n\nDeserializing:\n\nBut we also get the built-in validation for free:\n\nFor this reason, the nested serializer approach would be the first to try. You\nwould use the custom field approach when the nested serializer becomes\ninfeasible or overly complex.\n\nThe following third party packages are also available.\n\nThe drf-compound-fields package provides \"compound\" serializer fields, such as\nlists of simple values, which can be described by other fields rather than\nserializers with the `many=True` option. Also provided are fields for typed\ndictionaries and values that can be either a specific type or a list of items\nof that type.\n\nThe drf-extra-fields package provides extra serializer fields for REST\nframework, including `Base64ImageField` and `PointField` classes.\n\nthe djangorestframework-recursive package provides a `RecursiveField` for\nserializing and deserializing recursive structures\n\nThe django-rest-framework-gis package provides geographic addons for django\nrest framework like a `GeometryField` field and a GeoJSON serializer.\n\nThe django-rest-framework-hstore package provides an `HStoreField` to support\ndjango-hstore `DictionaryField` model field.\n\nfields.py\n\n"}, {"name": "ValidationError", "path": "api-guide/exceptions/index#validationerror", "type": "Ref: Exceptions", "text": "\nExceptions\u2026 allow error handling to be organized cleanly in a central or high-\nlevel place within the program structure.\n\n\u2014 Doug Hellmann, Python Exception Handling Techniques\n\nREST framework's views handle various exceptions, and deal with returning\nappropriate error responses.\n\nThe handled exceptions are:\n\nIn each case, REST framework will return a response with an appropriate status\ncode and content-type. The body of the response will include any additional\ndetails regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\nMight receive an error response indicating that the `DELETE` method is not\nallowed on that resource:\n\nValidation errors are handled slightly differently, and will include the field\nnames as the keys in the response. If the validation error was not specific to\na particular field then it will use the \"non_field_errors\" key, or whatever\nstring value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\nYou can implement custom exception handling by creating a handler function\nthat converts exceptions raised in your API views into response objects. This\nallows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be\nhandled, and the second is a dictionary containing any extra context such as\nthe view currently being handled. The exception handler function should either\nreturn a `Response` object, or return `None` if the exception cannot be\nhandled. If the handler returns `None` then the exception will be re-raised\nand Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the\nHTTP status code in the body of the response, like so:\n\nIn order to alter the style of the response, you could write the following\ncustom exception handler:\n\nThe context argument is not used by the default handler, but can be useful if\nthe exception handler needs further information such as the view currently\nbeing handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the\n`EXCEPTION_HANDLER` setting key. For example:\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard\nexception handler provided by REST framework:\n\nNote that the exception handler will only be called for responses generated by\nraised exceptions. It will not be used for any responses returned directly by\nthe view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by\nthe generic views when serializer validation fails.\n\nSignature: `APIException()`\n\nThe base class for all exceptions raised inside an `APIView` class or\n`@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the\n`.status_code`, `.default_detail`, and `default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be\nunreachable, you might want to implement an exception for the \"503 Service\nUnavailable\" HTTP response code. You could do this like so:\n\nThere are a number of different properties available for inspecting the status\nof an API exception. You can use these to build custom exception handling for\nyour project.\n\nThe available attributes and methods are:\n\nIn most cases the error detail will be a simple item:\n\nIn the case of validation errors the error detail will be either a list or\ndictionary of items:\n\nSignature: `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nSignature: `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401\nUnauthenticated\", but it may also result in a \"403 Forbidden\" response,\ndepending on the authentication scheme in use. See the authentication\ndocumentation for more details.\n\nSignature: `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403\nForbidden\".\n\nSignature: `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exists at the given URL. This exception is\nequivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404\nNot Found\".\n\nSignature: `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method\non the view.\n\nBy default this exception results in a response with the HTTP status code \"405\nMethod Not Allowed\".\n\nSignature: `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be\nsatisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406\nNot Acceptable\".\n\nSignature: `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request\ndata when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415\nUnsupported Media Type\".\n\nSignature: `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429\nToo Many Requests\".\n\nSignature: `ValidationError(detail, code=None)`\n\nThe `ValidationError` exception is slightly different from the other\n`APIException` classes:\n\nThe `ValidationError` class should be used for serializer and field\nvalidation, and by validator classes. It is also raised when calling\n`serializer.is_valid` with the `raise_exception` keyword argument:\n\nThe generic views use the `raise_exception=True` flag, which means that you\ncan override the style of validation error responses globally in your API. To\ndo so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400\nBad Request\".\n\nDjango REST Framework provides two error views suitable for providing generic\nJSON `500` Server Error and `400` Bad Request responses. (Django's default\nerror views provide HTML responses, which may not be appropriate for an API-\nonly application.)\n\nUse these as per Django's Customizing error views documentation.\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\nexceptions.py\n\n"}, {"name": "Validators", "path": "api-guide/validators/index", "type": "API Guide", "text": "\nValidators can be useful for re-using validation logic between different types\nof fields.\n\n\u2014 Django documentation\n\nMost of the time you're dealing with validation in REST framework you'll\nsimply be relying on the default field validation, or writing explicit\nvalidation methods on serializer or field classes.\n\nHowever, sometimes you'll want to place your validation logic into reusable\ncomponents, so that it can easily be reused throughout your codebase. This can\nbe achieved by using validator functions and validator classes.\n\nValidation in Django REST framework serializers is handled a little\ndifferently to how validation works in Django's `ModelForm` class.\n\nWith `ModelForm` the validation is performed partially on the form, and\npartially on the model instance. With REST framework the validation is\nperformed entirely on the serializer class. This is advantageous for the\nfollowing reasons:\n\nWhen you're using `ModelSerializer` all of this is handled automatically for\nyou. If you want to drop down to using `Serializer` classes instead, then you\nneed to define the validation rules explicitly.\n\nAs an example of how REST framework uses explicit validation, we'll take a\nsimple model class that has a field with a uniqueness constraint.\n\nHere's a basic `ModelSerializer` that we can use for creating or updating\ninstances of `CustomerReportRecord`:\n\nIf we open up the Django shell using `manage.py shell` we can now\n\nThe interesting bit here is the `reference` field. We can see that the\nuniqueness constraint is being explicitly enforced by a validator on the\nserializer field.\n\nBecause of this more explicit style REST framework includes a few validator\nclasses that are not available in core Django. These classes are detailed\nbelow.\n\nThis validator can be used to enforce the `unique=True` constraint on model\nfields. It takes a single required argument, and an optional `messages`\nargument:\n\nThis validator should be applied to serializer fields, like so:\n\nThis validator can be used to enforce `unique_together` constraints on model\ninstances. It has two required arguments, and a single optional `messages`\nargument:\n\nThe validator should be applied to serializer classes, like so:\n\nNote: The `UniqueTogetherValidator` class always imposes an implicit\nconstraint that all the fields it applies to are always treated as required.\nFields with `default` values are an exception to this as they always supply a\nvalue even when omitted from user input.\n\nThese validators can be used to enforce the `unique_for_date`,\n`unique_for_month` and `unique_for_year` constraints on model instances. They\ntake the following arguments:\n\nThe validator should be applied to serializer classes, like so:\n\nThe date field that is used for the validation is always required to be\npresent on the serializer class. You can't simply rely on a model class\n`default=...`, because the value being used for the default wouldn't be\ngenerated until after the validation has run.\n\nThere are a couple of styles you may want to use for this depending on how you\nwant your API to behave. If you're using `ModelSerializer` you'll probably\nsimply rely on the defaults that REST framework generates for you, but if you\nare using `Serializer` or simply want more explicit control, use on of the\nstyles demonstrated below.\n\nIf you want the date field to be writable the only thing worth noting is that\nyou should ensure that it is always available in the input data, either by\nsetting a `default` argument, or by setting `required=True`.\n\nIf you want the date field to be visible, but not editable by the user, then\nset `read_only=True` and additionally set a `default=...` argument.\n\nIf you want the date field to be entirely hidden from the user, then use\n`HiddenField`. This field type does not accept user input, but instead always\nreturns its default value to the `validated_data` in the serializer.\n\nNote: The `UniqueFor<Range>Validator` classes impose an implicit constraint\nthat the fields they are applied to are always treated as required. Fields\nwith `default` values are an exception to this as they always supply a value\neven when omitted from user input.\n\nValidators that are applied across multiple fields in the serializer can\nsometimes require a field input that should not be provided by the API client,\nbut that is available as input to the validator.\n\nTwo patterns that you may want to use for this sort of validation include:\n\nREST framework includes a couple of defaults that may be useful in this\ncontext.\n\nA default class that can be used to represent the current user. In order to\nuse this, the 'request' must have been provided as part of the context\ndictionary when instantiating the serializer.\n\nA default class that can be used to only set a default argument during create\noperations. During updates the field is omitted.\n\nIt takes a single argument, which is the default value or callable that should\nbe used during create operations.\n\nThere are some ambiguous cases where you'll need to instead handle validation\nexplicitly, rather than relying on the default serializer classes that\n`ModelSerializer` generates.\n\nIn these cases you may want to disable the automatically generated validators,\nby specifying an empty list for the serializer `Meta.validators` attribute.\n\nBy default \"unique together\" validation enforces that all fields be\n`required=True`. In some cases, you might want to explicit apply\n`required=False` to one of the fields, in which case the desired behaviour of\nthe validation is ambiguous.\n\nIn this case you will typically need to exclude the validator from the\nserializer class, and instead write any validation logic explicitly, either in\nthe `.validate()` method, or else in the view.\n\nFor example:\n\nWhen applying an update to an existing instance, uniqueness validators will\nexclude the current instance from the uniqueness check. The current instance\nis available in the context of the uniqueness check, because it exists as an\nattribute on the serializer, having initially been passed using `instance=...`\nwhen instantiating the serializer.\n\nIn the case of update operations on nested serializers there's no way of\napplying this exclusion, because the instance is not available.\n\nAgain, you'll probably want to explicitly remove the validator from the\nserializer class, and write the code for the validation constraint explicitly,\nin a `.validate()` method, or in the view.\n\nIf you're not sure exactly what behavior a `ModelSerializer` class will\ngenerate it is usually a good idea to run `manage.py shell`, and print an\ninstance of the serializer, so that you can inspect the fields and validators\nthat it automatically generates for you.\n\nAlso keep in mind that with complex cases it can often be better to explicitly\ndefine your serializer classes, rather than relying on the default\n`ModelSerializer` behavior. This involves a little more code, but ensures that\nthe resulting behavior is more transparent.\n\nYou can use any of Django's existing validators, or write your own custom\nvalidators.\n\nA validator may be any callable that raises a `serializers.ValidationError` on\nfailure.\n\nYou can specify custom field-level validation by adding\n`.validate_<field_name>` methods to your `Serializer` subclass. This is\ndocumented in the Serializer docs\n\nTo write a class-based validator, use the `__call__` method. Class-based\nvalidators are useful as they allow you to parameterize and reuse behavior.\n\nIn some advanced cases you might want a validator to be passed the serializer\nfield it is being used with as additional context. You can do so by setting a\n`requires_context = True` attribute on the validator. The `__call__` method\nwill then be called with the `serializer_field` or `serializer` as an\nadditional argument.\n\nvalidators.py\n\n"}, {"name": "Versioning", "path": "api-guide/versioning/index", "type": "API Guide", "text": "\nVersioning an interface is just a \"polite\" way to kill deployed clients.\n\n\u2014 Roy Fielding.\n\nAPI versioning allows you to alter behavior between different clients. REST\nframework provides for a number of different versioning schemes.\n\nVersioning is determined by the incoming client request, and may either be\nbased on the request URL, or based on the request headers.\n\nThere are a number of valid approaches to approaching versioning. Non-\nversioned systems can also be appropriate, particularly if you're engineering\nfor very long-term systems with multiple clients outside of your control.\n\nWhen API versioning is enabled, the `request.version` attribute will contain a\nstring that corresponds to the version requested in the incoming client\nrequest.\n\nBy default, versioning is not enabled, and `request.version` will always\nreturn `None`.\n\nHow you vary the API behavior is up to you, but one example you might\ntypically want is to switch to a different serialization style in a newer\nversion. For example:\n\nThe `reverse` function included by REST framework ties in with the versioning\nscheme. You need to make sure to include the current `request` as a keyword\nargument, like so.\n\nThe above function will apply any URL transformations appropriate to the\nrequest version. For example:\n\nWhen using hyperlinked serialization styles together with a URL based\nversioning scheme make sure to include the request as context to the\nserializer.\n\nDoing so will allow any returned URLs to include the appropriate versioning.\n\nThe versioning scheme is defined by the `DEFAULT_VERSIONING_CLASS` settings\nkey.\n\nUnless it is explicitly set, the value for `DEFAULT_VERSIONING_CLASS` will be\n`None`. In this case the `request.version` attribute will always return\n`None`.\n\nYou can also set the versioning scheme on an individual view. Typically you\nwon't need to do this, as it makes more sense to have a single versioning\nscheme used globally. If you do need to do so, use the `versioning_class`\nattribute.\n\nThe following settings keys are also used to control versioning:\n\nYou can also set your versioning class plus those three values on a per-view\nor a per-viewset basis by defining your own versioning scheme and using the\n`default_version`, `allowed_versions` and `version_param` class variables. For\nexample, if you want to use `URLPathVersioning`:\n\nThis scheme requires the client to specify the version as part of the media\ntype in the `Accept` header. The version is included as a media type\nparameter, that supplements the main media type.\n\nHere's an example HTTP request using the accept header versioning style.\n\nIn the example request above `request.version` attribute would return the\nstring `'1.0'`.\n\nVersioning based on accept headers is generally considered as best practice,\nalthough other styles may be suitable depending on your client requirements.\n\nStrictly speaking the `json` media type is not specified as including\nadditional parameters. If you are building a well-specified public API you\nmight consider using a vendor media type. To do so, configure your renderers\nto use a JSON based renderer with a custom media type:\n\nYour client requests would now look like this:\n\nThis scheme requires the client to specify the version as part of the URL\npath.\n\nYour URL conf must include a pattern that matches the version with a\n`'version'` keyword argument, so that this information is available to the\nversioning scheme.\n\nTo the client, this scheme is the same as `URLPathVersioning`. The only\ndifference is how it is configured in your Django application, as it uses URL\nnamespacing, instead of URL keyword arguments.\n\nWith this scheme the `request.version` attribute is determined based on the\n`namespace` that matches the incoming request path.\n\nIn the following example we're giving a set of views two different possible\nURL prefixes, each under a different namespace:\n\nBoth `URLPathVersioning` and `NamespaceVersioning` are reasonable if you just\nneed a simple versioning scheme. The `URLPathVersioning` approach might be\nbetter suitable for small ad-hoc projects, and the `NamespaceVersioning` is\nprobably easier to manage for larger projects.\n\nThe hostname versioning scheme requires the client to specify the requested\nversion as part of the hostname in the URL.\n\nFor example the following is an HTTP request to the\n`http://v1.example.com/bookings/` URL:\n\nBy default this implementation expects the hostname to match this simple\nregular expression:\n\nNote that the first group is enclosed in brackets, indicating that this is the\nmatched portion of the hostname.\n\nThe `HostNameVersioning` scheme can be awkward to use in debug mode as you\nwill typically be accessing a raw IP address such as `127.0.0.1`. There are\nvarious online tutorials on how to access localhost with a custom subdomain\nwhich you may find helpful in this case.\n\nHostname based versioning can be particularly useful if you have requirements\nto route incoming requests to different servers based on the version, as you\ncan configure different DNS records for different API versions.\n\nThis scheme is a simple style that includes the version as a query parameter\nin the URL. For example:\n\nTo implement a custom versioning scheme, subclass `BaseVersioning` and\noverride the `.determine_version` method.\n\nThe following example uses a custom `X-API-Version` header to determine the\nrequested version.\n\nIf your versioning scheme is based on the request URL, you will also want to\nalter how versioned URLs are determined. In order to do so you should override\nthe `.reverse()` method on the class. See the source code for examples.\n\nversioning.py\n\n"}, {"name": "Versioning settings", "path": "api-guide/settings/index#versioning-settings", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "View names and descriptions", "path": "api-guide/settings/index#view-names-and-descriptions", "type": "Ref: Settings", "text": "\nNamespaces are one honking great idea - let's do more of those!\n\n\u2014 The Zen of Python\n\nConfiguration for REST framework is all namespaced inside a single Django\nsetting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like\nthis:\n\nIf you need to access the values of REST framework's API settings in your\nproject, you should use the `api_settings` object. For example.\n\nThe `api_settings` object will check for any user-defined settings, and\notherwise fall back to the default values. Any setting that uses string import\npaths to refer to a class will automatically import and return the referenced\nclass, instead of the string literal.\n\nThe following settings control the basic API policies, and are applied to\nevery `APIView` class-based view, or `@api_view` function based view.\n\nA list or tuple of renderer classes, that determines the default set of\nrenderers that may be used when returning a `Response` object.\n\nDefault:\n\nA list or tuple of parser classes, that determines the default set of parsers\nused when accessing the `request.data` property.\n\nDefault:\n\nA list or tuple of authentication classes, that determines the default set of\nauthenticators used when accessing the `request.user` or `request.auth`\nproperties.\n\nDefault:\n\nA list or tuple of permission classes, that determines the default set of\npermissions checked at the start of a view. Permission must be granted by\nevery class in the list.\n\nDefault:\n\nA list or tuple of throttle classes, that determines the default set of\nthrottles checked at the start of a view.\n\nDefault: `[]`\n\nA content negotiation class, that determines how a renderer is selected for\nthe response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\nThe following settings control the behavior of the generic class-based views.\n\nA list of filter backend classes that should be used for generic filtering. If\nset to `None` then generic filtering is disabled.\n\nThe default class to use for queryset pagination. If set to `None`, pagination\nis disabled by default. See the pagination documentation for further guidance\non setting and modifying the pagination style.\n\nDefault: `None`\n\nThe default page size to use for pagination. If set to `None`, pagination is\ndisabled by default.\n\nDefault: `None`\n\nThe name of a query parameter, which can be used to specify the search term\nused by `SearchFilter`.\n\nDefault: `search`\n\nThe name of a query parameter, which can be used to specify the ordering of\nresults returned by `OrderingFilter`.\n\nDefault: `ordering`\n\nThe value that should be used for `request.version` when no versioning\ninformation is present.\n\nDefault: `None`\n\nIf set, this value will restrict the set of versions that may be returned by\nthe versioning scheme, and will raise an error if the provided version if not\nin this set.\n\nDefault: `None`\n\nThe string that should used for any versioning parameters, such as in the\nmedia type or URL query parameters.\n\nDefault: `'version'`\n\nThe following settings control the behavior of unauthenticated requests.\n\nThe class that should be used to initialize `request.user` for unauthenticated\nrequests. (If removing authentication entirely, e.g. by removing\n`django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to\n`None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\nThe class that should be used to initialize `request.auth` for unauthenticated\nrequests.\n\nDefault: `None`\n\nThe following settings control the behavior of APIRequestFactory and APIClient\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the\n`TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a\ntest request, for example: `client.post('/users', {'username': 'jamie'},\nformat='json')`\n\nDefault:\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field\nname when generating a schema path parameter. Typically this will be `'id'`.\nThis gives a more suitable representation as \"primary key\" is an\nimplementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\nIf set, this is used to map internal viewset method names onto external action\nnames used in the schema generation. This allows us to generate names that are\nmore suitable for an external representation than those that are used\ninternally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\nThe name of a URL parameter that may be used to override the default content\nnegotiation `Accept` header behavior, by using a `format=\u2026` query parameter in\nthe request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be\ndisabled.\n\nDefault: `'format'`\n\nThe name of a parameter in the URL conf that may be used to provide a format\nsuffix. This setting is applied when using `format_suffix_patterns` to include\nsuffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\nThe following settings are used to control how date and time representations\nmay be parsed and rendered.\n\nA format string that should be used by default for rendering the output of\n`DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer\nfields will return Python `datetime` objects, and the datetime encoding will\nbe determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`DateField` serializer fields. If `None`, then `DateField` serializer fields\nwill return Python `date` objects, and the date encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nA format string that should be used by default for rendering the output of\n`TimeField` serializer fields. If `None`, then `TimeField` serializer fields\nwill return Python `time` objects, and the time encoding will be determined by\nthe renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python strftime format string.\n\nDefault: `'iso-8601'`\n\nA list of format strings that should be used by default for parsing inputs to\n`TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python strftime format\nstrings.\n\nDefault: `['iso-8601']`\n\nWhen set to `True`, JSON responses will allow unicode characters in responses.\nFor example:\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\nBoth styles conform to RFC 4627, and are syntactically valid JSON. The unicode\nstyle is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\nWhen set to `True`, JSON responses will return compact representations, with\nno spacing after `':'` and `','` characters. For example:\n\nWhen set to `False`, JSON responses will return slightly more verbose\nrepresentations, like so:\n\nThe default style is to return minified responses, in line with Heroku's API\ndesign guidelines.\n\nDefault: `True`\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically\nvalid JSON, raising an exception for the extended float values (`nan`, `inf`,\n`-inf`) accepted by Python's `json` module. This is the recommended setting,\nas these values are not generally supported. e.g., neither Javascript's\n`JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However,\nthese values are still invalid and will need to be specially handled in your\ncode.\n\nDefault: `True`\n\nWhen returning decimal objects in API representations that do not support a\nnative decimal type, it is normally best to return the value as a string. This\navoids the loss of precision that occurs with binary floating point\nimplementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings\ninstead of `Decimal` objects. When set to `False`, serializers will return\n`Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\nThe following settings are used to generate the view names and descriptions,\nas used in responses to `OPTIONS` requests, and as used in the browsable API.\n\nA string representing the function that should be used when generating view\nnames.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_name'`\n\nA string representing the function that should be used when generating view\ndescriptions.\n\nThis setting can be changed to support markup styles other than the default\nmarkdown. For example, you can use it to support `rst` markup in your view\ndocstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\nIf the view instance inherits `ViewSet`, it may have been initialized with\nseveral optional arguments:\n\nDefault: `'rest_framework.views.get_view_description'`\n\nGlobal settings for select field cutoffs for rendering relational fields in\nthe browsable API.\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\nA string representing the function that should be used when returning a\nresponse for any given exception. If the function returns `None`, a 500 error\nwill be raised.\n\nThis setting can be changed to support error responses other than the default\n`{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide\nAPI responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\nDefault: `'rest_framework.views.exception_handler'`\n\nA string representing the key that should be used for serializer errors that\ndo not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\nA string representing the key that should be used for the URL fields generated\nby `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\nAn integer of 0 or more, that may be used to specify the number of application\nproxies that the API runs behind. This allows throttling to more accurately\nidentify client IP addresses. If set to `None` then less strict IP matching\nwill be used by the throttle classes.\n\nDefault: `None`\n\nsettings.py\n\n"}, {"name": "ViewSet", "path": "api-guide/viewsets/index#viewset", "type": "Ref: ViewSets", "text": "\nAfter routing has determined which controller to use for a request, your\ncontroller is responsible for making sense of the request and producing the\nappropriate output.\n\n\u2014 Ruby on Rails Documentation\n\nDjango REST framework allows you to combine the logic for a set of related\nviews in a single class, called a `ViewSet`. In other frameworks you may also\nfind conceptually similar implementations named something like 'Resources' or\n'Controllers'.\n\nA `ViewSet` class is simply a type of class-based View, that does not provide\nany method handlers such as `.get()` or `.post()`, and instead provides\nactions such as `.list()` and `.create()`.\n\nThe method handlers for a `ViewSet` are only bound to the corresponding\nactions at the point of finalizing the view, using the `.as_view()` method.\n\nTypically, rather than explicitly registering the views in a viewset in the\nurlconf, you'll register the viewset with a router class, that automatically\ndetermines the urlconf for you.\n\nLet's define a simple viewset that can be used to list or retrieve all the\nusers in the system.\n\nIf we need to, we can bind this viewset into two separate views, like so:\n\nTypically we wouldn't do this, but would instead register the viewset with a\nrouter, and allow the urlconf to be automatically generated.\n\nRather than writing your own viewsets, you'll often want to use the existing\nbase classes that provide a default set of behavior. For example:\n\nThere are two main advantages of using a `ViewSet` class over using a `View`\nclass.\n\nBoth of these come with a trade-off. Using regular views and URL confs is more\nexplicit and gives you more control. ViewSets are helpful if you want to get\nup and running quickly, or when you have a large API and you want to enforce a\nconsistent URL configuration throughout.\n\nThe default routers included with REST framework will provide routes for a\nstandard set of create/retrieve/update/destroy style actions, as shown below:\n\nDuring dispatch, the following attributes are available on the `ViewSet`.\n\nYou may inspect these attributes to adjust behaviour based on the current\naction. For example, you could restrict permissions to everything except the\n`list` action similar to this:\n\nIf you have ad-hoc methods that should be routable, you can mark them as such\nwith the `@action` decorator. Like regular actions, extra actions may be\nintended for either a single object, or an entire collection. To indicate\nthis, set the `detail` argument to `True` or `False`. The router will\nconfigure its URL patterns accordingly. e.g., the `DefaultRouter` will\nconfigure detail actions to contain `pk` in their URL patterns.\n\nA more complete example of extra actions:\n\nThe `action` decorator will route `GET` requests by default, but may also\naccept other HTTP methods by setting the `methods` argument. For example:\n\nThe decorator allows you to override any viewset-level configuration such as\n`permission_classes`, `serializer_class`, `filter_backends`...:\n\nThe two new actions will then be available at the urls\n`^users/{pk}/set_password/$` and `^users/{pk}/unset_password/$`. Use the\n`url_path` and `url_name` parameters to change the URL segment and the reverse\nURL name of the action.\n\nTo view all extra actions, call the `.get_extra_actions()` method.\n\nExtra actions can map additional HTTP methods to separate `ViewSet` methods.\nFor example, the above password set/unset methods could be consolidated into a\nsingle route. Note that additional mappings do not accept arguments.\n\nIf you need to get the URL of an action, use the `.reverse_action()` method.\nThis is a convenience wrapper for `reverse()`, automatically passing the\nview's `request` object and prepending the `url_name` with the `.basename`\nattribute.\n\nNote that the `basename` is provided by the router during `ViewSet`\nregistration. If you are not using a router, then you must provide the\n`basename` argument to the `.as_view()` method.\n\nUsing the example from the previous section:\n\nAlternatively, you can use the `url_name` attribute set by the `@action`\ndecorator.\n\nThe `url_name` argument for `.reverse_action()` should match the same argument\nto the `@action` decorator. Additionally, this method can be used to reverse\nthe default actions, such as `list` and `create`.\n\nThe `ViewSet` class inherits from `APIView`. You can use any of the standard\nattributes such as `permission_classes`, `authentication_classes` in order to\ncontrol the API policy on the viewset.\n\nThe `ViewSet` class does not provide any implementations of actions. In order\nto use a `ViewSet` class you'll override the class and define the action\nimplementations explicitly.\n\nThe `GenericViewSet` class inherits from `GenericAPIView`, and provides the\ndefault set of `get_object`, `get_queryset` methods and other generic view\nbase behavior, but does not include any actions by default.\n\nIn order to use a `GenericViewSet` class you'll override the class and either\nmixin the required mixin classes, or define the action implementations\nexplicitly.\n\nThe `ModelViewSet` class inherits from `GenericAPIView` and includes\nimplementations for various actions, by mixing in the behavior of the various\nmixin classes.\n\nThe actions provided by the `ModelViewSet` class are `.list()`, `.retrieve()`,\n`.create()`, `.update()`, `.partial_update()`, and `.destroy()`.\n\nBecause `ModelViewSet` extends `GenericAPIView`, you'll normally need to\nprovide at least the `queryset` and `serializer_class` attributes. For\nexample:\n\nNote that you can use any of the standard attributes or method overrides\nprovided by `GenericAPIView`. For example, to use a `ViewSet` that dynamically\ndetermines the queryset it should operate on, you might do something like\nthis:\n\nNote however that upon removal of the `queryset` property from your `ViewSet`,\nany associated router will be unable to derive the basename of your Model\nautomatically, and so you will have to specify the `basename` kwarg as part of\nyour router registration.\n\nAlso note that although this class provides the complete set of\ncreate/list/retrieve/update/destroy actions by default, you can restrict the\navailable operations by using the standard permission classes.\n\nThe `ReadOnlyModelViewSet` class also inherits from `GenericAPIView`. As with\n`ModelViewSet` it also includes implementations for various actions, but\nunlike `ModelViewSet` only provides the 'read-only' actions, `.list()` and\n`.retrieve()`.\n\nAs with `ModelViewSet`, you'll normally need to provide at least the\n`queryset` and `serializer_class` attributes. For example:\n\nAgain, as with `ModelViewSet`, you can use any of the standard attributes and\nmethod overrides available to `GenericAPIView`.\n\nYou may need to provide custom `ViewSet` classes that do not have the full set\nof `ModelViewSet` actions, or that customize the behavior in some other way.\n\nTo create a base viewset class that provides `create`, `list` and `retrieve`\noperations, inherit from `GenericViewSet`, and mixin the required actions:\n\nBy creating your own base `ViewSet` classes, you can provide common behavior\nthat can be reused in multiple viewsets across your API.\n\nviewsets.py\n\n"}, {"name": "ViewSets", "path": "api-guide/viewsets/index", "type": "API Guide", "text": "\nAfter routing has determined which controller to use for a request, your\ncontroller is responsible for making sense of the request and producing the\nappropriate output.\n\n\u2014 Ruby on Rails Documentation\n\nDjango REST framework allows you to combine the logic for a set of related\nviews in a single class, called a `ViewSet`. In other frameworks you may also\nfind conceptually similar implementations named something like 'Resources' or\n'Controllers'.\n\nA `ViewSet` class is simply a type of class-based View, that does not provide\nany method handlers such as `.get()` or `.post()`, and instead provides\nactions such as `.list()` and `.create()`.\n\nThe method handlers for a `ViewSet` are only bound to the corresponding\nactions at the point of finalizing the view, using the `.as_view()` method.\n\nTypically, rather than explicitly registering the views in a viewset in the\nurlconf, you'll register the viewset with a router class, that automatically\ndetermines the urlconf for you.\n\nLet's define a simple viewset that can be used to list or retrieve all the\nusers in the system.\n\nIf we need to, we can bind this viewset into two separate views, like so:\n\nTypically we wouldn't do this, but would instead register the viewset with a\nrouter, and allow the urlconf to be automatically generated.\n\nRather than writing your own viewsets, you'll often want to use the existing\nbase classes that provide a default set of behavior. For example:\n\nThere are two main advantages of using a `ViewSet` class over using a `View`\nclass.\n\nBoth of these come with a trade-off. Using regular views and URL confs is more\nexplicit and gives you more control. ViewSets are helpful if you want to get\nup and running quickly, or when you have a large API and you want to enforce a\nconsistent URL configuration throughout.\n\nThe default routers included with REST framework will provide routes for a\nstandard set of create/retrieve/update/destroy style actions, as shown below:\n\nDuring dispatch, the following attributes are available on the `ViewSet`.\n\nYou may inspect these attributes to adjust behaviour based on the current\naction. For example, you could restrict permissions to everything except the\n`list` action similar to this:\n\nIf you have ad-hoc methods that should be routable, you can mark them as such\nwith the `@action` decorator. Like regular actions, extra actions may be\nintended for either a single object, or an entire collection. To indicate\nthis, set the `detail` argument to `True` or `False`. The router will\nconfigure its URL patterns accordingly. e.g., the `DefaultRouter` will\nconfigure detail actions to contain `pk` in their URL patterns.\n\nA more complete example of extra actions:\n\nThe `action` decorator will route `GET` requests by default, but may also\naccept other HTTP methods by setting the `methods` argument. For example:\n\nThe decorator allows you to override any viewset-level configuration such as\n`permission_classes`, `serializer_class`, `filter_backends`...:\n\nThe two new actions will then be available at the urls\n`^users/{pk}/set_password/$` and `^users/{pk}/unset_password/$`. Use the\n`url_path` and `url_name` parameters to change the URL segment and the reverse\nURL name of the action.\n\nTo view all extra actions, call the `.get_extra_actions()` method.\n\nExtra actions can map additional HTTP methods to separate `ViewSet` methods.\nFor example, the above password set/unset methods could be consolidated into a\nsingle route. Note that additional mappings do not accept arguments.\n\nIf you need to get the URL of an action, use the `.reverse_action()` method.\nThis is a convenience wrapper for `reverse()`, automatically passing the\nview's `request` object and prepending the `url_name` with the `.basename`\nattribute.\n\nNote that the `basename` is provided by the router during `ViewSet`\nregistration. If you are not using a router, then you must provide the\n`basename` argument to the `.as_view()` method.\n\nUsing the example from the previous section:\n\nAlternatively, you can use the `url_name` attribute set by the `@action`\ndecorator.\n\nThe `url_name` argument for `.reverse_action()` should match the same argument\nto the `@action` decorator. Additionally, this method can be used to reverse\nthe default actions, such as `list` and `create`.\n\nThe `ViewSet` class inherits from `APIView`. You can use any of the standard\nattributes such as `permission_classes`, `authentication_classes` in order to\ncontrol the API policy on the viewset.\n\nThe `ViewSet` class does not provide any implementations of actions. In order\nto use a `ViewSet` class you'll override the class and define the action\nimplementations explicitly.\n\nThe `GenericViewSet` class inherits from `GenericAPIView`, and provides the\ndefault set of `get_object`, `get_queryset` methods and other generic view\nbase behavior, but does not include any actions by default.\n\nIn order to use a `GenericViewSet` class you'll override the class and either\nmixin the required mixin classes, or define the action implementations\nexplicitly.\n\nThe `ModelViewSet` class inherits from `GenericAPIView` and includes\nimplementations for various actions, by mixing in the behavior of the various\nmixin classes.\n\nThe actions provided by the `ModelViewSet` class are `.list()`, `.retrieve()`,\n`.create()`, `.update()`, `.partial_update()`, and `.destroy()`.\n\nBecause `ModelViewSet` extends `GenericAPIView`, you'll normally need to\nprovide at least the `queryset` and `serializer_class` attributes. For\nexample:\n\nNote that you can use any of the standard attributes or method overrides\nprovided by `GenericAPIView`. For example, to use a `ViewSet` that dynamically\ndetermines the queryset it should operate on, you might do something like\nthis:\n\nNote however that upon removal of the `queryset` property from your `ViewSet`,\nany associated router will be unable to derive the basename of your Model\nautomatically, and so you will have to specify the `basename` kwarg as part of\nyour router registration.\n\nAlso note that although this class provides the complete set of\ncreate/list/retrieve/update/destroy actions by default, you can restrict the\navailable operations by using the standard permission classes.\n\nThe `ReadOnlyModelViewSet` class also inherits from `GenericAPIView`. As with\n`ModelViewSet` it also includes implementations for various actions, but\nunlike `ModelViewSet` only provides the 'read-only' actions, `.list()` and\n`.retrieve()`.\n\nAs with `ModelViewSet`, you'll normally need to provide at least the\n`queryset` and `serializer_class` attributes. For example:\n\nAgain, as with `ModelViewSet`, you can use any of the standard attributes and\nmethod overrides available to `GenericAPIView`.\n\nYou may need to provide custom `ViewSet` classes that do not have the full set\nof `ModelViewSet` actions, or that customize the behavior in some other way.\n\nTo create a base viewset class that provides `create`, `list` and `retrieve`\noperations, inherit from `GenericViewSet`, and mixin the required actions:\n\nBy creating your own base `ViewSet` classes, you can provide common behavior\nthat can be reused in multiple viewsets across your API.\n\nviewsets.py\n\n"}]