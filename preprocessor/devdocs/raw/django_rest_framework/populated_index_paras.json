[{"name": "0: Quickstart", "path": "tutorial/quickstart/index", "type": "Tutorial", "text": ["We're going to create a simple API to allow admin users to view and edit the users and groups in the system.", "Create a new Django project named tutorial, then start a new app called quickstart.", "The project layout should look like:", "It may look unusual that the application has been created within the project directory. Using the project's namespace avoids name clashes with external modules (a topic that goes outside the scope of the quickstart).", "Now sync your database for the first time:", "We'll also create an initial user named admin with a password of password123. We'll authenticate as that user later in our example.", "Once you've set up a database and the initial user is created and ready to go, open up the app's directory and we'll get coding...", "First up we're going to define some serializers. Let's create a new module named tutorial/quickstart/serializers.py that we'll use for our data representations.", "Notice that we're using hyperlinked relations in this case with HyperlinkedModelSerializer. You can also use primary key and various other relationships, but hyperlinking is good RESTful design.", "Right, we'd better write some views then. Open tutorial/quickstart/views.py and get typing.", "Rather than write multiple views we're grouping together all the common behavior into classes called ViewSets.", "We can easily break these down into individual views if we need to, but using viewsets keeps the view logic nicely organized as well as being very concise.", "Okay, now let's wire up the API URLs. On to tutorial/urls.py...", "Because we're using viewsets instead of views, we can automatically generate the URL conf for our API, by simply registering the viewsets with a router class.", "Again, if we need more control over the API URLs we can simply drop down to using regular class-based views, and writing the URL conf explicitly.", "Finally, we're including default login and logout views for use with the browsable API. That's optional, but useful if your API requires authentication and you want to use the browsable API.", "Pagination allows you to control how many objects per page are returned. To enable it add the following lines to tutorial/settings.py", "Add 'rest_framework' to INSTALLED_APPS. The settings module will be in tutorial/settings.py", "Okay, we're done.", "We're now ready to test the API we've built. Let's fire up the server from the command line.", "We can now access our API, both from the command-line, using tools like curl...", "Or using the httpie, command line tool...", "Or directly through the browser, by going to the URL http://127.0.0.1:8000/users/...", "", "If you're working through the browser, make sure to login using the control in the top right corner.", "Great, that was easy!", "If you want to get a more in depth understanding of how REST framework fits together head on over to the tutorial, or start browsing the API guide."]}, {"name": "1: Serialization", "path": "tutorial/1-serialization/index", "type": "Tutorial", "text": ["This tutorial will cover creating a simple pastebin code highlighting Web API. Along the way it will introduce the various components that make up REST framework, and give you a comprehensive understanding of how everything fits together.", "The tutorial is fairly in-depth, so you should probably get a cookie and a cup of your favorite brew before getting started. If you just want a quick overview, you should head over to the quickstart documentation instead.", "Note: The code for this tutorial is available in the encode/rest-framework-tutorial repository on GitHub. The completed implementation is also online as a sandbox version for testing, available here.", "Before we do anything else we'll create a new virtual environment, using venv. This will make sure our package configuration is kept nicely isolated from any other projects we're working on.", "Now that we're inside a virtual environment, we can install our package requirements.", "Note: To exit the virtual environment at any time, just type deactivate. For more information see the venv documentation.", "Okay, we're ready to get coding. To get started, let's create a new project to work with.", "Once that's done we can create an app that we'll use to create a simple Web API.", "We'll need to add our new snippets app and the rest_framework app to INSTALLED_APPS. Let's edit the tutorial/settings.py file:", "Okay, we're ready to roll.", "For the purposes of this tutorial we're going to start by creating a simple Snippet model that is used to store code snippets. Go ahead and edit the snippets/models.py file. Note: Good programming practices include comments. Although you will find them in our repository version of this tutorial code, we have omitted them here to focus on the code itself.", "We'll also need to create an initial migration for our snippet model, and sync the database for the first time.", "The first thing we need to get started on our Web API is to provide a way of serializing and deserializing the snippet instances into representations such as json. We can do this by declaring serializers that work very similar to Django's forms. Create a file in the snippets directory named serializers.py and add the following.", "The first part of the serializer class defines the fields that get serialized/deserialized. The create() and update() methods define how fully fledged instances are created or modified when calling serializer.save()", "A serializer class is very similar to a Django Form class, and includes similar validation flags on the various fields, such as required, max_length and default.", "The field flags can also control how the serializer should be displayed in certain circumstances, such as when rendering to HTML. The {'base_template': 'textarea.html'} flag above is equivalent to using widget=widgets.Textarea on a Django Form class. This is particularly useful for controlling how the browsable API should be displayed, as we'll see later in the tutorial.", "We can actually also save ourselves some time by using the ModelSerializer class, as we'll see later, but for now we'll keep our serializer definition explicit.", "Before we go any further we'll familiarize ourselves with using our new Serializer class. Let's drop into the Django shell.", "Okay, once we've got a few imports out of the way, let's create a couple of code snippets to work with.", "We've now got a few snippet instances to play with. Let's take a look at serializing one of those instances.", "At this point we've translated the model instance into Python native datatypes. To finalize the serialization process we render the data into json.", "Deserialization is similar. First we parse a stream into Python native datatypes...", "...then we restore those native datatypes into a fully populated object instance.", "Notice how similar the API is to working with forms. The similarity should become even more apparent when we start writing views that use our serializer.", "We can also serialize querysets instead of model instances. To do so we simply add a many=True flag to the serializer arguments.", "Our SnippetSerializer class is replicating a lot of information that's also contained in the Snippet model. It would be nice if we could keep our code a bit more concise.", "In the same way that Django provides both Form classes and ModelForm classes, REST framework includes both Serializer classes, and ModelSerializer classes.", "Let's look at refactoring our serializer using the ModelSerializer class. Open the file snippets/serializers.py again, and replace the SnippetSerializer class with the following.", "One nice property that serializers have is that you can inspect all the fields in a serializer instance, by printing its representation. Open the Django shell with python manage.py shell, then try the following:", "It's important to remember that ModelSerializer classes don't do anything particularly magical, they are simply a shortcut for creating serializer classes:", "Let's see how we can write some API views using our new Serializer class. For the moment we won't use any of REST framework's other features, we'll just write the views as regular Django views.", "Edit the snippets/views.py file, and add the following.", "The root of our API is going to be a view that supports listing all the existing snippets, or creating a new snippet.", "Note that because we want to be able to POST to this view from clients that won't have a CSRF token we need to mark the view as csrf_exempt. This isn't something that you'd normally want to do, and REST framework views actually use more sensible behavior than this, but it'll do for our purposes right now.", "We'll also need a view which corresponds to an individual snippet, and can be used to retrieve, update or delete the snippet.", "Finally we need to wire these views up. Create the snippets/urls.py file:", "We also need to wire up the root urlconf, in the tutorial/urls.py file, to include our snippet app's URLs.", "It's worth noting that there are a couple of edge cases we're not dealing with properly at the moment. If we send malformed json, or if a request is made with a method that the view doesn't handle, then we'll end up with a 500 \"server error\" response. Still, this'll do for now.", "Now we can start up a sample server that serves our snippets.", "Quit out of the shell...", "...and start up Django's development server.", "In another terminal window, we can test the server.", "We can test our API using curl or httpie. Httpie is a user friendly http client that's written in Python. Let's install that.", "You can install httpie using pip:", "Finally, we can get a list of all of the snippets:", "Or we can get a particular snippet by referencing its id:", "Similarly, you can have the same json displayed by visiting these URLs in a web browser.", "We're doing okay so far, we've got a serialization API that feels pretty similar to Django's Forms API, and some regular Django views.", "Our API views don't do anything particularly special at the moment, beyond serving json responses, and there are some error handling edge cases we'd still like to clean up, but it's a functioning Web API.", "We'll see how we can start to improve things in part 2 of the tutorial."]}, {"name": "2: Requests and Responses", "path": "tutorial/2-requests-and-responses/index", "type": "Tutorial", "text": ["From this point we're going to really start covering the core of REST framework. Let's introduce a couple of essential building blocks.", "REST framework introduces a Request object that extends the regular HttpRequest, and provides more flexible request parsing. The core functionality of the Request object is the request.data attribute, which is similar to request.POST, but more useful for working with Web APIs.", "REST framework also introduces a Response object, which is a type of TemplateResponse that takes unrendered content and uses content negotiation to determine the correct content type to return to the client.", "Using numeric HTTP status codes in your views doesn't always make for obvious reading, and it's easy to not notice if you get an error code wrong. REST framework provides more explicit identifiers for each status code, such as HTTP_400_BAD_REQUEST in the status module. It's a good idea to use these throughout rather than using numeric identifiers.", "REST framework provides two wrappers you can use to write API views.", "These wrappers provide a few bits of functionality such as making sure you receive Request instances in your view, and adding context to Response objects so that content negotiation can be performed.", "The wrappers also provide behaviour such as returning 405 Method Not Allowed responses when appropriate, and handling any ParseError exceptions that occur when accessing request.data with malformed input.", "Okay, let's go ahead and start using these new components to refactor our views slightly.", "Our instance view is an improvement over the previous example. It's a little more concise, and the code now feels very similar to if we were working with the Forms API. We're also using named status codes, which makes the response meanings more obvious.", "Here is the view for an individual snippet, in the views.py module.", "This should all feel very familiar - it is not a lot different from working with regular Django views.", "Notice that we're no longer explicitly tying our requests or responses to a given content type. request.data can handle incoming json requests, but it can also handle other formats. Similarly we're returning response objects with data, but allowing REST framework to render the response into the correct content type for us.", "To take advantage of the fact that our responses are no longer hardwired to a single content type let's add support for format suffixes to our API endpoints. Using format suffixes gives us URLs that explicitly refer to a given format, and means our API will be able to handle URLs such as http://example.com/api/items/4.json.", "Start by adding a format keyword argument to both of the views, like so.", "and", "Now update the snippets/urls.py file slightly, to append a set of format_suffix_patterns in addition to the existing URLs.", "We don't necessarily need to add these extra url patterns in, but it gives us a simple, clean way of referring to a specific format.", "Go ahead and test the API from the command line, as we did in tutorial part 1. Everything is working pretty similarly, although we've got some nicer error handling if we send invalid requests.", "We can get a list of all of the snippets, as before.", "We can control the format of the response that we get back, either by using the Accept header:", "Or by appending a format suffix:", "Similarly, we can control the format of the request that we send, using the Content-Type header.", "If you add a --debug switch to the http requests above, you will be able to see the request type in request headers.", "Now go and open the API in a web browser, by visiting http://127.0.0.1:8000/snippets/.", "Because the API chooses the content type of the response based on the client request, it will, by default, return an HTML-formatted representation of the resource when that resource is requested by a web browser. This allows for the API to return a fully web-browsable HTML representation.", "Having a web-browsable API is a huge usability win, and makes developing and using your API much easier. It also dramatically lowers the barrier-to-entry for other developers wanting to inspect and work with your API.", "See the browsable api topic for more information about the browsable API feature and how to customize it.", "In tutorial part 3, we'll start using class-based views, and see how generic views reduce the amount of code we need to write."]}, {"name": "3: Class-based Views", "path": "tutorial/3-class-based-views/index", "type": "Tutorial", "text": ["We can also write our API views using class-based views, rather than function based views. As we'll see this is a powerful pattern that allows us to reuse common functionality, and helps us keep our code DRY.", "We'll start by rewriting the root view as a class-based view. All this involves is a little bit of refactoring of views.py.", "So far, so good. It looks pretty similar to the previous case, but we've got better separation between the different HTTP methods. We'll also need to update the instance view in views.py.", "That's looking good. Again, it's still pretty similar to the function based view right now.", "We'll also need to refactor our snippets/urls.py slightly now that we're using class-based views.", "Okay, we're done. If you run the development server everything should be working just as before.", "One of the big wins of using class-based views is that it allows us to easily compose reusable bits of behaviour.", "The create/retrieve/update/delete operations that we've been using so far are going to be pretty similar for any model-backed API views we create. Those bits of common behaviour are implemented in REST framework's mixin classes.", "Let's take a look at how we can compose the views by using the mixin classes. Here's our views.py module again.", "We'll take a moment to examine exactly what's happening here. We're building our view using GenericAPIView, and adding in ListModelMixin and CreateModelMixin.", "The base class provides the core functionality, and the mixin classes provide the .list() and .create() actions. We're then explicitly binding the get and post methods to the appropriate actions. Simple enough stuff so far.", "Pretty similar. Again we're using the GenericAPIView class to provide the core functionality, and adding in mixins to provide the .retrieve(), .update() and .destroy() actions.", "Using the mixin classes we've rewritten the views to use slightly less code than before, but we can go one step further. REST framework provides a set of already mixed-in generic views that we can use to trim down our views.py module even more.", "Wow, that's pretty concise. We've gotten a huge amount for free, and our code looks like good, clean, idiomatic Django.", "Next we'll move onto part 4 of the tutorial, where we'll take a look at how we can deal with authentication and permissions for our API."]}, {"name": "4: Authentication & Permissions", "path": "tutorial/4-authentication-and-permissions/index", "type": "Tutorial", "text": ["Currently our API doesn't have any restrictions on who can edit or delete code snippets. We'd like to have some more advanced behavior in order to make sure that:", "We're going to make a couple of changes to our Snippet model class. First, let's add a couple of fields. One of those fields will be used to represent the user who created the code snippet. The other field will be used to store the highlighted HTML representation of the code.", "Add the following two fields to the Snippet model in models.py.", "We'd also need to make sure that when the model is saved, that we populate the highlighted field, using the pygments code highlighting library.", "We'll need some extra imports:", "And now we can add a .save() method to our model class:", "When that's all done we'll need to update our database tables. Normally we'd create a database migration in order to do that, but for the purposes of this tutorial, let's just delete the database and start again.", "You might also want to create a few different users, to use for testing the API. The quickest way to do this will be with the createsuperuser command.", "Now that we've got some users to work with, we'd better add representations of those users to our API. Creating a new serializer is easy. In serializers.py add:", "Because 'snippets' is a reverse relationship on the User model, it will not be included by default when using the ModelSerializer class, so we needed to add an explicit field for it.", "We'll also add a couple of views to views.py. We'd like to just use read-only views for the user representations, so we'll use the ListAPIView and RetrieveAPIView generic class-based views.", "Make sure to also import the UserSerializer class", "Finally we need to add those views into the API, by referencing them from the URL conf. Add the following to the patterns in snippets/urls.py.", "Right now, if we created a code snippet, there'd be no way of associating the user that created the snippet, with the snippet instance. The user isn't sent as part of the serialized representation, but is instead a property of the incoming request.", "The way we deal with that is by overriding a .perform_create() method on our snippet views, that allows us to modify how the instance save is managed, and handle any information that is implicit in the incoming request or requested URL.", "On the SnippetList view class, add the following method:", "The create() method of our serializer will now be passed an additional 'owner' field, along with the validated data from the request.", "Now that snippets are associated with the user that created them, let's update our SnippetSerializer to reflect that. Add the following field to the serializer definition in serializers.py:", "Note: Make sure you also add 'owner', to the list of fields in the inner Meta class.", "This field is doing something quite interesting. The source argument controls which attribute is used to populate a field, and can point at any attribute on the serialized instance. It can also take the dotted notation shown above, in which case it will traverse the given attributes, in a similar way as it is used with Django's template language.", "The field we've added is the untyped ReadOnlyField class, in contrast to the other typed fields, such as CharField, BooleanField etc... The untyped ReadOnlyField is always read-only, and will be used for serialized representations, but will not be used for updating model instances when they are deserialized. We could have also used CharField(read_only=True) here.", "Now that code snippets are associated with users, we want to make sure that only authenticated users are able to create, update and delete code snippets.", "REST framework includes a number of permission classes that we can use to restrict who can access a given view. In this case the one we're looking for is IsAuthenticatedOrReadOnly, which will ensure that authenticated requests get read-write access, and unauthenticated requests get read-only access.", "First add the following import in the views module", "Then, add the following property to both the SnippetList and SnippetDetail view classes.", "If you open a browser and navigate to the browsable API at the moment, you'll find that you're no longer able to create new code snippets. In order to do so we'd need to be able to login as a user.", "We can add a login view for use with the browsable API, by editing the URLconf in our project-level urls.py file.", "Add the following import at the top of the file:", "And, at the end of the file, add a pattern to include the login and logout views for the browsable API.", "The 'api-auth/' part of pattern can actually be whatever URL you want to use.", "Now if you open up the browser again and refresh the page you'll see a 'Login' link in the top right of the page. If you log in as one of the users you created earlier, you'll be able to create code snippets again.", "Once you've created a few code snippets, navigate to the '/users/' endpoint, and notice that the representation includes a list of the snippet ids that are associated with each user, in each user's 'snippets' field.", "Really we'd like all code snippets to be visible to anyone, but also make sure that only the user that created a code snippet is able to update or delete it.", "To do that we're going to need to create a custom permission.", "In the snippets app, create a new file, permissions.py", "Now we can add that custom permission to our snippet instance endpoint, by editing the permission_classes property on the SnippetDetail view class:", "Make sure to also import the IsOwnerOrReadOnly class.", "Now, if you open a browser again, you find that the 'DELETE' and 'PUT' actions only appear on a snippet instance endpoint if you're logged in as the same user that created the code snippet.", "Because we now have a set of permissions on the API, we need to authenticate our requests to it if we want to edit any snippets. We haven't set up any authentication classes, so the defaults are currently applied, which are SessionAuthentication and BasicAuthentication.", "When we interact with the API through the web browser, we can login, and the browser session will then provide the required authentication for the requests.", "If we're interacting with the API programmatically we need to explicitly provide the authentication credentials on each request.", "If we try to create a snippet without authenticating, we'll get an error:", "We can make a successful request by including the username and password of one of the users we created earlier.", "We've now got a fairly fine-grained set of permissions on our Web API, and end points for users of the system and for the code snippets that they have created.", "In part 5 of the tutorial we'll look at how we can tie everything together by creating an HTML endpoint for our highlighted snippets, and improve the cohesion of our API by using hyperlinking for the relationships within the system."]}, {"name": "5: Relationships & Hyperlinked APIs", "path": "tutorial/5-relationships-and-hyperlinked-apis/index", "type": "Tutorial", "text": ["At the moment relationships within our API are represented by using primary keys. In this part of the tutorial we'll improve the cohesion and discoverability of our API, by instead using hyperlinking for relationships.", "Right now we have endpoints for 'snippets' and 'users', but we don't have a single entry point to our API. To create one, we'll use a regular function-based view and the @api_view decorator we introduced earlier. In your snippets/views.py add:", "Two things should be noticed here. First, we're using REST framework's reverse function in order to return fully-qualified URLs; second, URL patterns are identified by convenience names that we will declare later on in our snippets/urls.py.", "The other obvious thing that's still missing from our pastebin API is the code highlighting endpoints.", "Unlike all our other API endpoints, we don't want to use JSON, but instead just present an HTML representation. There are two styles of HTML renderer provided by REST framework, one for dealing with HTML rendered using templates, the other for dealing with pre-rendered HTML. The second renderer is the one we'd like to use for this endpoint.", "The other thing we need to consider when creating the code highlight view is that there's no existing concrete generic view that we can use. We're not returning an object instance, but instead a property of an object instance.", "Instead of using a concrete generic view, we'll use the base class for representing instances, and create our own .get() method. In your snippets/views.py add:", "As usual we need to add the new views that we've created in to our URLconf. We'll add a url pattern for our new API root in snippets/urls.py:", "And then add a url pattern for the snippet highlights:", "Dealing with relationships between entities is one of the more challenging aspects of Web API design. There are a number of different ways that we might choose to represent a relationship:", "REST framework supports all of these styles, and can apply them across forward or reverse relationships, or apply them across custom managers such as generic foreign keys.", "In this case we'd like to use a hyperlinked style between entities. In order to do so, we'll modify our serializers to extend HyperlinkedModelSerializer instead of the existing ModelSerializer.", "The HyperlinkedModelSerializer has the following differences from ModelSerializer:", "We can easily re-write our existing serializers to use hyperlinking. In your snippets/serializers.py add:", "Notice that we've also added a new 'highlight' field. This field is of the same type as the url field, except that it points to the 'snippet-highlight' url pattern, instead of the 'snippet-detail' url pattern.", "Because we've included format suffixed URLs such as '.json', we also need to indicate on the highlight field that any format suffixed hyperlinks it returns should use the '.html' suffix.", "If we're going to have a hyperlinked API, we need to make sure we name our URL patterns. Let's take a look at which URL patterns we need to name.", "After adding all those names into our URLconf, our final snippets/urls.py file should look like this:", "The list views for users and code snippets could end up returning quite a lot of instances, so really we'd like to make sure we paginate the results, and allow the API client to step through each of the individual pages.", "We can change the default list style to use pagination, by modifying our tutorial/settings.py file slightly. Add the following setting:", "Note that settings in REST framework are all namespaced into a single dictionary setting, named REST_FRAMEWORK, which helps keep them well separated from your other project settings.", "We could also customize the pagination style if we needed to, but in this case we'll just stick with the default.", "If we open a browser and navigate to the browsable API, you'll find that you can now work your way around the API simply by following links.", "You'll also be able to see the 'highlight' links on the snippet instances, that will take you to the highlighted code HTML representations.", "In part 6 of the tutorial we'll look at how we can use ViewSets and Routers to reduce the amount of code we need to build our API."]}, {"name": "6: ViewSets & Routers", "path": "tutorial/6-viewsets-and-routers/index", "type": "Tutorial", "text": ["REST framework includes an abstraction for dealing with ViewSets, that allows the developer to concentrate on modeling the state and interactions of the API, and leave the URL construction to be handled automatically, based on common conventions.", "ViewSet classes are almost the same thing as View classes, except that they provide operations such as retrieve, or update, and not method handlers such as get or put.", "A ViewSet class is only bound to a set of method handlers at the last moment, when it is instantiated into a set of views, typically by using a Router class which handles the complexities of defining the URL conf for you.", "Let's take our current set of views, and refactor them into view sets.", "First of all let's refactor our UserList and UserDetail views into a single UserViewSet. We can remove the two views, and replace them with a single class:", "Here we've used the ReadOnlyModelViewSet class to automatically provide the default 'read-only' operations. We're still setting the queryset and serializer_class attributes exactly as we did when we were using regular views, but we no longer need to provide the same information to two separate classes.", "Next we're going to replace the SnippetList, SnippetDetail and SnippetHighlight view classes. We can remove the three views, and again replace them with a single class.", "This time we've used the ModelViewSet class in order to get the complete set of default read and write operations.", "Notice that we've also used the @action decorator to create a custom action, named highlight. This decorator can be used to add any custom endpoints that don't fit into the standard create/update/delete style.", "Custom actions which use the @action decorator will respond to GET requests by default. We can use the methods argument if we wanted an action that responded to POST requests.", "The URLs for custom actions by default depend on the method name itself. If you want to change the way url should be constructed, you can include url_path as a decorator keyword argument.", "The handler methods only get bound to the actions when we define the URLConf. To see what's going on under the hood let's first explicitly create a set of views from our ViewSets.", "In the snippets/urls.py file we bind our ViewSet classes into a set of concrete views.", "Notice how we're creating multiple views from each ViewSet class, by binding the http methods to the required action for each view.", "Now that we've bound our resources into concrete views, we can register the views with the URL conf as usual.", "Because we're using ViewSet classes rather than View classes, we actually don't need to design the URL conf ourselves. The conventions for wiring up resources into views and urls can be handled automatically, using a Router class. All we need to do is register the appropriate view sets with a router, and let it do the rest.", "Here's our re-wired snippets/urls.py file.", "Registering the viewsets with the router is similar to providing a urlpattern. We include two arguments - the URL prefix for the views, and the viewset itself.", "The DefaultRouter class we're using also automatically creates the API root view for us, so we can now delete the api_root method from our views module.", "Using viewsets can be a really useful abstraction. It helps ensure that URL conventions will be consistent across your API, minimizes the amount of code you need to write, and allows you to concentrate on the interactions and representations your API provides rather than the specifics of the URL conf.", "That doesn't mean it's always the right approach to take. There's a similar set of trade-offs to consider as when using class-based views instead of function based views. Using viewsets is less explicit than building your views individually."]}, {"name": "AcceptHeaderVersioning", "path": "api-guide/versioning/index#acceptheaderversioning", "type": "Ref: Versioning", "text": ["Versioning an interface is just a \"polite\" way to kill deployed clients.", "\u2014 Roy Fielding.", "API versioning allows you to alter behavior between different clients. REST framework provides for a number of different versioning schemes.", "Versioning is determined by the incoming client request, and may either be based on the request URL, or based on the request headers.", "There are a number of valid approaches to approaching versioning. Non-versioned systems can also be appropriate, particularly if you're engineering for very long-term systems with multiple clients outside of your control.", "When API versioning is enabled, the request.version attribute will contain a string that corresponds to the version requested in the incoming client request.", "By default, versioning is not enabled, and request.version will always return None.", "How you vary the API behavior is up to you, but one example you might typically want is to switch to a different serialization style in a newer version. For example:", "The reverse function included by REST framework ties in with the versioning scheme. You need to make sure to include the current request as a keyword argument, like so.", "The above function will apply any URL transformations appropriate to the request version. For example:", "When using hyperlinked serialization styles together with a URL based versioning scheme make sure to include the request as context to the serializer.", "Doing so will allow any returned URLs to include the appropriate versioning.", "The versioning scheme is defined by the DEFAULT_VERSIONING_CLASS settings key.", "Unless it is explicitly set, the value for DEFAULT_VERSIONING_CLASS will be None. In this case the request.version attribute will always return None.", "You can also set the versioning scheme on an individual view. Typically you won't need to do this, as it makes more sense to have a single versioning scheme used globally. If you do need to do so, use the versioning_class attribute.", "The following settings keys are also used to control versioning:", "You can also set your versioning class plus those three values on a per-view or a per-viewset basis by defining your own versioning scheme and using the default_version, allowed_versions and version_param class variables. For example, if you want to use URLPathVersioning:", "This scheme requires the client to specify the version as part of the media type in the Accept header. The version is included as a media type parameter, that supplements the main media type.", "Here's an example HTTP request using the accept header versioning style.", "In the example request above request.version attribute would return the string '1.0'.", "Versioning based on accept headers is generally considered as best practice, although other styles may be suitable depending on your client requirements.", "Strictly speaking the json media type is not specified as including additional parameters. If you are building a well-specified public API you might consider using a vendor media type. To do so, configure your renderers to use a JSON based renderer with a custom media type:", "Your client requests would now look like this:", "This scheme requires the client to specify the version as part of the URL path.", "Your URL conf must include a pattern that matches the version with a 'version' keyword argument, so that this information is available to the versioning scheme.", "To the client, this scheme is the same as URLPathVersioning. The only difference is how it is configured in your Django application, as it uses URL namespacing, instead of URL keyword arguments.", "With this scheme the request.version attribute is determined based on the namespace that matches the incoming request path.", "In the following example we're giving a set of views two different possible URL prefixes, each under a different namespace:", "Both URLPathVersioning and NamespaceVersioning are reasonable if you just need a simple versioning scheme. The URLPathVersioning approach might be better suitable for small ad-hoc projects, and the NamespaceVersioning is probably easier to manage for larger projects.", "The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.", "For example the following is an HTTP request to the http://v1.example.com/bookings/ URL:", "By default this implementation expects the hostname to match this simple regular expression:", "Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.", "The HostNameVersioning scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as 127.0.0.1. There are various online tutorials on how to access localhost with a custom subdomain which you may find helpful in this case.", "Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.", "This scheme is a simple style that includes the version as a query parameter in the URL. For example:", "To implement a custom versioning scheme, subclass BaseVersioning and override the .determine_version method.", "The following example uses a custom X-API-Version header to determine the requested version.", "If your versioning scheme is based on the request URL, you will also want to alter how versioned URLs are determined. In order to do so you should override the .reverse() method on the class. See the source code for examples.", "versioning.py"]}, {"name": "AdminRenderer", "path": "api-guide/renderers/index#adminrenderer", "type": "Ref: Renderers", "text": ["Before a TemplateResponse instance can be returned to the client, it must be rendered. The rendering process takes the intermediate representation of template and context, and turns it into the final byte stream that can be served to the client.", "\u2014 Django documentation", "REST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.", "The set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.", "The basic process of content negotiation involves examining the request's Accept header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL http://example.com/api/users_count.json might be an endpoint that always returns JSON data.", "For more information see the documentation on content negotiation.", "The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use JSON as the main media type and also include the self describing API.", "You can also set the renderers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "It's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an Accept: */* header, or not including an Accept header at all, then REST framework will select the first renderer in the list to use for the response.", "For example if your API serves JSON responses and the HTML browsable API, you might want to make JSONRenderer your default renderer, in order to send JSON responses to clients that do not specify an Accept header.", "If your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making TemplateHTMLRenderer your default renderer, in order to play nicely with older browsers that send broken accept headers.", "Renders the request data into JSON, using utf-8 encoding.", "Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:", "The client may additionally include an 'indent' media type parameter, in which case the returned JSON will be indented. For example Accept: application/json; indent=4.", "The default JSON encoding style can be altered using the UNICODE_JSON and COMPACT_JSON settings keys.", ".media_type: application/json", ".format: 'json'", ".charset: None", "Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the Response does not need to be serialized. Also, unlike other renderers, you may want to include a template_name argument when creating the Response.", "The TemplateHTMLRenderer will create a RequestContext, using the response.data as the context dict, and determine a template name to use to render the context.", "Note: When used with a view that makes use of a serializer the Response sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the TemplateHTMLRenderer to render it. For example:", "The template name is determined by (in order of preference):", "An example of a view that uses TemplateHTMLRenderer:", "You can use TemplateHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", "If you're building websites that use TemplateHTMLRenderer along with other renderer classes, you should consider listing TemplateHTMLRenderer as the first class in the renderer_classes list, so that it will be prioritised first even for browsers that send poorly formed ACCEPT: headers.", "See the HTML & Forms Topic Page for further examples of TemplateHTMLRenderer usage.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: StaticHTMLRenderer", "A simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.", "An example of a view that uses StaticHTMLRenderer:", "You can use StaticHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: TemplateHTMLRenderer", "Renders data into HTML for the Browsable API:", "", "This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.", ".media_type: text/html", ".format: 'api'", ".charset: utf-8", ".template: 'rest_framework/api.html'", "By default the response content will be rendered with the highest priority renderer apart from BrowsableAPIRenderer. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the get_default_renderer() method. For example:", "Renders data into HTML for an admin-like display:", "", "This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.", "Note that views that have nested or list serializers for their input won't work well with the AdminRenderer, as the HTML forms are unable to properly support them.", "Note: The AdminRenderer is only able to include links to detail pages when a properly configured URL_FIELD_NAME (url by default) attribute is present in the data. For HyperlinkedModelSerializer this will be the case, but for ModelSerializer or plain Serializer classes you'll need to make sure to include the field explicitly. For example here we use models get_absolute_url method:", ".media_type: text/html", ".format: 'admin'", ".charset: utf-8", ".template: 'rest_framework/admin.html'", "Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing <form> tags, a hidden CSRF input or any submit buttons.", "This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the render_form template tag.", "For more information see the HTML & Forms documentation.", ".media_type: text/html", ".format: 'form'", ".charset: utf-8", ".template: 'rest_framework/horizontal/form.html'", "This renderer is used for rendering HTML multipart form data. It is not suitable as a response renderer, but is instead used for creating test requests, using REST framework's test client and test request factory.", ".media_type: multipart/form-data; boundary=BoUnDaRyStRiNg", ".format: 'multipart'", ".charset: utf-8", "To implement a custom renderer, you should override BaseRenderer, set the .media_type and .format properties, and implement the .render(self, data, media_type=None, renderer_context=None) method.", "The method should return a bytestring, which will be used as the body of the HTTP response.", "The arguments passed to the .render() method are:", "The request data, as set by the Response() instantiation.", "Optional. If provided, this is the accepted media type, as determined by the content negotiation stage.", "Depending on the client's Accept: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"application/json; nested=true\".", "Optional. If provided, this is a dictionary of contextual information provided by the view.", "By default this will include the following keys: view, request, response, args, kwargs.", "The following is an example plaintext renderer that will return a response with the data parameter as the content of the response.", "By default renderer classes are assumed to be using the UTF-8 encoding. To use a different encoding, set the charset attribute on the renderer.", "Note that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the Response class, with the charset attribute set on the renderer used to determine the encoding.", "If the renderer returns a bytestring representing raw binary content, you should set a charset value of None, which will ensure the Content-Type header of the response will not have a charset value set.", "In some cases you may also want to set the render_style attribute to 'binary'. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.", "You can do some pretty flexible things using REST framework's renderers. Some examples...", "In some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access request.accepted_renderer to determine the negotiated renderer that will be used for the response.", "For example:", "In some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a media_type value such as image/*, or */*.", "If you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the content_type attribute. For example:", "For the purposes of many Web APIs, simple JSON responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and HATEOAS you'll need to consider the design and usage of your media types in more detail.", "In the words of Roy Fielding, \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".", "For good examples of custom media types, see GitHub's use of a custom application/vnd.github+json media type, and Mike Amundsen's IANA approved application/vnd.collection+json JSON-based hypermedia.", "Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an Http404 or PermissionDenied exception, or a subclass of APIException.", "If you're using either the TemplateHTMLRenderer or the StaticHTMLRenderer and an exception is raised, the behavior is slightly different, and mirrors Django's default handling of error views.", "Exceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.", "Templates will render with a RequestContext which includes the status_code and details keys.", "Note: If DEBUG=True, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST framework JSONP provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Warning: If you require cross-domain AJAX requests, you should generally be using the more modern approach of CORS as an alternative to JSONP. See the CORS documentation for more details.", "The jsonp approach is essentially a browser hack, and is only appropriate for globally readable API endpoints, where GET requests are unauthenticated and do not require any user permissions.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "XLSX is the world's most popular binary spreadsheet format. Tim Allen of The Wharton School maintains drf-renderer-xlsx, which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.", "Install using pip.", "Modify your REST framework settings.", "To avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the Content-Disposition header. If no filename is provided, it will default to export.xlsx. For example:", "Comma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. Mjumbe Poe maintains the djangorestframework-csv package which provides CSV renderer support for REST framework.", "UltraJSON is an optimized C JSON encoder which can give significantly faster JSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now unmaintained drf-ujson-renderer, which implements JSON rendering using the UJSON package.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "Django REST Pandas provides a serializer and renderers that support additional data processing and output via the Pandas DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both .xls and .xlsx), and a number of other formats. It is maintained by S. Andrew Sheppard as part of the wq Project.", "Rest Framework Latex provides a renderer that outputs PDFs using Laulatex. It is maintained by Pebble (S/F Software).", "renderers.py"]}, {"name": "AllowAny", "path": "api-guide/permissions/index#allowany", "type": "Ref: Permissions", "text": ["Authentication or identification by itself is not usually sufficient to gain access to information or code. For that, the entity requesting access must have authorization.", "\u2014 Apple Developer Documentation", "Together with authentication and throttling, permissions determine whether a request should be granted or denied access.", "Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.", "Permissions are used to grant or deny access for different classes of users to different parts of the API.", "The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.", "A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in REST framework.", "Permissions in REST framework are always defined as a list of permission classes.", "Before running the main body of the view each permission in the list is checked. If any permission check fails an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.", "When the permissions checks fail either a \"403 Forbidden\" or a \"401 Unauthorized\" response will be returned, according to the following rules:", "REST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.", "Object level permissions are run by REST framework's generic views when .get_object() is called. As with view level permissions, an exceptions.PermissionDenied exception will be raised if the user is not allowed to act on the given object.", "If you're writing your own views and want to enforce object level permissions, or if you override the get_object method on a generic view, then you'll need to explicitly call the .check_object_permissions(request, obj) method on the view at the point at which you've retrieved the object.", "This will either raise a PermissionDenied or NotAuthenticated exception, or simply return if the view has the appropriate permissions.", "For example:", "Note: With the exception of DjangoObjectPermissions, the provided permission classes in rest_framework.permissions do not implement the methods necessary to check object permissions.", "If you wish to use the provided permission classes in order to check object permissions, you must subclass them and implement the has_object_permission() method described in the Custom permissions section (below).", "For performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.", "Often when you're using object level permissions you'll also want to filter the queryset appropriately, to ensure that users only have visibility onto instances that they are permitted to view.", "Because the get_object() method is not called, object level permissions from the has_object_permission() method are not applied when creating objects. In order to restrict object creation you need to implement the permission check either in your Serializer class or override the perform_create() method of your ViewSet class.", "The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting. For example.", "If not specified, this setting defaults to allowing unrestricted access:", "You can also set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Note: when you set new permission classes via the class attribute or decorators you're telling the view to ignore the default list set in the settings.py file.", "Provided they inherit from rest_framework.permissions.BasePermission, permissions can be composed using standard Python bitwise operators. For example, IsAuthenticatedOrReadOnly could be written:", "Note: it supports & (and), | (or) and ~ (not).", "The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated.", "This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.", "The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.", "This permission is suitable if you want your API to only be accessible to registered users.", "The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.", "This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.", "The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the \"safe\" methods; GET, HEAD or OPTIONS.", "This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.", "This permission class ties into Django's standard django.contrib.auth model permissions. This permission must only be applied to views that have a .queryset property or get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant model permissions assigned.", "The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a view model permission for GET requests.", "To use custom model permissions, override DjangoModelPermissions and set the .perms_map property. Refer to the source code for details.", "Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API.", "This permission class ties into Django's standard object permissions framework that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as django-guardian.", "As with DjangoModelPermissions, this permission must only be applied to views that have a .queryset property or .get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant per-object permissions and relevant model permissions assigned.", "Note that DjangoObjectPermissions does not require the django-guardian package, and should support other object-level backends equally well.", "As with DjangoModelPermissions you can use custom model permissions by overriding DjangoObjectPermissions and setting the .perms_map property. Refer to the source code for details.", "Note: If you need object level view permissions for GET, HEAD and OPTIONS requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the DjangoObjectPermissionsFilter class provided by the djangorestframework-guardian package. It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.", "To implement a custom permission, override BasePermission and implement either, or both, of the following methods:", "The methods should return True if the request should be granted access, and False otherwise.", "If you need to test if a request is a read operation or a write operation, you should check the request method against the constant SAFE_METHODS, which is a tuple containing 'GET', 'OPTIONS' and 'HEAD'. For example:", "Note: The instance-level has_object_permission method will only be called if the view-level has_permission checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call .check_object_permissions(request, obj). If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising PermissionDenied on failure.)", "Custom permissions will raise a PermissionDenied exception if the test fails. To change the error message associated with the exception, implement a message attribute directly on your custom permission. Otherwise the default_detail attribute from PermissionDenied will be used. Similarly, to change the code identifier associated with the exception, implement a code attribute directly on your custom permission - otherwise the default_code attribute from PermissionDenied will be used.", "The following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.", "As well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:", "Note that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling self.check_object_permissions(request, obj) from the view once you have the object instance. This call will raise an appropriate APIException if any object-level permission checks fail, and will otherwise simply return.", "Also note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the filtering documentation for more details.", "REST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.", "The following table lists the access restriction methods and the level of control they offer over which actions.", "* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  ** The get_*() methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.", "The following third party packages are also available.", "The Django REST - Access Policy package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies. ", "The Composed Permissions package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.", "The REST Condition package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.", "The DRY Rest Permissions package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.", "The Django Rest Framework Roles package makes it easier to parameterize your API over multiple types of users.", "The Django REST Framework API Key package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. machines) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.", "The Django Rest Framework Role Filters package provides simple filtering over multiple types of roles.", "The Django Rest Framework PSQ package is an extension that gives support for having action-based permission_classes, serializer_class, and queryset dependent on permission-based rules.", "permissions.py"]}, {"name": "AnonRateThrottle", "path": "api-guide/throttling/index#anonratethrottle", "type": "Ref: Throttling", "text": ["HTTP/1.1 420 Enhance Your Calm", "Twitter API rate limiting response", "Throttling is similar to permissions, in that it determines if a request should be authorized. Throttles indicate a temporary state, and are used to control the rate of requests that clients can make to an API.", "As with permissions, multiple throttles may be used. Your API might have a restrictive throttle for unauthenticated requests, and a less restrictive throttle for authenticated requests.", "Another scenario where you might want to use multiple throttles would be if you need to impose different constraints on different parts of the API, due to some services being particularly resource-intensive.", "Multiple throttles can also be used if you want to impose both burst throttling rates, and sustained throttling rates. For example, you might want to limit a user to a maximum of 60 requests per minute, and 1000 requests per day.", "Throttles do not necessarily only refer to rate-limiting requests. For example a storage service might also need to throttle against bandwidth, and a paid data service might want to throttle against a certain number of a records being accessed.", "As with permissions and authentication, throttling in REST framework is always defined as a list of classes.", "Before running the main body of the view each throttle in the list is checked. If any throttle check fails an exceptions.Throttled exception will be raised, and the main body of the view will not run.", "The default throttling policy may be set globally, using the DEFAULT_THROTTLE_CLASSES and DEFAULT_THROTTLE_RATES settings. For example.", "The rate descriptions used in DEFAULT_THROTTLE_RATES may include second, minute, hour or day as the throttle period.", "You can also set the throttling policy on a per-view or per-viewset basis, using the APIView class-based views.", "If you're using the @api_view decorator with function based views you can use the following decorator.", "It's also possible to set throttle classes for routes that are created using the @action decorator. Throttle classes set in this way will override any viewset level class settings.", "The X-Forwarded-For HTTP header and REMOTE_ADDR WSGI variable are used to uniquely identify client IP addresses for throttling. If the X-Forwarded-For header is present then it will be used, otherwise the value of the REMOTE_ADDR variable from the WSGI environment will be used.", "If you need to strictly identify unique client IP addresses, you'll need to first configure the number of application proxies that the API runs behind by setting the NUM_PROXIES setting. This setting should be an integer of zero or more. If set to non-zero then the client IP will be identified as being the last IP address in the X-Forwarded-For header, once any application proxy IP addresses have first been excluded. If set to zero, then the REMOTE_ADDR value will always be used as the identifying IP address.", "It is important to understand that if you configure the NUM_PROXIES setting, then all clients behind a unique NAT'd gateway will be treated as a single client.", "Further context on how the X-Forwarded-For header works, and identifying a remote client IP can be found here.", "The throttle classes provided by REST framework use Django's cache backend. You should make sure that you've set appropriate cache settings. The default value of LocMemCache backend should be okay for simple setups. See Django's cache documentation for more details.", "If you need to use a cache other than 'default', you can do so by creating a custom throttle class and setting the cache attribute. For example:", "You'll need to remember to also set your custom throttle class in the 'DEFAULT_THROTTLE_CLASSES' settings key, or using the throttle_classes view attribute.", "The AnonRateThrottle will only ever throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.", "The allowed request rate is determined from one of the following (in order of preference).", "AnonRateThrottle is suitable if you want to restrict the rate of requests from unknown sources.", "The UserRateThrottle will throttle users to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.", "The allowed request rate is determined from one of the following (in order of preference).", "An API may have multiple UserRateThrottles in place at the same time. To do so, override UserRateThrottle and set a unique \"scope\" for each class.", "For example, multiple user throttle rates could be implemented by using the following classes...", "...and the following settings.", "UserRateThrottle is suitable if you want simple global rate restrictions per-user.", "The ScopedRateThrottle class can be used to restrict access to specific parts of the API. This throttle will only be applied if the view that is being accessed includes a .throttle_scope property. The unique throttle key will then be formed by concatenating the \"scope\" of the request with the unique user id or IP address.", "The allowed request rate is determined by the DEFAULT_THROTTLE_RATES setting using a key from the request \"scope\".", "For example, given the following views...", "...and the following settings.", "User requests to either ContactListView or ContactDetailView would be restricted to a total of 1000 requests per-day. User requests to UploadView would be restricted to 20 requests per day.", "To create a custom throttle, override BaseThrottle and implement .allow_request(self, request, view). The method should return True if the request should be allowed, and False otherwise.", "Optionally you may also override the .wait() method. If implemented, .wait() should return a recommended number of seconds to wait before attempting the next request, or None. The .wait() method will only be called if .allow_request() has previously returned False.", "If the .wait() method is implemented and the request is throttled, then a Retry-After header will be included in the response.", "The following is an example of a rate throttle, that will randomly throttle 1 in every 10 requests.", "throttling.py"]}, {"name": "API policy settings", "path": "api-guide/settings/index#api-policy-settings", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "APIException", "path": "api-guide/exceptions/index#apiexception", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "Authentication", "path": "api-guide/authentication/index", "type": "API Guide", "text": ["Auth needs to be pluggable.", "\u2014 Jacob Kaplan-Moss, \"REST worst practices\"", "Authentication is the mechanism of associating an incoming request with a set of identifying credentials, such as the user the request came from, or the token that it was signed with. The permission and throttling policies can then use those credentials to determine if the request should be permitted.", "REST framework provides several authentication schemes out of the box, and also allows you to implement custom schemes.", "Authentication always runs at the very start of the view, before the permission and throttling checks occur, and before any other code is allowed to proceed.", "The request.user property will typically be set to an instance of the contrib.auth package's User class.", "The request.auth property is used for any additional authentication information, for example, it may be used to represent an authentication token that the request was signed with.", "Note: Don't forget that authentication by itself won't allow or disallow an incoming request, it simply identifies the credentials that the request was made with.", "For information on how to set up the permission policies for your API please see the permissions documentation.", "The authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set request.user and request.auth using the return value of the first class that successfully authenticates.", "If no class authenticates, request.user will be set to an instance of django.contrib.auth.models.AnonymousUser, and request.auth will be set to None.", "The value of request.user and request.auth for unauthenticated requests can be modified using the UNAUTHENTICATED_USER and UNAUTHENTICATED_TOKEN settings.", "The default authentication schemes may be set globally, using the DEFAULT_AUTHENTICATION_CLASSES setting. For example.", "You can also set the authentication scheme on a per-view or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "When an unauthenticated request is denied permission there are two different error codes that may be appropriate.", "HTTP 401 responses must always include a WWW-Authenticate header, that instructs the client how to authenticate. HTTP 403 responses do not include the WWW-Authenticate header.", "The kind of response that will be used depends on the authentication scheme. Although multiple authentication schemes may be in use, only one scheme may be used to determine the type of response. The first authentication class set on the view is used when determining the type of response.", "Note that when a request may successfully authenticate, but still be denied permission to perform the request, in which case a 403 Permission Denied response will always be used, regardless of the authentication scheme.", "Note that if deploying to Apache using mod_wsgi, the authorization header is not passed through to a WSGI application by default, as it is assumed that authentication will be handled by Apache, rather than at an application level.", "If you are deploying to Apache, and using any non-session based authentication, you will need to explicitly configure mod_wsgi to pass the required headers through to the application. This can be done by specifying the WSGIPassAuthorization directive in the appropriate context and setting it to 'On'.", "This authentication scheme uses HTTP Basic Authentication, signed against a user's username and password. Basic authentication is generally only appropriate for testing.", "If successfully authenticated, BasicAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "Note: If you use BasicAuthentication in production you must ensure that your API is only available over https. You should also ensure that your API clients will always re-request the username and password at login, and will never store those details to persistent storage.", "This authentication scheme uses a simple token-based HTTP Authentication scheme. Token authentication is appropriate for client-server setups, such as native desktop and mobile clients.", "To use the TokenAuthentication scheme you'll need to configure the authentication classes to include TokenAuthentication, and additionally include rest_framework.authtoken in your INSTALLED_APPS setting:", "Note: Make sure to run manage.py migrate after changing your settings. The rest_framework.authtoken app provides Django database migrations.", "You'll also need to create tokens for your users.", "For clients to authenticate, the token key should be included in the Authorization HTTP header. The key should be prefixed by the string literal \"Token\", with whitespace separating the two strings. For example:", "Note: If you want to use a different keyword in the header, such as Bearer, simply subclass TokenAuthentication and set the keyword class variable.", "If successfully authenticated, TokenAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "The curl command line tool may be useful for testing token authenticated APIs. For example:", "Note: If you use TokenAuthentication in production you must ensure that your API is only available over https.", "If you want every user to have an automatically generated Token, you can simply catch the User's post_save signal.", "Note that you'll want to ensure you place this code snippet in an installed models.py module, or some other location that will be imported by Django on startup.", "If you've already created some users, you can generate tokens for all existing users like this:", "When using TokenAuthentication, you may want to provide a mechanism for clients to obtain a token given the username and password. REST framework provides a built-in view to provide this behaviour. To use it, add the obtain_auth_token view to your URLconf:", "Note that the URL part of the pattern can be whatever you want to use.", "The obtain_auth_token view will return a JSON response when valid username and password fields are POSTed to the view using form data or JSON:", "Note that the default obtain_auth_token view explicitly uses JSON requests and responses, rather than using default renderer and parser classes in your settings.", "By default, there are no permissions or throttling applied to the obtain_auth_token view. If you do wish to apply to throttle you'll need to override the view class, and include them using the throttle_classes attribute.", "If you need a customized version of the obtain_auth_token view, you can do so by subclassing the ObtainAuthToken view class, and using that in your url conf instead.", "For example, you may return additional user information beyond the token value:", "And in your urls.py:", "It is also possible to create Tokens manually through the admin interface. In case you are using a large user base, we recommend that you monkey patch the TokenAdmin class customize it to your needs, more specifically by declaring the user field as raw_field.", "your_app/admin.py:", "Since version 3.6.4 it's possible to generate a user token using the following command:", "this command will return the API token for the given user, creating it if it doesn't exist:", "In case you want to regenerate the token (for example if it has been compromised or leaked) you can pass an additional parameter:", "This authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website.", "If successfully authenticated, SessionAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 403 Forbidden response.", "If you're using an AJAX-style API with SessionAuthentication, you'll need to make sure you include a valid CSRF token for any \"unsafe\" HTTP method calls, such as PUT, PATCH, POST or DELETE requests. See the Django CSRF documentation for more details.", "Warning: Always use Django's standard login view when creating login pages. This will ensure your login views are properly protected.", "CSRF validation in REST framework works slightly differently from standard Django due to the need to support both session and non-session based authentication to the same views. This means that only authenticated requests require CSRF tokens, and anonymous requests may be sent without CSRF tokens. This behaviour is not suitable for login views, which should always have CSRF validation applied.", "This authentication scheme allows you to delegate authentication to your web server, which sets the REMOTE_USER environment variable.", "To use it, you must have django.contrib.auth.backends.RemoteUserBackend (or a subclass) in your AUTHENTICATION_BACKENDS setting. By default, RemoteUserBackend creates User objects for usernames that don't already exist. To change this and other behaviour, consult the Django documentation.", "If successfully authenticated, RemoteUserAuthentication provides the following credentials:", "Consult your web server's documentation for information about configuring an authentication method, e.g.:", "To implement a custom authentication scheme, subclass BaseAuthentication and override the .authenticate(self, request) method. The method should return a two-tuple of (user, auth) if authentication succeeds, or None otherwise.", "In some circumstances instead of returning None, you may want to raise an AuthenticationFailed exception from the .authenticate() method.", "Typically the approach you should take is:", "You may also override the .authenticate_header(self, request) method. If implemented, it should return a string that will be used as the value of the WWW-Authenticate header in a HTTP 401 Unauthorized response.", "If the .authenticate_header() method is not overridden, the authentication scheme will return HTTP 403 Forbidden responses when an unauthenticated request is denied access.", "Note: When your custom authenticator is invoked by the request object's .user or .auth properties, you may see an AttributeError re-raised as a WrappedAttributeError. This is necessary to prevent the original exception from being suppressed by the outer property access. Python will not recognize that the AttributeError originates from your custom authenticator and will instead assume that the request object does not have a .user or .auth property. These errors should be fixed or otherwise handled by your authenticator.", "The following example will authenticate any incoming request as the user given by the username in a custom request header named 'X-USERNAME'.", "The following third-party packages are also available.", "The Django OAuth Toolkit package provides OAuth 2.0 support and works with Python 3.4+. The package is maintained by jazzband and uses the excellent OAuthLib. The package is well documented, and well supported and is currently our recommended package for OAuth 2.0 support.", "Install using pip.", "Add the package to your INSTALLED_APPS and modify your REST framework settings.", "For more details see the Django REST framework - Getting started documentation.", "The Django REST framework OAuth package provides both OAuth1 and OAuth2 support for REST framework.", "This package was previously included directly in the REST framework but is now supported and maintained as a third-party package.", "Install the package using pip.", "For details on configuration and usage see the Django REST framework OAuth documentation for authentication and permissions.", "JSON Web Token is a fairly new standard which can be used for token-based authentication. Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn't need to use a database to validate a token. A package for JWT authentication is djangorestframework-simplejwt which provides some features as well as a pluggable token blacklist app.", "The HawkREST library builds on the Mohawk library to let you work with Hawk signed requests and responses in your API. Hawk lets two parties securely communicate with each other using messages signed by a shared key. It is based on HTTP MAC access authentication (which was based on parts of OAuth 1.0).", "HTTP Signature (currently a IETF draft) provides a way to achieve origin authentication and message integrity for HTTP messages. Similar to Amazon's HTTP Signature scheme, used by many of its services, it permits stateless, per-request authentication. Elvio Toccalino maintains the djangorestframework-httpsignature (outdated) package which provides an easy to use HTTP Signature Authentication mechanism. You can use the updated fork version of djangorestframework-httpsignature, which is drf-httpsig.", "Djoser library provides a set of views to handle basic actions such as registration, login, logout, password reset and account activation. The package works with a custom user model and uses token-based authentication. This is ready to use REST implementation of the Django authentication system.", "This library provides a set of REST API endpoints for registration, authentication (including social media authentication), password reset, retrieve and update user details, etc. By having these API endpoints, your client apps such as AngularJS, iOS, Android, and others can communicate to your Django backend site independently via REST APIs for user management.", "There are currently two forks of this project.", "Django-rest-framework-social-oauth2 library provides an easy way to integrate social plugins (facebook, twitter, google, etc.) to your authentication system and an easy oauth2 setup. With this library, you will be able to authenticate users based on external tokens (e.g. facebook access token), convert these tokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to authenticate your users.", "Django-rest-knox library provides models and views to handle token-based authentication in a more secure and extensible way than the built-in TokenAuthentication scheme - with Single Page Applications and Mobile clients in mind. It provides per-client tokens, and views to generate them when provided some other authentication (usually basic authentication), to delete the token (providing a server enforced logout) and to delete all tokens (logs out all clients that a user is logged into).", "drfpasswordless adds (Medium, Square Cash inspired) passwordless support to Django REST Framework's TokenAuthentication scheme. Users log in and sign up with a token sent to a contact point like an email address or a mobile number.", "django-rest-authemail provides a RESTful API interface for user signup and authentication. Email addresses are used for authentication, rather than usernames. API endpoints are available for signup, signup email verification, login, logout, password reset, password reset verification, email change, email change verification, password change, and user detail. A fully functional example project and detailed instructions are included.", "Django-Rest-Durin is built with the idea to have one library that does token auth for multiple Web/CLI/Mobile API clients via one interface but allows different token configuration for each API Client that consumes the API. It provides support for multiple tokens per user via custom models, views, permissions that work with Django-Rest-Framework. The token expiration time can be different per API client and is customizable via the Django Admin Interface.", "More information can be found in the Documentation.", "authentication.py"]}, {"name": "Authentication settings", "path": "api-guide/settings/index#authentication-settings", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "AuthenticationFailed", "path": "api-guide/exceptions/index#authenticationfailed", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "BaseSerializer", "path": "api-guide/serializers/index#baseserializer", "type": "Ref: Serializers", "text": ["Expanding the usefulness of the serializers is something that we would like to address. However, it's not a trivial problem, and it will take some serious design work.", "\u2014 Russell Keith-Magee, Django users group", "Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.", "The serializers in REST framework work very similarly to Django's Form and ModelForm classes. We provide a Serializer class which gives you a powerful, generic way to control the output of your responses, as well as a ModelSerializer class which provides a useful shortcut for creating serializers that deal with model instances and querysets.", "Let's start by creating a simple object we can use for example purposes:", "We'll declare a serializer that we can use to serialize and deserialize data that corresponds to Comment objects.", "Declaring a serializer looks very similar to declaring a form:", "We can now use CommentSerializer to serialize a comment, or list of comments. Again, using the Serializer class looks a lot like using a Form class.", "At this point we've translated the model instance into Python native datatypes. To finalise the serialization process we render the data into json.", "Deserialization is similar. First we parse a stream into Python native datatypes...", "...then we restore those native datatypes into a dictionary of validated data.", "If we want to be able to return complete object instances based on the validated data we need to implement one or both of the .create() and .update() methods. For example:", "If your object instances correspond to Django models you'll also want to ensure that these methods save the object to the database. For example, if Comment was a Django model, the methods might look like this:", "Now when deserializing data, we can call .save() to return an object instance, based on the validated data.", "Calling .save() will either create a new instance, or update an existing instance, depending on if an existing instance was passed when instantiating the serializer class:", "Both the .create() and .update() methods are optional. You can implement either neither, one, or both of them, depending on the use-case for your serializer class.", "Sometimes you'll want your view code to be able to inject additional data at the point of saving the instance. This additional data might include information like the current user, the current time, or anything else that is not part of the request data.", "You can do so by including additional keyword arguments when calling .save(). For example:", "Any additional keyword arguments will be included in the validated_data argument when .create() or .update() are called.", "In some cases the .create() and .update() method names may not be meaningful. For example, in a contact form we may not be creating new instances, but instead sending an email or other message.", "In these cases you might instead choose to override .save() directly, as being more readable and meaningful.", "For example:", "Note that in the case above we're now having to access the serializer .validated_data property directly.", "When deserializing data, you always need to call is_valid() before attempting to access the validated data, or save an object instance. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example:", "Each key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The non_field_errors key may also be present, and will list any general validation errors. The name of the non_field_errors key may be customized using the NON_FIELD_ERRORS_KEY REST framework setting.", "When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items.", "The .is_valid() method takes an optional raise_exception flag that will cause it to raise a serializers.ValidationError exception if there are validation errors.", "These exceptions are automatically dealt with by the default exception handler that REST framework provides, and will return HTTP 400 Bad Request responses by default.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. These are similar to the .clean_<field_name> methods on Django forms.", "These methods take a single argument, which is the field value that requires validation.", "Your validate_<field_name> methods should return the validated value or raise a serializers.ValidationError. For example:", "Note: If your <field_name> is declared on your serializer with the parameter required=False then this validation step will not take place if the field is not included.", "To do any other validation that requires access to multiple fields, add a method called .validate() to your Serializer subclass. This method takes a single argument, which is a dictionary of field values. It should raise a serializers.ValidationError if necessary, or just return the validated values. For example:", "Individual fields on a serializer can include validators, by declaring them on the field instance, for example:", "Serializer classes can also include reusable validators that are applied to the complete set of field data. These validators are included by declaring them on an inner Meta class, like so:", "For more information see the validators documentation.", "When passing an initial object or queryset to a serializer instance, the object will be made available as .instance. If no initial object is passed then the .instance attribute will be None.", "When passing data to a serializer instance, the unmodified data will be made available as .initial_data. If the data keyword argument is not passed then the .initial_data attribute will not exist.", "By default, serializers must be passed values for all required fields or they will raise validation errors. You can use the partial argument in order to allow partial updates.", "The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers.", "The Serializer class is itself a type of Field, and can be used to represent relationships where one object type is nested inside another.", "If a nested representation may optionally accept the None value you should pass the required=False flag to the nested serializer.", "Similarly if a nested representation should be a list of items, you should pass the many=True flag to the nested serializer.", "When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object.", "Similarly, the .validated_data property will include nested data structures.", "If you're supporting writable nested representations you'll need to write .create() or .update() methods that handle saving multiple objects.", "The following example demonstrates how you might handle creating a user with a nested profile object.", "For updates you'll want to think carefully about how to handle updates to relationships. For example if the data for the relationship is None, or not provided, which of the following should occur?", "Here's an example for an .update() method on our previous UserSerializer class.", "Because the behavior of nested creates and updates can be ambiguous, and may require complex dependencies between related models, REST framework 3 requires you to always write these methods explicitly. The default ModelSerializer .create() and .update() methods do not include support for writable nested representations.", "There are however, third-party packages available such as DRF Writable Nested that support automatic writable nested representations.", "An alternative to saving multiple related instances in the serializer is to write custom model manager classes that handle creating the correct instances.", "For example, suppose we wanted to ensure that User instances and Profile instances are always created together as a pair. We might write a custom manager class that looks something like this:", "This manager class now more nicely encapsulates that user instances and profile instances are always created at the same time. Our .create() method on the serializer class can now be re-written to use the new manager method.", "For more details on this approach see the Django documentation on model managers, and this blogpost on using model and manager classes.", "The Serializer class can also handle serializing or deserializing lists of objects.", "To serialize a queryset or list of objects instead of a single object instance, you should pass the many=True flag when instantiating the serializer. You can then pass a queryset or list of objects to be serialized.", "The default behavior for deserializing multiple objects is to support multiple object creation, but not support multiple object updates. For more information on how to support or customize either of these cases, see the ListSerializer documentation below.", "There are some cases where you need to provide extra context to the serializer in addition to the object being serialized. One common case is if you're using a serializer that includes hyperlinked relations, which requires the serializer to have access to the current request so that it can properly generate fully qualified URLs.", "You can provide arbitrary additional context by passing a context argument when instantiating the serializer. For example:", "The context dictionary can be used within any serializer field logic, such as a custom .to_representation() method, by accessing the self.context attribute.", "Often you'll want serializer classes that map closely to Django model definitions.", "The ModelSerializer class provides a shortcut that lets you automatically create a Serializer class with fields that correspond to the Model fields.", "The ModelSerializer class is the same as a regular Serializer class, except that:", "Declaring a ModelSerializer looks like this:", "By default, all the model fields on the class will be mapped to a corresponding serializer fields.", "Any relationships such as foreign keys on the model will be mapped to PrimaryKeyRelatedField. Reverse relationships are not included by default unless explicitly included as specified in the serializer relations documentation.", "Serializer classes generate helpful verbose representation strings, that allow you to fully inspect the state of their fields. This is particularly useful when working with ModelSerializers where you want to determine what set of fields and validators are being automatically created for you.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "If you only want a subset of the default fields to be used in a model serializer, you can do so using fields or exclude options, just as you would with a ModelForm. It is strongly recommended that you explicitly set all fields that should be serialized using the fields attribute. This will make it less likely to result in unintentionally exposing data when your models change.", "For example:", "You can also set the fields attribute to the special value '__all__' to indicate that all fields in the model should be used.", "For example:", "You can set the exclude attribute to a list of fields to be excluded from the serializer.", "For example:", "In the example above, if the Account model had 3 fields account_name, users, and created, this will result in the fields account_name and created to be serialized.", "The names in the fields and exclude attributes will normally map to model fields on the model class.", "Alternatively names in the fields options can map to properties or methods which take no arguments that exist on the model class.", "Since version 3.3.0, it is mandatory to provide one of the attributes fields or exclude.", "The default ModelSerializer uses primary keys for relationships, but you can also easily generate nested representations using the depth option:", "The depth option should be set to an integer value that indicates the depth of relationships that should be traversed before reverting to a flat representation.", "If you want to customize the way the serialization is done you'll need to define the field yourself.", "You can add extra fields to a ModelSerializer or override the default fields by declaring fields on the class, just as you would for a Serializer class.", "Extra fields can correspond to any property or callable on the model.", "You may wish to specify multiple fields as read-only. Instead of adding each field explicitly with the read_only=True attribute, you may use the shortcut Meta option, read_only_fields.", "This option should be a list or tuple of field names, and is declared as follows:", "Model fields which have editable=False set, and AutoField fields will be set to read-only by default, and do not need to be added to the read_only_fields option.", "Note: There is a special-case where a read-only field is part of a unique_together constraint at the model level. In this case the field is required by the serializer class in order to validate the constraint, but should also not be editable by the user.", "The right way to deal with this is to specify the field explicitly on the serializer, providing both the read_only=True and default=\u2026 keyword arguments.", "One example of this is a read-only relation to the currently authenticated User which is unique_together with another identifier. In this case you would declare the user field like so:", "Please review the Validators Documentation for details on the UniqueTogetherValidator and CurrentUserDefault classes.", "There is also a shortcut allowing you to specify arbitrary additional keyword arguments on fields, using the extra_kwargs option. As in the case of read_only_fields, this means you do not need to explicitly declare the field on the serializer.", "This option is a dictionary, mapping field names to a dictionary of keyword arguments. For example:", "Please keep in mind that, if the field has already been explicitly declared on the serializer class, then the extra_kwargs option will be ignored.", "When serializing model instances, there are a number of different ways you might choose to represent relationships. The default representation for ModelSerializer is to use the primary keys of the related instances.", "Alternative representations include serializing using hyperlinks, serializing complete nested representations, or serializing with a custom representation.", "For full details see the serializer relations documentation.", "The ModelSerializer class also exposes an API that you can override in order to alter how serializer fields are automatically determined when instantiating the serializer.", "Normally if a ModelSerializer does not generate the fields you need by default then you should either add them to the class explicitly, or simply use a regular Serializer class instead. However in some cases you may want to create a new base class that defines how the serializer fields are created for any given model.", "A mapping of Django model fields to REST framework serializer fields. You can override this mapping to alter the default serializer fields that should be used for each model field.", "This property should be the serializer field class, that is used for relational fields by default.", "For ModelSerializer this defaults to PrimaryKeyRelatedField.", "For HyperlinkedModelSerializer this defaults to serializers.HyperlinkedRelatedField.", "The serializer field class that should be used for any url field on the serializer.", "Defaults to serializers.HyperlinkedIdentityField", "The serializer field class that should be used for any choice fields on the serializer.", "Defaults to serializers.ChoiceField", "The following methods are called to determine the class and keyword arguments for each field that should be automatically included on the serializer. Each of these methods should return a two tuple of (field_class, field_kwargs).", "Called to generate a serializer field that maps to a standard model field.", "The default implementation returns a serializer class based on the serializer_field_mapping attribute.", "Called to generate a serializer field that maps to a relational model field.", "The default implementation returns a serializer class based on the serializer_related_field attribute.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a relational model field, when the depth option has been set.", "The default implementation dynamically creates a nested serializer class based on either ModelSerializer or HyperlinkedModelSerializer.", "The nested_depth will be the value of the depth option, minus one.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a property or zero-argument method on the model class.", "The default implementation returns a ReadOnlyField class.", "Called to generate a serializer field for the serializer's own url field. The default implementation returns a HyperlinkedIdentityField class.", "Called when the field name did not map to any model field or model property. The default implementation raises an error, although subclasses may customize this behavior.", "The HyperlinkedModelSerializer class is similar to the ModelSerializer class except that it uses hyperlinks to represent relationships, rather than primary keys.", "By default the serializer will include a url field instead of a primary key field.", "The url field will be represented using a HyperlinkedIdentityField serializer field, and any relationships on the model will be represented using a HyperlinkedRelatedField serializer field.", "You can explicitly include the primary key by adding it to the fields option, for example:", "When instantiating a HyperlinkedModelSerializer you must include the current request in the serializer context, for example:", "Doing so will ensure that the hyperlinks can include an appropriate hostname, so that the resulting representation uses fully qualified URLs, such as:", "Rather than relative URLs, such as:", "If you do want to use relative URLs, you should explicitly pass {'request': None} in the serializer context.", "There needs to be a way of determining which views should be used for hyperlinking to model instances.", "By default hyperlinks are expected to correspond to a view name that matches the style '{model_name}-detail', and looks up the instance by a pk keyword argument.", "You can override a URL field view name and lookup field by using either, or both of, the view_name and lookup_field options in the extra_kwargs setting, like so:", "Alternatively you can set the fields on the serializer explicitly. For example:", "Tip: Properly matching together hyperlinked representations and your URL conf can sometimes be a bit fiddly. Printing the repr of a HyperlinkedModelSerializer instance is a particularly useful way to inspect exactly which view names and lookup fields the relationships are expected to map too.", "The name of the URL field defaults to 'url'. You can override this globally, by using the URL_FIELD_NAME setting.", "The ListSerializer class provides the behavior for serializing and validating multiple objects at once. You won't typically need to use ListSerializer directly, but should instead simply pass many=True when instantiating a serializer.", "When a serializer is instantiated and many=True is passed, a ListSerializer instance will be created. The serializer class then becomes a child of the parent ListSerializer", "The following argument can also be passed to a ListSerializer field or a serializer that is passed many=True:", "This is True by default, but can be set to False if you want to disallow empty lists as valid input.", "There are a few use cases when you might want to customize the ListSerializer behavior. For example:", "For these cases you can modify the class that is used when many=True is passed, by using the list_serializer_class option on the serializer Meta class.", "For example:", "The default implementation for multiple object creation is to simply call .create() for each item in the list. If you want to customize this behavior, you'll need to customize the .create() method on ListSerializer class that is used when many=True is passed.", "For example:", "By default the ListSerializer class does not support multiple updates. This is because the behavior that should be expected for insertions and deletions is ambiguous.", "To support multiple updates you'll need to do so explicitly. When writing your multiple update code make sure to keep the following in mind:", "You will need to add an explicit id field to the instance serializer. The default implicitly-generated id field is marked as read_only. This causes it to be removed on updates. Once you declare it explicitly, it will be available in the list serializer's update method.", "Here's an example of how you might choose to implement multiple updates:", "It is possible that a third party package may be included alongside the 3.1 release that provides some automatic support for multiple update operations, similar to the allow_add_remove behavior that was present in REST framework 2.", "When a serializer with many=True is instantiated, we need to determine which arguments and keyword arguments should be passed to the .__init__() method for both the child Serializer class, and for the parent ListSerializer class.", "The default implementation is to pass all arguments to both classes, except for validators, and any custom keyword arguments, both of which are assumed to be intended for the child serializer class.", "Occasionally you might need to explicitly specify how the child and parent classes should be instantiated when many=True is passed. You can do so by using the many_init class method.", "BaseSerializer class that can be used to easily support alternative serialization and deserialization styles.", "This class implements the same basic API as the Serializer class:", "There are four methods that can be overridden, depending on what functionality you want the serializer class to support:", "Because this class provides the same interface as the Serializer class, you can use it with the existing generic class-based views exactly as you would for a regular Serializer or ModelSerializer.", "The only difference you'll notice when doing so is the BaseSerializer classes will not generate HTML forms in the browsable API. This is because the data they return does not include all the field information that would allow each field to be rendered into a suitable HTML input.", "To implement a read-only serializer using the BaseSerializer class, we just need to override the .to_representation() method. Let's take a look at an example using a simple Django model:", "It's simple to create a read-only serializer for converting HighScore instances into primitive data types.", "We can now use this class to serialize single HighScore instances:", "Or use it to serialize multiple instances:", "To create a read-write serializer we first need to implement a .to_internal_value() method. This method returns the validated values that will be used to construct the object instance, and may raise a serializers.ValidationError if the supplied data is in an incorrect format.", "Once you've implemented .to_internal_value(), the basic validation API will be available on the serializer, and you will be able to use .is_valid(), .validated_data and .errors.", "If you want to also support .save() you'll need to also implement either or both of the .create() and .update() methods.", "Here's a complete example of our previous HighScoreSerializer, that's been updated to support both read and write operations.", "The BaseSerializer class is also useful if you want to implement new generic serializer classes for dealing with particular serialization styles, or for integrating with alternative storage backends.", "The following class is an example of a generic serializer that can handle coercing arbitrary objects into primitive representations.", "If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the .to_representation() or .to_internal_value() methods.", "Some reasons this might be useful include...", "The signatures for these methods are as follows:", "Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API.", "May be overridden in order to modify the representation style. For example:", "Takes the unvalidated incoming data as input and should return the validated data that will be made available as serializer.validated_data. The return value will also be passed to the .create() or .update() methods if .save() is called on the serializer class.", "If any of the validation fails, then the method should raise a serializers.ValidationError(errors). The errors argument should be a dictionary mapping field names (or settings.NON_FIELD_ERRORS_KEY) to a list of error messages. If you don't need to alter deserialization behavior and instead want to provide object-level validation, it's recommended that you instead override the .validate() method.", "The data argument passed to this method will normally be the value of request.data, so the datatype it provides will depend on the parser classes you have configured for your API.", "Similar to Django forms, you can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example,", "Like Django's Model and ModelForm classes, the inner Meta class on serializers does not implicitly inherit from it's parents' inner Meta classes. If you want the Meta class to inherit from a parent class you must do so explicitly. For example:", "Typically we would recommend not using inheritance on inner Meta classes, but instead declaring all options explicitly.", "Additionally, the following caveats apply to serializer inheritance:", "It\u2019s possible to declaratively remove a Field inherited from a parent class by setting the name to be None on the subclass.", "However, you can only use this technique to opt out from a field defined declaratively by a parent class; it won\u2019t prevent the ModelSerializer from generating a default field. To opt-out from default fields, see Specifying which fields to include.", "Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the .fields attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer.", "Modifying the fields argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.", "For example, if you wanted to be able to set which fields should be used by a serializer at the point of initializing it, you could create a serializer class like so:", "This would then allow you to do the following:", "REST framework 2 provided an API to allow developers to override how a ModelSerializer class would automatically generate the default set of fields.", "This API included the .get_field(), .get_pk_field() and other methods.", "Because the serializers have been fundamentally redesigned with 3.0 this API no longer exists. You can still modify the fields that get created but you'll need to refer to the source code, and be aware that if the changes you make are against private bits of API then they may be subject to change.", "The following third party packages are also available.", "The django-rest-marshmallow package provides an alternative implementation for serializers, using the python marshmallow library. It exposes the same API as the REST framework serializers, and can be used as a drop-in replacement in some use-cases.", "The serpy package is an alternative implementation for serializers that is built for speed. Serpy serializes complex datatypes to simple native types. The native types can be easily converted to JSON or any other format needed.", "The django-rest-framework-mongoengine package provides a MongoEngineModelSerializer serializer class that supports using MongoDB as the storage layer for Django REST framework.", "The django-rest-framework-gis package provides a GeoFeatureModelSerializer serializer class that supports GeoJSON both for read and write operations.", "The django-rest-framework-hstore package provides an HStoreSerializer to support django-hstore DictionaryField model field and its schema-mode feature.", "The dynamic-rest package extends the ModelSerializer and ModelViewSet interfaces, adding API query parameters for filtering, sorting, and including / excluding all fields and relationships defined by your serializers.", "The drf-dynamic-fields package provides a mixin to dynamically limit the fields per serializer to a subset specified by an URL parameter.", "The drf-flex-fields package extends the ModelSerializer and ModelViewSet to provide commonly used functionality for dynamically setting fields and expanding primitive fields to nested models, both from URL parameters and your serializer class definitions.", "The django-rest-framework-serializer-extensions package provides a collection of tools to DRY up your serializers, by allowing fields to be defined on a per-view/request basis. Fields can be whitelisted, blacklisted and child serializers can be optionally expanded.", "The html-json-forms package provides an algorithm and serializer for processing <form> submissions per the (inactive) HTML JSON Form specification. The serializer facilitates processing of arbitrarily nested JSON structures within HTML. For example, <input name=\"items[0][id]\" value=\"5\"> will be interpreted as {\"items\": [{\"id\": \"5\"}]}.", "DRF-Base64 provides a set of field and model serializers that handles the upload of base64-encoded files.", "djangorestframework-queryfields allows API clients to specify which fields will be sent in the response via inclusion/exclusion query parameters.", "The drf-writable-nested package provides writable nested model serializer which allows to create/update models with nested related data.", "The drf-encrypt-content package helps you encrypt your data, serialized through ModelSerializer. It also contains some helper functions. Which helps you to encrypt your data. ", "serializers.py"]}, {"name": "BasicAuthentication", "path": "api-guide/authentication/index#basicauthentication", "type": "Ref: Authentication", "text": ["Auth needs to be pluggable.", "\u2014 Jacob Kaplan-Moss, \"REST worst practices\"", "Authentication is the mechanism of associating an incoming request with a set of identifying credentials, such as the user the request came from, or the token that it was signed with. The permission and throttling policies can then use those credentials to determine if the request should be permitted.", "REST framework provides several authentication schemes out of the box, and also allows you to implement custom schemes.", "Authentication always runs at the very start of the view, before the permission and throttling checks occur, and before any other code is allowed to proceed.", "The request.user property will typically be set to an instance of the contrib.auth package's User class.", "The request.auth property is used for any additional authentication information, for example, it may be used to represent an authentication token that the request was signed with.", "Note: Don't forget that authentication by itself won't allow or disallow an incoming request, it simply identifies the credentials that the request was made with.", "For information on how to set up the permission policies for your API please see the permissions documentation.", "The authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set request.user and request.auth using the return value of the first class that successfully authenticates.", "If no class authenticates, request.user will be set to an instance of django.contrib.auth.models.AnonymousUser, and request.auth will be set to None.", "The value of request.user and request.auth for unauthenticated requests can be modified using the UNAUTHENTICATED_USER and UNAUTHENTICATED_TOKEN settings.", "The default authentication schemes may be set globally, using the DEFAULT_AUTHENTICATION_CLASSES setting. For example.", "You can also set the authentication scheme on a per-view or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "When an unauthenticated request is denied permission there are two different error codes that may be appropriate.", "HTTP 401 responses must always include a WWW-Authenticate header, that instructs the client how to authenticate. HTTP 403 responses do not include the WWW-Authenticate header.", "The kind of response that will be used depends on the authentication scheme. Although multiple authentication schemes may be in use, only one scheme may be used to determine the type of response. The first authentication class set on the view is used when determining the type of response.", "Note that when a request may successfully authenticate, but still be denied permission to perform the request, in which case a 403 Permission Denied response will always be used, regardless of the authentication scheme.", "Note that if deploying to Apache using mod_wsgi, the authorization header is not passed through to a WSGI application by default, as it is assumed that authentication will be handled by Apache, rather than at an application level.", "If you are deploying to Apache, and using any non-session based authentication, you will need to explicitly configure mod_wsgi to pass the required headers through to the application. This can be done by specifying the WSGIPassAuthorization directive in the appropriate context and setting it to 'On'.", "This authentication scheme uses HTTP Basic Authentication, signed against a user's username and password. Basic authentication is generally only appropriate for testing.", "If successfully authenticated, BasicAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "Note: If you use BasicAuthentication in production you must ensure that your API is only available over https. You should also ensure that your API clients will always re-request the username and password at login, and will never store those details to persistent storage.", "This authentication scheme uses a simple token-based HTTP Authentication scheme. Token authentication is appropriate for client-server setups, such as native desktop and mobile clients.", "To use the TokenAuthentication scheme you'll need to configure the authentication classes to include TokenAuthentication, and additionally include rest_framework.authtoken in your INSTALLED_APPS setting:", "Note: Make sure to run manage.py migrate after changing your settings. The rest_framework.authtoken app provides Django database migrations.", "You'll also need to create tokens for your users.", "For clients to authenticate, the token key should be included in the Authorization HTTP header. The key should be prefixed by the string literal \"Token\", with whitespace separating the two strings. For example:", "Note: If you want to use a different keyword in the header, such as Bearer, simply subclass TokenAuthentication and set the keyword class variable.", "If successfully authenticated, TokenAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "The curl command line tool may be useful for testing token authenticated APIs. For example:", "Note: If you use TokenAuthentication in production you must ensure that your API is only available over https.", "If you want every user to have an automatically generated Token, you can simply catch the User's post_save signal.", "Note that you'll want to ensure you place this code snippet in an installed models.py module, or some other location that will be imported by Django on startup.", "If you've already created some users, you can generate tokens for all existing users like this:", "When using TokenAuthentication, you may want to provide a mechanism for clients to obtain a token given the username and password. REST framework provides a built-in view to provide this behaviour. To use it, add the obtain_auth_token view to your URLconf:", "Note that the URL part of the pattern can be whatever you want to use.", "The obtain_auth_token view will return a JSON response when valid username and password fields are POSTed to the view using form data or JSON:", "Note that the default obtain_auth_token view explicitly uses JSON requests and responses, rather than using default renderer and parser classes in your settings.", "By default, there are no permissions or throttling applied to the obtain_auth_token view. If you do wish to apply to throttle you'll need to override the view class, and include them using the throttle_classes attribute.", "If you need a customized version of the obtain_auth_token view, you can do so by subclassing the ObtainAuthToken view class, and using that in your url conf instead.", "For example, you may return additional user information beyond the token value:", "And in your urls.py:", "It is also possible to create Tokens manually through the admin interface. In case you are using a large user base, we recommend that you monkey patch the TokenAdmin class customize it to your needs, more specifically by declaring the user field as raw_field.", "your_app/admin.py:", "Since version 3.6.4 it's possible to generate a user token using the following command:", "this command will return the API token for the given user, creating it if it doesn't exist:", "In case you want to regenerate the token (for example if it has been compromised or leaked) you can pass an additional parameter:", "This authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website.", "If successfully authenticated, SessionAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 403 Forbidden response.", "If you're using an AJAX-style API with SessionAuthentication, you'll need to make sure you include a valid CSRF token for any \"unsafe\" HTTP method calls, such as PUT, PATCH, POST or DELETE requests. See the Django CSRF documentation for more details.", "Warning: Always use Django's standard login view when creating login pages. This will ensure your login views are properly protected.", "CSRF validation in REST framework works slightly differently from standard Django due to the need to support both session and non-session based authentication to the same views. This means that only authenticated requests require CSRF tokens, and anonymous requests may be sent without CSRF tokens. This behaviour is not suitable for login views, which should always have CSRF validation applied.", "This authentication scheme allows you to delegate authentication to your web server, which sets the REMOTE_USER environment variable.", "To use it, you must have django.contrib.auth.backends.RemoteUserBackend (or a subclass) in your AUTHENTICATION_BACKENDS setting. By default, RemoteUserBackend creates User objects for usernames that don't already exist. To change this and other behaviour, consult the Django documentation.", "If successfully authenticated, RemoteUserAuthentication provides the following credentials:", "Consult your web server's documentation for information about configuring an authentication method, e.g.:", "To implement a custom authentication scheme, subclass BaseAuthentication and override the .authenticate(self, request) method. The method should return a two-tuple of (user, auth) if authentication succeeds, or None otherwise.", "In some circumstances instead of returning None, you may want to raise an AuthenticationFailed exception from the .authenticate() method.", "Typically the approach you should take is:", "You may also override the .authenticate_header(self, request) method. If implemented, it should return a string that will be used as the value of the WWW-Authenticate header in a HTTP 401 Unauthorized response.", "If the .authenticate_header() method is not overridden, the authentication scheme will return HTTP 403 Forbidden responses when an unauthenticated request is denied access.", "Note: When your custom authenticator is invoked by the request object's .user or .auth properties, you may see an AttributeError re-raised as a WrappedAttributeError. This is necessary to prevent the original exception from being suppressed by the outer property access. Python will not recognize that the AttributeError originates from your custom authenticator and will instead assume that the request object does not have a .user or .auth property. These errors should be fixed or otherwise handled by your authenticator.", "The following example will authenticate any incoming request as the user given by the username in a custom request header named 'X-USERNAME'.", "The following third-party packages are also available.", "The Django OAuth Toolkit package provides OAuth 2.0 support and works with Python 3.4+. The package is maintained by jazzband and uses the excellent OAuthLib. The package is well documented, and well supported and is currently our recommended package for OAuth 2.0 support.", "Install using pip.", "Add the package to your INSTALLED_APPS and modify your REST framework settings.", "For more details see the Django REST framework - Getting started documentation.", "The Django REST framework OAuth package provides both OAuth1 and OAuth2 support for REST framework.", "This package was previously included directly in the REST framework but is now supported and maintained as a third-party package.", "Install the package using pip.", "For details on configuration and usage see the Django REST framework OAuth documentation for authentication and permissions.", "JSON Web Token is a fairly new standard which can be used for token-based authentication. Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn't need to use a database to validate a token. A package for JWT authentication is djangorestframework-simplejwt which provides some features as well as a pluggable token blacklist app.", "The HawkREST library builds on the Mohawk library to let you work with Hawk signed requests and responses in your API. Hawk lets two parties securely communicate with each other using messages signed by a shared key. It is based on HTTP MAC access authentication (which was based on parts of OAuth 1.0).", "HTTP Signature (currently a IETF draft) provides a way to achieve origin authentication and message integrity for HTTP messages. Similar to Amazon's HTTP Signature scheme, used by many of its services, it permits stateless, per-request authentication. Elvio Toccalino maintains the djangorestframework-httpsignature (outdated) package which provides an easy to use HTTP Signature Authentication mechanism. You can use the updated fork version of djangorestframework-httpsignature, which is drf-httpsig.", "Djoser library provides a set of views to handle basic actions such as registration, login, logout, password reset and account activation. The package works with a custom user model and uses token-based authentication. This is ready to use REST implementation of the Django authentication system.", "This library provides a set of REST API endpoints for registration, authentication (including social media authentication), password reset, retrieve and update user details, etc. By having these API endpoints, your client apps such as AngularJS, iOS, Android, and others can communicate to your Django backend site independently via REST APIs for user management.", "There are currently two forks of this project.", "Django-rest-framework-social-oauth2 library provides an easy way to integrate social plugins (facebook, twitter, google, etc.) to your authentication system and an easy oauth2 setup. With this library, you will be able to authenticate users based on external tokens (e.g. facebook access token), convert these tokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to authenticate your users.", "Django-rest-knox library provides models and views to handle token-based authentication in a more secure and extensible way than the built-in TokenAuthentication scheme - with Single Page Applications and Mobile clients in mind. It provides per-client tokens, and views to generate them when provided some other authentication (usually basic authentication), to delete the token (providing a server enforced logout) and to delete all tokens (logs out all clients that a user is logged into).", "drfpasswordless adds (Medium, Square Cash inspired) passwordless support to Django REST Framework's TokenAuthentication scheme. Users log in and sign up with a token sent to a contact point like an email address or a mobile number.", "django-rest-authemail provides a RESTful API interface for user signup and authentication. Email addresses are used for authentication, rather than usernames. API endpoints are available for signup, signup email verification, login, logout, password reset, password reset verification, email change, email change verification, password change, and user detail. A fully functional example project and detailed instructions are included.", "Django-Rest-Durin is built with the idea to have one library that does token auth for multiple Web/CLI/Mobile API clients via one interface but allows different token configuration for each API Client that consumes the API. It provides support for multiple tokens per user via custom models, views, permissions that work with Django-Rest-Framework. The token expiration time can be different per API client and is customizable via the Django Admin Interface.", "More information can be found in the Documentation.", "authentication.py"]}, {"name": "BooleanField", "path": "api-guide/fields/index#booleanfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "BrowsableAPIRenderer", "path": "api-guide/renderers/index#browsableapirenderer", "type": "Ref: Renderers", "text": ["Before a TemplateResponse instance can be returned to the client, it must be rendered. The rendering process takes the intermediate representation of template and context, and turns it into the final byte stream that can be served to the client.", "\u2014 Django documentation", "REST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.", "The set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.", "The basic process of content negotiation involves examining the request's Accept header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL http://example.com/api/users_count.json might be an endpoint that always returns JSON data.", "For more information see the documentation on content negotiation.", "The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use JSON as the main media type and also include the self describing API.", "You can also set the renderers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "It's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an Accept: */* header, or not including an Accept header at all, then REST framework will select the first renderer in the list to use for the response.", "For example if your API serves JSON responses and the HTML browsable API, you might want to make JSONRenderer your default renderer, in order to send JSON responses to clients that do not specify an Accept header.", "If your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making TemplateHTMLRenderer your default renderer, in order to play nicely with older browsers that send broken accept headers.", "Renders the request data into JSON, using utf-8 encoding.", "Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:", "The client may additionally include an 'indent' media type parameter, in which case the returned JSON will be indented. For example Accept: application/json; indent=4.", "The default JSON encoding style can be altered using the UNICODE_JSON and COMPACT_JSON settings keys.", ".media_type: application/json", ".format: 'json'", ".charset: None", "Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the Response does not need to be serialized. Also, unlike other renderers, you may want to include a template_name argument when creating the Response.", "The TemplateHTMLRenderer will create a RequestContext, using the response.data as the context dict, and determine a template name to use to render the context.", "Note: When used with a view that makes use of a serializer the Response sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the TemplateHTMLRenderer to render it. For example:", "The template name is determined by (in order of preference):", "An example of a view that uses TemplateHTMLRenderer:", "You can use TemplateHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", "If you're building websites that use TemplateHTMLRenderer along with other renderer classes, you should consider listing TemplateHTMLRenderer as the first class in the renderer_classes list, so that it will be prioritised first even for browsers that send poorly formed ACCEPT: headers.", "See the HTML & Forms Topic Page for further examples of TemplateHTMLRenderer usage.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: StaticHTMLRenderer", "A simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.", "An example of a view that uses StaticHTMLRenderer:", "You can use StaticHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: TemplateHTMLRenderer", "Renders data into HTML for the Browsable API:", "", "This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.", ".media_type: text/html", ".format: 'api'", ".charset: utf-8", ".template: 'rest_framework/api.html'", "By default the response content will be rendered with the highest priority renderer apart from BrowsableAPIRenderer. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the get_default_renderer() method. For example:", "Renders data into HTML for an admin-like display:", "", "This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.", "Note that views that have nested or list serializers for their input won't work well with the AdminRenderer, as the HTML forms are unable to properly support them.", "Note: The AdminRenderer is only able to include links to detail pages when a properly configured URL_FIELD_NAME (url by default) attribute is present in the data. For HyperlinkedModelSerializer this will be the case, but for ModelSerializer or plain Serializer classes you'll need to make sure to include the field explicitly. For example here we use models get_absolute_url method:", ".media_type: text/html", ".format: 'admin'", ".charset: utf-8", ".template: 'rest_framework/admin.html'", "Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing <form> tags, a hidden CSRF input or any submit buttons.", "This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the render_form template tag.", "For more information see the HTML & Forms documentation.", ".media_type: text/html", ".format: 'form'", ".charset: utf-8", ".template: 'rest_framework/horizontal/form.html'", "This renderer is used for rendering HTML multipart form data. It is not suitable as a response renderer, but is instead used for creating test requests, using REST framework's test client and test request factory.", ".media_type: multipart/form-data; boundary=BoUnDaRyStRiNg", ".format: 'multipart'", ".charset: utf-8", "To implement a custom renderer, you should override BaseRenderer, set the .media_type and .format properties, and implement the .render(self, data, media_type=None, renderer_context=None) method.", "The method should return a bytestring, which will be used as the body of the HTTP response.", "The arguments passed to the .render() method are:", "The request data, as set by the Response() instantiation.", "Optional. If provided, this is the accepted media type, as determined by the content negotiation stage.", "Depending on the client's Accept: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"application/json; nested=true\".", "Optional. If provided, this is a dictionary of contextual information provided by the view.", "By default this will include the following keys: view, request, response, args, kwargs.", "The following is an example plaintext renderer that will return a response with the data parameter as the content of the response.", "By default renderer classes are assumed to be using the UTF-8 encoding. To use a different encoding, set the charset attribute on the renderer.", "Note that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the Response class, with the charset attribute set on the renderer used to determine the encoding.", "If the renderer returns a bytestring representing raw binary content, you should set a charset value of None, which will ensure the Content-Type header of the response will not have a charset value set.", "In some cases you may also want to set the render_style attribute to 'binary'. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.", "You can do some pretty flexible things using REST framework's renderers. Some examples...", "In some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access request.accepted_renderer to determine the negotiated renderer that will be used for the response.", "For example:", "In some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a media_type value such as image/*, or */*.", "If you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the content_type attribute. For example:", "For the purposes of many Web APIs, simple JSON responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and HATEOAS you'll need to consider the design and usage of your media types in more detail.", "In the words of Roy Fielding, \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".", "For good examples of custom media types, see GitHub's use of a custom application/vnd.github+json media type, and Mike Amundsen's IANA approved application/vnd.collection+json JSON-based hypermedia.", "Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an Http404 or PermissionDenied exception, or a subclass of APIException.", "If you're using either the TemplateHTMLRenderer or the StaticHTMLRenderer and an exception is raised, the behavior is slightly different, and mirrors Django's default handling of error views.", "Exceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.", "Templates will render with a RequestContext which includes the status_code and details keys.", "Note: If DEBUG=True, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST framework JSONP provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Warning: If you require cross-domain AJAX requests, you should generally be using the more modern approach of CORS as an alternative to JSONP. See the CORS documentation for more details.", "The jsonp approach is essentially a browser hack, and is only appropriate for globally readable API endpoints, where GET requests are unauthenticated and do not require any user permissions.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "XLSX is the world's most popular binary spreadsheet format. Tim Allen of The Wharton School maintains drf-renderer-xlsx, which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.", "Install using pip.", "Modify your REST framework settings.", "To avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the Content-Disposition header. If no filename is provided, it will default to export.xlsx. For example:", "Comma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. Mjumbe Poe maintains the djangorestframework-csv package which provides CSV renderer support for REST framework.", "UltraJSON is an optimized C JSON encoder which can give significantly faster JSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now unmaintained drf-ujson-renderer, which implements JSON rendering using the UJSON package.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "Django REST Pandas provides a serializer and renderers that support additional data processing and output via the Pandas DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both .xls and .xlsx), and a number of other formats. It is maintained by S. Andrew Sheppard as part of the wq Project.", "Rest Framework Latex provides a renderer that outputs PDFs using Laulatex. It is maintained by Pebble (S/F Software).", "renderers.py"]}, {"name": "Caching", "path": "api-guide/caching/index", "type": "API Guide", "text": ["A certain woman had a very sharp consciousness but almost no memory ... She remembered enough to work, and she worked hard. - Lydia Davis", "Caching in REST Framework works well with the cache utilities provided in Django.", "Django provides a method_decorator to use decorators with class based views. This can be used with other cache decorators such as cache_page, vary_on_cookie and vary_on_headers.", "NOTE: The cache_page decorator only caches the GET and HEAD responses with status 200."]}, {"name": "CharField", "path": "api-guide/fields/index#charfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "ChoiceField", "path": "api-guide/fields/index#choicefield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "Class-based Views", "path": "api-guide/views/index", "type": "API Guide", "text": ["Django's class-based views are a welcome departure from the old-style views.", "\u2014 Reinout van Rees", "REST framework provides an APIView class, which subclasses Django's View class.", "APIView classes are different from regular View classes in the following ways:", "Using the APIView class is pretty much the same as using a regular View class, as usual, the incoming request is dispatched to an appropriate handler method such as .get() or .post(). Additionally, a number of attributes may be set on the class that control various aspects of the API policy.", "For example:", "Note: The full methods, attributes on, and relations between Django REST Framework's APIView, GenericAPIView, various Mixins, and Viewsets can be initially complex. In addition to the documentation here, the Classy Django REST Framework resource provides a browsable reference, with full methods and attributes, for each of Django REST Framework's class-based views.", "The following attributes control the pluggable aspects of API views.", "The following methods are used by REST framework to instantiate the various pluggable API policies. You won't typically need to override these methods.", "The following methods are called before dispatching to the handler method.", "The following methods are called directly by the view's .dispatch() method. These perform any actions that need to occur before or after calling the handler methods such as .get(), .post(), put(), patch() and .delete().", "Performs any actions that need to occur before the handler method gets called. This method is used to enforce permissions and throttling, and perform content negotiation.", "You won't typically need to override this method.", "Any exception thrown by the handler method will be passed to this method, which either returns a Response instance, or re-raises the exception.", "The default implementation handles any subclass of rest_framework.exceptions.APIException, as well as Django's Http404 and PermissionDenied exceptions, and returns an appropriate error response.", "If you need to customize the error responses your API returns you should subclass this method.", "Ensures that the request object that is passed to the handler method is an instance of Request, rather than the usual Django HttpRequest.", "You won't typically need to override this method.", "Ensures that any Response object returned from the handler method will be rendered into the correct content type, as determined by the content negotiation.", "You won't typically need to override this method.", "Saying [that class-based views] is always the superior solution is a mistake.", "\u2014 Nick Coghlan", "REST framework also allows you to work with regular function based views. It provides a set of simple decorators that wrap your function based views to ensure they receive an instance of Request (rather than the usual Django HttpRequest) and allows them to return a Response (instead of a Django HttpResponse), and allow you to configure how the request is processed.", "Signature: @api_view(http_method_names=['GET'])", "The core of this functionality is the api_view decorator, which takes a list of HTTP methods that your view should respond to. For example, this is how you would write a very simple view that just manually returns some data:", "This view will use the default renderers, parsers, authentication classes etc specified in the settings.", "By default only GET methods will be accepted. Other methods will respond with \"405 Method Not Allowed\". To alter this behaviour, specify which methods the view allows, like so:", "To override the default settings, REST framework provides a set of additional decorators which can be added to your views. These must come after (below) the @api_view decorator. For example, to create a view that uses a throttle to ensure it can only be called once per day by a particular user, use the @throttle_classes decorator, passing a list of throttle classes:", "These decorators correspond to the attributes set on APIView subclasses, described above.", "The available decorators are:", "Each of these decorators takes a single argument which must be a list or tuple of classes.", "To override the default schema generation for function based views you may use the @schema decorator. This must come after (below) the @api_view decorator. For example:", "This decorator takes a single AutoSchema instance, an AutoSchema subclass instance or ManualSchema instance as described in the Schemas documentation. You may pass None in order to exclude the view from schema generation.", "decorators.pyviews.py"]}, {"name": "Content negotiation", "path": "api-guide/content-negotiation/index", "type": "API Guide", "text": ["HTTP has provisions for several mechanisms for \"content negotiation\" - the process of selecting the best representation for a given response when there are multiple representations available.", "\u2014 RFC 2616, Fielding et al.", "Content negotiation is the process of selecting one of multiple possible representations to return to a client, based on client or server preferences.", "REST framework uses a simple style of content negotiation to determine which media type should be returned to a client, based on the available renderers, the priorities of each of those renderers, and the client's Accept: header. The style used is partly client-driven, and partly server-driven.", "For example, given the following Accept header:", "The priorities for each of the given media types would be:", "If the requested view was only configured with renderers for YAML and HTML, then REST framework would select whichever renderer was listed first in the renderer_classes list or DEFAULT_RENDERER_CLASSES setting.", "For more information on the HTTP Accept header, see RFC 2616", "Note: \"q\" values are not taken into account by REST framework when determining preference. The use of \"q\" values negatively impacts caching, and in the author's opinion they are an unnecessary and overcomplicated approach to content negotiation.", "This is a valid approach as the HTTP spec deliberately underspecifies how a server should weight server-based preferences against client-based preferences.", "It's unlikely that you'll want to provide a custom content negotiation scheme for REST framework, but you can do so if needed. To implement a custom content negotiation scheme override BaseContentNegotiation.", "REST framework's content negotiation classes handle selection of both the appropriate parser for the request, and the appropriate renderer for the response, so you should implement both the .select_parser(request, parsers) and .select_renderer(request, renderers, format_suffix) methods.", "The select_parser() method should return one of the parser instances from the list of available parsers, or None if none of the parsers can handle the incoming request.", "The select_renderer() method should return a two-tuple of (renderer instance, media type), or raise a NotAcceptable exception.", "The following is a custom content negotiation class which ignores the client request when selecting the appropriate parser or renderer.", "The default content negotiation class may be set globally, using the DEFAULT_CONTENT_NEGOTIATION_CLASS setting. For example, the following settings would use our example IgnoreClientContentNegotiation class.", "You can also set the content negotiation used for an individual view, or viewset, using the APIView class-based views.", "negotiation.py"]}, {"name": "Content type controls", "path": "api-guide/settings/index#content-type-controls", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "CreateAPIView", "path": "api-guide/generic-views/index#createapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "CreateModelMixin", "path": "api-guide/generic-views/index#createmodelmixin", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "CursorPagination", "path": "api-guide/pagination/index#cursorpagination", "type": "Ref: Pagination", "text": ["Django provides a few classes that help you manage paginated data \u2013 that is, data that\u2019s split across several pages, with \u201cPrevious/Next\u201d links.", "\u2014 Django documentation", "REST framework includes support for customizable pagination styles. This allows you to modify how large result sets are split into individual pages of data.", "The pagination API can support either:", "The built-in styles currently all use links included as part of the content of the response. This style is more accessible when using the browsable API.", "Pagination is only performed automatically if you're using the generic views or viewsets. If you're using a regular APIView, you'll need to call into the pagination API yourself to ensure you return a paginated response. See the source code for the mixins.ListModelMixin and generics.GenericAPIView classes for an example.", "Pagination can be turned off by setting the pagination class to None.", "The pagination style may be set globally, using the DEFAULT_PAGINATION_CLASS and PAGE_SIZE setting keys. For example, to use the built-in limit/offset pagination, you would do something like this:", "Note that you need to set both the pagination class, and the page size that should be used. Both DEFAULT_PAGINATION_CLASS and PAGE_SIZE are None by default.", "You can also set the pagination class on an individual view by using the pagination_class attribute. Typically you'll want to use the same pagination style throughout your API, although you might want to vary individual aspects of the pagination, such as default or maximum page size, on a per-view basis.", "If you want to modify particular aspects of the pagination style, you'll want to override one of the pagination classes, and set the attributes that you want to change.", "You can then apply your new style to a view using the pagination_class attribute:", "Or apply the style globally, using the DEFAULT_PAGINATION_CLASS settings key. For example:", "This pagination style accepts a single number page number in the request query parameters.", "Request:", "Response:", "To enable the PageNumberPagination style globally, use the following configuration, and set the PAGE_SIZE as desired:", "On GenericAPIView subclasses you may also set the pagination_class attribute to select PageNumberPagination on a per-view basis.", "The PageNumberPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the PageNumberPagination class, and then enable your custom pagination class as above.", "This pagination style mirrors the syntax used when looking up multiple database records. The client includes both a \"limit\" and an \"offset\" query parameter. The limit indicates the maximum number of items to return, and is equivalent to the page_size in other styles. The offset indicates the starting position of the query in relation to the complete set of unpaginated items.", "Request:", "Response:", "To enable the LimitOffsetPagination style globally, use the following configuration:", "Optionally, you may also set a PAGE_SIZE key. If the PAGE_SIZE parameter is also used then the limit query parameter will be optional, and may be omitted by the client.", "On GenericAPIView subclasses you may also set the pagination_class attribute to select LimitOffsetPagination on a per-view basis.", "The LimitOffsetPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the LimitOffsetPagination class, and then enable your custom pagination class as above.", "The cursor-based pagination presents an opaque \"cursor\" indicator that the client may use to page through the result set. This pagination style only presents forward and reverse controls, and does not allow the client to navigate to arbitrary positions.", "Cursor based pagination requires that there is a unique, unchanging ordering of items in the result set. This ordering might typically be a creation timestamp on the records, as this presents a consistent ordering to paginate against.", "Cursor based pagination is more complex than other schemes. It also requires that the result set presents a fixed ordering, and does not allow the client to arbitrarily index into the result set. However it does provide the following benefits:", "Proper use of cursor based pagination requires a little attention to detail. You'll need to think about what ordering you want the scheme to be applied against. The default is to order by \"-created\". This assumes that there must be a 'created' timestamp field on the model instances, and will present a \"timeline\" style paginated view, with the most recently added items first.", "You can modify the ordering by overriding the 'ordering' attribute on the pagination class, or by using the OrderingFilter filter class together with CursorPagination. When used with OrderingFilter you should strongly consider restricting the fields that the user may order by.", "Proper usage of cursor pagination should have an ordering field that satisfies the following:", "Using an ordering field that does not satisfy these constraints will generally still work, but you'll be losing some of the benefits of cursor pagination.", "For more technical details on the implementation we use for cursor pagination, the \"Building cursors for the Disqus API\" blog post gives a good overview of the basic approach.", "To enable the CursorPagination style globally, use the following configuration, modifying the PAGE_SIZE as desired:", "On GenericAPIView subclasses you may also set the pagination_class attribute to select CursorPagination on a per-view basis.", "The CursorPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the CursorPagination class, and then enable your custom pagination class as above.", "To create a custom pagination serializer class, you should inherit the subclass pagination.BasePagination, override the paginate_queryset(self, queryset, request, view=None), and get_paginated_response(self, data) methods:", "Note that the paginate_queryset method may set state on the pagination instance, that may later be used by the get_paginated_response method.", "Suppose we want to replace the default pagination output style with a modified format that includes the next and previous links under in a nested 'links' key. We could specify a custom pagination class like so:", "We'd then need to setup the custom class in our configuration:", "Note that if you care about how the ordering of keys is displayed in responses in the browsable API you might choose to use an OrderedDict when constructing the body of paginated responses, but this is optional.", "To have your custom pagination class be used by default, use the DEFAULT_PAGINATION_CLASS setting:", "API responses for list endpoints will now include a Link header, instead of including the pagination links as part of the body of the response, for example:", "", "A custom pagination style, using the 'Link' header'", "You can also make the pagination controls available to the schema autogeneration that REST framework provides, by implementing a get_schema_fields() method. This method should have the following signature:", "get_schema_fields(self, view)", "The method should return a list of coreapi.Field instances.", "By default using the pagination classes will cause HTML pagination controls to be displayed in the browsable API. There are two built-in display styles. The PageNumberPagination and LimitOffsetPagination classes display a list of page numbers with previous and next controls. The CursorPagination class displays a simpler style that only displays a previous and next control.", "You can override the templates that render the HTML pagination controls. The two built-in styles are:", "Providing a template with either of these paths in a global template directory will override the default rendering for the relevant pagination classes.", "Alternatively you can disable HTML pagination controls completely by subclassing on of the existing classes, setting template = None as an attribute on the class. You'll then need to configure your DEFAULT_PAGINATION_CLASS settings key to use your custom class as the default pagination style.", "The low-level API for determining if a pagination class should display the controls or not is exposed as a display_page_controls attribute on the pagination instance. Custom pagination classes should be set to True in the paginate_queryset method if they require the HTML pagination controls to be displayed.", "The .to_html() and .get_html_context() methods may also be overridden in a custom pagination class in order to further customize how the controls are rendered.", "The following third party packages are also available.", "The DRF-extensions package includes a PaginateByMaxMixin mixin class that allows your API clients to specify ?page_size=max to obtain the maximum allowed page size.", "The drf-proxy-pagination package includes a ProxyPagination class which allows to choose pagination class with a query parameter.", "The django-rest-framework-link-header-pagination package includes a LinkHeaderPagination class which provides pagination via an HTTP Link header as described in Github's developer documentation.", "pagination.py"]}, {"name": "Date and time formatting", "path": "api-guide/settings/index#date-and-time-formatting", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "DateField", "path": "api-guide/fields/index#datefield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "DateTimeField", "path": "api-guide/fields/index#datetimefield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "DecimalField", "path": "api-guide/fields/index#decimalfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "DefaultRouter", "path": "api-guide/routers/index#defaultrouter", "type": "Ref: Routers", "text": ["Resource routing allows you to quickly declare all of the common routes for a given resourceful controller. Instead of declaring separate routes for your index... a resourceful route declares them in a single line of code.", "\u2014 Ruby on Rails Documentation", "Some Web frameworks such as Rails provide functionality for automatically determining how the URLs for an application should be mapped to the logic that deals with handling incoming requests.", "REST framework adds support for automatic URL routing to Django, and provides you with a simple, quick and consistent way of wiring your view logic to a set of URLs.", "Here's an example of a simple URL conf, that uses SimpleRouter.", "There are two mandatory arguments to the register() method:", "Optionally, you may also specify an additional argument:", "The example above would generate the following URL patterns:", "Note: The basename argument is used to specify the initial part of the view name pattern. In the example above, that's the user or account part.", "Typically you won't need to specify the basename argument, but if you have a viewset where you've defined a custom get_queryset method, then the viewset may not have a .queryset attribute set. If you try to register that viewset you'll see an error like this:", "This means you'll need to explicitly set the basename argument when registering the viewset, as it could not be automatically determined from the model name.", "The .urls attribute on a router instance is simply a standard list of URL patterns. There are a number of different styles for how you can include these URLs.", "For example, you can append router.urls to a list of existing views...", "Alternatively you can use Django's include function, like so...", "You may use include with an application namespace:", "Or both an application and instance namespace:", "See Django's URL namespaces docs and the include API reference for more details.", "Note: If using namespacing with hyperlinked serializers you'll also need to ensure that any view_name parameters on the serializers correctly reflect the namespace. In the examples above you'd need to include a parameter such as view_name='app_name:user-detail' for serializer fields hyperlinked to the user detail view.", "The automatic view_name generation uses a pattern like %(model_name)-detail. Unless your models names actually clash you may be better off not namespacing your Django REST Framework views when using hyperlinked serializers.", "A viewset may mark extra actions for routing by decorating a method with the @action decorator. These extra actions will be included in the generated routes. For example, given the set_password method on the UserViewSet class:", "The following route would be generated:", "By default, the URL pattern is based on the method name, and the URL name is the combination of the ViewSet.basename and the hyphenated method name. If you don't want to use the defaults for either of these values, you can instead provide the url_path and url_name arguments to the @action decorator.", "For example, if you want to change the URL for our custom action to ^users/{pk}/change-password/$, you could write:", "The above example would now generate the following URL pattern:", "This router includes routes for the standard set of list, create, retrieve, update, partial_update and destroy actions. The viewset can also mark additional methods to be routed, using the @action decorator.", "By default the URLs created by SimpleRouter are appended with a trailing slash. This behavior can be modified by setting the trailing_slash argument to False when instantiating the router. For example:", "Trailing slashes are conventional in Django, but are not used by default in some other frameworks such as Rails. Which style you choose to use is largely a matter of preference, although some javascript frameworks may expect a particular routing style.", "The router will match lookup values containing any characters except slashes and period characters. For a more restrictive (or lenient) lookup pattern, set the lookup_value_regex attribute on the viewset. For example, you can limit the lookup to valid UUIDs:", "This router is similar to SimpleRouter as above, but additionally includes a default API root view, that returns a response containing hyperlinks to all the list views. It also generates routes for optional .json style format suffixes.", "As with SimpleRouter the trailing slashes on the URL routes can be removed by setting the trailing_slash argument to False when instantiating the router.", "Implementing a custom router isn't something you'd need to do very often, but it can be useful if you have specific requirements about how the URLs for your API are structured. Doing so allows you to encapsulate the URL structure in a reusable way that ensures you don't have to write your URL patterns explicitly for each new view.", "The simplest way to implement a custom router is to subclass one of the existing router classes. The .routes attribute is used to template the URL patterns that will be mapped to each viewset. The .routes attribute is a list of Route named tuples.", "The arguments to the Route named tuple are:", "url: A string representing the URL to be routed. May include the following format strings:", "mapping: A mapping of HTTP method names to the view methods", "name: The name of the URL as used in reverse calls. May include the following format string:", "initkwargs: A dictionary of any additional arguments that should be passed when instantiating the view. Note that the detail, basename, and suffix arguments are reserved for viewset introspection and are also used by the browsable API to generate the view name and breadcrumb links.", "You can also customize how the @action decorator is routed. Include the DynamicRoute named tuple in the .routes list, setting the detail argument as appropriate for the list-based and detail-based routes. In addition to detail, the arguments to DynamicRoute are:", "url: A string representing the URL to be routed. May include the same format strings as Route, and additionally accepts the {url_path} format string.", "name: The name of the URL as used in reverse calls. May include the following format strings:", "initkwargs: A dictionary of any additional arguments that should be passed when instantiating the view.", "The following example will only route to the list and retrieve actions, and does not use the trailing slash convention.", "Let's take a look at the routes our CustomReadOnlyRouter would generate for a simple viewset.", "views.py:", "urls.py:", "The following mappings would be generated...", "For another example of setting the .routes attribute, see the source code for the SimpleRouter class.", "If you want to provide totally custom behavior, you can override BaseRouter and override the get_urls(self) method. The method should inspect the registered viewsets and return a list of URL patterns. The registered prefix, viewset and basename tuples may be inspected by accessing the self.registry attribute.", "You may also want to override the get_default_basename(self, viewset) method, or else always explicitly set the basename argument when registering your viewsets with the router.", "The following third party packages are also available.", "The drf-nested-routers package provides routers and relationship fields for working with nested resources.", "The wq.db package provides an advanced ModelRouter class (and singleton instance) that extends DefaultRouter with a register_model() API. Much like Django's admin.site.register, the only required argument to rest.router.register_model is a model class. Reasonable defaults for a url prefix, serializer, and viewset will be inferred from the model and global configuration.", "The DRF-extensions package provides routers for creating nested viewsets, collection level controllers with customizable endpoint names.", "routers.py"]}, {"name": "DestroyAPIView", "path": "api-guide/generic-views/index#destroyapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "DestroyModelMixin", "path": "api-guide/generic-views/index#destroymodelmixin", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "DictField", "path": "api-guide/fields/index#dictfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "DjangoFilterBackend", "path": "api-guide/filtering/index#djangofilterbackend", "type": "Ref: Filtering", "text": ["The root QuerySet provided by the Manager describes all objects in the database table. Usually, though, you'll need to select only a subset of the complete set of objects.", "\u2014 Django documentation", "The default behavior of REST framework's generic list views is to return the entire queryset for a model manager. Often you will want your API to restrict the items that are returned by the queryset.", "The simplest way to filter the queryset of any view that subclasses GenericAPIView is to override the .get_queryset() method.", "Overriding this method allows you to customize the queryset returned by the view in a number of different ways.", "You might want to filter the queryset to ensure that only results relevant to the currently authenticated user making the request are returned.", "You can do so by filtering based on the value of request.user.", "For example:", "Another style of filtering might involve restricting the queryset based on some part of the URL.", "For example if your URL config contained an entry like this:", "You could then write a view that returned a purchase queryset filtered by the username portion of the URL:", "A final example of filtering the initial queryset would be to determine the initial queryset based on query parameters in the url.", "We can override .get_queryset() to deal with URLs such as http://example.com/api/purchases?username=denvercoder9, and filter the queryset only if the username parameter is included in the URL:", "As well as being able to override the default queryset, REST framework also includes support for generic filtering backends that allow you to easily construct complex searches and filters.", "Generic filters can also present themselves as HTML controls in the browsable API and admin API.", "", "The default filter backends may be set globally, using the DEFAULT_FILTER_BACKENDS setting. For example.", "You can also set the filter backends on a per-view, or per-viewset basis, using the GenericAPIView class-based views.", "Note that if a filter backend is configured for a view, then as well as being used to filter list views, it will also be used to filter the querysets used for returning a single object.", "For instance, given the previous example, and a product with an id of 4675, the following URL would either return the corresponding object, or return a 404 response, depending on if the filtering conditions were met by the given product instance:", "Note that you can use both an overridden .get_queryset() and generic filtering together, and everything will work as expected. For example, if Product had a many-to-many relationship with User, named purchase, you might want to write a view like this:", "The django-filter library includes a DjangoFilterBackend class which supports highly customizable field filtering for REST framework.", "To use DjangoFilterBackend, first install django-filter.", "Then add 'django_filters' to Django's INSTALLED_APPS:", "You should now either add the filter backend to your settings:", "Or add the filter backend to an individual View or ViewSet.", "If all you need is simple equality-based filtering, you can set a filterset_fields attribute on the view, or viewset, listing the set of fields you wish to filter against.", "This will automatically create a FilterSet class for the given fields, and will allow you to make requests such as:", "For more advanced filtering requirements you can specify a FilterSet class that should be used by the view. You can read more about FilterSets in the django-filter documentation. It's also recommended that you read the section on DRF integration.", "The SearchFilter class supports simple single query parameter based searching, and is based on the Django admin's search functionality.", "When in use, the browsable API will include a SearchFilter control:", "", "The SearchFilter class will only be applied if the view has a search_fields attribute set. The search_fields attribute should be a list of names of text type fields on the model, such as CharField or TextField.", "This will allow the client to filter the items in the list by making queries such as:", "You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation:", "For JSONField and HStoreField fields you can filter based on nested values within the data structure using the same double-underscore notation:", "By default, searches will use case-insensitive partial matches. The search parameter may contain multiple search terms, which should be whitespace and/or comma separated. If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched.", "The search behavior may be restricted by prepending various characters to the search_fields.", "For example:", "By default, the search parameter is named 'search', but this may be overridden with the SEARCH_PARAM setting.", "To dynamically change search fields based on request content, it's possible to subclass the SearchFilter and override the get_search_fields() function. For example, the following subclass will only search on title if the query parameter title_only is in the request:", "For more details, see the Django documentation.", "The OrderingFilter class supports simple query parameter controlled ordering of results.", "", "By default, the query parameter is named 'ordering', but this may by overridden with the ORDERING_PARAM setting.", "For example, to order users by username:", "The client may also specify reverse orderings by prefixing the field name with '-', like so:", "Multiple orderings may also be specified:", "It's recommended that you explicitly specify which fields the API should allowing in the ordering filter. You can do this by setting an ordering_fields attribute on the view, like so:", "This helps prevent unexpected data leakage, such as allowing users to order against a password hash field or other sensitive data.", "If you don't specify an ordering_fields attribute on the view, the filter class will default to allowing the user to filter on any readable fields on the serializer specified by the serializer_class attribute.", "If you are confident that the queryset being used by the view doesn't contain any sensitive data, you can also explicitly specify that a view should allow ordering on any model field or queryset aggregate, by using the special value '__all__'.", "If an ordering attribute is set on the view, this will be used as the default ordering.", "Typically you'd instead control this by setting order_by on the initial queryset, but using the ordering parameter on the view allows you to specify the ordering in a way that it can then be passed automatically as context to a rendered template. This makes it possible to automatically render column headers differently if they are being used to order the results.", "The ordering attribute may be either a string or a list/tuple of strings.", "You can also provide your own generic filtering backend, or write an installable app for other developers to use.", "To do so override BaseFilterBackend, and override the .filter_queryset(self, request, queryset, view) method. The method should return a new, filtered queryset.", "As well as allowing clients to perform searches and filtering, generic filter backends can be useful for restricting which objects should be visible to any given request or user.", "For example, you might need to restrict users to only being able to see objects they created.", "We could achieve the same behavior by overriding get_queryset() on the views, but using a filter backend allows you to more easily add this restriction to multiple views, or to apply it across the entire API.", "Generic filters may also present an interface in the browsable API. To do so you should implement a to_html() method which returns a rendered HTML representation of the filter. This method should have the following signature:", "to_html(self, request, queryset, view)", "The method should return a rendered HTML string.", "You can also make the filter controls available to the schema autogeneration that REST framework provides, by implementing a get_schema_fields() method. This method should have the following signature:", "get_schema_fields(self, view)", "The method should return a list of coreapi.Field instances.", "The following third party packages provide additional filter implementations.", "The django-rest-framework-filters package works together with the DjangoFilterBackend class, and allows you to easily create filters across relationships, or create multiple filter lookup types for a given field.", "The djangorestframework-word-filter developed as alternative to filters.SearchFilter which will search full word in text, or exact match.", "django-url-filter provides a safe way to filter data via human-friendly URLs. It works very similar to DRF serializers and fields in a sense that they can be nested except they are called filtersets and filters. That provides easy way to filter related data. Also this library is generic-purpose so it can be used to filter other sources of data and not only Django QuerySets.", "drf-url-filter is a simple Django app to apply filters on drf ModelViewSet's Queryset in a clean, simple and configurable way. It also supports validations on incoming query params and their values. A beautiful python package Voluptuous is being used for validations on the incoming query parameters. The best part about voluptuous is you can define your own validations as per your query params requirements.", "filters.py"]}, {"name": "DjangoModelPermissions", "path": "api-guide/permissions/index#djangomodelpermissions", "type": "Ref: Permissions", "text": ["Authentication or identification by itself is not usually sufficient to gain access to information or code. For that, the entity requesting access must have authorization.", "\u2014 Apple Developer Documentation", "Together with authentication and throttling, permissions determine whether a request should be granted or denied access.", "Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.", "Permissions are used to grant or deny access for different classes of users to different parts of the API.", "The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.", "A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in REST framework.", "Permissions in REST framework are always defined as a list of permission classes.", "Before running the main body of the view each permission in the list is checked. If any permission check fails an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.", "When the permissions checks fail either a \"403 Forbidden\" or a \"401 Unauthorized\" response will be returned, according to the following rules:", "REST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.", "Object level permissions are run by REST framework's generic views when .get_object() is called. As with view level permissions, an exceptions.PermissionDenied exception will be raised if the user is not allowed to act on the given object.", "If you're writing your own views and want to enforce object level permissions, or if you override the get_object method on a generic view, then you'll need to explicitly call the .check_object_permissions(request, obj) method on the view at the point at which you've retrieved the object.", "This will either raise a PermissionDenied or NotAuthenticated exception, or simply return if the view has the appropriate permissions.", "For example:", "Note: With the exception of DjangoObjectPermissions, the provided permission classes in rest_framework.permissions do not implement the methods necessary to check object permissions.", "If you wish to use the provided permission classes in order to check object permissions, you must subclass them and implement the has_object_permission() method described in the Custom permissions section (below).", "For performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.", "Often when you're using object level permissions you'll also want to filter the queryset appropriately, to ensure that users only have visibility onto instances that they are permitted to view.", "Because the get_object() method is not called, object level permissions from the has_object_permission() method are not applied when creating objects. In order to restrict object creation you need to implement the permission check either in your Serializer class or override the perform_create() method of your ViewSet class.", "The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting. For example.", "If not specified, this setting defaults to allowing unrestricted access:", "You can also set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Note: when you set new permission classes via the class attribute or decorators you're telling the view to ignore the default list set in the settings.py file.", "Provided they inherit from rest_framework.permissions.BasePermission, permissions can be composed using standard Python bitwise operators. For example, IsAuthenticatedOrReadOnly could be written:", "Note: it supports & (and), | (or) and ~ (not).", "The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated.", "This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.", "The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.", "This permission is suitable if you want your API to only be accessible to registered users.", "The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.", "This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.", "The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the \"safe\" methods; GET, HEAD or OPTIONS.", "This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.", "This permission class ties into Django's standard django.contrib.auth model permissions. This permission must only be applied to views that have a .queryset property or get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant model permissions assigned.", "The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a view model permission for GET requests.", "To use custom model permissions, override DjangoModelPermissions and set the .perms_map property. Refer to the source code for details.", "Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API.", "This permission class ties into Django's standard object permissions framework that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as django-guardian.", "As with DjangoModelPermissions, this permission must only be applied to views that have a .queryset property or .get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant per-object permissions and relevant model permissions assigned.", "Note that DjangoObjectPermissions does not require the django-guardian package, and should support other object-level backends equally well.", "As with DjangoModelPermissions you can use custom model permissions by overriding DjangoObjectPermissions and setting the .perms_map property. Refer to the source code for details.", "Note: If you need object level view permissions for GET, HEAD and OPTIONS requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the DjangoObjectPermissionsFilter class provided by the djangorestframework-guardian package. It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.", "To implement a custom permission, override BasePermission and implement either, or both, of the following methods:", "The methods should return True if the request should be granted access, and False otherwise.", "If you need to test if a request is a read operation or a write operation, you should check the request method against the constant SAFE_METHODS, which is a tuple containing 'GET', 'OPTIONS' and 'HEAD'. For example:", "Note: The instance-level has_object_permission method will only be called if the view-level has_permission checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call .check_object_permissions(request, obj). If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising PermissionDenied on failure.)", "Custom permissions will raise a PermissionDenied exception if the test fails. To change the error message associated with the exception, implement a message attribute directly on your custom permission. Otherwise the default_detail attribute from PermissionDenied will be used. Similarly, to change the code identifier associated with the exception, implement a code attribute directly on your custom permission - otherwise the default_code attribute from PermissionDenied will be used.", "The following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.", "As well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:", "Note that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling self.check_object_permissions(request, obj) from the view once you have the object instance. This call will raise an appropriate APIException if any object-level permission checks fail, and will otherwise simply return.", "Also note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the filtering documentation for more details.", "REST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.", "The following table lists the access restriction methods and the level of control they offer over which actions.", "* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  ** The get_*() methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.", "The following third party packages are also available.", "The Django REST - Access Policy package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies. ", "The Composed Permissions package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.", "The REST Condition package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.", "The DRY Rest Permissions package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.", "The Django Rest Framework Roles package makes it easier to parameterize your API over multiple types of users.", "The Django REST Framework API Key package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. machines) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.", "The Django Rest Framework Role Filters package provides simple filtering over multiple types of roles.", "The Django Rest Framework PSQ package is an extension that gives support for having action-based permission_classes, serializer_class, and queryset dependent on permission-based rules.", "permissions.py"]}, {"name": "DjangoModelPermissionsOrAnonReadOnly", "path": "api-guide/permissions/index#djangomodelpermissionsoranonreadonly", "type": "Ref: Permissions", "text": ["Authentication or identification by itself is not usually sufficient to gain access to information or code. For that, the entity requesting access must have authorization.", "\u2014 Apple Developer Documentation", "Together with authentication and throttling, permissions determine whether a request should be granted or denied access.", "Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.", "Permissions are used to grant or deny access for different classes of users to different parts of the API.", "The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.", "A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in REST framework.", "Permissions in REST framework are always defined as a list of permission classes.", "Before running the main body of the view each permission in the list is checked. If any permission check fails an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.", "When the permissions checks fail either a \"403 Forbidden\" or a \"401 Unauthorized\" response will be returned, according to the following rules:", "REST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.", "Object level permissions are run by REST framework's generic views when .get_object() is called. As with view level permissions, an exceptions.PermissionDenied exception will be raised if the user is not allowed to act on the given object.", "If you're writing your own views and want to enforce object level permissions, or if you override the get_object method on a generic view, then you'll need to explicitly call the .check_object_permissions(request, obj) method on the view at the point at which you've retrieved the object.", "This will either raise a PermissionDenied or NotAuthenticated exception, or simply return if the view has the appropriate permissions.", "For example:", "Note: With the exception of DjangoObjectPermissions, the provided permission classes in rest_framework.permissions do not implement the methods necessary to check object permissions.", "If you wish to use the provided permission classes in order to check object permissions, you must subclass them and implement the has_object_permission() method described in the Custom permissions section (below).", "For performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.", "Often when you're using object level permissions you'll also want to filter the queryset appropriately, to ensure that users only have visibility onto instances that they are permitted to view.", "Because the get_object() method is not called, object level permissions from the has_object_permission() method are not applied when creating objects. In order to restrict object creation you need to implement the permission check either in your Serializer class or override the perform_create() method of your ViewSet class.", "The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting. For example.", "If not specified, this setting defaults to allowing unrestricted access:", "You can also set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Note: when you set new permission classes via the class attribute or decorators you're telling the view to ignore the default list set in the settings.py file.", "Provided they inherit from rest_framework.permissions.BasePermission, permissions can be composed using standard Python bitwise operators. For example, IsAuthenticatedOrReadOnly could be written:", "Note: it supports & (and), | (or) and ~ (not).", "The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated.", "This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.", "The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.", "This permission is suitable if you want your API to only be accessible to registered users.", "The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.", "This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.", "The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the \"safe\" methods; GET, HEAD or OPTIONS.", "This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.", "This permission class ties into Django's standard django.contrib.auth model permissions. This permission must only be applied to views that have a .queryset property or get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant model permissions assigned.", "The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a view model permission for GET requests.", "To use custom model permissions, override DjangoModelPermissions and set the .perms_map property. Refer to the source code for details.", "Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API.", "This permission class ties into Django's standard object permissions framework that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as django-guardian.", "As with DjangoModelPermissions, this permission must only be applied to views that have a .queryset property or .get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant per-object permissions and relevant model permissions assigned.", "Note that DjangoObjectPermissions does not require the django-guardian package, and should support other object-level backends equally well.", "As with DjangoModelPermissions you can use custom model permissions by overriding DjangoObjectPermissions and setting the .perms_map property. Refer to the source code for details.", "Note: If you need object level view permissions for GET, HEAD and OPTIONS requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the DjangoObjectPermissionsFilter class provided by the djangorestframework-guardian package. It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.", "To implement a custom permission, override BasePermission and implement either, or both, of the following methods:", "The methods should return True if the request should be granted access, and False otherwise.", "If you need to test if a request is a read operation or a write operation, you should check the request method against the constant SAFE_METHODS, which is a tuple containing 'GET', 'OPTIONS' and 'HEAD'. For example:", "Note: The instance-level has_object_permission method will only be called if the view-level has_permission checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call .check_object_permissions(request, obj). If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising PermissionDenied on failure.)", "Custom permissions will raise a PermissionDenied exception if the test fails. To change the error message associated with the exception, implement a message attribute directly on your custom permission. Otherwise the default_detail attribute from PermissionDenied will be used. Similarly, to change the code identifier associated with the exception, implement a code attribute directly on your custom permission - otherwise the default_code attribute from PermissionDenied will be used.", "The following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.", "As well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:", "Note that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling self.check_object_permissions(request, obj) from the view once you have the object instance. This call will raise an appropriate APIException if any object-level permission checks fail, and will otherwise simply return.", "Also note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the filtering documentation for more details.", "REST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.", "The following table lists the access restriction methods and the level of control they offer over which actions.", "* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  ** The get_*() methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.", "The following third party packages are also available.", "The Django REST - Access Policy package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies. ", "The Composed Permissions package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.", "The REST Condition package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.", "The DRY Rest Permissions package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.", "The Django Rest Framework Roles package makes it easier to parameterize your API over multiple types of users.", "The Django REST Framework API Key package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. machines) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.", "The Django Rest Framework Role Filters package provides simple filtering over multiple types of roles.", "The Django Rest Framework PSQ package is an extension that gives support for having action-based permission_classes, serializer_class, and queryset dependent on permission-based rules.", "permissions.py"]}, {"name": "DjangoObjectPermissions", "path": "api-guide/permissions/index#djangoobjectpermissions", "type": "Ref: Permissions", "text": ["Authentication or identification by itself is not usually sufficient to gain access to information or code. For that, the entity requesting access must have authorization.", "\u2014 Apple Developer Documentation", "Together with authentication and throttling, permissions determine whether a request should be granted or denied access.", "Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.", "Permissions are used to grant or deny access for different classes of users to different parts of the API.", "The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.", "A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in REST framework.", "Permissions in REST framework are always defined as a list of permission classes.", "Before running the main body of the view each permission in the list is checked. If any permission check fails an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.", "When the permissions checks fail either a \"403 Forbidden\" or a \"401 Unauthorized\" response will be returned, according to the following rules:", "REST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.", "Object level permissions are run by REST framework's generic views when .get_object() is called. As with view level permissions, an exceptions.PermissionDenied exception will be raised if the user is not allowed to act on the given object.", "If you're writing your own views and want to enforce object level permissions, or if you override the get_object method on a generic view, then you'll need to explicitly call the .check_object_permissions(request, obj) method on the view at the point at which you've retrieved the object.", "This will either raise a PermissionDenied or NotAuthenticated exception, or simply return if the view has the appropriate permissions.", "For example:", "Note: With the exception of DjangoObjectPermissions, the provided permission classes in rest_framework.permissions do not implement the methods necessary to check object permissions.", "If you wish to use the provided permission classes in order to check object permissions, you must subclass them and implement the has_object_permission() method described in the Custom permissions section (below).", "For performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.", "Often when you're using object level permissions you'll also want to filter the queryset appropriately, to ensure that users only have visibility onto instances that they are permitted to view.", "Because the get_object() method is not called, object level permissions from the has_object_permission() method are not applied when creating objects. In order to restrict object creation you need to implement the permission check either in your Serializer class or override the perform_create() method of your ViewSet class.", "The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting. For example.", "If not specified, this setting defaults to allowing unrestricted access:", "You can also set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Note: when you set new permission classes via the class attribute or decorators you're telling the view to ignore the default list set in the settings.py file.", "Provided they inherit from rest_framework.permissions.BasePermission, permissions can be composed using standard Python bitwise operators. For example, IsAuthenticatedOrReadOnly could be written:", "Note: it supports & (and), | (or) and ~ (not).", "The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated.", "This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.", "The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.", "This permission is suitable if you want your API to only be accessible to registered users.", "The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.", "This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.", "The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the \"safe\" methods; GET, HEAD or OPTIONS.", "This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.", "This permission class ties into Django's standard django.contrib.auth model permissions. This permission must only be applied to views that have a .queryset property or get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant model permissions assigned.", "The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a view model permission for GET requests.", "To use custom model permissions, override DjangoModelPermissions and set the .perms_map property. Refer to the source code for details.", "Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API.", "This permission class ties into Django's standard object permissions framework that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as django-guardian.", "As with DjangoModelPermissions, this permission must only be applied to views that have a .queryset property or .get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant per-object permissions and relevant model permissions assigned.", "Note that DjangoObjectPermissions does not require the django-guardian package, and should support other object-level backends equally well.", "As with DjangoModelPermissions you can use custom model permissions by overriding DjangoObjectPermissions and setting the .perms_map property. Refer to the source code for details.", "Note: If you need object level view permissions for GET, HEAD and OPTIONS requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the DjangoObjectPermissionsFilter class provided by the djangorestframework-guardian package. It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.", "To implement a custom permission, override BasePermission and implement either, or both, of the following methods:", "The methods should return True if the request should be granted access, and False otherwise.", "If you need to test if a request is a read operation or a write operation, you should check the request method against the constant SAFE_METHODS, which is a tuple containing 'GET', 'OPTIONS' and 'HEAD'. For example:", "Note: The instance-level has_object_permission method will only be called if the view-level has_permission checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call .check_object_permissions(request, obj). If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising PermissionDenied on failure.)", "Custom permissions will raise a PermissionDenied exception if the test fails. To change the error message associated with the exception, implement a message attribute directly on your custom permission. Otherwise the default_detail attribute from PermissionDenied will be used. Similarly, to change the code identifier associated with the exception, implement a code attribute directly on your custom permission - otherwise the default_code attribute from PermissionDenied will be used.", "The following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.", "As well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:", "Note that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling self.check_object_permissions(request, obj) from the view once you have the object instance. This call will raise an appropriate APIException if any object-level permission checks fail, and will otherwise simply return.", "Also note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the filtering documentation for more details.", "REST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.", "The following table lists the access restriction methods and the level of control they offer over which actions.", "* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  ** The get_*() methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.", "The following third party packages are also available.", "The Django REST - Access Policy package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies. ", "The Composed Permissions package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.", "The REST Condition package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.", "The DRY Rest Permissions package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.", "The Django Rest Framework Roles package makes it easier to parameterize your API over multiple types of users.", "The Django REST Framework API Key package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. machines) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.", "The Django Rest Framework Role Filters package provides simple filtering over multiple types of roles.", "The Django Rest Framework PSQ package is an extension that gives support for having action-based permission_classes, serializer_class, and queryset dependent on permission-based rules.", "permissions.py"]}, {"name": "DurationField", "path": "api-guide/fields/index#durationfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "EmailField", "path": "api-guide/fields/index#emailfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "Encodings", "path": "api-guide/settings/index#encodings", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "Exceptions", "path": "api-guide/exceptions/index", "type": "API Guide", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "FileField", "path": "api-guide/fields/index#filefield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "FilePathField", "path": "api-guide/fields/index#filepathfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "FileUploadParser", "path": "api-guide/parsers/index#fileuploadparser", "type": "Ref: Parsers", "text": ["Machine interacting web services tend to use more structured formats for sending data than form-encoded, since they're sending more complex data than simple forms", "\u2014 Malcom Tredinnick, Django developers group", "REST framework includes a number of built in Parser classes, that allow you to accept requests with various media types. There is also support for defining your own custom parsers, which gives you the flexibility to design the media types that your API accepts.", "The set of valid parsers for a view is always defined as a list of classes. When request.data is accessed, REST framework will examine the Content-Type header on the incoming request, and determine which parser to use to parse the request content.", "Note: When developing client applications always remember to make sure you're setting the Content-Type header when sending data in an HTTP request.", "If you don't set the content type, most clients will default to using 'application/x-www-form-urlencoded', which may not be what you wanted.", "As an example, if you are sending json encoded data using jQuery with the .ajax() method, you should make sure to include the contentType: 'application/json' setting.", "The default set of parsers may be set globally, using the DEFAULT_PARSER_CLASSES setting. For example, the following settings would allow only requests with JSON content, instead of the default of JSON or form data.", "You can also set the parsers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Parses JSON request content. request.data will be populated with a dictionary of data.", ".media_type: application/json", "Parses HTML form content. request.data will be populated with a QueryDict of data.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: application/x-www-form-urlencoded", "Parses multipart HTML form content, which supports file uploads. Both request.data will be populated with a QueryDict.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: multipart/form-data", "Parses raw file upload content. The request.data property will be a dictionary with a single key 'file' containing the uploaded file.", "If the view used with FileUploadParser is called with a filename URL keyword argument, then that argument will be used as the filename.", "If it is called without a filename URL keyword argument, then the client must set the filename in the Content-Disposition HTTP header. For example Content-Disposition: attachment; filename=upload.jpg.", ".media_type: */*", "To implement a custom parser, you should override BaseParser, set the .media_type property, and implement the .parse(self, stream, media_type, parser_context) method.", "The method should return the data that will be used to populate the request.data property.", "The arguments passed to .parse() are:", "A stream-like object representing the body of the request.", "Optional. If provided, this is the media type of the incoming request content.", "Depending on the request's Content-Type: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"text/plain; charset=utf-8\".", "Optional. If supplied, this argument will be a dictionary containing any additional context that may be required to parse the request content.", "By default this will include the following keys: view, request, args, kwargs.", "The following is an example plaintext parser that will populate the request.data property with a string representing the body of the request.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "parsers.py"]}, {"name": "Filtering", "path": "api-guide/filtering/index", "type": "API Guide", "text": ["The root QuerySet provided by the Manager describes all objects in the database table. Usually, though, you'll need to select only a subset of the complete set of objects.", "\u2014 Django documentation", "The default behavior of REST framework's generic list views is to return the entire queryset for a model manager. Often you will want your API to restrict the items that are returned by the queryset.", "The simplest way to filter the queryset of any view that subclasses GenericAPIView is to override the .get_queryset() method.", "Overriding this method allows you to customize the queryset returned by the view in a number of different ways.", "You might want to filter the queryset to ensure that only results relevant to the currently authenticated user making the request are returned.", "You can do so by filtering based on the value of request.user.", "For example:", "Another style of filtering might involve restricting the queryset based on some part of the URL.", "For example if your URL config contained an entry like this:", "You could then write a view that returned a purchase queryset filtered by the username portion of the URL:", "A final example of filtering the initial queryset would be to determine the initial queryset based on query parameters in the url.", "We can override .get_queryset() to deal with URLs such as http://example.com/api/purchases?username=denvercoder9, and filter the queryset only if the username parameter is included in the URL:", "As well as being able to override the default queryset, REST framework also includes support for generic filtering backends that allow you to easily construct complex searches and filters.", "Generic filters can also present themselves as HTML controls in the browsable API and admin API.", "", "The default filter backends may be set globally, using the DEFAULT_FILTER_BACKENDS setting. For example.", "You can also set the filter backends on a per-view, or per-viewset basis, using the GenericAPIView class-based views.", "Note that if a filter backend is configured for a view, then as well as being used to filter list views, it will also be used to filter the querysets used for returning a single object.", "For instance, given the previous example, and a product with an id of 4675, the following URL would either return the corresponding object, or return a 404 response, depending on if the filtering conditions were met by the given product instance:", "Note that you can use both an overridden .get_queryset() and generic filtering together, and everything will work as expected. For example, if Product had a many-to-many relationship with User, named purchase, you might want to write a view like this:", "The django-filter library includes a DjangoFilterBackend class which supports highly customizable field filtering for REST framework.", "To use DjangoFilterBackend, first install django-filter.", "Then add 'django_filters' to Django's INSTALLED_APPS:", "You should now either add the filter backend to your settings:", "Or add the filter backend to an individual View or ViewSet.", "If all you need is simple equality-based filtering, you can set a filterset_fields attribute on the view, or viewset, listing the set of fields you wish to filter against.", "This will automatically create a FilterSet class for the given fields, and will allow you to make requests such as:", "For more advanced filtering requirements you can specify a FilterSet class that should be used by the view. You can read more about FilterSets in the django-filter documentation. It's also recommended that you read the section on DRF integration.", "The SearchFilter class supports simple single query parameter based searching, and is based on the Django admin's search functionality.", "When in use, the browsable API will include a SearchFilter control:", "", "The SearchFilter class will only be applied if the view has a search_fields attribute set. The search_fields attribute should be a list of names of text type fields on the model, such as CharField or TextField.", "This will allow the client to filter the items in the list by making queries such as:", "You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation:", "For JSONField and HStoreField fields you can filter based on nested values within the data structure using the same double-underscore notation:", "By default, searches will use case-insensitive partial matches. The search parameter may contain multiple search terms, which should be whitespace and/or comma separated. If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched.", "The search behavior may be restricted by prepending various characters to the search_fields.", "For example:", "By default, the search parameter is named 'search', but this may be overridden with the SEARCH_PARAM setting.", "To dynamically change search fields based on request content, it's possible to subclass the SearchFilter and override the get_search_fields() function. For example, the following subclass will only search on title if the query parameter title_only is in the request:", "For more details, see the Django documentation.", "The OrderingFilter class supports simple query parameter controlled ordering of results.", "", "By default, the query parameter is named 'ordering', but this may by overridden with the ORDERING_PARAM setting.", "For example, to order users by username:", "The client may also specify reverse orderings by prefixing the field name with '-', like so:", "Multiple orderings may also be specified:", "It's recommended that you explicitly specify which fields the API should allowing in the ordering filter. You can do this by setting an ordering_fields attribute on the view, like so:", "This helps prevent unexpected data leakage, such as allowing users to order against a password hash field or other sensitive data.", "If you don't specify an ordering_fields attribute on the view, the filter class will default to allowing the user to filter on any readable fields on the serializer specified by the serializer_class attribute.", "If you are confident that the queryset being used by the view doesn't contain any sensitive data, you can also explicitly specify that a view should allow ordering on any model field or queryset aggregate, by using the special value '__all__'.", "If an ordering attribute is set on the view, this will be used as the default ordering.", "Typically you'd instead control this by setting order_by on the initial queryset, but using the ordering parameter on the view allows you to specify the ordering in a way that it can then be passed automatically as context to a rendered template. This makes it possible to automatically render column headers differently if they are being used to order the results.", "The ordering attribute may be either a string or a list/tuple of strings.", "You can also provide your own generic filtering backend, or write an installable app for other developers to use.", "To do so override BaseFilterBackend, and override the .filter_queryset(self, request, queryset, view) method. The method should return a new, filtered queryset.", "As well as allowing clients to perform searches and filtering, generic filter backends can be useful for restricting which objects should be visible to any given request or user.", "For example, you might need to restrict users to only being able to see objects they created.", "We could achieve the same behavior by overriding get_queryset() on the views, but using a filter backend allows you to more easily add this restriction to multiple views, or to apply it across the entire API.", "Generic filters may also present an interface in the browsable API. To do so you should implement a to_html() method which returns a rendered HTML representation of the filter. This method should have the following signature:", "to_html(self, request, queryset, view)", "The method should return a rendered HTML string.", "You can also make the filter controls available to the schema autogeneration that REST framework provides, by implementing a get_schema_fields() method. This method should have the following signature:", "get_schema_fields(self, view)", "The method should return a list of coreapi.Field instances.", "The following third party packages provide additional filter implementations.", "The django-rest-framework-filters package works together with the DjangoFilterBackend class, and allows you to easily create filters across relationships, or create multiple filter lookup types for a given field.", "The djangorestframework-word-filter developed as alternative to filters.SearchFilter which will search full word in text, or exact match.", "django-url-filter provides a safe way to filter data via human-friendly URLs. It works very similar to DRF serializers and fields in a sense that they can be nested except they are called filtersets and filters. That provides easy way to filter related data. Also this library is generic-purpose so it can be used to filter other sources of data and not only Django QuerySets.", "drf-url-filter is a simple Django app to apply filters on drf ModelViewSet's Queryset in a clean, simple and configurable way. It also supports validations on incoming query params and their values. A beautiful python package Voluptuous is being used for validations on the incoming query parameters. The best part about voluptuous is you can define your own validations as per your query params requirements.", "filters.py"]}, {"name": "FloatField", "path": "api-guide/fields/index#floatfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "Format suffixes", "path": "api-guide/format-suffixes/index", "type": "API Guide", "text": ["Section 6.2.1 does not say that content negotiation should be used all the time.", "\u2014 Roy Fielding, REST discuss mailing list", "A common pattern for Web APIs is to use filename extensions on URLs to provide an endpoint for a given media type. For example, 'http://example.com/api/users.json' to serve a JSON representation.", "Adding format-suffix patterns to each individual entry in the URLconf for your API is error-prone and non-DRY, so REST framework provides a shortcut to adding these patterns to your URLConf.", "Signature: format_suffix_patterns(urlpatterns, suffix_required=False, allowed=None)", "Returns a URL pattern list which includes format suffix patterns appended to each of the URL patterns provided.", "Arguments:", "Example:", "When using format_suffix_patterns, you must make sure to add the 'format' keyword argument to the corresponding views. For example:", "Or with class-based views:", "The name of the kwarg used may be modified by using the FORMAT_SUFFIX_KWARG setting.", "Also note that format_suffix_patterns does not support descending into include URL patterns.", "If using the i18n_patterns function provided by Django, as well as format_suffix_patterns you should make sure that the i18n_patterns function is applied as the final, or outermost function. For example:", "An alternative to the format suffixes is to include the requested format in a query parameter. REST framework provides this option by default, and it is used in the browsable API to switch between differing available representations.", "To select a representation using its short format, use the format query parameter. For example: http://example.com/organizations/?format=csv.", "The name of this query parameter can be modified using the URL_FORMAT_OVERRIDE setting. Set the value to None to disable this behavior.", "There seems to be a view among some of the Web community that filename extensions are not a RESTful pattern, and that HTTP Accept headers should always be used instead.", "It is actually a misconception. For example, take the following quote from Roy Fielding discussing the relative merits of query parameter media-type indicators vs. file extension media-type indicators:", "\u201cThat's why I always prefer extensions. Neither choice has anything to do with REST.\u201d \u2014 Roy Fielding, REST discuss mailing list", "The quote does not mention Accept headers, but it does make it clear that format suffixes should be considered an acceptable pattern.", "urlpatterns.py"]}, {"name": "FormParser", "path": "api-guide/parsers/index#formparser", "type": "Ref: Parsers", "text": ["Machine interacting web services tend to use more structured formats for sending data than form-encoded, since they're sending more complex data than simple forms", "\u2014 Malcom Tredinnick, Django developers group", "REST framework includes a number of built in Parser classes, that allow you to accept requests with various media types. There is also support for defining your own custom parsers, which gives you the flexibility to design the media types that your API accepts.", "The set of valid parsers for a view is always defined as a list of classes. When request.data is accessed, REST framework will examine the Content-Type header on the incoming request, and determine which parser to use to parse the request content.", "Note: When developing client applications always remember to make sure you're setting the Content-Type header when sending data in an HTTP request.", "If you don't set the content type, most clients will default to using 'application/x-www-form-urlencoded', which may not be what you wanted.", "As an example, if you are sending json encoded data using jQuery with the .ajax() method, you should make sure to include the contentType: 'application/json' setting.", "The default set of parsers may be set globally, using the DEFAULT_PARSER_CLASSES setting. For example, the following settings would allow only requests with JSON content, instead of the default of JSON or form data.", "You can also set the parsers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Parses JSON request content. request.data will be populated with a dictionary of data.", ".media_type: application/json", "Parses HTML form content. request.data will be populated with a QueryDict of data.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: application/x-www-form-urlencoded", "Parses multipart HTML form content, which supports file uploads. Both request.data will be populated with a QueryDict.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: multipart/form-data", "Parses raw file upload content. The request.data property will be a dictionary with a single key 'file' containing the uploaded file.", "If the view used with FileUploadParser is called with a filename URL keyword argument, then that argument will be used as the filename.", "If it is called without a filename URL keyword argument, then the client must set the filename in the Content-Disposition HTTP header. For example Content-Disposition: attachment; filename=upload.jpg.", ".media_type: */*", "To implement a custom parser, you should override BaseParser, set the .media_type property, and implement the .parse(self, stream, media_type, parser_context) method.", "The method should return the data that will be used to populate the request.data property.", "The arguments passed to .parse() are:", "A stream-like object representing the body of the request.", "Optional. If provided, this is the media type of the incoming request content.", "Depending on the request's Content-Type: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"text/plain; charset=utf-8\".", "Optional. If supplied, this argument will be a dictionary containing any additional context that may be required to parse the request content.", "By default this will include the following keys: view, request, args, kwargs.", "The following is an example plaintext parser that will populate the request.data property with a string representing the body of the request.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "parsers.py"]}, {"name": "Generic view settings", "path": "api-guide/settings/index#generic-view-settings", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "Generic views", "path": "api-guide/generic-views/index", "type": "API Guide", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "GenericAPIView", "path": "api-guide/generic-views/index#genericapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "GenericViewSet", "path": "api-guide/viewsets/index#genericviewset", "type": "Ref: ViewSets", "text": ["After routing has determined which controller to use for a request, your controller is responsible for making sense of the request and producing the appropriate output.", "\u2014 Ruby on Rails Documentation", "Django REST framework allows you to combine the logic for a set of related views in a single class, called a ViewSet. In other frameworks you may also find conceptually similar implementations named something like 'Resources' or 'Controllers'.", "A ViewSet class is simply a type of class-based View, that does not provide any method handlers such as .get() or .post(), and instead provides actions such as .list() and .create().", "The method handlers for a ViewSet are only bound to the corresponding actions at the point of finalizing the view, using the .as_view() method.", "Typically, rather than explicitly registering the views in a viewset in the urlconf, you'll register the viewset with a router class, that automatically determines the urlconf for you.", "Let's define a simple viewset that can be used to list or retrieve all the users in the system.", "If we need to, we can bind this viewset into two separate views, like so:", "Typically we wouldn't do this, but would instead register the viewset with a router, and allow the urlconf to be automatically generated.", "Rather than writing your own viewsets, you'll often want to use the existing base classes that provide a default set of behavior. For example:", "There are two main advantages of using a ViewSet class over using a View class.", "Both of these come with a trade-off. Using regular views and URL confs is more explicit and gives you more control. ViewSets are helpful if you want to get up and running quickly, or when you have a large API and you want to enforce a consistent URL configuration throughout.", "The default routers included with REST framework will provide routes for a standard set of create/retrieve/update/destroy style actions, as shown below:", "During dispatch, the following attributes are available on the ViewSet.", "You may inspect these attributes to adjust behaviour based on the current action. For example, you could restrict permissions to everything except the list action similar to this:", "If you have ad-hoc methods that should be routable, you can mark them as such with the @action decorator. Like regular actions, extra actions may be intended for either a single object, or an entire collection. To indicate this, set the detail argument to True or False. The router will configure its URL patterns accordingly. e.g., the DefaultRouter will configure detail actions to contain pk in their URL patterns.", "A more complete example of extra actions:", "The action decorator will route GET requests by default, but may also accept other HTTP methods by setting the methods argument. For example:", "The decorator allows you to override any viewset-level configuration such as permission_classes, serializer_class, filter_backends...:", "The two new actions will then be available at the urls ^users/{pk}/set_password/$ and ^users/{pk}/unset_password/$. Use the url_path and url_name parameters to change the URL segment and the reverse URL name of the action.", "To view all extra actions, call the .get_extra_actions() method.", "Extra actions can map additional HTTP methods to separate ViewSet methods. For example, the above password set/unset methods could be consolidated into a single route. Note that additional mappings do not accept arguments.", "If you need to get the URL of an action, use the .reverse_action() method. This is a convenience wrapper for reverse(), automatically passing the view's request object and prepending the url_name with the .basename attribute.", "Note that the basename is provided by the router during ViewSet registration. If you are not using a router, then you must provide the basename argument to the .as_view() method.", "Using the example from the previous section:", "Alternatively, you can use the url_name attribute set by the @action decorator.", "The url_name argument for .reverse_action() should match the same argument to the @action decorator. Additionally, this method can be used to reverse the default actions, such as list and create.", "The ViewSet class inherits from APIView. You can use any of the standard attributes such as permission_classes, authentication_classes in order to control the API policy on the viewset.", "The ViewSet class does not provide any implementations of actions. In order to use a ViewSet class you'll override the class and define the action implementations explicitly.", "The GenericViewSet class inherits from GenericAPIView, and provides the default set of get_object, get_queryset methods and other generic view base behavior, but does not include any actions by default.", "In order to use a GenericViewSet class you'll override the class and either mixin the required mixin classes, or define the action implementations explicitly.", "The ModelViewSet class inherits from GenericAPIView and includes implementations for various actions, by mixing in the behavior of the various mixin classes.", "The actions provided by the ModelViewSet class are .list(), .retrieve(), .create(), .update(), .partial_update(), and .destroy().", "Because ModelViewSet extends GenericAPIView, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Note that you can use any of the standard attributes or method overrides provided by GenericAPIView. For example, to use a ViewSet that dynamically determines the queryset it should operate on, you might do something like this:", "Note however that upon removal of the queryset property from your ViewSet, any associated router will be unable to derive the basename of your Model automatically, and so you will have to specify the basename kwarg as part of your router registration.", "Also note that although this class provides the complete set of create/list/retrieve/update/destroy actions by default, you can restrict the available operations by using the standard permission classes.", "The ReadOnlyModelViewSet class also inherits from GenericAPIView. As with ModelViewSet it also includes implementations for various actions, but unlike ModelViewSet only provides the 'read-only' actions, .list() and .retrieve().", "As with ModelViewSet, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Again, as with ModelViewSet, you can use any of the standard attributes and method overrides available to GenericAPIView.", "You may need to provide custom ViewSet classes that do not have the full set of ModelViewSet actions, or that customize the behavior in some other way.", "To create a base viewset class that provides create, list and retrieve operations, inherit from GenericViewSet, and mixin the required actions:", "By creating your own base ViewSet classes, you can provide common behavior that can be reused in multiple viewsets across your API.", "viewsets.py"]}, {"name": "HiddenField", "path": "api-guide/fields/index#hiddenfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "HostNameVersioning", "path": "api-guide/versioning/index#hostnameversioning", "type": "Ref: Versioning", "text": ["Versioning an interface is just a \"polite\" way to kill deployed clients.", "\u2014 Roy Fielding.", "API versioning allows you to alter behavior between different clients. REST framework provides for a number of different versioning schemes.", "Versioning is determined by the incoming client request, and may either be based on the request URL, or based on the request headers.", "There are a number of valid approaches to approaching versioning. Non-versioned systems can also be appropriate, particularly if you're engineering for very long-term systems with multiple clients outside of your control.", "When API versioning is enabled, the request.version attribute will contain a string that corresponds to the version requested in the incoming client request.", "By default, versioning is not enabled, and request.version will always return None.", "How you vary the API behavior is up to you, but one example you might typically want is to switch to a different serialization style in a newer version. For example:", "The reverse function included by REST framework ties in with the versioning scheme. You need to make sure to include the current request as a keyword argument, like so.", "The above function will apply any URL transformations appropriate to the request version. For example:", "When using hyperlinked serialization styles together with a URL based versioning scheme make sure to include the request as context to the serializer.", "Doing so will allow any returned URLs to include the appropriate versioning.", "The versioning scheme is defined by the DEFAULT_VERSIONING_CLASS settings key.", "Unless it is explicitly set, the value for DEFAULT_VERSIONING_CLASS will be None. In this case the request.version attribute will always return None.", "You can also set the versioning scheme on an individual view. Typically you won't need to do this, as it makes more sense to have a single versioning scheme used globally. If you do need to do so, use the versioning_class attribute.", "The following settings keys are also used to control versioning:", "You can also set your versioning class plus those three values on a per-view or a per-viewset basis by defining your own versioning scheme and using the default_version, allowed_versions and version_param class variables. For example, if you want to use URLPathVersioning:", "This scheme requires the client to specify the version as part of the media type in the Accept header. The version is included as a media type parameter, that supplements the main media type.", "Here's an example HTTP request using the accept header versioning style.", "In the example request above request.version attribute would return the string '1.0'.", "Versioning based on accept headers is generally considered as best practice, although other styles may be suitable depending on your client requirements.", "Strictly speaking the json media type is not specified as including additional parameters. If you are building a well-specified public API you might consider using a vendor media type. To do so, configure your renderers to use a JSON based renderer with a custom media type:", "Your client requests would now look like this:", "This scheme requires the client to specify the version as part of the URL path.", "Your URL conf must include a pattern that matches the version with a 'version' keyword argument, so that this information is available to the versioning scheme.", "To the client, this scheme is the same as URLPathVersioning. The only difference is how it is configured in your Django application, as it uses URL namespacing, instead of URL keyword arguments.", "With this scheme the request.version attribute is determined based on the namespace that matches the incoming request path.", "In the following example we're giving a set of views two different possible URL prefixes, each under a different namespace:", "Both URLPathVersioning and NamespaceVersioning are reasonable if you just need a simple versioning scheme. The URLPathVersioning approach might be better suitable for small ad-hoc projects, and the NamespaceVersioning is probably easier to manage for larger projects.", "The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.", "For example the following is an HTTP request to the http://v1.example.com/bookings/ URL:", "By default this implementation expects the hostname to match this simple regular expression:", "Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.", "The HostNameVersioning scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as 127.0.0.1. There are various online tutorials on how to access localhost with a custom subdomain which you may find helpful in this case.", "Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.", "This scheme is a simple style that includes the version as a query parameter in the URL. For example:", "To implement a custom versioning scheme, subclass BaseVersioning and override the .determine_version method.", "The following example uses a custom X-API-Version header to determine the requested version.", "If your versioning scheme is based on the request URL, you will also want to alter how versioned URLs are determined. In order to do so you should override the .reverse() method on the class. See the source code for examples.", "versioning.py"]}, {"name": "HStoreField", "path": "api-guide/fields/index#hstorefield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "HTML Select Field cutoffs", "path": "api-guide/settings/index#html-select-field-cutoffs", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "HTMLFormRenderer", "path": "api-guide/renderers/index#htmlformrenderer", "type": "Ref: Renderers", "text": ["Before a TemplateResponse instance can be returned to the client, it must be rendered. The rendering process takes the intermediate representation of template and context, and turns it into the final byte stream that can be served to the client.", "\u2014 Django documentation", "REST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.", "The set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.", "The basic process of content negotiation involves examining the request's Accept header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL http://example.com/api/users_count.json might be an endpoint that always returns JSON data.", "For more information see the documentation on content negotiation.", "The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use JSON as the main media type and also include the self describing API.", "You can also set the renderers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "It's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an Accept: */* header, or not including an Accept header at all, then REST framework will select the first renderer in the list to use for the response.", "For example if your API serves JSON responses and the HTML browsable API, you might want to make JSONRenderer your default renderer, in order to send JSON responses to clients that do not specify an Accept header.", "If your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making TemplateHTMLRenderer your default renderer, in order to play nicely with older browsers that send broken accept headers.", "Renders the request data into JSON, using utf-8 encoding.", "Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:", "The client may additionally include an 'indent' media type parameter, in which case the returned JSON will be indented. For example Accept: application/json; indent=4.", "The default JSON encoding style can be altered using the UNICODE_JSON and COMPACT_JSON settings keys.", ".media_type: application/json", ".format: 'json'", ".charset: None", "Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the Response does not need to be serialized. Also, unlike other renderers, you may want to include a template_name argument when creating the Response.", "The TemplateHTMLRenderer will create a RequestContext, using the response.data as the context dict, and determine a template name to use to render the context.", "Note: When used with a view that makes use of a serializer the Response sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the TemplateHTMLRenderer to render it. For example:", "The template name is determined by (in order of preference):", "An example of a view that uses TemplateHTMLRenderer:", "You can use TemplateHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", "If you're building websites that use TemplateHTMLRenderer along with other renderer classes, you should consider listing TemplateHTMLRenderer as the first class in the renderer_classes list, so that it will be prioritised first even for browsers that send poorly formed ACCEPT: headers.", "See the HTML & Forms Topic Page for further examples of TemplateHTMLRenderer usage.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: StaticHTMLRenderer", "A simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.", "An example of a view that uses StaticHTMLRenderer:", "You can use StaticHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: TemplateHTMLRenderer", "Renders data into HTML for the Browsable API:", "", "This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.", ".media_type: text/html", ".format: 'api'", ".charset: utf-8", ".template: 'rest_framework/api.html'", "By default the response content will be rendered with the highest priority renderer apart from BrowsableAPIRenderer. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the get_default_renderer() method. For example:", "Renders data into HTML for an admin-like display:", "", "This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.", "Note that views that have nested or list serializers for their input won't work well with the AdminRenderer, as the HTML forms are unable to properly support them.", "Note: The AdminRenderer is only able to include links to detail pages when a properly configured URL_FIELD_NAME (url by default) attribute is present in the data. For HyperlinkedModelSerializer this will be the case, but for ModelSerializer or plain Serializer classes you'll need to make sure to include the field explicitly. For example here we use models get_absolute_url method:", ".media_type: text/html", ".format: 'admin'", ".charset: utf-8", ".template: 'rest_framework/admin.html'", "Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing <form> tags, a hidden CSRF input or any submit buttons.", "This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the render_form template tag.", "For more information see the HTML & Forms documentation.", ".media_type: text/html", ".format: 'form'", ".charset: utf-8", ".template: 'rest_framework/horizontal/form.html'", "This renderer is used for rendering HTML multipart form data. It is not suitable as a response renderer, but is instead used for creating test requests, using REST framework's test client and test request factory.", ".media_type: multipart/form-data; boundary=BoUnDaRyStRiNg", ".format: 'multipart'", ".charset: utf-8", "To implement a custom renderer, you should override BaseRenderer, set the .media_type and .format properties, and implement the .render(self, data, media_type=None, renderer_context=None) method.", "The method should return a bytestring, which will be used as the body of the HTTP response.", "The arguments passed to the .render() method are:", "The request data, as set by the Response() instantiation.", "Optional. If provided, this is the accepted media type, as determined by the content negotiation stage.", "Depending on the client's Accept: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"application/json; nested=true\".", "Optional. If provided, this is a dictionary of contextual information provided by the view.", "By default this will include the following keys: view, request, response, args, kwargs.", "The following is an example plaintext renderer that will return a response with the data parameter as the content of the response.", "By default renderer classes are assumed to be using the UTF-8 encoding. To use a different encoding, set the charset attribute on the renderer.", "Note that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the Response class, with the charset attribute set on the renderer used to determine the encoding.", "If the renderer returns a bytestring representing raw binary content, you should set a charset value of None, which will ensure the Content-Type header of the response will not have a charset value set.", "In some cases you may also want to set the render_style attribute to 'binary'. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.", "You can do some pretty flexible things using REST framework's renderers. Some examples...", "In some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access request.accepted_renderer to determine the negotiated renderer that will be used for the response.", "For example:", "In some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a media_type value such as image/*, or */*.", "If you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the content_type attribute. For example:", "For the purposes of many Web APIs, simple JSON responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and HATEOAS you'll need to consider the design and usage of your media types in more detail.", "In the words of Roy Fielding, \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".", "For good examples of custom media types, see GitHub's use of a custom application/vnd.github+json media type, and Mike Amundsen's IANA approved application/vnd.collection+json JSON-based hypermedia.", "Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an Http404 or PermissionDenied exception, or a subclass of APIException.", "If you're using either the TemplateHTMLRenderer or the StaticHTMLRenderer and an exception is raised, the behavior is slightly different, and mirrors Django's default handling of error views.", "Exceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.", "Templates will render with a RequestContext which includes the status_code and details keys.", "Note: If DEBUG=True, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST framework JSONP provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Warning: If you require cross-domain AJAX requests, you should generally be using the more modern approach of CORS as an alternative to JSONP. See the CORS documentation for more details.", "The jsonp approach is essentially a browser hack, and is only appropriate for globally readable API endpoints, where GET requests are unauthenticated and do not require any user permissions.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "XLSX is the world's most popular binary spreadsheet format. Tim Allen of The Wharton School maintains drf-renderer-xlsx, which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.", "Install using pip.", "Modify your REST framework settings.", "To avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the Content-Disposition header. If no filename is provided, it will default to export.xlsx. For example:", "Comma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. Mjumbe Poe maintains the djangorestframework-csv package which provides CSV renderer support for REST framework.", "UltraJSON is an optimized C JSON encoder which can give significantly faster JSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now unmaintained drf-ujson-renderer, which implements JSON rendering using the UJSON package.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "Django REST Pandas provides a serializer and renderers that support additional data processing and output via the Pandas DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both .xls and .xlsx), and a number of other formats. It is maintained by S. Andrew Sheppard as part of the wq Project.", "Rest Framework Latex provides a renderer that outputs PDFs using Laulatex. It is maintained by Pebble (S/F Software).", "renderers.py"]}, {"name": "HyperlinkedIdentityField", "path": "api-guide/relations/index#hyperlinkedidentityfield", "type": "Ref: Serializer relations", "text": ["Data structures, not algorithms, are central to programming.", "\u2014 Rob Pike", "Relational fields are used to represent model relationships. They can be applied to ForeignKey, ManyToManyField and OneToOneField relationships, as well as to reverse relationships, and custom relationships such as GenericForeignKey.", "Note: The relational fields are declared in relations.py, but by convention you should import them from the serializers module, using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "When using the ModelSerializer class, serializer fields and relationships will be automatically generated for you. Inspecting these automatically generated fields can be a useful tool for determining how to customize the relationship style.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "In order to explain the various types of relational fields, we'll use a couple of simple models for our examples. Our models will be for music albums, and the tracks listed on each album.", "StringRelatedField may be used to represent the target of the relationship using its __str__ method.", "For example, the following serializer:", "Would serialize to the following representation:", "This field is read only.", "Arguments:", "PrimaryKeyRelatedField may be used to represent the target of the relationship using its primary key.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Arguments:", "HyperlinkedRelatedField may be used to represent the target of the relationship using a hyperlink.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Note: This field is designed for objects that map to a URL that accepts a single URL keyword argument, as set using the lookup_field and lookup_url_kwarg arguments.", "This is suitable for URLs that contain a single primary key or slug argument as part of the URL.", "If you require more complex hyperlinked representation you'll need to customize the field, as described in the custom hyperlinked fields section, below.", "Arguments:", "SlugRelatedField may be used to represent the target of the relationship using a field on the target.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "When using SlugRelatedField as a read-write field, you will normally want to ensure that the slug field corresponds to a model field with unique=True.", "Arguments:", "This field can be applied as an identity relationship, such as the 'url' field on a HyperlinkedModelSerializer. It can also be used for an attribute on the object. For example, the following serializer:", "Would serialize to a representation like this:", "This field is always read-only.", "Arguments:", "As opposed to previously discussed references to another entity, the referred entity can instead also be embedded or nested in the representation of the object that refers to it. Such nested relationships can be expressed by using serializers as fields. ", "If the field is used to represent a to-many relationship, you should add the many=True flag to the serializer field.", "For example, the following serializer:", "Would serialize to a nested representation like this:", "By default nested serializers are read-only. If you want to support write-operations to a nested serializer field you'll need to create create() and/or update() methods in order to explicitly specify how the child relationships should be saved:", "In rare cases where none of the existing relational styles fit the representation you need, you can implement a completely custom relational field, that describes exactly how the output representation should be generated from the model instance.", "To implement a custom relational field, you should override RelatedField, and implement the .to_representation(self, value) method. This method takes the target of the field as the value argument, and should return the representation that should be used to serialize the target. The value argument will typically be a model instance.", "If you want to implement a read-write relational field, you must also implement the .to_internal_value(self, data) method.", "To provide a dynamic queryset based on the context, you can also override .get_queryset(self) instead of specifying .queryset on the class or when initializing the field.", "For example, we could define a relational field to serialize a track to a custom string representation, using its ordering, title, and duration:", "This custom field would then serialize to the following representation:", "In some cases you may need to customize the behavior of a hyperlinked field, in order to represent URLs that require more than a single lookup field.", "You can achieve this by overriding HyperlinkedRelatedField. There are two methods that may be overridden:", "get_url(self, obj, view_name, request, format)", "The get_url method is used to map the object instance to its URL representation.", "May raise a NoReverseMatch if the view_name and lookup_field attributes are not configured to correctly match the URL conf.", "get_object(self, view_name, view_args, view_kwargs)", "If you want to support a writable hyperlinked field then you'll also want to override get_object, in order to map incoming URLs back to the object they represent. For read-only hyperlinked fields there is no need to override this method.", "The return value of this method should the object that corresponds to the matched URL conf arguments.", "May raise an ObjectDoesNotExist exception.", "Say we have a URL for a customer object that takes two keyword arguments, like so:", "This cannot be represented with the default implementation, which accepts only a single lookup field.", "In this case we'd need to override HyperlinkedRelatedField to get the behavior we want:", "Note that if you wanted to use this style together with the generic views then you'd also need to override .get_object on the view in order to get the correct lookup behavior.", "Generally we recommend a flat style for API representations where possible, but the nested URL style can also be reasonable when used in moderation.", "The queryset argument is only ever required for writable relationship field, in which case it is used for performing the model instance lookup, that maps from the primitive user input, into a model instance.", "In version 2.x a serializer class could sometimes automatically determine the queryset argument if a ModelSerializer class was being used.", "This behavior is now replaced with always using an explicit queryset argument for writable relational fields.", "Doing so reduces the amount of hidden 'magic' that ModelSerializer provides, makes the behavior of the field more clear, and ensures that it is trivial to move between using the ModelSerializer shortcut, or using fully explicit Serializer classes.", "The built-in __str__ method of the model will be used to generate string representations of the objects used to populate the choices property. These choices are used to populate select HTML inputs in the browsable API.", "To provide customized representations for such inputs, override display_value() of a RelatedField subclass. This method will receive a model object, and should return a string suitable for representing it. For example:", "When rendered in the browsable API relational fields will default to only displaying a maximum of 1000 selectable items. If more items are present then a disabled option with \"More than 1000 items\u2026\" will be displayed.", "This behavior is intended to prevent a template from being unable to render in an acceptable timespan due to a very large number of relationships being displayed.", "There are two keyword arguments you can use to control this behavior:", "You can also control these globally using the settings HTML_SELECT_CUTOFF and HTML_SELECT_CUTOFF_TEXT.", "In cases where the cutoff is being enforced you may want to instead use a plain input field in the HTML form. You can do so using the style keyword argument. For example:", "Note that reverse relationships are not automatically included by the ModelSerializer and HyperlinkedModelSerializer classes. To include a reverse relationship, you must explicitly add it to the fields list. For example:", "You'll normally want to ensure that you've set an appropriate related_name argument on the relationship, that you can use as the field name. For example:", "If you have not set a related name for the reverse relationship, you'll need to use the automatically generated related name in the fields argument. For example:", "See the Django documentation on reverse relationships for more details.", "If you want to serialize a generic foreign key, you need to define a custom field, to determine explicitly how you want to serialize the targets of the relationship.", "For example, given the following model for a tag, which has a generic relationship with other arbitrary models:", "And the following two models, which may have associated tags:", "We could define a custom field that could be used to serialize tagged instances, using the type of each instance to determine how it should be serialized:", "If you need the target of the relationship to have a nested representation, you can use the required serializers inside the .to_representation() method:", "Note that reverse generic keys, expressed using the GenericRelation field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.", "For more information see the Django documentation on generic relations.", "By default, relational fields that target a ManyToManyField with a through model specified are set to read-only.", "If you explicitly specify a relational field pointing to a ManyToManyField with a through model, be sure to set read_only to True.", "If you wish to represent extra fields on a through model then you may serialize the through model as a nested object.", "The following third party packages are also available.", "The drf-nested-routers package provides routers and relationship fields for working with nested resources.", "The rest-framework-generic-relations library provides read/write serialization for generic foreign keys.", "relations.py"]}, {"name": "HyperlinkedModelSerializer", "path": "api-guide/serializers/index#hyperlinkedmodelserializer", "type": "Ref: Serializers", "text": ["Expanding the usefulness of the serializers is something that we would like to address. However, it's not a trivial problem, and it will take some serious design work.", "\u2014 Russell Keith-Magee, Django users group", "Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.", "The serializers in REST framework work very similarly to Django's Form and ModelForm classes. We provide a Serializer class which gives you a powerful, generic way to control the output of your responses, as well as a ModelSerializer class which provides a useful shortcut for creating serializers that deal with model instances and querysets.", "Let's start by creating a simple object we can use for example purposes:", "We'll declare a serializer that we can use to serialize and deserialize data that corresponds to Comment objects.", "Declaring a serializer looks very similar to declaring a form:", "We can now use CommentSerializer to serialize a comment, or list of comments. Again, using the Serializer class looks a lot like using a Form class.", "At this point we've translated the model instance into Python native datatypes. To finalise the serialization process we render the data into json.", "Deserialization is similar. First we parse a stream into Python native datatypes...", "...then we restore those native datatypes into a dictionary of validated data.", "If we want to be able to return complete object instances based on the validated data we need to implement one or both of the .create() and .update() methods. For example:", "If your object instances correspond to Django models you'll also want to ensure that these methods save the object to the database. For example, if Comment was a Django model, the methods might look like this:", "Now when deserializing data, we can call .save() to return an object instance, based on the validated data.", "Calling .save() will either create a new instance, or update an existing instance, depending on if an existing instance was passed when instantiating the serializer class:", "Both the .create() and .update() methods are optional. You can implement either neither, one, or both of them, depending on the use-case for your serializer class.", "Sometimes you'll want your view code to be able to inject additional data at the point of saving the instance. This additional data might include information like the current user, the current time, or anything else that is not part of the request data.", "You can do so by including additional keyword arguments when calling .save(). For example:", "Any additional keyword arguments will be included in the validated_data argument when .create() or .update() are called.", "In some cases the .create() and .update() method names may not be meaningful. For example, in a contact form we may not be creating new instances, but instead sending an email or other message.", "In these cases you might instead choose to override .save() directly, as being more readable and meaningful.", "For example:", "Note that in the case above we're now having to access the serializer .validated_data property directly.", "When deserializing data, you always need to call is_valid() before attempting to access the validated data, or save an object instance. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example:", "Each key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The non_field_errors key may also be present, and will list any general validation errors. The name of the non_field_errors key may be customized using the NON_FIELD_ERRORS_KEY REST framework setting.", "When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items.", "The .is_valid() method takes an optional raise_exception flag that will cause it to raise a serializers.ValidationError exception if there are validation errors.", "These exceptions are automatically dealt with by the default exception handler that REST framework provides, and will return HTTP 400 Bad Request responses by default.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. These are similar to the .clean_<field_name> methods on Django forms.", "These methods take a single argument, which is the field value that requires validation.", "Your validate_<field_name> methods should return the validated value or raise a serializers.ValidationError. For example:", "Note: If your <field_name> is declared on your serializer with the parameter required=False then this validation step will not take place if the field is not included.", "To do any other validation that requires access to multiple fields, add a method called .validate() to your Serializer subclass. This method takes a single argument, which is a dictionary of field values. It should raise a serializers.ValidationError if necessary, or just return the validated values. For example:", "Individual fields on a serializer can include validators, by declaring them on the field instance, for example:", "Serializer classes can also include reusable validators that are applied to the complete set of field data. These validators are included by declaring them on an inner Meta class, like so:", "For more information see the validators documentation.", "When passing an initial object or queryset to a serializer instance, the object will be made available as .instance. If no initial object is passed then the .instance attribute will be None.", "When passing data to a serializer instance, the unmodified data will be made available as .initial_data. If the data keyword argument is not passed then the .initial_data attribute will not exist.", "By default, serializers must be passed values for all required fields or they will raise validation errors. You can use the partial argument in order to allow partial updates.", "The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers.", "The Serializer class is itself a type of Field, and can be used to represent relationships where one object type is nested inside another.", "If a nested representation may optionally accept the None value you should pass the required=False flag to the nested serializer.", "Similarly if a nested representation should be a list of items, you should pass the many=True flag to the nested serializer.", "When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object.", "Similarly, the .validated_data property will include nested data structures.", "If you're supporting writable nested representations you'll need to write .create() or .update() methods that handle saving multiple objects.", "The following example demonstrates how you might handle creating a user with a nested profile object.", "For updates you'll want to think carefully about how to handle updates to relationships. For example if the data for the relationship is None, or not provided, which of the following should occur?", "Here's an example for an .update() method on our previous UserSerializer class.", "Because the behavior of nested creates and updates can be ambiguous, and may require complex dependencies between related models, REST framework 3 requires you to always write these methods explicitly. The default ModelSerializer .create() and .update() methods do not include support for writable nested representations.", "There are however, third-party packages available such as DRF Writable Nested that support automatic writable nested representations.", "An alternative to saving multiple related instances in the serializer is to write custom model manager classes that handle creating the correct instances.", "For example, suppose we wanted to ensure that User instances and Profile instances are always created together as a pair. We might write a custom manager class that looks something like this:", "This manager class now more nicely encapsulates that user instances and profile instances are always created at the same time. Our .create() method on the serializer class can now be re-written to use the new manager method.", "For more details on this approach see the Django documentation on model managers, and this blogpost on using model and manager classes.", "The Serializer class can also handle serializing or deserializing lists of objects.", "To serialize a queryset or list of objects instead of a single object instance, you should pass the many=True flag when instantiating the serializer. You can then pass a queryset or list of objects to be serialized.", "The default behavior for deserializing multiple objects is to support multiple object creation, but not support multiple object updates. For more information on how to support or customize either of these cases, see the ListSerializer documentation below.", "There are some cases where you need to provide extra context to the serializer in addition to the object being serialized. One common case is if you're using a serializer that includes hyperlinked relations, which requires the serializer to have access to the current request so that it can properly generate fully qualified URLs.", "You can provide arbitrary additional context by passing a context argument when instantiating the serializer. For example:", "The context dictionary can be used within any serializer field logic, such as a custom .to_representation() method, by accessing the self.context attribute.", "Often you'll want serializer classes that map closely to Django model definitions.", "The ModelSerializer class provides a shortcut that lets you automatically create a Serializer class with fields that correspond to the Model fields.", "The ModelSerializer class is the same as a regular Serializer class, except that:", "Declaring a ModelSerializer looks like this:", "By default, all the model fields on the class will be mapped to a corresponding serializer fields.", "Any relationships such as foreign keys on the model will be mapped to PrimaryKeyRelatedField. Reverse relationships are not included by default unless explicitly included as specified in the serializer relations documentation.", "Serializer classes generate helpful verbose representation strings, that allow you to fully inspect the state of their fields. This is particularly useful when working with ModelSerializers where you want to determine what set of fields and validators are being automatically created for you.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "If you only want a subset of the default fields to be used in a model serializer, you can do so using fields or exclude options, just as you would with a ModelForm. It is strongly recommended that you explicitly set all fields that should be serialized using the fields attribute. This will make it less likely to result in unintentionally exposing data when your models change.", "For example:", "You can also set the fields attribute to the special value '__all__' to indicate that all fields in the model should be used.", "For example:", "You can set the exclude attribute to a list of fields to be excluded from the serializer.", "For example:", "In the example above, if the Account model had 3 fields account_name, users, and created, this will result in the fields account_name and created to be serialized.", "The names in the fields and exclude attributes will normally map to model fields on the model class.", "Alternatively names in the fields options can map to properties or methods which take no arguments that exist on the model class.", "Since version 3.3.0, it is mandatory to provide one of the attributes fields or exclude.", "The default ModelSerializer uses primary keys for relationships, but you can also easily generate nested representations using the depth option:", "The depth option should be set to an integer value that indicates the depth of relationships that should be traversed before reverting to a flat representation.", "If you want to customize the way the serialization is done you'll need to define the field yourself.", "You can add extra fields to a ModelSerializer or override the default fields by declaring fields on the class, just as you would for a Serializer class.", "Extra fields can correspond to any property or callable on the model.", "You may wish to specify multiple fields as read-only. Instead of adding each field explicitly with the read_only=True attribute, you may use the shortcut Meta option, read_only_fields.", "This option should be a list or tuple of field names, and is declared as follows:", "Model fields which have editable=False set, and AutoField fields will be set to read-only by default, and do not need to be added to the read_only_fields option.", "Note: There is a special-case where a read-only field is part of a unique_together constraint at the model level. In this case the field is required by the serializer class in order to validate the constraint, but should also not be editable by the user.", "The right way to deal with this is to specify the field explicitly on the serializer, providing both the read_only=True and default=\u2026 keyword arguments.", "One example of this is a read-only relation to the currently authenticated User which is unique_together with another identifier. In this case you would declare the user field like so:", "Please review the Validators Documentation for details on the UniqueTogetherValidator and CurrentUserDefault classes.", "There is also a shortcut allowing you to specify arbitrary additional keyword arguments on fields, using the extra_kwargs option. As in the case of read_only_fields, this means you do not need to explicitly declare the field on the serializer.", "This option is a dictionary, mapping field names to a dictionary of keyword arguments. For example:", "Please keep in mind that, if the field has already been explicitly declared on the serializer class, then the extra_kwargs option will be ignored.", "When serializing model instances, there are a number of different ways you might choose to represent relationships. The default representation for ModelSerializer is to use the primary keys of the related instances.", "Alternative representations include serializing using hyperlinks, serializing complete nested representations, or serializing with a custom representation.", "For full details see the serializer relations documentation.", "The ModelSerializer class also exposes an API that you can override in order to alter how serializer fields are automatically determined when instantiating the serializer.", "Normally if a ModelSerializer does not generate the fields you need by default then you should either add them to the class explicitly, or simply use a regular Serializer class instead. However in some cases you may want to create a new base class that defines how the serializer fields are created for any given model.", "A mapping of Django model fields to REST framework serializer fields. You can override this mapping to alter the default serializer fields that should be used for each model field.", "This property should be the serializer field class, that is used for relational fields by default.", "For ModelSerializer this defaults to PrimaryKeyRelatedField.", "For HyperlinkedModelSerializer this defaults to serializers.HyperlinkedRelatedField.", "The serializer field class that should be used for any url field on the serializer.", "Defaults to serializers.HyperlinkedIdentityField", "The serializer field class that should be used for any choice fields on the serializer.", "Defaults to serializers.ChoiceField", "The following methods are called to determine the class and keyword arguments for each field that should be automatically included on the serializer. Each of these methods should return a two tuple of (field_class, field_kwargs).", "Called to generate a serializer field that maps to a standard model field.", "The default implementation returns a serializer class based on the serializer_field_mapping attribute.", "Called to generate a serializer field that maps to a relational model field.", "The default implementation returns a serializer class based on the serializer_related_field attribute.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a relational model field, when the depth option has been set.", "The default implementation dynamically creates a nested serializer class based on either ModelSerializer or HyperlinkedModelSerializer.", "The nested_depth will be the value of the depth option, minus one.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a property or zero-argument method on the model class.", "The default implementation returns a ReadOnlyField class.", "Called to generate a serializer field for the serializer's own url field. The default implementation returns a HyperlinkedIdentityField class.", "Called when the field name did not map to any model field or model property. The default implementation raises an error, although subclasses may customize this behavior.", "The HyperlinkedModelSerializer class is similar to the ModelSerializer class except that it uses hyperlinks to represent relationships, rather than primary keys.", "By default the serializer will include a url field instead of a primary key field.", "The url field will be represented using a HyperlinkedIdentityField serializer field, and any relationships on the model will be represented using a HyperlinkedRelatedField serializer field.", "You can explicitly include the primary key by adding it to the fields option, for example:", "When instantiating a HyperlinkedModelSerializer you must include the current request in the serializer context, for example:", "Doing so will ensure that the hyperlinks can include an appropriate hostname, so that the resulting representation uses fully qualified URLs, such as:", "Rather than relative URLs, such as:", "If you do want to use relative URLs, you should explicitly pass {'request': None} in the serializer context.", "There needs to be a way of determining which views should be used for hyperlinking to model instances.", "By default hyperlinks are expected to correspond to a view name that matches the style '{model_name}-detail', and looks up the instance by a pk keyword argument.", "You can override a URL field view name and lookup field by using either, or both of, the view_name and lookup_field options in the extra_kwargs setting, like so:", "Alternatively you can set the fields on the serializer explicitly. For example:", "Tip: Properly matching together hyperlinked representations and your URL conf can sometimes be a bit fiddly. Printing the repr of a HyperlinkedModelSerializer instance is a particularly useful way to inspect exactly which view names and lookup fields the relationships are expected to map too.", "The name of the URL field defaults to 'url'. You can override this globally, by using the URL_FIELD_NAME setting.", "The ListSerializer class provides the behavior for serializing and validating multiple objects at once. You won't typically need to use ListSerializer directly, but should instead simply pass many=True when instantiating a serializer.", "When a serializer is instantiated and many=True is passed, a ListSerializer instance will be created. The serializer class then becomes a child of the parent ListSerializer", "The following argument can also be passed to a ListSerializer field or a serializer that is passed many=True:", "This is True by default, but can be set to False if you want to disallow empty lists as valid input.", "There are a few use cases when you might want to customize the ListSerializer behavior. For example:", "For these cases you can modify the class that is used when many=True is passed, by using the list_serializer_class option on the serializer Meta class.", "For example:", "The default implementation for multiple object creation is to simply call .create() for each item in the list. If you want to customize this behavior, you'll need to customize the .create() method on ListSerializer class that is used when many=True is passed.", "For example:", "By default the ListSerializer class does not support multiple updates. This is because the behavior that should be expected for insertions and deletions is ambiguous.", "To support multiple updates you'll need to do so explicitly. When writing your multiple update code make sure to keep the following in mind:", "You will need to add an explicit id field to the instance serializer. The default implicitly-generated id field is marked as read_only. This causes it to be removed on updates. Once you declare it explicitly, it will be available in the list serializer's update method.", "Here's an example of how you might choose to implement multiple updates:", "It is possible that a third party package may be included alongside the 3.1 release that provides some automatic support for multiple update operations, similar to the allow_add_remove behavior that was present in REST framework 2.", "When a serializer with many=True is instantiated, we need to determine which arguments and keyword arguments should be passed to the .__init__() method for both the child Serializer class, and for the parent ListSerializer class.", "The default implementation is to pass all arguments to both classes, except for validators, and any custom keyword arguments, both of which are assumed to be intended for the child serializer class.", "Occasionally you might need to explicitly specify how the child and parent classes should be instantiated when many=True is passed. You can do so by using the many_init class method.", "BaseSerializer class that can be used to easily support alternative serialization and deserialization styles.", "This class implements the same basic API as the Serializer class:", "There are four methods that can be overridden, depending on what functionality you want the serializer class to support:", "Because this class provides the same interface as the Serializer class, you can use it with the existing generic class-based views exactly as you would for a regular Serializer or ModelSerializer.", "The only difference you'll notice when doing so is the BaseSerializer classes will not generate HTML forms in the browsable API. This is because the data they return does not include all the field information that would allow each field to be rendered into a suitable HTML input.", "To implement a read-only serializer using the BaseSerializer class, we just need to override the .to_representation() method. Let's take a look at an example using a simple Django model:", "It's simple to create a read-only serializer for converting HighScore instances into primitive data types.", "We can now use this class to serialize single HighScore instances:", "Or use it to serialize multiple instances:", "To create a read-write serializer we first need to implement a .to_internal_value() method. This method returns the validated values that will be used to construct the object instance, and may raise a serializers.ValidationError if the supplied data is in an incorrect format.", "Once you've implemented .to_internal_value(), the basic validation API will be available on the serializer, and you will be able to use .is_valid(), .validated_data and .errors.", "If you want to also support .save() you'll need to also implement either or both of the .create() and .update() methods.", "Here's a complete example of our previous HighScoreSerializer, that's been updated to support both read and write operations.", "The BaseSerializer class is also useful if you want to implement new generic serializer classes for dealing with particular serialization styles, or for integrating with alternative storage backends.", "The following class is an example of a generic serializer that can handle coercing arbitrary objects into primitive representations.", "If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the .to_representation() or .to_internal_value() methods.", "Some reasons this might be useful include...", "The signatures for these methods are as follows:", "Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API.", "May be overridden in order to modify the representation style. For example:", "Takes the unvalidated incoming data as input and should return the validated data that will be made available as serializer.validated_data. The return value will also be passed to the .create() or .update() methods if .save() is called on the serializer class.", "If any of the validation fails, then the method should raise a serializers.ValidationError(errors). The errors argument should be a dictionary mapping field names (or settings.NON_FIELD_ERRORS_KEY) to a list of error messages. If you don't need to alter deserialization behavior and instead want to provide object-level validation, it's recommended that you instead override the .validate() method.", "The data argument passed to this method will normally be the value of request.data, so the datatype it provides will depend on the parser classes you have configured for your API.", "Similar to Django forms, you can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example,", "Like Django's Model and ModelForm classes, the inner Meta class on serializers does not implicitly inherit from it's parents' inner Meta classes. If you want the Meta class to inherit from a parent class you must do so explicitly. For example:", "Typically we would recommend not using inheritance on inner Meta classes, but instead declaring all options explicitly.", "Additionally, the following caveats apply to serializer inheritance:", "It\u2019s possible to declaratively remove a Field inherited from a parent class by setting the name to be None on the subclass.", "However, you can only use this technique to opt out from a field defined declaratively by a parent class; it won\u2019t prevent the ModelSerializer from generating a default field. To opt-out from default fields, see Specifying which fields to include.", "Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the .fields attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer.", "Modifying the fields argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.", "For example, if you wanted to be able to set which fields should be used by a serializer at the point of initializing it, you could create a serializer class like so:", "This would then allow you to do the following:", "REST framework 2 provided an API to allow developers to override how a ModelSerializer class would automatically generate the default set of fields.", "This API included the .get_field(), .get_pk_field() and other methods.", "Because the serializers have been fundamentally redesigned with 3.0 this API no longer exists. You can still modify the fields that get created but you'll need to refer to the source code, and be aware that if the changes you make are against private bits of API then they may be subject to change.", "The following third party packages are also available.", "The django-rest-marshmallow package provides an alternative implementation for serializers, using the python marshmallow library. It exposes the same API as the REST framework serializers, and can be used as a drop-in replacement in some use-cases.", "The serpy package is an alternative implementation for serializers that is built for speed. Serpy serializes complex datatypes to simple native types. The native types can be easily converted to JSON or any other format needed.", "The django-rest-framework-mongoengine package provides a MongoEngineModelSerializer serializer class that supports using MongoDB as the storage layer for Django REST framework.", "The django-rest-framework-gis package provides a GeoFeatureModelSerializer serializer class that supports GeoJSON both for read and write operations.", "The django-rest-framework-hstore package provides an HStoreSerializer to support django-hstore DictionaryField model field and its schema-mode feature.", "The dynamic-rest package extends the ModelSerializer and ModelViewSet interfaces, adding API query parameters for filtering, sorting, and including / excluding all fields and relationships defined by your serializers.", "The drf-dynamic-fields package provides a mixin to dynamically limit the fields per serializer to a subset specified by an URL parameter.", "The drf-flex-fields package extends the ModelSerializer and ModelViewSet to provide commonly used functionality for dynamically setting fields and expanding primitive fields to nested models, both from URL parameters and your serializer class definitions.", "The django-rest-framework-serializer-extensions package provides a collection of tools to DRY up your serializers, by allowing fields to be defined on a per-view/request basis. Fields can be whitelisted, blacklisted and child serializers can be optionally expanded.", "The html-json-forms package provides an algorithm and serializer for processing <form> submissions per the (inactive) HTML JSON Form specification. The serializer facilitates processing of arbitrarily nested JSON structures within HTML. For example, <input name=\"items[0][id]\" value=\"5\"> will be interpreted as {\"items\": [{\"id\": \"5\"}]}.", "DRF-Base64 provides a set of field and model serializers that handles the upload of base64-encoded files.", "djangorestframework-queryfields allows API clients to specify which fields will be sent in the response via inclusion/exclusion query parameters.", "The drf-writable-nested package provides writable nested model serializer which allows to create/update models with nested related data.", "The drf-encrypt-content package helps you encrypt your data, serialized through ModelSerializer. It also contains some helper functions. Which helps you to encrypt your data. ", "serializers.py"]}, {"name": "HyperlinkedRelatedField", "path": "api-guide/relations/index#hyperlinkedrelatedfield", "type": "Ref: Serializer relations", "text": ["Data structures, not algorithms, are central to programming.", "\u2014 Rob Pike", "Relational fields are used to represent model relationships. They can be applied to ForeignKey, ManyToManyField and OneToOneField relationships, as well as to reverse relationships, and custom relationships such as GenericForeignKey.", "Note: The relational fields are declared in relations.py, but by convention you should import them from the serializers module, using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "When using the ModelSerializer class, serializer fields and relationships will be automatically generated for you. Inspecting these automatically generated fields can be a useful tool for determining how to customize the relationship style.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "In order to explain the various types of relational fields, we'll use a couple of simple models for our examples. Our models will be for music albums, and the tracks listed on each album.", "StringRelatedField may be used to represent the target of the relationship using its __str__ method.", "For example, the following serializer:", "Would serialize to the following representation:", "This field is read only.", "Arguments:", "PrimaryKeyRelatedField may be used to represent the target of the relationship using its primary key.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Arguments:", "HyperlinkedRelatedField may be used to represent the target of the relationship using a hyperlink.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Note: This field is designed for objects that map to a URL that accepts a single URL keyword argument, as set using the lookup_field and lookup_url_kwarg arguments.", "This is suitable for URLs that contain a single primary key or slug argument as part of the URL.", "If you require more complex hyperlinked representation you'll need to customize the field, as described in the custom hyperlinked fields section, below.", "Arguments:", "SlugRelatedField may be used to represent the target of the relationship using a field on the target.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "When using SlugRelatedField as a read-write field, you will normally want to ensure that the slug field corresponds to a model field with unique=True.", "Arguments:", "This field can be applied as an identity relationship, such as the 'url' field on a HyperlinkedModelSerializer. It can also be used for an attribute on the object. For example, the following serializer:", "Would serialize to a representation like this:", "This field is always read-only.", "Arguments:", "As opposed to previously discussed references to another entity, the referred entity can instead also be embedded or nested in the representation of the object that refers to it. Such nested relationships can be expressed by using serializers as fields. ", "If the field is used to represent a to-many relationship, you should add the many=True flag to the serializer field.", "For example, the following serializer:", "Would serialize to a nested representation like this:", "By default nested serializers are read-only. If you want to support write-operations to a nested serializer field you'll need to create create() and/or update() methods in order to explicitly specify how the child relationships should be saved:", "In rare cases where none of the existing relational styles fit the representation you need, you can implement a completely custom relational field, that describes exactly how the output representation should be generated from the model instance.", "To implement a custom relational field, you should override RelatedField, and implement the .to_representation(self, value) method. This method takes the target of the field as the value argument, and should return the representation that should be used to serialize the target. The value argument will typically be a model instance.", "If you want to implement a read-write relational field, you must also implement the .to_internal_value(self, data) method.", "To provide a dynamic queryset based on the context, you can also override .get_queryset(self) instead of specifying .queryset on the class or when initializing the field.", "For example, we could define a relational field to serialize a track to a custom string representation, using its ordering, title, and duration:", "This custom field would then serialize to the following representation:", "In some cases you may need to customize the behavior of a hyperlinked field, in order to represent URLs that require more than a single lookup field.", "You can achieve this by overriding HyperlinkedRelatedField. There are two methods that may be overridden:", "get_url(self, obj, view_name, request, format)", "The get_url method is used to map the object instance to its URL representation.", "May raise a NoReverseMatch if the view_name and lookup_field attributes are not configured to correctly match the URL conf.", "get_object(self, view_name, view_args, view_kwargs)", "If you want to support a writable hyperlinked field then you'll also want to override get_object, in order to map incoming URLs back to the object they represent. For read-only hyperlinked fields there is no need to override this method.", "The return value of this method should the object that corresponds to the matched URL conf arguments.", "May raise an ObjectDoesNotExist exception.", "Say we have a URL for a customer object that takes two keyword arguments, like so:", "This cannot be represented with the default implementation, which accepts only a single lookup field.", "In this case we'd need to override HyperlinkedRelatedField to get the behavior we want:", "Note that if you wanted to use this style together with the generic views then you'd also need to override .get_object on the view in order to get the correct lookup behavior.", "Generally we recommend a flat style for API representations where possible, but the nested URL style can also be reasonable when used in moderation.", "The queryset argument is only ever required for writable relationship field, in which case it is used for performing the model instance lookup, that maps from the primitive user input, into a model instance.", "In version 2.x a serializer class could sometimes automatically determine the queryset argument if a ModelSerializer class was being used.", "This behavior is now replaced with always using an explicit queryset argument for writable relational fields.", "Doing so reduces the amount of hidden 'magic' that ModelSerializer provides, makes the behavior of the field more clear, and ensures that it is trivial to move between using the ModelSerializer shortcut, or using fully explicit Serializer classes.", "The built-in __str__ method of the model will be used to generate string representations of the objects used to populate the choices property. These choices are used to populate select HTML inputs in the browsable API.", "To provide customized representations for such inputs, override display_value() of a RelatedField subclass. This method will receive a model object, and should return a string suitable for representing it. For example:", "When rendered in the browsable API relational fields will default to only displaying a maximum of 1000 selectable items. If more items are present then a disabled option with \"More than 1000 items\u2026\" will be displayed.", "This behavior is intended to prevent a template from being unable to render in an acceptable timespan due to a very large number of relationships being displayed.", "There are two keyword arguments you can use to control this behavior:", "You can also control these globally using the settings HTML_SELECT_CUTOFF and HTML_SELECT_CUTOFF_TEXT.", "In cases where the cutoff is being enforced you may want to instead use a plain input field in the HTML form. You can do so using the style keyword argument. For example:", "Note that reverse relationships are not automatically included by the ModelSerializer and HyperlinkedModelSerializer classes. To include a reverse relationship, you must explicitly add it to the fields list. For example:", "You'll normally want to ensure that you've set an appropriate related_name argument on the relationship, that you can use as the field name. For example:", "If you have not set a related name for the reverse relationship, you'll need to use the automatically generated related name in the fields argument. For example:", "See the Django documentation on reverse relationships for more details.", "If you want to serialize a generic foreign key, you need to define a custom field, to determine explicitly how you want to serialize the targets of the relationship.", "For example, given the following model for a tag, which has a generic relationship with other arbitrary models:", "And the following two models, which may have associated tags:", "We could define a custom field that could be used to serialize tagged instances, using the type of each instance to determine how it should be serialized:", "If you need the target of the relationship to have a nested representation, you can use the required serializers inside the .to_representation() method:", "Note that reverse generic keys, expressed using the GenericRelation field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.", "For more information see the Django documentation on generic relations.", "By default, relational fields that target a ManyToManyField with a through model specified are set to read-only.", "If you explicitly specify a relational field pointing to a ManyToManyField with a through model, be sure to set read_only to True.", "If you wish to represent extra fields on a through model then you may serialize the through model as a nested object.", "The following third party packages are also available.", "The drf-nested-routers package provides routers and relationship fields for working with nested resources.", "The rest-framework-generic-relations library provides read/write serialization for generic foreign keys.", "relations.py"]}, {"name": "ImageField", "path": "api-guide/fields/index#imagefield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "IntegerField", "path": "api-guide/fields/index#integerfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "IPAddressField", "path": "api-guide/fields/index#ipaddressfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "IsAdminUser", "path": "api-guide/permissions/index#isadminuser", "type": "Ref: Permissions", "text": ["Authentication or identification by itself is not usually sufficient to gain access to information or code. For that, the entity requesting access must have authorization.", "\u2014 Apple Developer Documentation", "Together with authentication and throttling, permissions determine whether a request should be granted or denied access.", "Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.", "Permissions are used to grant or deny access for different classes of users to different parts of the API.", "The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.", "A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in REST framework.", "Permissions in REST framework are always defined as a list of permission classes.", "Before running the main body of the view each permission in the list is checked. If any permission check fails an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.", "When the permissions checks fail either a \"403 Forbidden\" or a \"401 Unauthorized\" response will be returned, according to the following rules:", "REST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.", "Object level permissions are run by REST framework's generic views when .get_object() is called. As with view level permissions, an exceptions.PermissionDenied exception will be raised if the user is not allowed to act on the given object.", "If you're writing your own views and want to enforce object level permissions, or if you override the get_object method on a generic view, then you'll need to explicitly call the .check_object_permissions(request, obj) method on the view at the point at which you've retrieved the object.", "This will either raise a PermissionDenied or NotAuthenticated exception, or simply return if the view has the appropriate permissions.", "For example:", "Note: With the exception of DjangoObjectPermissions, the provided permission classes in rest_framework.permissions do not implement the methods necessary to check object permissions.", "If you wish to use the provided permission classes in order to check object permissions, you must subclass them and implement the has_object_permission() method described in the Custom permissions section (below).", "For performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.", "Often when you're using object level permissions you'll also want to filter the queryset appropriately, to ensure that users only have visibility onto instances that they are permitted to view.", "Because the get_object() method is not called, object level permissions from the has_object_permission() method are not applied when creating objects. In order to restrict object creation you need to implement the permission check either in your Serializer class or override the perform_create() method of your ViewSet class.", "The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting. For example.", "If not specified, this setting defaults to allowing unrestricted access:", "You can also set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Note: when you set new permission classes via the class attribute or decorators you're telling the view to ignore the default list set in the settings.py file.", "Provided they inherit from rest_framework.permissions.BasePermission, permissions can be composed using standard Python bitwise operators. For example, IsAuthenticatedOrReadOnly could be written:", "Note: it supports & (and), | (or) and ~ (not).", "The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated.", "This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.", "The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.", "This permission is suitable if you want your API to only be accessible to registered users.", "The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.", "This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.", "The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the \"safe\" methods; GET, HEAD or OPTIONS.", "This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.", "This permission class ties into Django's standard django.contrib.auth model permissions. This permission must only be applied to views that have a .queryset property or get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant model permissions assigned.", "The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a view model permission for GET requests.", "To use custom model permissions, override DjangoModelPermissions and set the .perms_map property. Refer to the source code for details.", "Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API.", "This permission class ties into Django's standard object permissions framework that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as django-guardian.", "As with DjangoModelPermissions, this permission must only be applied to views that have a .queryset property or .get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant per-object permissions and relevant model permissions assigned.", "Note that DjangoObjectPermissions does not require the django-guardian package, and should support other object-level backends equally well.", "As with DjangoModelPermissions you can use custom model permissions by overriding DjangoObjectPermissions and setting the .perms_map property. Refer to the source code for details.", "Note: If you need object level view permissions for GET, HEAD and OPTIONS requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the DjangoObjectPermissionsFilter class provided by the djangorestframework-guardian package. It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.", "To implement a custom permission, override BasePermission and implement either, or both, of the following methods:", "The methods should return True if the request should be granted access, and False otherwise.", "If you need to test if a request is a read operation or a write operation, you should check the request method against the constant SAFE_METHODS, which is a tuple containing 'GET', 'OPTIONS' and 'HEAD'. For example:", "Note: The instance-level has_object_permission method will only be called if the view-level has_permission checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call .check_object_permissions(request, obj). If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising PermissionDenied on failure.)", "Custom permissions will raise a PermissionDenied exception if the test fails. To change the error message associated with the exception, implement a message attribute directly on your custom permission. Otherwise the default_detail attribute from PermissionDenied will be used. Similarly, to change the code identifier associated with the exception, implement a code attribute directly on your custom permission - otherwise the default_code attribute from PermissionDenied will be used.", "The following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.", "As well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:", "Note that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling self.check_object_permissions(request, obj) from the view once you have the object instance. This call will raise an appropriate APIException if any object-level permission checks fail, and will otherwise simply return.", "Also note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the filtering documentation for more details.", "REST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.", "The following table lists the access restriction methods and the level of control they offer over which actions.", "* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  ** The get_*() methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.", "The following third party packages are also available.", "The Django REST - Access Policy package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies. ", "The Composed Permissions package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.", "The REST Condition package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.", "The DRY Rest Permissions package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.", "The Django Rest Framework Roles package makes it easier to parameterize your API over multiple types of users.", "The Django REST Framework API Key package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. machines) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.", "The Django Rest Framework Role Filters package provides simple filtering over multiple types of roles.", "The Django Rest Framework PSQ package is an extension that gives support for having action-based permission_classes, serializer_class, and queryset dependent on permission-based rules.", "permissions.py"]}, {"name": "IsAuthenticated", "path": "api-guide/permissions/index#isauthenticated", "type": "Ref: Permissions", "text": ["Authentication or identification by itself is not usually sufficient to gain access to information or code. For that, the entity requesting access must have authorization.", "\u2014 Apple Developer Documentation", "Together with authentication and throttling, permissions determine whether a request should be granted or denied access.", "Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.", "Permissions are used to grant or deny access for different classes of users to different parts of the API.", "The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.", "A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in REST framework.", "Permissions in REST framework are always defined as a list of permission classes.", "Before running the main body of the view each permission in the list is checked. If any permission check fails an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.", "When the permissions checks fail either a \"403 Forbidden\" or a \"401 Unauthorized\" response will be returned, according to the following rules:", "REST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.", "Object level permissions are run by REST framework's generic views when .get_object() is called. As with view level permissions, an exceptions.PermissionDenied exception will be raised if the user is not allowed to act on the given object.", "If you're writing your own views and want to enforce object level permissions, or if you override the get_object method on a generic view, then you'll need to explicitly call the .check_object_permissions(request, obj) method on the view at the point at which you've retrieved the object.", "This will either raise a PermissionDenied or NotAuthenticated exception, or simply return if the view has the appropriate permissions.", "For example:", "Note: With the exception of DjangoObjectPermissions, the provided permission classes in rest_framework.permissions do not implement the methods necessary to check object permissions.", "If you wish to use the provided permission classes in order to check object permissions, you must subclass them and implement the has_object_permission() method described in the Custom permissions section (below).", "For performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.", "Often when you're using object level permissions you'll also want to filter the queryset appropriately, to ensure that users only have visibility onto instances that they are permitted to view.", "Because the get_object() method is not called, object level permissions from the has_object_permission() method are not applied when creating objects. In order to restrict object creation you need to implement the permission check either in your Serializer class or override the perform_create() method of your ViewSet class.", "The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting. For example.", "If not specified, this setting defaults to allowing unrestricted access:", "You can also set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Note: when you set new permission classes via the class attribute or decorators you're telling the view to ignore the default list set in the settings.py file.", "Provided they inherit from rest_framework.permissions.BasePermission, permissions can be composed using standard Python bitwise operators. For example, IsAuthenticatedOrReadOnly could be written:", "Note: it supports & (and), | (or) and ~ (not).", "The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated.", "This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.", "The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.", "This permission is suitable if you want your API to only be accessible to registered users.", "The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.", "This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.", "The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the \"safe\" methods; GET, HEAD or OPTIONS.", "This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.", "This permission class ties into Django's standard django.contrib.auth model permissions. This permission must only be applied to views that have a .queryset property or get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant model permissions assigned.", "The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a view model permission for GET requests.", "To use custom model permissions, override DjangoModelPermissions and set the .perms_map property. Refer to the source code for details.", "Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API.", "This permission class ties into Django's standard object permissions framework that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as django-guardian.", "As with DjangoModelPermissions, this permission must only be applied to views that have a .queryset property or .get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant per-object permissions and relevant model permissions assigned.", "Note that DjangoObjectPermissions does not require the django-guardian package, and should support other object-level backends equally well.", "As with DjangoModelPermissions you can use custom model permissions by overriding DjangoObjectPermissions and setting the .perms_map property. Refer to the source code for details.", "Note: If you need object level view permissions for GET, HEAD and OPTIONS requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the DjangoObjectPermissionsFilter class provided by the djangorestframework-guardian package. It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.", "To implement a custom permission, override BasePermission and implement either, or both, of the following methods:", "The methods should return True if the request should be granted access, and False otherwise.", "If you need to test if a request is a read operation or a write operation, you should check the request method against the constant SAFE_METHODS, which is a tuple containing 'GET', 'OPTIONS' and 'HEAD'. For example:", "Note: The instance-level has_object_permission method will only be called if the view-level has_permission checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call .check_object_permissions(request, obj). If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising PermissionDenied on failure.)", "Custom permissions will raise a PermissionDenied exception if the test fails. To change the error message associated with the exception, implement a message attribute directly on your custom permission. Otherwise the default_detail attribute from PermissionDenied will be used. Similarly, to change the code identifier associated with the exception, implement a code attribute directly on your custom permission - otherwise the default_code attribute from PermissionDenied will be used.", "The following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.", "As well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:", "Note that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling self.check_object_permissions(request, obj) from the view once you have the object instance. This call will raise an appropriate APIException if any object-level permission checks fail, and will otherwise simply return.", "Also note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the filtering documentation for more details.", "REST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.", "The following table lists the access restriction methods and the level of control they offer over which actions.", "* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  ** The get_*() methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.", "The following third party packages are also available.", "The Django REST - Access Policy package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies. ", "The Composed Permissions package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.", "The REST Condition package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.", "The DRY Rest Permissions package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.", "The Django Rest Framework Roles package makes it easier to parameterize your API over multiple types of users.", "The Django REST Framework API Key package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. machines) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.", "The Django Rest Framework Role Filters package provides simple filtering over multiple types of roles.", "The Django Rest Framework PSQ package is an extension that gives support for having action-based permission_classes, serializer_class, and queryset dependent on permission-based rules.", "permissions.py"]}, {"name": "IsAuthenticatedOrReadOnly", "path": "api-guide/permissions/index#isauthenticatedorreadonly", "type": "Ref: Permissions", "text": ["Authentication or identification by itself is not usually sufficient to gain access to information or code. For that, the entity requesting access must have authorization.", "\u2014 Apple Developer Documentation", "Together with authentication and throttling, permissions determine whether a request should be granted or denied access.", "Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.", "Permissions are used to grant or deny access for different classes of users to different parts of the API.", "The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.", "A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in REST framework.", "Permissions in REST framework are always defined as a list of permission classes.", "Before running the main body of the view each permission in the list is checked. If any permission check fails an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.", "When the permissions checks fail either a \"403 Forbidden\" or a \"401 Unauthorized\" response will be returned, according to the following rules:", "REST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.", "Object level permissions are run by REST framework's generic views when .get_object() is called. As with view level permissions, an exceptions.PermissionDenied exception will be raised if the user is not allowed to act on the given object.", "If you're writing your own views and want to enforce object level permissions, or if you override the get_object method on a generic view, then you'll need to explicitly call the .check_object_permissions(request, obj) method on the view at the point at which you've retrieved the object.", "This will either raise a PermissionDenied or NotAuthenticated exception, or simply return if the view has the appropriate permissions.", "For example:", "Note: With the exception of DjangoObjectPermissions, the provided permission classes in rest_framework.permissions do not implement the methods necessary to check object permissions.", "If you wish to use the provided permission classes in order to check object permissions, you must subclass them and implement the has_object_permission() method described in the Custom permissions section (below).", "For performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.", "Often when you're using object level permissions you'll also want to filter the queryset appropriately, to ensure that users only have visibility onto instances that they are permitted to view.", "Because the get_object() method is not called, object level permissions from the has_object_permission() method are not applied when creating objects. In order to restrict object creation you need to implement the permission check either in your Serializer class or override the perform_create() method of your ViewSet class.", "The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting. For example.", "If not specified, this setting defaults to allowing unrestricted access:", "You can also set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Note: when you set new permission classes via the class attribute or decorators you're telling the view to ignore the default list set in the settings.py file.", "Provided they inherit from rest_framework.permissions.BasePermission, permissions can be composed using standard Python bitwise operators. For example, IsAuthenticatedOrReadOnly could be written:", "Note: it supports & (and), | (or) and ~ (not).", "The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated.", "This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.", "The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.", "This permission is suitable if you want your API to only be accessible to registered users.", "The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.", "This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.", "The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the \"safe\" methods; GET, HEAD or OPTIONS.", "This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.", "This permission class ties into Django's standard django.contrib.auth model permissions. This permission must only be applied to views that have a .queryset property or get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant model permissions assigned.", "The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a view model permission for GET requests.", "To use custom model permissions, override DjangoModelPermissions and set the .perms_map property. Refer to the source code for details.", "Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API.", "This permission class ties into Django's standard object permissions framework that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as django-guardian.", "As with DjangoModelPermissions, this permission must only be applied to views that have a .queryset property or .get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant per-object permissions and relevant model permissions assigned.", "Note that DjangoObjectPermissions does not require the django-guardian package, and should support other object-level backends equally well.", "As with DjangoModelPermissions you can use custom model permissions by overriding DjangoObjectPermissions and setting the .perms_map property. Refer to the source code for details.", "Note: If you need object level view permissions for GET, HEAD and OPTIONS requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the DjangoObjectPermissionsFilter class provided by the djangorestframework-guardian package. It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.", "To implement a custom permission, override BasePermission and implement either, or both, of the following methods:", "The methods should return True if the request should be granted access, and False otherwise.", "If you need to test if a request is a read operation or a write operation, you should check the request method against the constant SAFE_METHODS, which is a tuple containing 'GET', 'OPTIONS' and 'HEAD'. For example:", "Note: The instance-level has_object_permission method will only be called if the view-level has_permission checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call .check_object_permissions(request, obj). If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising PermissionDenied on failure.)", "Custom permissions will raise a PermissionDenied exception if the test fails. To change the error message associated with the exception, implement a message attribute directly on your custom permission. Otherwise the default_detail attribute from PermissionDenied will be used. Similarly, to change the code identifier associated with the exception, implement a code attribute directly on your custom permission - otherwise the default_code attribute from PermissionDenied will be used.", "The following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.", "As well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:", "Note that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling self.check_object_permissions(request, obj) from the view once you have the object instance. This call will raise an appropriate APIException if any object-level permission checks fail, and will otherwise simply return.", "Also note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the filtering documentation for more details.", "REST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.", "The following table lists the access restriction methods and the level of control they offer over which actions.", "* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  ** The get_*() methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.", "The following third party packages are also available.", "The Django REST - Access Policy package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies. ", "The Composed Permissions package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.", "The REST Condition package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.", "The DRY Rest Permissions package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.", "The Django Rest Framework Roles package makes it easier to parameterize your API over multiple types of users.", "The Django REST Framework API Key package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. machines) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.", "The Django Rest Framework Role Filters package provides simple filtering over multiple types of roles.", "The Django Rest Framework PSQ package is an extension that gives support for having action-based permission_classes, serializer_class, and queryset dependent on permission-based rules.", "permissions.py"]}, {"name": "JSONField", "path": "api-guide/fields/index#jsonfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "JSONParser", "path": "api-guide/parsers/index#jsonparser", "type": "Ref: Parsers", "text": ["Machine interacting web services tend to use more structured formats for sending data than form-encoded, since they're sending more complex data than simple forms", "\u2014 Malcom Tredinnick, Django developers group", "REST framework includes a number of built in Parser classes, that allow you to accept requests with various media types. There is also support for defining your own custom parsers, which gives you the flexibility to design the media types that your API accepts.", "The set of valid parsers for a view is always defined as a list of classes. When request.data is accessed, REST framework will examine the Content-Type header on the incoming request, and determine which parser to use to parse the request content.", "Note: When developing client applications always remember to make sure you're setting the Content-Type header when sending data in an HTTP request.", "If you don't set the content type, most clients will default to using 'application/x-www-form-urlencoded', which may not be what you wanted.", "As an example, if you are sending json encoded data using jQuery with the .ajax() method, you should make sure to include the contentType: 'application/json' setting.", "The default set of parsers may be set globally, using the DEFAULT_PARSER_CLASSES setting. For example, the following settings would allow only requests with JSON content, instead of the default of JSON or form data.", "You can also set the parsers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Parses JSON request content. request.data will be populated with a dictionary of data.", ".media_type: application/json", "Parses HTML form content. request.data will be populated with a QueryDict of data.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: application/x-www-form-urlencoded", "Parses multipart HTML form content, which supports file uploads. Both request.data will be populated with a QueryDict.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: multipart/form-data", "Parses raw file upload content. The request.data property will be a dictionary with a single key 'file' containing the uploaded file.", "If the view used with FileUploadParser is called with a filename URL keyword argument, then that argument will be used as the filename.", "If it is called without a filename URL keyword argument, then the client must set the filename in the Content-Disposition HTTP header. For example Content-Disposition: attachment; filename=upload.jpg.", ".media_type: */*", "To implement a custom parser, you should override BaseParser, set the .media_type property, and implement the .parse(self, stream, media_type, parser_context) method.", "The method should return the data that will be used to populate the request.data property.", "The arguments passed to .parse() are:", "A stream-like object representing the body of the request.", "Optional. If provided, this is the media type of the incoming request content.", "Depending on the request's Content-Type: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"text/plain; charset=utf-8\".", "Optional. If supplied, this argument will be a dictionary containing any additional context that may be required to parse the request content.", "By default this will include the following keys: view, request, args, kwargs.", "The following is an example plaintext parser that will populate the request.data property with a string representing the body of the request.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "parsers.py"]}, {"name": "JSONRenderer", "path": "api-guide/renderers/index#jsonrenderer", "type": "Ref: Renderers", "text": ["Before a TemplateResponse instance can be returned to the client, it must be rendered. The rendering process takes the intermediate representation of template and context, and turns it into the final byte stream that can be served to the client.", "\u2014 Django documentation", "REST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.", "The set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.", "The basic process of content negotiation involves examining the request's Accept header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL http://example.com/api/users_count.json might be an endpoint that always returns JSON data.", "For more information see the documentation on content negotiation.", "The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use JSON as the main media type and also include the self describing API.", "You can also set the renderers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "It's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an Accept: */* header, or not including an Accept header at all, then REST framework will select the first renderer in the list to use for the response.", "For example if your API serves JSON responses and the HTML browsable API, you might want to make JSONRenderer your default renderer, in order to send JSON responses to clients that do not specify an Accept header.", "If your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making TemplateHTMLRenderer your default renderer, in order to play nicely with older browsers that send broken accept headers.", "Renders the request data into JSON, using utf-8 encoding.", "Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:", "The client may additionally include an 'indent' media type parameter, in which case the returned JSON will be indented. For example Accept: application/json; indent=4.", "The default JSON encoding style can be altered using the UNICODE_JSON and COMPACT_JSON settings keys.", ".media_type: application/json", ".format: 'json'", ".charset: None", "Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the Response does not need to be serialized. Also, unlike other renderers, you may want to include a template_name argument when creating the Response.", "The TemplateHTMLRenderer will create a RequestContext, using the response.data as the context dict, and determine a template name to use to render the context.", "Note: When used with a view that makes use of a serializer the Response sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the TemplateHTMLRenderer to render it. For example:", "The template name is determined by (in order of preference):", "An example of a view that uses TemplateHTMLRenderer:", "You can use TemplateHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", "If you're building websites that use TemplateHTMLRenderer along with other renderer classes, you should consider listing TemplateHTMLRenderer as the first class in the renderer_classes list, so that it will be prioritised first even for browsers that send poorly formed ACCEPT: headers.", "See the HTML & Forms Topic Page for further examples of TemplateHTMLRenderer usage.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: StaticHTMLRenderer", "A simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.", "An example of a view that uses StaticHTMLRenderer:", "You can use StaticHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: TemplateHTMLRenderer", "Renders data into HTML for the Browsable API:", "", "This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.", ".media_type: text/html", ".format: 'api'", ".charset: utf-8", ".template: 'rest_framework/api.html'", "By default the response content will be rendered with the highest priority renderer apart from BrowsableAPIRenderer. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the get_default_renderer() method. For example:", "Renders data into HTML for an admin-like display:", "", "This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.", "Note that views that have nested or list serializers for their input won't work well with the AdminRenderer, as the HTML forms are unable to properly support them.", "Note: The AdminRenderer is only able to include links to detail pages when a properly configured URL_FIELD_NAME (url by default) attribute is present in the data. For HyperlinkedModelSerializer this will be the case, but for ModelSerializer or plain Serializer classes you'll need to make sure to include the field explicitly. For example here we use models get_absolute_url method:", ".media_type: text/html", ".format: 'admin'", ".charset: utf-8", ".template: 'rest_framework/admin.html'", "Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing <form> tags, a hidden CSRF input or any submit buttons.", "This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the render_form template tag.", "For more information see the HTML & Forms documentation.", ".media_type: text/html", ".format: 'form'", ".charset: utf-8", ".template: 'rest_framework/horizontal/form.html'", "This renderer is used for rendering HTML multipart form data. It is not suitable as a response renderer, but is instead used for creating test requests, using REST framework's test client and test request factory.", ".media_type: multipart/form-data; boundary=BoUnDaRyStRiNg", ".format: 'multipart'", ".charset: utf-8", "To implement a custom renderer, you should override BaseRenderer, set the .media_type and .format properties, and implement the .render(self, data, media_type=None, renderer_context=None) method.", "The method should return a bytestring, which will be used as the body of the HTTP response.", "The arguments passed to the .render() method are:", "The request data, as set by the Response() instantiation.", "Optional. If provided, this is the accepted media type, as determined by the content negotiation stage.", "Depending on the client's Accept: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"application/json; nested=true\".", "Optional. If provided, this is a dictionary of contextual information provided by the view.", "By default this will include the following keys: view, request, response, args, kwargs.", "The following is an example plaintext renderer that will return a response with the data parameter as the content of the response.", "By default renderer classes are assumed to be using the UTF-8 encoding. To use a different encoding, set the charset attribute on the renderer.", "Note that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the Response class, with the charset attribute set on the renderer used to determine the encoding.", "If the renderer returns a bytestring representing raw binary content, you should set a charset value of None, which will ensure the Content-Type header of the response will not have a charset value set.", "In some cases you may also want to set the render_style attribute to 'binary'. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.", "You can do some pretty flexible things using REST framework's renderers. Some examples...", "In some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access request.accepted_renderer to determine the negotiated renderer that will be used for the response.", "For example:", "In some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a media_type value such as image/*, or */*.", "If you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the content_type attribute. For example:", "For the purposes of many Web APIs, simple JSON responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and HATEOAS you'll need to consider the design and usage of your media types in more detail.", "In the words of Roy Fielding, \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".", "For good examples of custom media types, see GitHub's use of a custom application/vnd.github+json media type, and Mike Amundsen's IANA approved application/vnd.collection+json JSON-based hypermedia.", "Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an Http404 or PermissionDenied exception, or a subclass of APIException.", "If you're using either the TemplateHTMLRenderer or the StaticHTMLRenderer and an exception is raised, the behavior is slightly different, and mirrors Django's default handling of error views.", "Exceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.", "Templates will render with a RequestContext which includes the status_code and details keys.", "Note: If DEBUG=True, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST framework JSONP provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Warning: If you require cross-domain AJAX requests, you should generally be using the more modern approach of CORS as an alternative to JSONP. See the CORS documentation for more details.", "The jsonp approach is essentially a browser hack, and is only appropriate for globally readable API endpoints, where GET requests are unauthenticated and do not require any user permissions.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "XLSX is the world's most popular binary spreadsheet format. Tim Allen of The Wharton School maintains drf-renderer-xlsx, which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.", "Install using pip.", "Modify your REST framework settings.", "To avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the Content-Disposition header. If no filename is provided, it will default to export.xlsx. For example:", "Comma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. Mjumbe Poe maintains the djangorestframework-csv package which provides CSV renderer support for REST framework.", "UltraJSON is an optimized C JSON encoder which can give significantly faster JSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now unmaintained drf-ujson-renderer, which implements JSON rendering using the UJSON package.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "Django REST Pandas provides a serializer and renderers that support additional data processing and output via the Pandas DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both .xls and .xlsx), and a number of other formats. It is maintained by S. Andrew Sheppard as part of the wq Project.", "Rest Framework Latex provides a renderer that outputs PDFs using Laulatex. It is maintained by Pebble (S/F Software).", "renderers.py"]}, {"name": "LimitOffsetPagination", "path": "api-guide/pagination/index#limitoffsetpagination", "type": "Ref: Pagination", "text": ["Django provides a few classes that help you manage paginated data \u2013 that is, data that\u2019s split across several pages, with \u201cPrevious/Next\u201d links.", "\u2014 Django documentation", "REST framework includes support for customizable pagination styles. This allows you to modify how large result sets are split into individual pages of data.", "The pagination API can support either:", "The built-in styles currently all use links included as part of the content of the response. This style is more accessible when using the browsable API.", "Pagination is only performed automatically if you're using the generic views or viewsets. If you're using a regular APIView, you'll need to call into the pagination API yourself to ensure you return a paginated response. See the source code for the mixins.ListModelMixin and generics.GenericAPIView classes for an example.", "Pagination can be turned off by setting the pagination class to None.", "The pagination style may be set globally, using the DEFAULT_PAGINATION_CLASS and PAGE_SIZE setting keys. For example, to use the built-in limit/offset pagination, you would do something like this:", "Note that you need to set both the pagination class, and the page size that should be used. Both DEFAULT_PAGINATION_CLASS and PAGE_SIZE are None by default.", "You can also set the pagination class on an individual view by using the pagination_class attribute. Typically you'll want to use the same pagination style throughout your API, although you might want to vary individual aspects of the pagination, such as default or maximum page size, on a per-view basis.", "If you want to modify particular aspects of the pagination style, you'll want to override one of the pagination classes, and set the attributes that you want to change.", "You can then apply your new style to a view using the pagination_class attribute:", "Or apply the style globally, using the DEFAULT_PAGINATION_CLASS settings key. For example:", "This pagination style accepts a single number page number in the request query parameters.", "Request:", "Response:", "To enable the PageNumberPagination style globally, use the following configuration, and set the PAGE_SIZE as desired:", "On GenericAPIView subclasses you may also set the pagination_class attribute to select PageNumberPagination on a per-view basis.", "The PageNumberPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the PageNumberPagination class, and then enable your custom pagination class as above.", "This pagination style mirrors the syntax used when looking up multiple database records. The client includes both a \"limit\" and an \"offset\" query parameter. The limit indicates the maximum number of items to return, and is equivalent to the page_size in other styles. The offset indicates the starting position of the query in relation to the complete set of unpaginated items.", "Request:", "Response:", "To enable the LimitOffsetPagination style globally, use the following configuration:", "Optionally, you may also set a PAGE_SIZE key. If the PAGE_SIZE parameter is also used then the limit query parameter will be optional, and may be omitted by the client.", "On GenericAPIView subclasses you may also set the pagination_class attribute to select LimitOffsetPagination on a per-view basis.", "The LimitOffsetPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the LimitOffsetPagination class, and then enable your custom pagination class as above.", "The cursor-based pagination presents an opaque \"cursor\" indicator that the client may use to page through the result set. This pagination style only presents forward and reverse controls, and does not allow the client to navigate to arbitrary positions.", "Cursor based pagination requires that there is a unique, unchanging ordering of items in the result set. This ordering might typically be a creation timestamp on the records, as this presents a consistent ordering to paginate against.", "Cursor based pagination is more complex than other schemes. It also requires that the result set presents a fixed ordering, and does not allow the client to arbitrarily index into the result set. However it does provide the following benefits:", "Proper use of cursor based pagination requires a little attention to detail. You'll need to think about what ordering you want the scheme to be applied against. The default is to order by \"-created\". This assumes that there must be a 'created' timestamp field on the model instances, and will present a \"timeline\" style paginated view, with the most recently added items first.", "You can modify the ordering by overriding the 'ordering' attribute on the pagination class, or by using the OrderingFilter filter class together with CursorPagination. When used with OrderingFilter you should strongly consider restricting the fields that the user may order by.", "Proper usage of cursor pagination should have an ordering field that satisfies the following:", "Using an ordering field that does not satisfy these constraints will generally still work, but you'll be losing some of the benefits of cursor pagination.", "For more technical details on the implementation we use for cursor pagination, the \"Building cursors for the Disqus API\" blog post gives a good overview of the basic approach.", "To enable the CursorPagination style globally, use the following configuration, modifying the PAGE_SIZE as desired:", "On GenericAPIView subclasses you may also set the pagination_class attribute to select CursorPagination on a per-view basis.", "The CursorPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the CursorPagination class, and then enable your custom pagination class as above.", "To create a custom pagination serializer class, you should inherit the subclass pagination.BasePagination, override the paginate_queryset(self, queryset, request, view=None), and get_paginated_response(self, data) methods:", "Note that the paginate_queryset method may set state on the pagination instance, that may later be used by the get_paginated_response method.", "Suppose we want to replace the default pagination output style with a modified format that includes the next and previous links under in a nested 'links' key. We could specify a custom pagination class like so:", "We'd then need to setup the custom class in our configuration:", "Note that if you care about how the ordering of keys is displayed in responses in the browsable API you might choose to use an OrderedDict when constructing the body of paginated responses, but this is optional.", "To have your custom pagination class be used by default, use the DEFAULT_PAGINATION_CLASS setting:", "API responses for list endpoints will now include a Link header, instead of including the pagination links as part of the body of the response, for example:", "", "A custom pagination style, using the 'Link' header'", "You can also make the pagination controls available to the schema autogeneration that REST framework provides, by implementing a get_schema_fields() method. This method should have the following signature:", "get_schema_fields(self, view)", "The method should return a list of coreapi.Field instances.", "By default using the pagination classes will cause HTML pagination controls to be displayed in the browsable API. There are two built-in display styles. The PageNumberPagination and LimitOffsetPagination classes display a list of page numbers with previous and next controls. The CursorPagination class displays a simpler style that only displays a previous and next control.", "You can override the templates that render the HTML pagination controls. The two built-in styles are:", "Providing a template with either of these paths in a global template directory will override the default rendering for the relevant pagination classes.", "Alternatively you can disable HTML pagination controls completely by subclassing on of the existing classes, setting template = None as an attribute on the class. You'll then need to configure your DEFAULT_PAGINATION_CLASS settings key to use your custom class as the default pagination style.", "The low-level API for determining if a pagination class should display the controls or not is exposed as a display_page_controls attribute on the pagination instance. Custom pagination classes should be set to True in the paginate_queryset method if they require the HTML pagination controls to be displayed.", "The .to_html() and .get_html_context() methods may also be overridden in a custom pagination class in order to further customize how the controls are rendered.", "The following third party packages are also available.", "The DRF-extensions package includes a PaginateByMaxMixin mixin class that allows your API clients to specify ?page_size=max to obtain the maximum allowed page size.", "The drf-proxy-pagination package includes a ProxyPagination class which allows to choose pagination class with a query parameter.", "The django-rest-framework-link-header-pagination package includes a LinkHeaderPagination class which provides pagination via an HTTP Link header as described in Github's developer documentation.", "pagination.py"]}, {"name": "ListAPIView", "path": "api-guide/generic-views/index#listapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "ListCreateAPIView", "path": "api-guide/generic-views/index#listcreateapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "ListField", "path": "api-guide/fields/index#listfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "ListModelMixin", "path": "api-guide/generic-views/index#listmodelmixin", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "ListSerializer", "path": "api-guide/serializers/index#listserializer", "type": "Ref: Serializers", "text": ["Expanding the usefulness of the serializers is something that we would like to address. However, it's not a trivial problem, and it will take some serious design work.", "\u2014 Russell Keith-Magee, Django users group", "Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.", "The serializers in REST framework work very similarly to Django's Form and ModelForm classes. We provide a Serializer class which gives you a powerful, generic way to control the output of your responses, as well as a ModelSerializer class which provides a useful shortcut for creating serializers that deal with model instances and querysets.", "Let's start by creating a simple object we can use for example purposes:", "We'll declare a serializer that we can use to serialize and deserialize data that corresponds to Comment objects.", "Declaring a serializer looks very similar to declaring a form:", "We can now use CommentSerializer to serialize a comment, or list of comments. Again, using the Serializer class looks a lot like using a Form class.", "At this point we've translated the model instance into Python native datatypes. To finalise the serialization process we render the data into json.", "Deserialization is similar. First we parse a stream into Python native datatypes...", "...then we restore those native datatypes into a dictionary of validated data.", "If we want to be able to return complete object instances based on the validated data we need to implement one or both of the .create() and .update() methods. For example:", "If your object instances correspond to Django models you'll also want to ensure that these methods save the object to the database. For example, if Comment was a Django model, the methods might look like this:", "Now when deserializing data, we can call .save() to return an object instance, based on the validated data.", "Calling .save() will either create a new instance, or update an existing instance, depending on if an existing instance was passed when instantiating the serializer class:", "Both the .create() and .update() methods are optional. You can implement either neither, one, or both of them, depending on the use-case for your serializer class.", "Sometimes you'll want your view code to be able to inject additional data at the point of saving the instance. This additional data might include information like the current user, the current time, or anything else that is not part of the request data.", "You can do so by including additional keyword arguments when calling .save(). For example:", "Any additional keyword arguments will be included in the validated_data argument when .create() or .update() are called.", "In some cases the .create() and .update() method names may not be meaningful. For example, in a contact form we may not be creating new instances, but instead sending an email or other message.", "In these cases you might instead choose to override .save() directly, as being more readable and meaningful.", "For example:", "Note that in the case above we're now having to access the serializer .validated_data property directly.", "When deserializing data, you always need to call is_valid() before attempting to access the validated data, or save an object instance. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example:", "Each key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The non_field_errors key may also be present, and will list any general validation errors. The name of the non_field_errors key may be customized using the NON_FIELD_ERRORS_KEY REST framework setting.", "When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items.", "The .is_valid() method takes an optional raise_exception flag that will cause it to raise a serializers.ValidationError exception if there are validation errors.", "These exceptions are automatically dealt with by the default exception handler that REST framework provides, and will return HTTP 400 Bad Request responses by default.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. These are similar to the .clean_<field_name> methods on Django forms.", "These methods take a single argument, which is the field value that requires validation.", "Your validate_<field_name> methods should return the validated value or raise a serializers.ValidationError. For example:", "Note: If your <field_name> is declared on your serializer with the parameter required=False then this validation step will not take place if the field is not included.", "To do any other validation that requires access to multiple fields, add a method called .validate() to your Serializer subclass. This method takes a single argument, which is a dictionary of field values. It should raise a serializers.ValidationError if necessary, or just return the validated values. For example:", "Individual fields on a serializer can include validators, by declaring them on the field instance, for example:", "Serializer classes can also include reusable validators that are applied to the complete set of field data. These validators are included by declaring them on an inner Meta class, like so:", "For more information see the validators documentation.", "When passing an initial object or queryset to a serializer instance, the object will be made available as .instance. If no initial object is passed then the .instance attribute will be None.", "When passing data to a serializer instance, the unmodified data will be made available as .initial_data. If the data keyword argument is not passed then the .initial_data attribute will not exist.", "By default, serializers must be passed values for all required fields or they will raise validation errors. You can use the partial argument in order to allow partial updates.", "The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers.", "The Serializer class is itself a type of Field, and can be used to represent relationships where one object type is nested inside another.", "If a nested representation may optionally accept the None value you should pass the required=False flag to the nested serializer.", "Similarly if a nested representation should be a list of items, you should pass the many=True flag to the nested serializer.", "When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object.", "Similarly, the .validated_data property will include nested data structures.", "If you're supporting writable nested representations you'll need to write .create() or .update() methods that handle saving multiple objects.", "The following example demonstrates how you might handle creating a user with a nested profile object.", "For updates you'll want to think carefully about how to handle updates to relationships. For example if the data for the relationship is None, or not provided, which of the following should occur?", "Here's an example for an .update() method on our previous UserSerializer class.", "Because the behavior of nested creates and updates can be ambiguous, and may require complex dependencies between related models, REST framework 3 requires you to always write these methods explicitly. The default ModelSerializer .create() and .update() methods do not include support for writable nested representations.", "There are however, third-party packages available such as DRF Writable Nested that support automatic writable nested representations.", "An alternative to saving multiple related instances in the serializer is to write custom model manager classes that handle creating the correct instances.", "For example, suppose we wanted to ensure that User instances and Profile instances are always created together as a pair. We might write a custom manager class that looks something like this:", "This manager class now more nicely encapsulates that user instances and profile instances are always created at the same time. Our .create() method on the serializer class can now be re-written to use the new manager method.", "For more details on this approach see the Django documentation on model managers, and this blogpost on using model and manager classes.", "The Serializer class can also handle serializing or deserializing lists of objects.", "To serialize a queryset or list of objects instead of a single object instance, you should pass the many=True flag when instantiating the serializer. You can then pass a queryset or list of objects to be serialized.", "The default behavior for deserializing multiple objects is to support multiple object creation, but not support multiple object updates. For more information on how to support or customize either of these cases, see the ListSerializer documentation below.", "There are some cases where you need to provide extra context to the serializer in addition to the object being serialized. One common case is if you're using a serializer that includes hyperlinked relations, which requires the serializer to have access to the current request so that it can properly generate fully qualified URLs.", "You can provide arbitrary additional context by passing a context argument when instantiating the serializer. For example:", "The context dictionary can be used within any serializer field logic, such as a custom .to_representation() method, by accessing the self.context attribute.", "Often you'll want serializer classes that map closely to Django model definitions.", "The ModelSerializer class provides a shortcut that lets you automatically create a Serializer class with fields that correspond to the Model fields.", "The ModelSerializer class is the same as a regular Serializer class, except that:", "Declaring a ModelSerializer looks like this:", "By default, all the model fields on the class will be mapped to a corresponding serializer fields.", "Any relationships such as foreign keys on the model will be mapped to PrimaryKeyRelatedField. Reverse relationships are not included by default unless explicitly included as specified in the serializer relations documentation.", "Serializer classes generate helpful verbose representation strings, that allow you to fully inspect the state of their fields. This is particularly useful when working with ModelSerializers where you want to determine what set of fields and validators are being automatically created for you.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "If you only want a subset of the default fields to be used in a model serializer, you can do so using fields or exclude options, just as you would with a ModelForm. It is strongly recommended that you explicitly set all fields that should be serialized using the fields attribute. This will make it less likely to result in unintentionally exposing data when your models change.", "For example:", "You can also set the fields attribute to the special value '__all__' to indicate that all fields in the model should be used.", "For example:", "You can set the exclude attribute to a list of fields to be excluded from the serializer.", "For example:", "In the example above, if the Account model had 3 fields account_name, users, and created, this will result in the fields account_name and created to be serialized.", "The names in the fields and exclude attributes will normally map to model fields on the model class.", "Alternatively names in the fields options can map to properties or methods which take no arguments that exist on the model class.", "Since version 3.3.0, it is mandatory to provide one of the attributes fields or exclude.", "The default ModelSerializer uses primary keys for relationships, but you can also easily generate nested representations using the depth option:", "The depth option should be set to an integer value that indicates the depth of relationships that should be traversed before reverting to a flat representation.", "If you want to customize the way the serialization is done you'll need to define the field yourself.", "You can add extra fields to a ModelSerializer or override the default fields by declaring fields on the class, just as you would for a Serializer class.", "Extra fields can correspond to any property or callable on the model.", "You may wish to specify multiple fields as read-only. Instead of adding each field explicitly with the read_only=True attribute, you may use the shortcut Meta option, read_only_fields.", "This option should be a list or tuple of field names, and is declared as follows:", "Model fields which have editable=False set, and AutoField fields will be set to read-only by default, and do not need to be added to the read_only_fields option.", "Note: There is a special-case where a read-only field is part of a unique_together constraint at the model level. In this case the field is required by the serializer class in order to validate the constraint, but should also not be editable by the user.", "The right way to deal with this is to specify the field explicitly on the serializer, providing both the read_only=True and default=\u2026 keyword arguments.", "One example of this is a read-only relation to the currently authenticated User which is unique_together with another identifier. In this case you would declare the user field like so:", "Please review the Validators Documentation for details on the UniqueTogetherValidator and CurrentUserDefault classes.", "There is also a shortcut allowing you to specify arbitrary additional keyword arguments on fields, using the extra_kwargs option. As in the case of read_only_fields, this means you do not need to explicitly declare the field on the serializer.", "This option is a dictionary, mapping field names to a dictionary of keyword arguments. For example:", "Please keep in mind that, if the field has already been explicitly declared on the serializer class, then the extra_kwargs option will be ignored.", "When serializing model instances, there are a number of different ways you might choose to represent relationships. The default representation for ModelSerializer is to use the primary keys of the related instances.", "Alternative representations include serializing using hyperlinks, serializing complete nested representations, or serializing with a custom representation.", "For full details see the serializer relations documentation.", "The ModelSerializer class also exposes an API that you can override in order to alter how serializer fields are automatically determined when instantiating the serializer.", "Normally if a ModelSerializer does not generate the fields you need by default then you should either add them to the class explicitly, or simply use a regular Serializer class instead. However in some cases you may want to create a new base class that defines how the serializer fields are created for any given model.", "A mapping of Django model fields to REST framework serializer fields. You can override this mapping to alter the default serializer fields that should be used for each model field.", "This property should be the serializer field class, that is used for relational fields by default.", "For ModelSerializer this defaults to PrimaryKeyRelatedField.", "For HyperlinkedModelSerializer this defaults to serializers.HyperlinkedRelatedField.", "The serializer field class that should be used for any url field on the serializer.", "Defaults to serializers.HyperlinkedIdentityField", "The serializer field class that should be used for any choice fields on the serializer.", "Defaults to serializers.ChoiceField", "The following methods are called to determine the class and keyword arguments for each field that should be automatically included on the serializer. Each of these methods should return a two tuple of (field_class, field_kwargs).", "Called to generate a serializer field that maps to a standard model field.", "The default implementation returns a serializer class based on the serializer_field_mapping attribute.", "Called to generate a serializer field that maps to a relational model field.", "The default implementation returns a serializer class based on the serializer_related_field attribute.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a relational model field, when the depth option has been set.", "The default implementation dynamically creates a nested serializer class based on either ModelSerializer or HyperlinkedModelSerializer.", "The nested_depth will be the value of the depth option, minus one.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a property or zero-argument method on the model class.", "The default implementation returns a ReadOnlyField class.", "Called to generate a serializer field for the serializer's own url field. The default implementation returns a HyperlinkedIdentityField class.", "Called when the field name did not map to any model field or model property. The default implementation raises an error, although subclasses may customize this behavior.", "The HyperlinkedModelSerializer class is similar to the ModelSerializer class except that it uses hyperlinks to represent relationships, rather than primary keys.", "By default the serializer will include a url field instead of a primary key field.", "The url field will be represented using a HyperlinkedIdentityField serializer field, and any relationships on the model will be represented using a HyperlinkedRelatedField serializer field.", "You can explicitly include the primary key by adding it to the fields option, for example:", "When instantiating a HyperlinkedModelSerializer you must include the current request in the serializer context, for example:", "Doing so will ensure that the hyperlinks can include an appropriate hostname, so that the resulting representation uses fully qualified URLs, such as:", "Rather than relative URLs, such as:", "If you do want to use relative URLs, you should explicitly pass {'request': None} in the serializer context.", "There needs to be a way of determining which views should be used for hyperlinking to model instances.", "By default hyperlinks are expected to correspond to a view name that matches the style '{model_name}-detail', and looks up the instance by a pk keyword argument.", "You can override a URL field view name and lookup field by using either, or both of, the view_name and lookup_field options in the extra_kwargs setting, like so:", "Alternatively you can set the fields on the serializer explicitly. For example:", "Tip: Properly matching together hyperlinked representations and your URL conf can sometimes be a bit fiddly. Printing the repr of a HyperlinkedModelSerializer instance is a particularly useful way to inspect exactly which view names and lookup fields the relationships are expected to map too.", "The name of the URL field defaults to 'url'. You can override this globally, by using the URL_FIELD_NAME setting.", "The ListSerializer class provides the behavior for serializing and validating multiple objects at once. You won't typically need to use ListSerializer directly, but should instead simply pass many=True when instantiating a serializer.", "When a serializer is instantiated and many=True is passed, a ListSerializer instance will be created. The serializer class then becomes a child of the parent ListSerializer", "The following argument can also be passed to a ListSerializer field or a serializer that is passed many=True:", "This is True by default, but can be set to False if you want to disallow empty lists as valid input.", "There are a few use cases when you might want to customize the ListSerializer behavior. For example:", "For these cases you can modify the class that is used when many=True is passed, by using the list_serializer_class option on the serializer Meta class.", "For example:", "The default implementation for multiple object creation is to simply call .create() for each item in the list. If you want to customize this behavior, you'll need to customize the .create() method on ListSerializer class that is used when many=True is passed.", "For example:", "By default the ListSerializer class does not support multiple updates. This is because the behavior that should be expected for insertions and deletions is ambiguous.", "To support multiple updates you'll need to do so explicitly. When writing your multiple update code make sure to keep the following in mind:", "You will need to add an explicit id field to the instance serializer. The default implicitly-generated id field is marked as read_only. This causes it to be removed on updates. Once you declare it explicitly, it will be available in the list serializer's update method.", "Here's an example of how you might choose to implement multiple updates:", "It is possible that a third party package may be included alongside the 3.1 release that provides some automatic support for multiple update operations, similar to the allow_add_remove behavior that was present in REST framework 2.", "When a serializer with many=True is instantiated, we need to determine which arguments and keyword arguments should be passed to the .__init__() method for both the child Serializer class, and for the parent ListSerializer class.", "The default implementation is to pass all arguments to both classes, except for validators, and any custom keyword arguments, both of which are assumed to be intended for the child serializer class.", "Occasionally you might need to explicitly specify how the child and parent classes should be instantiated when many=True is passed. You can do so by using the many_init class method.", "BaseSerializer class that can be used to easily support alternative serialization and deserialization styles.", "This class implements the same basic API as the Serializer class:", "There are four methods that can be overridden, depending on what functionality you want the serializer class to support:", "Because this class provides the same interface as the Serializer class, you can use it with the existing generic class-based views exactly as you would for a regular Serializer or ModelSerializer.", "The only difference you'll notice when doing so is the BaseSerializer classes will not generate HTML forms in the browsable API. This is because the data they return does not include all the field information that would allow each field to be rendered into a suitable HTML input.", "To implement a read-only serializer using the BaseSerializer class, we just need to override the .to_representation() method. Let's take a look at an example using a simple Django model:", "It's simple to create a read-only serializer for converting HighScore instances into primitive data types.", "We can now use this class to serialize single HighScore instances:", "Or use it to serialize multiple instances:", "To create a read-write serializer we first need to implement a .to_internal_value() method. This method returns the validated values that will be used to construct the object instance, and may raise a serializers.ValidationError if the supplied data is in an incorrect format.", "Once you've implemented .to_internal_value(), the basic validation API will be available on the serializer, and you will be able to use .is_valid(), .validated_data and .errors.", "If you want to also support .save() you'll need to also implement either or both of the .create() and .update() methods.", "Here's a complete example of our previous HighScoreSerializer, that's been updated to support both read and write operations.", "The BaseSerializer class is also useful if you want to implement new generic serializer classes for dealing with particular serialization styles, or for integrating with alternative storage backends.", "The following class is an example of a generic serializer that can handle coercing arbitrary objects into primitive representations.", "If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the .to_representation() or .to_internal_value() methods.", "Some reasons this might be useful include...", "The signatures for these methods are as follows:", "Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API.", "May be overridden in order to modify the representation style. For example:", "Takes the unvalidated incoming data as input and should return the validated data that will be made available as serializer.validated_data. The return value will also be passed to the .create() or .update() methods if .save() is called on the serializer class.", "If any of the validation fails, then the method should raise a serializers.ValidationError(errors). The errors argument should be a dictionary mapping field names (or settings.NON_FIELD_ERRORS_KEY) to a list of error messages. If you don't need to alter deserialization behavior and instead want to provide object-level validation, it's recommended that you instead override the .validate() method.", "The data argument passed to this method will normally be the value of request.data, so the datatype it provides will depend on the parser classes you have configured for your API.", "Similar to Django forms, you can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example,", "Like Django's Model and ModelForm classes, the inner Meta class on serializers does not implicitly inherit from it's parents' inner Meta classes. If you want the Meta class to inherit from a parent class you must do so explicitly. For example:", "Typically we would recommend not using inheritance on inner Meta classes, but instead declaring all options explicitly.", "Additionally, the following caveats apply to serializer inheritance:", "It\u2019s possible to declaratively remove a Field inherited from a parent class by setting the name to be None on the subclass.", "However, you can only use this technique to opt out from a field defined declaratively by a parent class; it won\u2019t prevent the ModelSerializer from generating a default field. To opt-out from default fields, see Specifying which fields to include.", "Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the .fields attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer.", "Modifying the fields argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.", "For example, if you wanted to be able to set which fields should be used by a serializer at the point of initializing it, you could create a serializer class like so:", "This would then allow you to do the following:", "REST framework 2 provided an API to allow developers to override how a ModelSerializer class would automatically generate the default set of fields.", "This API included the .get_field(), .get_pk_field() and other methods.", "Because the serializers have been fundamentally redesigned with 3.0 this API no longer exists. You can still modify the fields that get created but you'll need to refer to the source code, and be aware that if the changes you make are against private bits of API then they may be subject to change.", "The following third party packages are also available.", "The django-rest-marshmallow package provides an alternative implementation for serializers, using the python marshmallow library. It exposes the same API as the REST framework serializers, and can be used as a drop-in replacement in some use-cases.", "The serpy package is an alternative implementation for serializers that is built for speed. Serpy serializes complex datatypes to simple native types. The native types can be easily converted to JSON or any other format needed.", "The django-rest-framework-mongoengine package provides a MongoEngineModelSerializer serializer class that supports using MongoDB as the storage layer for Django REST framework.", "The django-rest-framework-gis package provides a GeoFeatureModelSerializer serializer class that supports GeoJSON both for read and write operations.", "The django-rest-framework-hstore package provides an HStoreSerializer to support django-hstore DictionaryField model field and its schema-mode feature.", "The dynamic-rest package extends the ModelSerializer and ModelViewSet interfaces, adding API query parameters for filtering, sorting, and including / excluding all fields and relationships defined by your serializers.", "The drf-dynamic-fields package provides a mixin to dynamically limit the fields per serializer to a subset specified by an URL parameter.", "The drf-flex-fields package extends the ModelSerializer and ModelViewSet to provide commonly used functionality for dynamically setting fields and expanding primitive fields to nested models, both from URL parameters and your serializer class definitions.", "The django-rest-framework-serializer-extensions package provides a collection of tools to DRY up your serializers, by allowing fields to be defined on a per-view/request basis. Fields can be whitelisted, blacklisted and child serializers can be optionally expanded.", "The html-json-forms package provides an algorithm and serializer for processing <form> submissions per the (inactive) HTML JSON Form specification. The serializer facilitates processing of arbitrarily nested JSON structures within HTML. For example, <input name=\"items[0][id]\" value=\"5\"> will be interpreted as {\"items\": [{\"id\": \"5\"}]}.", "DRF-Base64 provides a set of field and model serializers that handles the upload of base64-encoded files.", "djangorestframework-queryfields allows API clients to specify which fields will be sent in the response via inclusion/exclusion query parameters.", "The drf-writable-nested package provides writable nested model serializer which allows to create/update models with nested related data.", "The drf-encrypt-content package helps you encrypt your data, serialized through ModelSerializer. It also contains some helper functions. Which helps you to encrypt your data. ", "serializers.py"]}, {"name": "Metadata", "path": "api-guide/metadata/index", "type": "API Guide", "text": ["[The OPTIONS] method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.", "\u2014 RFC7231, Section 4.3.7.", "REST framework includes a configurable mechanism for determining how your API should respond to OPTIONS requests. This allows you to return API schema or other resource information.", "There are not currently any widely adopted conventions for exactly what style of response should be returned for HTTP OPTIONS requests, so we provide an ad-hoc style that returns some useful information.", "Here's an example response that demonstrates the information that is returned by default.", "You can set the metadata class globally using the 'DEFAULT_METADATA_CLASS' settings key:", "Or you can set the metadata class individually for a view:", "The REST framework package only includes a single metadata class implementation, named SimpleMetadata. If you want to use an alternative style you'll need to implement a custom metadata class.", "If you have specific requirements for creating schema endpoints that are accessed with regular GET requests, you might consider re-using the metadata API for doing so.", "For example, the following additional route could be used on a viewset to provide a linkable schema endpoint.", "There are a couple of reasons that you might choose to take this approach, including that OPTIONS responses are not cacheable.", "If you want to provide a custom metadata class you should override BaseMetadata and implement the determine_metadata(self, request, view) method.", "Useful things that you might want to do could include returning schema information, using a format such as JSON schema, or returning debug information to admin users.", "The following class could be used to limit the information that is returned to OPTIONS requests.", "Then configure your settings to use this custom class:", "The following third party packages provide additional metadata implementations.", "drf-schema-adapter is a set of tools that makes it easier to provide schema information to frontend frameworks and libraries. It provides a metadata mixin as well as 2 metadata classes and several adapters suitable to generate json-schema as well as schema information readable by various libraries.", "You can also write your own adapter to work with your specific frontend. If you wish to do so, it also provides an exporter that can export those schema information to json files.", "metadata.py"]}, {"name": "MethodNotAllowed", "path": "api-guide/exceptions/index#methodnotallowed", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "Miscellaneous settings", "path": "api-guide/settings/index#miscellaneous-settings", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "ModelField", "path": "api-guide/fields/index#modelfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "ModelSerializer", "path": "api-guide/serializers/index#modelserializer", "type": "Ref: Serializers", "text": ["Expanding the usefulness of the serializers is something that we would like to address. However, it's not a trivial problem, and it will take some serious design work.", "\u2014 Russell Keith-Magee, Django users group", "Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.", "The serializers in REST framework work very similarly to Django's Form and ModelForm classes. We provide a Serializer class which gives you a powerful, generic way to control the output of your responses, as well as a ModelSerializer class which provides a useful shortcut for creating serializers that deal with model instances and querysets.", "Let's start by creating a simple object we can use for example purposes:", "We'll declare a serializer that we can use to serialize and deserialize data that corresponds to Comment objects.", "Declaring a serializer looks very similar to declaring a form:", "We can now use CommentSerializer to serialize a comment, or list of comments. Again, using the Serializer class looks a lot like using a Form class.", "At this point we've translated the model instance into Python native datatypes. To finalise the serialization process we render the data into json.", "Deserialization is similar. First we parse a stream into Python native datatypes...", "...then we restore those native datatypes into a dictionary of validated data.", "If we want to be able to return complete object instances based on the validated data we need to implement one or both of the .create() and .update() methods. For example:", "If your object instances correspond to Django models you'll also want to ensure that these methods save the object to the database. For example, if Comment was a Django model, the methods might look like this:", "Now when deserializing data, we can call .save() to return an object instance, based on the validated data.", "Calling .save() will either create a new instance, or update an existing instance, depending on if an existing instance was passed when instantiating the serializer class:", "Both the .create() and .update() methods are optional. You can implement either neither, one, or both of them, depending on the use-case for your serializer class.", "Sometimes you'll want your view code to be able to inject additional data at the point of saving the instance. This additional data might include information like the current user, the current time, or anything else that is not part of the request data.", "You can do so by including additional keyword arguments when calling .save(). For example:", "Any additional keyword arguments will be included in the validated_data argument when .create() or .update() are called.", "In some cases the .create() and .update() method names may not be meaningful. For example, in a contact form we may not be creating new instances, but instead sending an email or other message.", "In these cases you might instead choose to override .save() directly, as being more readable and meaningful.", "For example:", "Note that in the case above we're now having to access the serializer .validated_data property directly.", "When deserializing data, you always need to call is_valid() before attempting to access the validated data, or save an object instance. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example:", "Each key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The non_field_errors key may also be present, and will list any general validation errors. The name of the non_field_errors key may be customized using the NON_FIELD_ERRORS_KEY REST framework setting.", "When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items.", "The .is_valid() method takes an optional raise_exception flag that will cause it to raise a serializers.ValidationError exception if there are validation errors.", "These exceptions are automatically dealt with by the default exception handler that REST framework provides, and will return HTTP 400 Bad Request responses by default.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. These are similar to the .clean_<field_name> methods on Django forms.", "These methods take a single argument, which is the field value that requires validation.", "Your validate_<field_name> methods should return the validated value or raise a serializers.ValidationError. For example:", "Note: If your <field_name> is declared on your serializer with the parameter required=False then this validation step will not take place if the field is not included.", "To do any other validation that requires access to multiple fields, add a method called .validate() to your Serializer subclass. This method takes a single argument, which is a dictionary of field values. It should raise a serializers.ValidationError if necessary, or just return the validated values. For example:", "Individual fields on a serializer can include validators, by declaring them on the field instance, for example:", "Serializer classes can also include reusable validators that are applied to the complete set of field data. These validators are included by declaring them on an inner Meta class, like so:", "For more information see the validators documentation.", "When passing an initial object or queryset to a serializer instance, the object will be made available as .instance. If no initial object is passed then the .instance attribute will be None.", "When passing data to a serializer instance, the unmodified data will be made available as .initial_data. If the data keyword argument is not passed then the .initial_data attribute will not exist.", "By default, serializers must be passed values for all required fields or they will raise validation errors. You can use the partial argument in order to allow partial updates.", "The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers.", "The Serializer class is itself a type of Field, and can be used to represent relationships where one object type is nested inside another.", "If a nested representation may optionally accept the None value you should pass the required=False flag to the nested serializer.", "Similarly if a nested representation should be a list of items, you should pass the many=True flag to the nested serializer.", "When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object.", "Similarly, the .validated_data property will include nested data structures.", "If you're supporting writable nested representations you'll need to write .create() or .update() methods that handle saving multiple objects.", "The following example demonstrates how you might handle creating a user with a nested profile object.", "For updates you'll want to think carefully about how to handle updates to relationships. For example if the data for the relationship is None, or not provided, which of the following should occur?", "Here's an example for an .update() method on our previous UserSerializer class.", "Because the behavior of nested creates and updates can be ambiguous, and may require complex dependencies between related models, REST framework 3 requires you to always write these methods explicitly. The default ModelSerializer .create() and .update() methods do not include support for writable nested representations.", "There are however, third-party packages available such as DRF Writable Nested that support automatic writable nested representations.", "An alternative to saving multiple related instances in the serializer is to write custom model manager classes that handle creating the correct instances.", "For example, suppose we wanted to ensure that User instances and Profile instances are always created together as a pair. We might write a custom manager class that looks something like this:", "This manager class now more nicely encapsulates that user instances and profile instances are always created at the same time. Our .create() method on the serializer class can now be re-written to use the new manager method.", "For more details on this approach see the Django documentation on model managers, and this blogpost on using model and manager classes.", "The Serializer class can also handle serializing or deserializing lists of objects.", "To serialize a queryset or list of objects instead of a single object instance, you should pass the many=True flag when instantiating the serializer. You can then pass a queryset or list of objects to be serialized.", "The default behavior for deserializing multiple objects is to support multiple object creation, but not support multiple object updates. For more information on how to support or customize either of these cases, see the ListSerializer documentation below.", "There are some cases where you need to provide extra context to the serializer in addition to the object being serialized. One common case is if you're using a serializer that includes hyperlinked relations, which requires the serializer to have access to the current request so that it can properly generate fully qualified URLs.", "You can provide arbitrary additional context by passing a context argument when instantiating the serializer. For example:", "The context dictionary can be used within any serializer field logic, such as a custom .to_representation() method, by accessing the self.context attribute.", "Often you'll want serializer classes that map closely to Django model definitions.", "The ModelSerializer class provides a shortcut that lets you automatically create a Serializer class with fields that correspond to the Model fields.", "The ModelSerializer class is the same as a regular Serializer class, except that:", "Declaring a ModelSerializer looks like this:", "By default, all the model fields on the class will be mapped to a corresponding serializer fields.", "Any relationships such as foreign keys on the model will be mapped to PrimaryKeyRelatedField. Reverse relationships are not included by default unless explicitly included as specified in the serializer relations documentation.", "Serializer classes generate helpful verbose representation strings, that allow you to fully inspect the state of their fields. This is particularly useful when working with ModelSerializers where you want to determine what set of fields and validators are being automatically created for you.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "If you only want a subset of the default fields to be used in a model serializer, you can do so using fields or exclude options, just as you would with a ModelForm. It is strongly recommended that you explicitly set all fields that should be serialized using the fields attribute. This will make it less likely to result in unintentionally exposing data when your models change.", "For example:", "You can also set the fields attribute to the special value '__all__' to indicate that all fields in the model should be used.", "For example:", "You can set the exclude attribute to a list of fields to be excluded from the serializer.", "For example:", "In the example above, if the Account model had 3 fields account_name, users, and created, this will result in the fields account_name and created to be serialized.", "The names in the fields and exclude attributes will normally map to model fields on the model class.", "Alternatively names in the fields options can map to properties or methods which take no arguments that exist on the model class.", "Since version 3.3.0, it is mandatory to provide one of the attributes fields or exclude.", "The default ModelSerializer uses primary keys for relationships, but you can also easily generate nested representations using the depth option:", "The depth option should be set to an integer value that indicates the depth of relationships that should be traversed before reverting to a flat representation.", "If you want to customize the way the serialization is done you'll need to define the field yourself.", "You can add extra fields to a ModelSerializer or override the default fields by declaring fields on the class, just as you would for a Serializer class.", "Extra fields can correspond to any property or callable on the model.", "You may wish to specify multiple fields as read-only. Instead of adding each field explicitly with the read_only=True attribute, you may use the shortcut Meta option, read_only_fields.", "This option should be a list or tuple of field names, and is declared as follows:", "Model fields which have editable=False set, and AutoField fields will be set to read-only by default, and do not need to be added to the read_only_fields option.", "Note: There is a special-case where a read-only field is part of a unique_together constraint at the model level. In this case the field is required by the serializer class in order to validate the constraint, but should also not be editable by the user.", "The right way to deal with this is to specify the field explicitly on the serializer, providing both the read_only=True and default=\u2026 keyword arguments.", "One example of this is a read-only relation to the currently authenticated User which is unique_together with another identifier. In this case you would declare the user field like so:", "Please review the Validators Documentation for details on the UniqueTogetherValidator and CurrentUserDefault classes.", "There is also a shortcut allowing you to specify arbitrary additional keyword arguments on fields, using the extra_kwargs option. As in the case of read_only_fields, this means you do not need to explicitly declare the field on the serializer.", "This option is a dictionary, mapping field names to a dictionary of keyword arguments. For example:", "Please keep in mind that, if the field has already been explicitly declared on the serializer class, then the extra_kwargs option will be ignored.", "When serializing model instances, there are a number of different ways you might choose to represent relationships. The default representation for ModelSerializer is to use the primary keys of the related instances.", "Alternative representations include serializing using hyperlinks, serializing complete nested representations, or serializing with a custom representation.", "For full details see the serializer relations documentation.", "The ModelSerializer class also exposes an API that you can override in order to alter how serializer fields are automatically determined when instantiating the serializer.", "Normally if a ModelSerializer does not generate the fields you need by default then you should either add them to the class explicitly, or simply use a regular Serializer class instead. However in some cases you may want to create a new base class that defines how the serializer fields are created for any given model.", "A mapping of Django model fields to REST framework serializer fields. You can override this mapping to alter the default serializer fields that should be used for each model field.", "This property should be the serializer field class, that is used for relational fields by default.", "For ModelSerializer this defaults to PrimaryKeyRelatedField.", "For HyperlinkedModelSerializer this defaults to serializers.HyperlinkedRelatedField.", "The serializer field class that should be used for any url field on the serializer.", "Defaults to serializers.HyperlinkedIdentityField", "The serializer field class that should be used for any choice fields on the serializer.", "Defaults to serializers.ChoiceField", "The following methods are called to determine the class and keyword arguments for each field that should be automatically included on the serializer. Each of these methods should return a two tuple of (field_class, field_kwargs).", "Called to generate a serializer field that maps to a standard model field.", "The default implementation returns a serializer class based on the serializer_field_mapping attribute.", "Called to generate a serializer field that maps to a relational model field.", "The default implementation returns a serializer class based on the serializer_related_field attribute.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a relational model field, when the depth option has been set.", "The default implementation dynamically creates a nested serializer class based on either ModelSerializer or HyperlinkedModelSerializer.", "The nested_depth will be the value of the depth option, minus one.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a property or zero-argument method on the model class.", "The default implementation returns a ReadOnlyField class.", "Called to generate a serializer field for the serializer's own url field. The default implementation returns a HyperlinkedIdentityField class.", "Called when the field name did not map to any model field or model property. The default implementation raises an error, although subclasses may customize this behavior.", "The HyperlinkedModelSerializer class is similar to the ModelSerializer class except that it uses hyperlinks to represent relationships, rather than primary keys.", "By default the serializer will include a url field instead of a primary key field.", "The url field will be represented using a HyperlinkedIdentityField serializer field, and any relationships on the model will be represented using a HyperlinkedRelatedField serializer field.", "You can explicitly include the primary key by adding it to the fields option, for example:", "When instantiating a HyperlinkedModelSerializer you must include the current request in the serializer context, for example:", "Doing so will ensure that the hyperlinks can include an appropriate hostname, so that the resulting representation uses fully qualified URLs, such as:", "Rather than relative URLs, such as:", "If you do want to use relative URLs, you should explicitly pass {'request': None} in the serializer context.", "There needs to be a way of determining which views should be used for hyperlinking to model instances.", "By default hyperlinks are expected to correspond to a view name that matches the style '{model_name}-detail', and looks up the instance by a pk keyword argument.", "You can override a URL field view name and lookup field by using either, or both of, the view_name and lookup_field options in the extra_kwargs setting, like so:", "Alternatively you can set the fields on the serializer explicitly. For example:", "Tip: Properly matching together hyperlinked representations and your URL conf can sometimes be a bit fiddly. Printing the repr of a HyperlinkedModelSerializer instance is a particularly useful way to inspect exactly which view names and lookup fields the relationships are expected to map too.", "The name of the URL field defaults to 'url'. You can override this globally, by using the URL_FIELD_NAME setting.", "The ListSerializer class provides the behavior for serializing and validating multiple objects at once. You won't typically need to use ListSerializer directly, but should instead simply pass many=True when instantiating a serializer.", "When a serializer is instantiated and many=True is passed, a ListSerializer instance will be created. The serializer class then becomes a child of the parent ListSerializer", "The following argument can also be passed to a ListSerializer field or a serializer that is passed many=True:", "This is True by default, but can be set to False if you want to disallow empty lists as valid input.", "There are a few use cases when you might want to customize the ListSerializer behavior. For example:", "For these cases you can modify the class that is used when many=True is passed, by using the list_serializer_class option on the serializer Meta class.", "For example:", "The default implementation for multiple object creation is to simply call .create() for each item in the list. If you want to customize this behavior, you'll need to customize the .create() method on ListSerializer class that is used when many=True is passed.", "For example:", "By default the ListSerializer class does not support multiple updates. This is because the behavior that should be expected for insertions and deletions is ambiguous.", "To support multiple updates you'll need to do so explicitly. When writing your multiple update code make sure to keep the following in mind:", "You will need to add an explicit id field to the instance serializer. The default implicitly-generated id field is marked as read_only. This causes it to be removed on updates. Once you declare it explicitly, it will be available in the list serializer's update method.", "Here's an example of how you might choose to implement multiple updates:", "It is possible that a third party package may be included alongside the 3.1 release that provides some automatic support for multiple update operations, similar to the allow_add_remove behavior that was present in REST framework 2.", "When a serializer with many=True is instantiated, we need to determine which arguments and keyword arguments should be passed to the .__init__() method for both the child Serializer class, and for the parent ListSerializer class.", "The default implementation is to pass all arguments to both classes, except for validators, and any custom keyword arguments, both of which are assumed to be intended for the child serializer class.", "Occasionally you might need to explicitly specify how the child and parent classes should be instantiated when many=True is passed. You can do so by using the many_init class method.", "BaseSerializer class that can be used to easily support alternative serialization and deserialization styles.", "This class implements the same basic API as the Serializer class:", "There are four methods that can be overridden, depending on what functionality you want the serializer class to support:", "Because this class provides the same interface as the Serializer class, you can use it with the existing generic class-based views exactly as you would for a regular Serializer or ModelSerializer.", "The only difference you'll notice when doing so is the BaseSerializer classes will not generate HTML forms in the browsable API. This is because the data they return does not include all the field information that would allow each field to be rendered into a suitable HTML input.", "To implement a read-only serializer using the BaseSerializer class, we just need to override the .to_representation() method. Let's take a look at an example using a simple Django model:", "It's simple to create a read-only serializer for converting HighScore instances into primitive data types.", "We can now use this class to serialize single HighScore instances:", "Or use it to serialize multiple instances:", "To create a read-write serializer we first need to implement a .to_internal_value() method. This method returns the validated values that will be used to construct the object instance, and may raise a serializers.ValidationError if the supplied data is in an incorrect format.", "Once you've implemented .to_internal_value(), the basic validation API will be available on the serializer, and you will be able to use .is_valid(), .validated_data and .errors.", "If you want to also support .save() you'll need to also implement either or both of the .create() and .update() methods.", "Here's a complete example of our previous HighScoreSerializer, that's been updated to support both read and write operations.", "The BaseSerializer class is also useful if you want to implement new generic serializer classes for dealing with particular serialization styles, or for integrating with alternative storage backends.", "The following class is an example of a generic serializer that can handle coercing arbitrary objects into primitive representations.", "If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the .to_representation() or .to_internal_value() methods.", "Some reasons this might be useful include...", "The signatures for these methods are as follows:", "Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API.", "May be overridden in order to modify the representation style. For example:", "Takes the unvalidated incoming data as input and should return the validated data that will be made available as serializer.validated_data. The return value will also be passed to the .create() or .update() methods if .save() is called on the serializer class.", "If any of the validation fails, then the method should raise a serializers.ValidationError(errors). The errors argument should be a dictionary mapping field names (or settings.NON_FIELD_ERRORS_KEY) to a list of error messages. If you don't need to alter deserialization behavior and instead want to provide object-level validation, it's recommended that you instead override the .validate() method.", "The data argument passed to this method will normally be the value of request.data, so the datatype it provides will depend on the parser classes you have configured for your API.", "Similar to Django forms, you can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example,", "Like Django's Model and ModelForm classes, the inner Meta class on serializers does not implicitly inherit from it's parents' inner Meta classes. If you want the Meta class to inherit from a parent class you must do so explicitly. For example:", "Typically we would recommend not using inheritance on inner Meta classes, but instead declaring all options explicitly.", "Additionally, the following caveats apply to serializer inheritance:", "It\u2019s possible to declaratively remove a Field inherited from a parent class by setting the name to be None on the subclass.", "However, you can only use this technique to opt out from a field defined declaratively by a parent class; it won\u2019t prevent the ModelSerializer from generating a default field. To opt-out from default fields, see Specifying which fields to include.", "Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the .fields attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer.", "Modifying the fields argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.", "For example, if you wanted to be able to set which fields should be used by a serializer at the point of initializing it, you could create a serializer class like so:", "This would then allow you to do the following:", "REST framework 2 provided an API to allow developers to override how a ModelSerializer class would automatically generate the default set of fields.", "This API included the .get_field(), .get_pk_field() and other methods.", "Because the serializers have been fundamentally redesigned with 3.0 this API no longer exists. You can still modify the fields that get created but you'll need to refer to the source code, and be aware that if the changes you make are against private bits of API then they may be subject to change.", "The following third party packages are also available.", "The django-rest-marshmallow package provides an alternative implementation for serializers, using the python marshmallow library. It exposes the same API as the REST framework serializers, and can be used as a drop-in replacement in some use-cases.", "The serpy package is an alternative implementation for serializers that is built for speed. Serpy serializes complex datatypes to simple native types. The native types can be easily converted to JSON or any other format needed.", "The django-rest-framework-mongoengine package provides a MongoEngineModelSerializer serializer class that supports using MongoDB as the storage layer for Django REST framework.", "The django-rest-framework-gis package provides a GeoFeatureModelSerializer serializer class that supports GeoJSON both for read and write operations.", "The django-rest-framework-hstore package provides an HStoreSerializer to support django-hstore DictionaryField model field and its schema-mode feature.", "The dynamic-rest package extends the ModelSerializer and ModelViewSet interfaces, adding API query parameters for filtering, sorting, and including / excluding all fields and relationships defined by your serializers.", "The drf-dynamic-fields package provides a mixin to dynamically limit the fields per serializer to a subset specified by an URL parameter.", "The drf-flex-fields package extends the ModelSerializer and ModelViewSet to provide commonly used functionality for dynamically setting fields and expanding primitive fields to nested models, both from URL parameters and your serializer class definitions.", "The django-rest-framework-serializer-extensions package provides a collection of tools to DRY up your serializers, by allowing fields to be defined on a per-view/request basis. Fields can be whitelisted, blacklisted and child serializers can be optionally expanded.", "The html-json-forms package provides an algorithm and serializer for processing <form> submissions per the (inactive) HTML JSON Form specification. The serializer facilitates processing of arbitrarily nested JSON structures within HTML. For example, <input name=\"items[0][id]\" value=\"5\"> will be interpreted as {\"items\": [{\"id\": \"5\"}]}.", "DRF-Base64 provides a set of field and model serializers that handles the upload of base64-encoded files.", "djangorestframework-queryfields allows API clients to specify which fields will be sent in the response via inclusion/exclusion query parameters.", "The drf-writable-nested package provides writable nested model serializer which allows to create/update models with nested related data.", "The drf-encrypt-content package helps you encrypt your data, serialized through ModelSerializer. It also contains some helper functions. Which helps you to encrypt your data. ", "serializers.py"]}, {"name": "ModelViewSet", "path": "api-guide/viewsets/index#modelviewset", "type": "Ref: ViewSets", "text": ["After routing has determined which controller to use for a request, your controller is responsible for making sense of the request and producing the appropriate output.", "\u2014 Ruby on Rails Documentation", "Django REST framework allows you to combine the logic for a set of related views in a single class, called a ViewSet. In other frameworks you may also find conceptually similar implementations named something like 'Resources' or 'Controllers'.", "A ViewSet class is simply a type of class-based View, that does not provide any method handlers such as .get() or .post(), and instead provides actions such as .list() and .create().", "The method handlers for a ViewSet are only bound to the corresponding actions at the point of finalizing the view, using the .as_view() method.", "Typically, rather than explicitly registering the views in a viewset in the urlconf, you'll register the viewset with a router class, that automatically determines the urlconf for you.", "Let's define a simple viewset that can be used to list or retrieve all the users in the system.", "If we need to, we can bind this viewset into two separate views, like so:", "Typically we wouldn't do this, but would instead register the viewset with a router, and allow the urlconf to be automatically generated.", "Rather than writing your own viewsets, you'll often want to use the existing base classes that provide a default set of behavior. For example:", "There are two main advantages of using a ViewSet class over using a View class.", "Both of these come with a trade-off. Using regular views and URL confs is more explicit and gives you more control. ViewSets are helpful if you want to get up and running quickly, or when you have a large API and you want to enforce a consistent URL configuration throughout.", "The default routers included with REST framework will provide routes for a standard set of create/retrieve/update/destroy style actions, as shown below:", "During dispatch, the following attributes are available on the ViewSet.", "You may inspect these attributes to adjust behaviour based on the current action. For example, you could restrict permissions to everything except the list action similar to this:", "If you have ad-hoc methods that should be routable, you can mark them as such with the @action decorator. Like regular actions, extra actions may be intended for either a single object, or an entire collection. To indicate this, set the detail argument to True or False. The router will configure its URL patterns accordingly. e.g., the DefaultRouter will configure detail actions to contain pk in their URL patterns.", "A more complete example of extra actions:", "The action decorator will route GET requests by default, but may also accept other HTTP methods by setting the methods argument. For example:", "The decorator allows you to override any viewset-level configuration such as permission_classes, serializer_class, filter_backends...:", "The two new actions will then be available at the urls ^users/{pk}/set_password/$ and ^users/{pk}/unset_password/$. Use the url_path and url_name parameters to change the URL segment and the reverse URL name of the action.", "To view all extra actions, call the .get_extra_actions() method.", "Extra actions can map additional HTTP methods to separate ViewSet methods. For example, the above password set/unset methods could be consolidated into a single route. Note that additional mappings do not accept arguments.", "If you need to get the URL of an action, use the .reverse_action() method. This is a convenience wrapper for reverse(), automatically passing the view's request object and prepending the url_name with the .basename attribute.", "Note that the basename is provided by the router during ViewSet registration. If you are not using a router, then you must provide the basename argument to the .as_view() method.", "Using the example from the previous section:", "Alternatively, you can use the url_name attribute set by the @action decorator.", "The url_name argument for .reverse_action() should match the same argument to the @action decorator. Additionally, this method can be used to reverse the default actions, such as list and create.", "The ViewSet class inherits from APIView. You can use any of the standard attributes such as permission_classes, authentication_classes in order to control the API policy on the viewset.", "The ViewSet class does not provide any implementations of actions. In order to use a ViewSet class you'll override the class and define the action implementations explicitly.", "The GenericViewSet class inherits from GenericAPIView, and provides the default set of get_object, get_queryset methods and other generic view base behavior, but does not include any actions by default.", "In order to use a GenericViewSet class you'll override the class and either mixin the required mixin classes, or define the action implementations explicitly.", "The ModelViewSet class inherits from GenericAPIView and includes implementations for various actions, by mixing in the behavior of the various mixin classes.", "The actions provided by the ModelViewSet class are .list(), .retrieve(), .create(), .update(), .partial_update(), and .destroy().", "Because ModelViewSet extends GenericAPIView, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Note that you can use any of the standard attributes or method overrides provided by GenericAPIView. For example, to use a ViewSet that dynamically determines the queryset it should operate on, you might do something like this:", "Note however that upon removal of the queryset property from your ViewSet, any associated router will be unable to derive the basename of your Model automatically, and so you will have to specify the basename kwarg as part of your router registration.", "Also note that although this class provides the complete set of create/list/retrieve/update/destroy actions by default, you can restrict the available operations by using the standard permission classes.", "The ReadOnlyModelViewSet class also inherits from GenericAPIView. As with ModelViewSet it also includes implementations for various actions, but unlike ModelViewSet only provides the 'read-only' actions, .list() and .retrieve().", "As with ModelViewSet, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Again, as with ModelViewSet, you can use any of the standard attributes and method overrides available to GenericAPIView.", "You may need to provide custom ViewSet classes that do not have the full set of ModelViewSet actions, or that customize the behavior in some other way.", "To create a base viewset class that provides create, list and retrieve operations, inherit from GenericViewSet, and mixin the required actions:", "By creating your own base ViewSet classes, you can provide common behavior that can be reused in multiple viewsets across your API.", "viewsets.py"]}, {"name": "MultiPartParser", "path": "api-guide/parsers/index#multipartparser", "type": "Ref: Parsers", "text": ["Machine interacting web services tend to use more structured formats for sending data than form-encoded, since they're sending more complex data than simple forms", "\u2014 Malcom Tredinnick, Django developers group", "REST framework includes a number of built in Parser classes, that allow you to accept requests with various media types. There is also support for defining your own custom parsers, which gives you the flexibility to design the media types that your API accepts.", "The set of valid parsers for a view is always defined as a list of classes. When request.data is accessed, REST framework will examine the Content-Type header on the incoming request, and determine which parser to use to parse the request content.", "Note: When developing client applications always remember to make sure you're setting the Content-Type header when sending data in an HTTP request.", "If you don't set the content type, most clients will default to using 'application/x-www-form-urlencoded', which may not be what you wanted.", "As an example, if you are sending json encoded data using jQuery with the .ajax() method, you should make sure to include the contentType: 'application/json' setting.", "The default set of parsers may be set globally, using the DEFAULT_PARSER_CLASSES setting. For example, the following settings would allow only requests with JSON content, instead of the default of JSON or form data.", "You can also set the parsers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Parses JSON request content. request.data will be populated with a dictionary of data.", ".media_type: application/json", "Parses HTML form content. request.data will be populated with a QueryDict of data.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: application/x-www-form-urlencoded", "Parses multipart HTML form content, which supports file uploads. Both request.data will be populated with a QueryDict.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: multipart/form-data", "Parses raw file upload content. The request.data property will be a dictionary with a single key 'file' containing the uploaded file.", "If the view used with FileUploadParser is called with a filename URL keyword argument, then that argument will be used as the filename.", "If it is called without a filename URL keyword argument, then the client must set the filename in the Content-Disposition HTTP header. For example Content-Disposition: attachment; filename=upload.jpg.", ".media_type: */*", "To implement a custom parser, you should override BaseParser, set the .media_type property, and implement the .parse(self, stream, media_type, parser_context) method.", "The method should return the data that will be used to populate the request.data property.", "The arguments passed to .parse() are:", "A stream-like object representing the body of the request.", "Optional. If provided, this is the media type of the incoming request content.", "Depending on the request's Content-Type: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"text/plain; charset=utf-8\".", "Optional. If supplied, this argument will be a dictionary containing any additional context that may be required to parse the request content.", "By default this will include the following keys: view, request, args, kwargs.", "The following is an example plaintext parser that will populate the request.data property with a string representing the body of the request.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "parsers.py"]}, {"name": "MultiPartRenderer", "path": "api-guide/renderers/index#multipartrenderer", "type": "Ref: Renderers", "text": ["Before a TemplateResponse instance can be returned to the client, it must be rendered. The rendering process takes the intermediate representation of template and context, and turns it into the final byte stream that can be served to the client.", "\u2014 Django documentation", "REST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.", "The set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.", "The basic process of content negotiation involves examining the request's Accept header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL http://example.com/api/users_count.json might be an endpoint that always returns JSON data.", "For more information see the documentation on content negotiation.", "The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use JSON as the main media type and also include the self describing API.", "You can also set the renderers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "It's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an Accept: */* header, or not including an Accept header at all, then REST framework will select the first renderer in the list to use for the response.", "For example if your API serves JSON responses and the HTML browsable API, you might want to make JSONRenderer your default renderer, in order to send JSON responses to clients that do not specify an Accept header.", "If your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making TemplateHTMLRenderer your default renderer, in order to play nicely with older browsers that send broken accept headers.", "Renders the request data into JSON, using utf-8 encoding.", "Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:", "The client may additionally include an 'indent' media type parameter, in which case the returned JSON will be indented. For example Accept: application/json; indent=4.", "The default JSON encoding style can be altered using the UNICODE_JSON and COMPACT_JSON settings keys.", ".media_type: application/json", ".format: 'json'", ".charset: None", "Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the Response does not need to be serialized. Also, unlike other renderers, you may want to include a template_name argument when creating the Response.", "The TemplateHTMLRenderer will create a RequestContext, using the response.data as the context dict, and determine a template name to use to render the context.", "Note: When used with a view that makes use of a serializer the Response sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the TemplateHTMLRenderer to render it. For example:", "The template name is determined by (in order of preference):", "An example of a view that uses TemplateHTMLRenderer:", "You can use TemplateHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", "If you're building websites that use TemplateHTMLRenderer along with other renderer classes, you should consider listing TemplateHTMLRenderer as the first class in the renderer_classes list, so that it will be prioritised first even for browsers that send poorly formed ACCEPT: headers.", "See the HTML & Forms Topic Page for further examples of TemplateHTMLRenderer usage.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: StaticHTMLRenderer", "A simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.", "An example of a view that uses StaticHTMLRenderer:", "You can use StaticHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: TemplateHTMLRenderer", "Renders data into HTML for the Browsable API:", "", "This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.", ".media_type: text/html", ".format: 'api'", ".charset: utf-8", ".template: 'rest_framework/api.html'", "By default the response content will be rendered with the highest priority renderer apart from BrowsableAPIRenderer. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the get_default_renderer() method. For example:", "Renders data into HTML for an admin-like display:", "", "This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.", "Note that views that have nested or list serializers for their input won't work well with the AdminRenderer, as the HTML forms are unable to properly support them.", "Note: The AdminRenderer is only able to include links to detail pages when a properly configured URL_FIELD_NAME (url by default) attribute is present in the data. For HyperlinkedModelSerializer this will be the case, but for ModelSerializer or plain Serializer classes you'll need to make sure to include the field explicitly. For example here we use models get_absolute_url method:", ".media_type: text/html", ".format: 'admin'", ".charset: utf-8", ".template: 'rest_framework/admin.html'", "Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing <form> tags, a hidden CSRF input or any submit buttons.", "This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the render_form template tag.", "For more information see the HTML & Forms documentation.", ".media_type: text/html", ".format: 'form'", ".charset: utf-8", ".template: 'rest_framework/horizontal/form.html'", "This renderer is used for rendering HTML multipart form data. It is not suitable as a response renderer, but is instead used for creating test requests, using REST framework's test client and test request factory.", ".media_type: multipart/form-data; boundary=BoUnDaRyStRiNg", ".format: 'multipart'", ".charset: utf-8", "To implement a custom renderer, you should override BaseRenderer, set the .media_type and .format properties, and implement the .render(self, data, media_type=None, renderer_context=None) method.", "The method should return a bytestring, which will be used as the body of the HTTP response.", "The arguments passed to the .render() method are:", "The request data, as set by the Response() instantiation.", "Optional. If provided, this is the accepted media type, as determined by the content negotiation stage.", "Depending on the client's Accept: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"application/json; nested=true\".", "Optional. If provided, this is a dictionary of contextual information provided by the view.", "By default this will include the following keys: view, request, response, args, kwargs.", "The following is an example plaintext renderer that will return a response with the data parameter as the content of the response.", "By default renderer classes are assumed to be using the UTF-8 encoding. To use a different encoding, set the charset attribute on the renderer.", "Note that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the Response class, with the charset attribute set on the renderer used to determine the encoding.", "If the renderer returns a bytestring representing raw binary content, you should set a charset value of None, which will ensure the Content-Type header of the response will not have a charset value set.", "In some cases you may also want to set the render_style attribute to 'binary'. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.", "You can do some pretty flexible things using REST framework's renderers. Some examples...", "In some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access request.accepted_renderer to determine the negotiated renderer that will be used for the response.", "For example:", "In some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a media_type value such as image/*, or */*.", "If you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the content_type attribute. For example:", "For the purposes of many Web APIs, simple JSON responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and HATEOAS you'll need to consider the design and usage of your media types in more detail.", "In the words of Roy Fielding, \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".", "For good examples of custom media types, see GitHub's use of a custom application/vnd.github+json media type, and Mike Amundsen's IANA approved application/vnd.collection+json JSON-based hypermedia.", "Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an Http404 or PermissionDenied exception, or a subclass of APIException.", "If you're using either the TemplateHTMLRenderer or the StaticHTMLRenderer and an exception is raised, the behavior is slightly different, and mirrors Django's default handling of error views.", "Exceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.", "Templates will render with a RequestContext which includes the status_code and details keys.", "Note: If DEBUG=True, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST framework JSONP provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Warning: If you require cross-domain AJAX requests, you should generally be using the more modern approach of CORS as an alternative to JSONP. See the CORS documentation for more details.", "The jsonp approach is essentially a browser hack, and is only appropriate for globally readable API endpoints, where GET requests are unauthenticated and do not require any user permissions.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "XLSX is the world's most popular binary spreadsheet format. Tim Allen of The Wharton School maintains drf-renderer-xlsx, which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.", "Install using pip.", "Modify your REST framework settings.", "To avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the Content-Disposition header. If no filename is provided, it will default to export.xlsx. For example:", "Comma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. Mjumbe Poe maintains the djangorestframework-csv package which provides CSV renderer support for REST framework.", "UltraJSON is an optimized C JSON encoder which can give significantly faster JSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now unmaintained drf-ujson-renderer, which implements JSON rendering using the UJSON package.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "Django REST Pandas provides a serializer and renderers that support additional data processing and output via the Pandas DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both .xls and .xlsx), and a number of other formats. It is maintained by S. Andrew Sheppard as part of the wq Project.", "Rest Framework Latex provides a renderer that outputs PDFs using Laulatex. It is maintained by Pebble (S/F Software).", "renderers.py"]}, {"name": "MultipleChoiceField", "path": "api-guide/fields/index#multiplechoicefield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "NamespaceVersioning", "path": "api-guide/versioning/index#namespaceversioning", "type": "Ref: Versioning", "text": ["Versioning an interface is just a \"polite\" way to kill deployed clients.", "\u2014 Roy Fielding.", "API versioning allows you to alter behavior between different clients. REST framework provides for a number of different versioning schemes.", "Versioning is determined by the incoming client request, and may either be based on the request URL, or based on the request headers.", "There are a number of valid approaches to approaching versioning. Non-versioned systems can also be appropriate, particularly if you're engineering for very long-term systems with multiple clients outside of your control.", "When API versioning is enabled, the request.version attribute will contain a string that corresponds to the version requested in the incoming client request.", "By default, versioning is not enabled, and request.version will always return None.", "How you vary the API behavior is up to you, but one example you might typically want is to switch to a different serialization style in a newer version. For example:", "The reverse function included by REST framework ties in with the versioning scheme. You need to make sure to include the current request as a keyword argument, like so.", "The above function will apply any URL transformations appropriate to the request version. For example:", "When using hyperlinked serialization styles together with a URL based versioning scheme make sure to include the request as context to the serializer.", "Doing so will allow any returned URLs to include the appropriate versioning.", "The versioning scheme is defined by the DEFAULT_VERSIONING_CLASS settings key.", "Unless it is explicitly set, the value for DEFAULT_VERSIONING_CLASS will be None. In this case the request.version attribute will always return None.", "You can also set the versioning scheme on an individual view. Typically you won't need to do this, as it makes more sense to have a single versioning scheme used globally. If you do need to do so, use the versioning_class attribute.", "The following settings keys are also used to control versioning:", "You can also set your versioning class plus those three values on a per-view or a per-viewset basis by defining your own versioning scheme and using the default_version, allowed_versions and version_param class variables. For example, if you want to use URLPathVersioning:", "This scheme requires the client to specify the version as part of the media type in the Accept header. The version is included as a media type parameter, that supplements the main media type.", "Here's an example HTTP request using the accept header versioning style.", "In the example request above request.version attribute would return the string '1.0'.", "Versioning based on accept headers is generally considered as best practice, although other styles may be suitable depending on your client requirements.", "Strictly speaking the json media type is not specified as including additional parameters. If you are building a well-specified public API you might consider using a vendor media type. To do so, configure your renderers to use a JSON based renderer with a custom media type:", "Your client requests would now look like this:", "This scheme requires the client to specify the version as part of the URL path.", "Your URL conf must include a pattern that matches the version with a 'version' keyword argument, so that this information is available to the versioning scheme.", "To the client, this scheme is the same as URLPathVersioning. The only difference is how it is configured in your Django application, as it uses URL namespacing, instead of URL keyword arguments.", "With this scheme the request.version attribute is determined based on the namespace that matches the incoming request path.", "In the following example we're giving a set of views two different possible URL prefixes, each under a different namespace:", "Both URLPathVersioning and NamespaceVersioning are reasonable if you just need a simple versioning scheme. The URLPathVersioning approach might be better suitable for small ad-hoc projects, and the NamespaceVersioning is probably easier to manage for larger projects.", "The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.", "For example the following is an HTTP request to the http://v1.example.com/bookings/ URL:", "By default this implementation expects the hostname to match this simple regular expression:", "Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.", "The HostNameVersioning scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as 127.0.0.1. There are various online tutorials on how to access localhost with a custom subdomain which you may find helpful in this case.", "Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.", "This scheme is a simple style that includes the version as a query parameter in the URL. For example:", "To implement a custom versioning scheme, subclass BaseVersioning and override the .determine_version method.", "The following example uses a custom X-API-Version header to determine the requested version.", "If your versioning scheme is based on the request URL, you will also want to alter how versioned URLs are determined. In order to do so you should override the .reverse() method on the class. See the source code for examples.", "versioning.py"]}, {"name": "NotAcceptable", "path": "api-guide/exceptions/index#notacceptable", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "NotAuthenticated", "path": "api-guide/exceptions/index#notauthenticated", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "NotFound", "path": "api-guide/exceptions/index#notfound", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "NullBooleanField", "path": "api-guide/fields/index#nullbooleanfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "OrderingFilter", "path": "api-guide/filtering/index#orderingfilter", "type": "Ref: Filtering", "text": ["The root QuerySet provided by the Manager describes all objects in the database table. Usually, though, you'll need to select only a subset of the complete set of objects.", "\u2014 Django documentation", "The default behavior of REST framework's generic list views is to return the entire queryset for a model manager. Often you will want your API to restrict the items that are returned by the queryset.", "The simplest way to filter the queryset of any view that subclasses GenericAPIView is to override the .get_queryset() method.", "Overriding this method allows you to customize the queryset returned by the view in a number of different ways.", "You might want to filter the queryset to ensure that only results relevant to the currently authenticated user making the request are returned.", "You can do so by filtering based on the value of request.user.", "For example:", "Another style of filtering might involve restricting the queryset based on some part of the URL.", "For example if your URL config contained an entry like this:", "You could then write a view that returned a purchase queryset filtered by the username portion of the URL:", "A final example of filtering the initial queryset would be to determine the initial queryset based on query parameters in the url.", "We can override .get_queryset() to deal with URLs such as http://example.com/api/purchases?username=denvercoder9, and filter the queryset only if the username parameter is included in the URL:", "As well as being able to override the default queryset, REST framework also includes support for generic filtering backends that allow you to easily construct complex searches and filters.", "Generic filters can also present themselves as HTML controls in the browsable API and admin API.", "", "The default filter backends may be set globally, using the DEFAULT_FILTER_BACKENDS setting. For example.", "You can also set the filter backends on a per-view, or per-viewset basis, using the GenericAPIView class-based views.", "Note that if a filter backend is configured for a view, then as well as being used to filter list views, it will also be used to filter the querysets used for returning a single object.", "For instance, given the previous example, and a product with an id of 4675, the following URL would either return the corresponding object, or return a 404 response, depending on if the filtering conditions were met by the given product instance:", "Note that you can use both an overridden .get_queryset() and generic filtering together, and everything will work as expected. For example, if Product had a many-to-many relationship with User, named purchase, you might want to write a view like this:", "The django-filter library includes a DjangoFilterBackend class which supports highly customizable field filtering for REST framework.", "To use DjangoFilterBackend, first install django-filter.", "Then add 'django_filters' to Django's INSTALLED_APPS:", "You should now either add the filter backend to your settings:", "Or add the filter backend to an individual View or ViewSet.", "If all you need is simple equality-based filtering, you can set a filterset_fields attribute on the view, or viewset, listing the set of fields you wish to filter against.", "This will automatically create a FilterSet class for the given fields, and will allow you to make requests such as:", "For more advanced filtering requirements you can specify a FilterSet class that should be used by the view. You can read more about FilterSets in the django-filter documentation. It's also recommended that you read the section on DRF integration.", "The SearchFilter class supports simple single query parameter based searching, and is based on the Django admin's search functionality.", "When in use, the browsable API will include a SearchFilter control:", "", "The SearchFilter class will only be applied if the view has a search_fields attribute set. The search_fields attribute should be a list of names of text type fields on the model, such as CharField or TextField.", "This will allow the client to filter the items in the list by making queries such as:", "You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation:", "For JSONField and HStoreField fields you can filter based on nested values within the data structure using the same double-underscore notation:", "By default, searches will use case-insensitive partial matches. The search parameter may contain multiple search terms, which should be whitespace and/or comma separated. If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched.", "The search behavior may be restricted by prepending various characters to the search_fields.", "For example:", "By default, the search parameter is named 'search', but this may be overridden with the SEARCH_PARAM setting.", "To dynamically change search fields based on request content, it's possible to subclass the SearchFilter and override the get_search_fields() function. For example, the following subclass will only search on title if the query parameter title_only is in the request:", "For more details, see the Django documentation.", "The OrderingFilter class supports simple query parameter controlled ordering of results.", "", "By default, the query parameter is named 'ordering', but this may by overridden with the ORDERING_PARAM setting.", "For example, to order users by username:", "The client may also specify reverse orderings by prefixing the field name with '-', like so:", "Multiple orderings may also be specified:", "It's recommended that you explicitly specify which fields the API should allowing in the ordering filter. You can do this by setting an ordering_fields attribute on the view, like so:", "This helps prevent unexpected data leakage, such as allowing users to order against a password hash field or other sensitive data.", "If you don't specify an ordering_fields attribute on the view, the filter class will default to allowing the user to filter on any readable fields on the serializer specified by the serializer_class attribute.", "If you are confident that the queryset being used by the view doesn't contain any sensitive data, you can also explicitly specify that a view should allow ordering on any model field or queryset aggregate, by using the special value '__all__'.", "If an ordering attribute is set on the view, this will be used as the default ordering.", "Typically you'd instead control this by setting order_by on the initial queryset, but using the ordering parameter on the view allows you to specify the ordering in a way that it can then be passed automatically as context to a rendered template. This makes it possible to automatically render column headers differently if they are being used to order the results.", "The ordering attribute may be either a string or a list/tuple of strings.", "You can also provide your own generic filtering backend, or write an installable app for other developers to use.", "To do so override BaseFilterBackend, and override the .filter_queryset(self, request, queryset, view) method. The method should return a new, filtered queryset.", "As well as allowing clients to perform searches and filtering, generic filter backends can be useful for restricting which objects should be visible to any given request or user.", "For example, you might need to restrict users to only being able to see objects they created.", "We could achieve the same behavior by overriding get_queryset() on the views, but using a filter backend allows you to more easily add this restriction to multiple views, or to apply it across the entire API.", "Generic filters may also present an interface in the browsable API. To do so you should implement a to_html() method which returns a rendered HTML representation of the filter. This method should have the following signature:", "to_html(self, request, queryset, view)", "The method should return a rendered HTML string.", "You can also make the filter controls available to the schema autogeneration that REST framework provides, by implementing a get_schema_fields() method. This method should have the following signature:", "get_schema_fields(self, view)", "The method should return a list of coreapi.Field instances.", "The following third party packages provide additional filter implementations.", "The django-rest-framework-filters package works together with the DjangoFilterBackend class, and allows you to easily create filters across relationships, or create multiple filter lookup types for a given field.", "The djangorestframework-word-filter developed as alternative to filters.SearchFilter which will search full word in text, or exact match.", "django-url-filter provides a safe way to filter data via human-friendly URLs. It works very similar to DRF serializers and fields in a sense that they can be nested except they are called filtersets and filters. That provides easy way to filter related data. Also this library is generic-purpose so it can be used to filter other sources of data and not only Django QuerySets.", "drf-url-filter is a simple Django app to apply filters on drf ModelViewSet's Queryset in a clean, simple and configurable way. It also supports validations on incoming query params and their values. A beautiful python package Voluptuous is being used for validations on the incoming query parameters. The best part about voluptuous is you can define your own validations as per your query params requirements.", "filters.py"]}, {"name": "PageNumberPagination", "path": "api-guide/pagination/index#pagenumberpagination", "type": "Ref: Pagination", "text": ["Django provides a few classes that help you manage paginated data \u2013 that is, data that\u2019s split across several pages, with \u201cPrevious/Next\u201d links.", "\u2014 Django documentation", "REST framework includes support for customizable pagination styles. This allows you to modify how large result sets are split into individual pages of data.", "The pagination API can support either:", "The built-in styles currently all use links included as part of the content of the response. This style is more accessible when using the browsable API.", "Pagination is only performed automatically if you're using the generic views or viewsets. If you're using a regular APIView, you'll need to call into the pagination API yourself to ensure you return a paginated response. See the source code for the mixins.ListModelMixin and generics.GenericAPIView classes for an example.", "Pagination can be turned off by setting the pagination class to None.", "The pagination style may be set globally, using the DEFAULT_PAGINATION_CLASS and PAGE_SIZE setting keys. For example, to use the built-in limit/offset pagination, you would do something like this:", "Note that you need to set both the pagination class, and the page size that should be used. Both DEFAULT_PAGINATION_CLASS and PAGE_SIZE are None by default.", "You can also set the pagination class on an individual view by using the pagination_class attribute. Typically you'll want to use the same pagination style throughout your API, although you might want to vary individual aspects of the pagination, such as default or maximum page size, on a per-view basis.", "If you want to modify particular aspects of the pagination style, you'll want to override one of the pagination classes, and set the attributes that you want to change.", "You can then apply your new style to a view using the pagination_class attribute:", "Or apply the style globally, using the DEFAULT_PAGINATION_CLASS settings key. For example:", "This pagination style accepts a single number page number in the request query parameters.", "Request:", "Response:", "To enable the PageNumberPagination style globally, use the following configuration, and set the PAGE_SIZE as desired:", "On GenericAPIView subclasses you may also set the pagination_class attribute to select PageNumberPagination on a per-view basis.", "The PageNumberPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the PageNumberPagination class, and then enable your custom pagination class as above.", "This pagination style mirrors the syntax used when looking up multiple database records. The client includes both a \"limit\" and an \"offset\" query parameter. The limit indicates the maximum number of items to return, and is equivalent to the page_size in other styles. The offset indicates the starting position of the query in relation to the complete set of unpaginated items.", "Request:", "Response:", "To enable the LimitOffsetPagination style globally, use the following configuration:", "Optionally, you may also set a PAGE_SIZE key. If the PAGE_SIZE parameter is also used then the limit query parameter will be optional, and may be omitted by the client.", "On GenericAPIView subclasses you may also set the pagination_class attribute to select LimitOffsetPagination on a per-view basis.", "The LimitOffsetPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the LimitOffsetPagination class, and then enable your custom pagination class as above.", "The cursor-based pagination presents an opaque \"cursor\" indicator that the client may use to page through the result set. This pagination style only presents forward and reverse controls, and does not allow the client to navigate to arbitrary positions.", "Cursor based pagination requires that there is a unique, unchanging ordering of items in the result set. This ordering might typically be a creation timestamp on the records, as this presents a consistent ordering to paginate against.", "Cursor based pagination is more complex than other schemes. It also requires that the result set presents a fixed ordering, and does not allow the client to arbitrarily index into the result set. However it does provide the following benefits:", "Proper use of cursor based pagination requires a little attention to detail. You'll need to think about what ordering you want the scheme to be applied against. The default is to order by \"-created\". This assumes that there must be a 'created' timestamp field on the model instances, and will present a \"timeline\" style paginated view, with the most recently added items first.", "You can modify the ordering by overriding the 'ordering' attribute on the pagination class, or by using the OrderingFilter filter class together with CursorPagination. When used with OrderingFilter you should strongly consider restricting the fields that the user may order by.", "Proper usage of cursor pagination should have an ordering field that satisfies the following:", "Using an ordering field that does not satisfy these constraints will generally still work, but you'll be losing some of the benefits of cursor pagination.", "For more technical details on the implementation we use for cursor pagination, the \"Building cursors for the Disqus API\" blog post gives a good overview of the basic approach.", "To enable the CursorPagination style globally, use the following configuration, modifying the PAGE_SIZE as desired:", "On GenericAPIView subclasses you may also set the pagination_class attribute to select CursorPagination on a per-view basis.", "The CursorPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the CursorPagination class, and then enable your custom pagination class as above.", "To create a custom pagination serializer class, you should inherit the subclass pagination.BasePagination, override the paginate_queryset(self, queryset, request, view=None), and get_paginated_response(self, data) methods:", "Note that the paginate_queryset method may set state on the pagination instance, that may later be used by the get_paginated_response method.", "Suppose we want to replace the default pagination output style with a modified format that includes the next and previous links under in a nested 'links' key. We could specify a custom pagination class like so:", "We'd then need to setup the custom class in our configuration:", "Note that if you care about how the ordering of keys is displayed in responses in the browsable API you might choose to use an OrderedDict when constructing the body of paginated responses, but this is optional.", "To have your custom pagination class be used by default, use the DEFAULT_PAGINATION_CLASS setting:", "API responses for list endpoints will now include a Link header, instead of including the pagination links as part of the body of the response, for example:", "", "A custom pagination style, using the 'Link' header'", "You can also make the pagination controls available to the schema autogeneration that REST framework provides, by implementing a get_schema_fields() method. This method should have the following signature:", "get_schema_fields(self, view)", "The method should return a list of coreapi.Field instances.", "By default using the pagination classes will cause HTML pagination controls to be displayed in the browsable API. There are two built-in display styles. The PageNumberPagination and LimitOffsetPagination classes display a list of page numbers with previous and next controls. The CursorPagination class displays a simpler style that only displays a previous and next control.", "You can override the templates that render the HTML pagination controls. The two built-in styles are:", "Providing a template with either of these paths in a global template directory will override the default rendering for the relevant pagination classes.", "Alternatively you can disable HTML pagination controls completely by subclassing on of the existing classes, setting template = None as an attribute on the class. You'll then need to configure your DEFAULT_PAGINATION_CLASS settings key to use your custom class as the default pagination style.", "The low-level API for determining if a pagination class should display the controls or not is exposed as a display_page_controls attribute on the pagination instance. Custom pagination classes should be set to True in the paginate_queryset method if they require the HTML pagination controls to be displayed.", "The .to_html() and .get_html_context() methods may also be overridden in a custom pagination class in order to further customize how the controls are rendered.", "The following third party packages are also available.", "The DRF-extensions package includes a PaginateByMaxMixin mixin class that allows your API clients to specify ?page_size=max to obtain the maximum allowed page size.", "The drf-proxy-pagination package includes a ProxyPagination class which allows to choose pagination class with a query parameter.", "The django-rest-framework-link-header-pagination package includes a LinkHeaderPagination class which provides pagination via an HTTP Link header as described in Github's developer documentation.", "pagination.py"]}, {"name": "Pagination", "path": "api-guide/pagination/index", "type": "API Guide", "text": ["Django provides a few classes that help you manage paginated data \u2013 that is, data that\u2019s split across several pages, with \u201cPrevious/Next\u201d links.", "\u2014 Django documentation", "REST framework includes support for customizable pagination styles. This allows you to modify how large result sets are split into individual pages of data.", "The pagination API can support either:", "The built-in styles currently all use links included as part of the content of the response. This style is more accessible when using the browsable API.", "Pagination is only performed automatically if you're using the generic views or viewsets. If you're using a regular APIView, you'll need to call into the pagination API yourself to ensure you return a paginated response. See the source code for the mixins.ListModelMixin and generics.GenericAPIView classes for an example.", "Pagination can be turned off by setting the pagination class to None.", "The pagination style may be set globally, using the DEFAULT_PAGINATION_CLASS and PAGE_SIZE setting keys. For example, to use the built-in limit/offset pagination, you would do something like this:", "Note that you need to set both the pagination class, and the page size that should be used. Both DEFAULT_PAGINATION_CLASS and PAGE_SIZE are None by default.", "You can also set the pagination class on an individual view by using the pagination_class attribute. Typically you'll want to use the same pagination style throughout your API, although you might want to vary individual aspects of the pagination, such as default or maximum page size, on a per-view basis.", "If you want to modify particular aspects of the pagination style, you'll want to override one of the pagination classes, and set the attributes that you want to change.", "You can then apply your new style to a view using the pagination_class attribute:", "Or apply the style globally, using the DEFAULT_PAGINATION_CLASS settings key. For example:", "This pagination style accepts a single number page number in the request query parameters.", "Request:", "Response:", "To enable the PageNumberPagination style globally, use the following configuration, and set the PAGE_SIZE as desired:", "On GenericAPIView subclasses you may also set the pagination_class attribute to select PageNumberPagination on a per-view basis.", "The PageNumberPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the PageNumberPagination class, and then enable your custom pagination class as above.", "This pagination style mirrors the syntax used when looking up multiple database records. The client includes both a \"limit\" and an \"offset\" query parameter. The limit indicates the maximum number of items to return, and is equivalent to the page_size in other styles. The offset indicates the starting position of the query in relation to the complete set of unpaginated items.", "Request:", "Response:", "To enable the LimitOffsetPagination style globally, use the following configuration:", "Optionally, you may also set a PAGE_SIZE key. If the PAGE_SIZE parameter is also used then the limit query parameter will be optional, and may be omitted by the client.", "On GenericAPIView subclasses you may also set the pagination_class attribute to select LimitOffsetPagination on a per-view basis.", "The LimitOffsetPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the LimitOffsetPagination class, and then enable your custom pagination class as above.", "The cursor-based pagination presents an opaque \"cursor\" indicator that the client may use to page through the result set. This pagination style only presents forward and reverse controls, and does not allow the client to navigate to arbitrary positions.", "Cursor based pagination requires that there is a unique, unchanging ordering of items in the result set. This ordering might typically be a creation timestamp on the records, as this presents a consistent ordering to paginate against.", "Cursor based pagination is more complex than other schemes. It also requires that the result set presents a fixed ordering, and does not allow the client to arbitrarily index into the result set. However it does provide the following benefits:", "Proper use of cursor based pagination requires a little attention to detail. You'll need to think about what ordering you want the scheme to be applied against. The default is to order by \"-created\". This assumes that there must be a 'created' timestamp field on the model instances, and will present a \"timeline\" style paginated view, with the most recently added items first.", "You can modify the ordering by overriding the 'ordering' attribute on the pagination class, or by using the OrderingFilter filter class together with CursorPagination. When used with OrderingFilter you should strongly consider restricting the fields that the user may order by.", "Proper usage of cursor pagination should have an ordering field that satisfies the following:", "Using an ordering field that does not satisfy these constraints will generally still work, but you'll be losing some of the benefits of cursor pagination.", "For more technical details on the implementation we use for cursor pagination, the \"Building cursors for the Disqus API\" blog post gives a good overview of the basic approach.", "To enable the CursorPagination style globally, use the following configuration, modifying the PAGE_SIZE as desired:", "On GenericAPIView subclasses you may also set the pagination_class attribute to select CursorPagination on a per-view basis.", "The CursorPagination class includes a number of attributes that may be overridden to modify the pagination style.", "To set these attributes you should override the CursorPagination class, and then enable your custom pagination class as above.", "To create a custom pagination serializer class, you should inherit the subclass pagination.BasePagination, override the paginate_queryset(self, queryset, request, view=None), and get_paginated_response(self, data) methods:", "Note that the paginate_queryset method may set state on the pagination instance, that may later be used by the get_paginated_response method.", "Suppose we want to replace the default pagination output style with a modified format that includes the next and previous links under in a nested 'links' key. We could specify a custom pagination class like so:", "We'd then need to setup the custom class in our configuration:", "Note that if you care about how the ordering of keys is displayed in responses in the browsable API you might choose to use an OrderedDict when constructing the body of paginated responses, but this is optional.", "To have your custom pagination class be used by default, use the DEFAULT_PAGINATION_CLASS setting:", "API responses for list endpoints will now include a Link header, instead of including the pagination links as part of the body of the response, for example:", "", "A custom pagination style, using the 'Link' header'", "You can also make the pagination controls available to the schema autogeneration that REST framework provides, by implementing a get_schema_fields() method. This method should have the following signature:", "get_schema_fields(self, view)", "The method should return a list of coreapi.Field instances.", "By default using the pagination classes will cause HTML pagination controls to be displayed in the browsable API. There are two built-in display styles. The PageNumberPagination and LimitOffsetPagination classes display a list of page numbers with previous and next controls. The CursorPagination class displays a simpler style that only displays a previous and next control.", "You can override the templates that render the HTML pagination controls. The two built-in styles are:", "Providing a template with either of these paths in a global template directory will override the default rendering for the relevant pagination classes.", "Alternatively you can disable HTML pagination controls completely by subclassing on of the existing classes, setting template = None as an attribute on the class. You'll then need to configure your DEFAULT_PAGINATION_CLASS settings key to use your custom class as the default pagination style.", "The low-level API for determining if a pagination class should display the controls or not is exposed as a display_page_controls attribute on the pagination instance. Custom pagination classes should be set to True in the paginate_queryset method if they require the HTML pagination controls to be displayed.", "The .to_html() and .get_html_context() methods may also be overridden in a custom pagination class in order to further customize how the controls are rendered.", "The following third party packages are also available.", "The DRF-extensions package includes a PaginateByMaxMixin mixin class that allows your API clients to specify ?page_size=max to obtain the maximum allowed page size.", "The drf-proxy-pagination package includes a ProxyPagination class which allows to choose pagination class with a query parameter.", "The django-rest-framework-link-header-pagination package includes a LinkHeaderPagination class which provides pagination via an HTTP Link header as described in Github's developer documentation.", "pagination.py"]}, {"name": "ParseError", "path": "api-guide/exceptions/index#parseerror", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "Parsers", "path": "api-guide/parsers/index", "type": "API Guide", "text": ["Machine interacting web services tend to use more structured formats for sending data than form-encoded, since they're sending more complex data than simple forms", "\u2014 Malcom Tredinnick, Django developers group", "REST framework includes a number of built in Parser classes, that allow you to accept requests with various media types. There is also support for defining your own custom parsers, which gives you the flexibility to design the media types that your API accepts.", "The set of valid parsers for a view is always defined as a list of classes. When request.data is accessed, REST framework will examine the Content-Type header on the incoming request, and determine which parser to use to parse the request content.", "Note: When developing client applications always remember to make sure you're setting the Content-Type header when sending data in an HTTP request.", "If you don't set the content type, most clients will default to using 'application/x-www-form-urlencoded', which may not be what you wanted.", "As an example, if you are sending json encoded data using jQuery with the .ajax() method, you should make sure to include the contentType: 'application/json' setting.", "The default set of parsers may be set globally, using the DEFAULT_PARSER_CLASSES setting. For example, the following settings would allow only requests with JSON content, instead of the default of JSON or form data.", "You can also set the parsers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Parses JSON request content. request.data will be populated with a dictionary of data.", ".media_type: application/json", "Parses HTML form content. request.data will be populated with a QueryDict of data.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: application/x-www-form-urlencoded", "Parses multipart HTML form content, which supports file uploads. Both request.data will be populated with a QueryDict.", "You will typically want to use both FormParser and MultiPartParser together in order to fully support HTML form data.", ".media_type: multipart/form-data", "Parses raw file upload content. The request.data property will be a dictionary with a single key 'file' containing the uploaded file.", "If the view used with FileUploadParser is called with a filename URL keyword argument, then that argument will be used as the filename.", "If it is called without a filename URL keyword argument, then the client must set the filename in the Content-Disposition HTTP header. For example Content-Disposition: attachment; filename=upload.jpg.", ".media_type: */*", "To implement a custom parser, you should override BaseParser, set the .media_type property, and implement the .parse(self, stream, media_type, parser_context) method.", "The method should return the data that will be used to populate the request.data property.", "The arguments passed to .parse() are:", "A stream-like object representing the body of the request.", "Optional. If provided, this is the media type of the incoming request content.", "Depending on the request's Content-Type: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"text/plain; charset=utf-8\".", "Optional. If supplied, this argument will be a dictionary containing any additional context that may be required to parse the request content.", "By default this will include the following keys: view, request, args, kwargs.", "The following is an example plaintext parser that will populate the request.data property with a string representing the body of the request.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "parsers.py"]}, {"name": "PermissionDenied", "path": "api-guide/exceptions/index#permissiondenied", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "Permissions", "path": "api-guide/permissions/index", "type": "API Guide", "text": ["Authentication or identification by itself is not usually sufficient to gain access to information or code. For that, the entity requesting access must have authorization.", "\u2014 Apple Developer Documentation", "Together with authentication and throttling, permissions determine whether a request should be granted or denied access.", "Permission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted.", "Permissions are used to grant or deny access for different classes of users to different parts of the API.", "The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.", "A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in REST framework.", "Permissions in REST framework are always defined as a list of permission classes.", "Before running the main body of the view each permission in the list is checked. If any permission check fails an exceptions.PermissionDenied or exceptions.NotAuthenticated exception will be raised, and the main body of the view will not run.", "When the permissions checks fail either a \"403 Forbidden\" or a \"401 Unauthorized\" response will be returned, according to the following rules:", "REST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.", "Object level permissions are run by REST framework's generic views when .get_object() is called. As with view level permissions, an exceptions.PermissionDenied exception will be raised if the user is not allowed to act on the given object.", "If you're writing your own views and want to enforce object level permissions, or if you override the get_object method on a generic view, then you'll need to explicitly call the .check_object_permissions(request, obj) method on the view at the point at which you've retrieved the object.", "This will either raise a PermissionDenied or NotAuthenticated exception, or simply return if the view has the appropriate permissions.", "For example:", "Note: With the exception of DjangoObjectPermissions, the provided permission classes in rest_framework.permissions do not implement the methods necessary to check object permissions.", "If you wish to use the provided permission classes in order to check object permissions, you must subclass them and implement the has_object_permission() method described in the Custom permissions section (below).", "For performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.", "Often when you're using object level permissions you'll also want to filter the queryset appropriately, to ensure that users only have visibility onto instances that they are permitted to view.", "Because the get_object() method is not called, object level permissions from the has_object_permission() method are not applied when creating objects. In order to restrict object creation you need to implement the permission check either in your Serializer class or override the perform_create() method of your ViewSet class.", "The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting. For example.", "If not specified, this setting defaults to allowing unrestricted access:", "You can also set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "Note: when you set new permission classes via the class attribute or decorators you're telling the view to ignore the default list set in the settings.py file.", "Provided they inherit from rest_framework.permissions.BasePermission, permissions can be composed using standard Python bitwise operators. For example, IsAuthenticatedOrReadOnly could be written:", "Note: it supports & (and), | (or) and ~ (not).", "The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated.", "This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.", "The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise.", "This permission is suitable if you want your API to only be accessible to registered users.", "The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed.", "This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.", "The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request. Requests for unauthorised users will only be permitted if the request method is one of the \"safe\" methods; GET, HEAD or OPTIONS.", "This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.", "This permission class ties into Django's standard django.contrib.auth model permissions. This permission must only be applied to views that have a .queryset property or get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant model permissions assigned.", "The default behaviour can also be overridden to support custom model permissions. For example, you might want to include a view model permission for GET requests.", "To use custom model permissions, override DjangoModelPermissions and set the .perms_map property. Refer to the source code for details.", "Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API.", "This permission class ties into Django's standard object permissions framework that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as django-guardian.", "As with DjangoModelPermissions, this permission must only be applied to views that have a .queryset property or .get_queryset() method. Authorization will only be granted if the user is authenticated and has the relevant per-object permissions and relevant model permissions assigned.", "Note that DjangoObjectPermissions does not require the django-guardian package, and should support other object-level backends equally well.", "As with DjangoModelPermissions you can use custom model permissions by overriding DjangoObjectPermissions and setting the .perms_map property. Refer to the source code for details.", "Note: If you need object level view permissions for GET, HEAD and OPTIONS requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the DjangoObjectPermissionsFilter class provided by the djangorestframework-guardian package. It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.", "To implement a custom permission, override BasePermission and implement either, or both, of the following methods:", "The methods should return True if the request should be granted access, and False otherwise.", "If you need to test if a request is a read operation or a write operation, you should check the request method against the constant SAFE_METHODS, which is a tuple containing 'GET', 'OPTIONS' and 'HEAD'. For example:", "Note: The instance-level has_object_permission method will only be called if the view-level has_permission checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call .check_object_permissions(request, obj). If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising PermissionDenied on failure.)", "Custom permissions will raise a PermissionDenied exception if the test fails. To change the error message associated with the exception, implement a message attribute directly on your custom permission. Otherwise the default_detail attribute from PermissionDenied will be used. Similarly, to change the code identifier associated with the exception, implement a code attribute directly on your custom permission - otherwise the default_code attribute from PermissionDenied will be used.", "The following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.", "As well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:", "Note that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling self.check_object_permissions(request, obj) from the view once you have the object instance. This call will raise an appropriate APIException if any object-level permission checks fail, and will otherwise simply return.", "Also note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the filtering documentation for more details.", "REST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.", "The following table lists the access restriction methods and the level of control they offer over which actions.", "* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  ** The get_*() methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.", "The following third party packages are also available.", "The Django REST - Access Policy package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies. ", "The Composed Permissions package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.", "The REST Condition package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.", "The DRY Rest Permissions package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.", "The Django Rest Framework Roles package makes it easier to parameterize your API over multiple types of users.", "The Django REST Framework API Key package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. machines) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.", "The Django Rest Framework Role Filters package provides simple filtering over multiple types of roles.", "The Django Rest Framework PSQ package is an extension that gives support for having action-based permission_classes, serializer_class, and queryset dependent on permission-based rules.", "permissions.py"]}, {"name": "PrimaryKeyRelatedField", "path": "api-guide/relations/index#primarykeyrelatedfield", "type": "Ref: Serializer relations", "text": ["Data structures, not algorithms, are central to programming.", "\u2014 Rob Pike", "Relational fields are used to represent model relationships. They can be applied to ForeignKey, ManyToManyField and OneToOneField relationships, as well as to reverse relationships, and custom relationships such as GenericForeignKey.", "Note: The relational fields are declared in relations.py, but by convention you should import them from the serializers module, using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "When using the ModelSerializer class, serializer fields and relationships will be automatically generated for you. Inspecting these automatically generated fields can be a useful tool for determining how to customize the relationship style.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "In order to explain the various types of relational fields, we'll use a couple of simple models for our examples. Our models will be for music albums, and the tracks listed on each album.", "StringRelatedField may be used to represent the target of the relationship using its __str__ method.", "For example, the following serializer:", "Would serialize to the following representation:", "This field is read only.", "Arguments:", "PrimaryKeyRelatedField may be used to represent the target of the relationship using its primary key.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Arguments:", "HyperlinkedRelatedField may be used to represent the target of the relationship using a hyperlink.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Note: This field is designed for objects that map to a URL that accepts a single URL keyword argument, as set using the lookup_field and lookup_url_kwarg arguments.", "This is suitable for URLs that contain a single primary key or slug argument as part of the URL.", "If you require more complex hyperlinked representation you'll need to customize the field, as described in the custom hyperlinked fields section, below.", "Arguments:", "SlugRelatedField may be used to represent the target of the relationship using a field on the target.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "When using SlugRelatedField as a read-write field, you will normally want to ensure that the slug field corresponds to a model field with unique=True.", "Arguments:", "This field can be applied as an identity relationship, such as the 'url' field on a HyperlinkedModelSerializer. It can also be used for an attribute on the object. For example, the following serializer:", "Would serialize to a representation like this:", "This field is always read-only.", "Arguments:", "As opposed to previously discussed references to another entity, the referred entity can instead also be embedded or nested in the representation of the object that refers to it. Such nested relationships can be expressed by using serializers as fields. ", "If the field is used to represent a to-many relationship, you should add the many=True flag to the serializer field.", "For example, the following serializer:", "Would serialize to a nested representation like this:", "By default nested serializers are read-only. If you want to support write-operations to a nested serializer field you'll need to create create() and/or update() methods in order to explicitly specify how the child relationships should be saved:", "In rare cases where none of the existing relational styles fit the representation you need, you can implement a completely custom relational field, that describes exactly how the output representation should be generated from the model instance.", "To implement a custom relational field, you should override RelatedField, and implement the .to_representation(self, value) method. This method takes the target of the field as the value argument, and should return the representation that should be used to serialize the target. The value argument will typically be a model instance.", "If you want to implement a read-write relational field, you must also implement the .to_internal_value(self, data) method.", "To provide a dynamic queryset based on the context, you can also override .get_queryset(self) instead of specifying .queryset on the class or when initializing the field.", "For example, we could define a relational field to serialize a track to a custom string representation, using its ordering, title, and duration:", "This custom field would then serialize to the following representation:", "In some cases you may need to customize the behavior of a hyperlinked field, in order to represent URLs that require more than a single lookup field.", "You can achieve this by overriding HyperlinkedRelatedField. There are two methods that may be overridden:", "get_url(self, obj, view_name, request, format)", "The get_url method is used to map the object instance to its URL representation.", "May raise a NoReverseMatch if the view_name and lookup_field attributes are not configured to correctly match the URL conf.", "get_object(self, view_name, view_args, view_kwargs)", "If you want to support a writable hyperlinked field then you'll also want to override get_object, in order to map incoming URLs back to the object they represent. For read-only hyperlinked fields there is no need to override this method.", "The return value of this method should the object that corresponds to the matched URL conf arguments.", "May raise an ObjectDoesNotExist exception.", "Say we have a URL for a customer object that takes two keyword arguments, like so:", "This cannot be represented with the default implementation, which accepts only a single lookup field.", "In this case we'd need to override HyperlinkedRelatedField to get the behavior we want:", "Note that if you wanted to use this style together with the generic views then you'd also need to override .get_object on the view in order to get the correct lookup behavior.", "Generally we recommend a flat style for API representations where possible, but the nested URL style can also be reasonable when used in moderation.", "The queryset argument is only ever required for writable relationship field, in which case it is used for performing the model instance lookup, that maps from the primitive user input, into a model instance.", "In version 2.x a serializer class could sometimes automatically determine the queryset argument if a ModelSerializer class was being used.", "This behavior is now replaced with always using an explicit queryset argument for writable relational fields.", "Doing so reduces the amount of hidden 'magic' that ModelSerializer provides, makes the behavior of the field more clear, and ensures that it is trivial to move between using the ModelSerializer shortcut, or using fully explicit Serializer classes.", "The built-in __str__ method of the model will be used to generate string representations of the objects used to populate the choices property. These choices are used to populate select HTML inputs in the browsable API.", "To provide customized representations for such inputs, override display_value() of a RelatedField subclass. This method will receive a model object, and should return a string suitable for representing it. For example:", "When rendered in the browsable API relational fields will default to only displaying a maximum of 1000 selectable items. If more items are present then a disabled option with \"More than 1000 items\u2026\" will be displayed.", "This behavior is intended to prevent a template from being unable to render in an acceptable timespan due to a very large number of relationships being displayed.", "There are two keyword arguments you can use to control this behavior:", "You can also control these globally using the settings HTML_SELECT_CUTOFF and HTML_SELECT_CUTOFF_TEXT.", "In cases where the cutoff is being enforced you may want to instead use a plain input field in the HTML form. You can do so using the style keyword argument. For example:", "Note that reverse relationships are not automatically included by the ModelSerializer and HyperlinkedModelSerializer classes. To include a reverse relationship, you must explicitly add it to the fields list. For example:", "You'll normally want to ensure that you've set an appropriate related_name argument on the relationship, that you can use as the field name. For example:", "If you have not set a related name for the reverse relationship, you'll need to use the automatically generated related name in the fields argument. For example:", "See the Django documentation on reverse relationships for more details.", "If you want to serialize a generic foreign key, you need to define a custom field, to determine explicitly how you want to serialize the targets of the relationship.", "For example, given the following model for a tag, which has a generic relationship with other arbitrary models:", "And the following two models, which may have associated tags:", "We could define a custom field that could be used to serialize tagged instances, using the type of each instance to determine how it should be serialized:", "If you need the target of the relationship to have a nested representation, you can use the required serializers inside the .to_representation() method:", "Note that reverse generic keys, expressed using the GenericRelation field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.", "For more information see the Django documentation on generic relations.", "By default, relational fields that target a ManyToManyField with a through model specified are set to read-only.", "If you explicitly specify a relational field pointing to a ManyToManyField with a through model, be sure to set read_only to True.", "If you wish to represent extra fields on a through model then you may serialize the through model as a nested object.", "The following third party packages are also available.", "The drf-nested-routers package provides routers and relationship fields for working with nested resources.", "The rest-framework-generic-relations library provides read/write serialization for generic foreign keys.", "relations.py"]}, {"name": "QueryParameterVersioning", "path": "api-guide/versioning/index#queryparameterversioning", "type": "Ref: Versioning", "text": ["Versioning an interface is just a \"polite\" way to kill deployed clients.", "\u2014 Roy Fielding.", "API versioning allows you to alter behavior between different clients. REST framework provides for a number of different versioning schemes.", "Versioning is determined by the incoming client request, and may either be based on the request URL, or based on the request headers.", "There are a number of valid approaches to approaching versioning. Non-versioned systems can also be appropriate, particularly if you're engineering for very long-term systems with multiple clients outside of your control.", "When API versioning is enabled, the request.version attribute will contain a string that corresponds to the version requested in the incoming client request.", "By default, versioning is not enabled, and request.version will always return None.", "How you vary the API behavior is up to you, but one example you might typically want is to switch to a different serialization style in a newer version. For example:", "The reverse function included by REST framework ties in with the versioning scheme. You need to make sure to include the current request as a keyword argument, like so.", "The above function will apply any URL transformations appropriate to the request version. For example:", "When using hyperlinked serialization styles together with a URL based versioning scheme make sure to include the request as context to the serializer.", "Doing so will allow any returned URLs to include the appropriate versioning.", "The versioning scheme is defined by the DEFAULT_VERSIONING_CLASS settings key.", "Unless it is explicitly set, the value for DEFAULT_VERSIONING_CLASS will be None. In this case the request.version attribute will always return None.", "You can also set the versioning scheme on an individual view. Typically you won't need to do this, as it makes more sense to have a single versioning scheme used globally. If you do need to do so, use the versioning_class attribute.", "The following settings keys are also used to control versioning:", "You can also set your versioning class plus those three values on a per-view or a per-viewset basis by defining your own versioning scheme and using the default_version, allowed_versions and version_param class variables. For example, if you want to use URLPathVersioning:", "This scheme requires the client to specify the version as part of the media type in the Accept header. The version is included as a media type parameter, that supplements the main media type.", "Here's an example HTTP request using the accept header versioning style.", "In the example request above request.version attribute would return the string '1.0'.", "Versioning based on accept headers is generally considered as best practice, although other styles may be suitable depending on your client requirements.", "Strictly speaking the json media type is not specified as including additional parameters. If you are building a well-specified public API you might consider using a vendor media type. To do so, configure your renderers to use a JSON based renderer with a custom media type:", "Your client requests would now look like this:", "This scheme requires the client to specify the version as part of the URL path.", "Your URL conf must include a pattern that matches the version with a 'version' keyword argument, so that this information is available to the versioning scheme.", "To the client, this scheme is the same as URLPathVersioning. The only difference is how it is configured in your Django application, as it uses URL namespacing, instead of URL keyword arguments.", "With this scheme the request.version attribute is determined based on the namespace that matches the incoming request path.", "In the following example we're giving a set of views two different possible URL prefixes, each under a different namespace:", "Both URLPathVersioning and NamespaceVersioning are reasonable if you just need a simple versioning scheme. The URLPathVersioning approach might be better suitable for small ad-hoc projects, and the NamespaceVersioning is probably easier to manage for larger projects.", "The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.", "For example the following is an HTTP request to the http://v1.example.com/bookings/ URL:", "By default this implementation expects the hostname to match this simple regular expression:", "Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.", "The HostNameVersioning scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as 127.0.0.1. There are various online tutorials on how to access localhost with a custom subdomain which you may find helpful in this case.", "Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.", "This scheme is a simple style that includes the version as a query parameter in the URL. For example:", "To implement a custom versioning scheme, subclass BaseVersioning and override the .determine_version method.", "The following example uses a custom X-API-Version header to determine the requested version.", "If your versioning scheme is based on the request URL, you will also want to alter how versioned URLs are determined. In order to do so you should override the .reverse() method on the class. See the source code for examples.", "versioning.py"]}, {"name": "ReadOnlyField", "path": "api-guide/fields/index#readonlyfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "ReadOnlyModelViewSet", "path": "api-guide/viewsets/index#readonlymodelviewset", "type": "Ref: ViewSets", "text": ["After routing has determined which controller to use for a request, your controller is responsible for making sense of the request and producing the appropriate output.", "\u2014 Ruby on Rails Documentation", "Django REST framework allows you to combine the logic for a set of related views in a single class, called a ViewSet. In other frameworks you may also find conceptually similar implementations named something like 'Resources' or 'Controllers'.", "A ViewSet class is simply a type of class-based View, that does not provide any method handlers such as .get() or .post(), and instead provides actions such as .list() and .create().", "The method handlers for a ViewSet are only bound to the corresponding actions at the point of finalizing the view, using the .as_view() method.", "Typically, rather than explicitly registering the views in a viewset in the urlconf, you'll register the viewset with a router class, that automatically determines the urlconf for you.", "Let's define a simple viewset that can be used to list or retrieve all the users in the system.", "If we need to, we can bind this viewset into two separate views, like so:", "Typically we wouldn't do this, but would instead register the viewset with a router, and allow the urlconf to be automatically generated.", "Rather than writing your own viewsets, you'll often want to use the existing base classes that provide a default set of behavior. For example:", "There are two main advantages of using a ViewSet class over using a View class.", "Both of these come with a trade-off. Using regular views and URL confs is more explicit and gives you more control. ViewSets are helpful if you want to get up and running quickly, or when you have a large API and you want to enforce a consistent URL configuration throughout.", "The default routers included with REST framework will provide routes for a standard set of create/retrieve/update/destroy style actions, as shown below:", "During dispatch, the following attributes are available on the ViewSet.", "You may inspect these attributes to adjust behaviour based on the current action. For example, you could restrict permissions to everything except the list action similar to this:", "If you have ad-hoc methods that should be routable, you can mark them as such with the @action decorator. Like regular actions, extra actions may be intended for either a single object, or an entire collection. To indicate this, set the detail argument to True or False. The router will configure its URL patterns accordingly. e.g., the DefaultRouter will configure detail actions to contain pk in their URL patterns.", "A more complete example of extra actions:", "The action decorator will route GET requests by default, but may also accept other HTTP methods by setting the methods argument. For example:", "The decorator allows you to override any viewset-level configuration such as permission_classes, serializer_class, filter_backends...:", "The two new actions will then be available at the urls ^users/{pk}/set_password/$ and ^users/{pk}/unset_password/$. Use the url_path and url_name parameters to change the URL segment and the reverse URL name of the action.", "To view all extra actions, call the .get_extra_actions() method.", "Extra actions can map additional HTTP methods to separate ViewSet methods. For example, the above password set/unset methods could be consolidated into a single route. Note that additional mappings do not accept arguments.", "If you need to get the URL of an action, use the .reverse_action() method. This is a convenience wrapper for reverse(), automatically passing the view's request object and prepending the url_name with the .basename attribute.", "Note that the basename is provided by the router during ViewSet registration. If you are not using a router, then you must provide the basename argument to the .as_view() method.", "Using the example from the previous section:", "Alternatively, you can use the url_name attribute set by the @action decorator.", "The url_name argument for .reverse_action() should match the same argument to the @action decorator. Additionally, this method can be used to reverse the default actions, such as list and create.", "The ViewSet class inherits from APIView. You can use any of the standard attributes such as permission_classes, authentication_classes in order to control the API policy on the viewset.", "The ViewSet class does not provide any implementations of actions. In order to use a ViewSet class you'll override the class and define the action implementations explicitly.", "The GenericViewSet class inherits from GenericAPIView, and provides the default set of get_object, get_queryset methods and other generic view base behavior, but does not include any actions by default.", "In order to use a GenericViewSet class you'll override the class and either mixin the required mixin classes, or define the action implementations explicitly.", "The ModelViewSet class inherits from GenericAPIView and includes implementations for various actions, by mixing in the behavior of the various mixin classes.", "The actions provided by the ModelViewSet class are .list(), .retrieve(), .create(), .update(), .partial_update(), and .destroy().", "Because ModelViewSet extends GenericAPIView, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Note that you can use any of the standard attributes or method overrides provided by GenericAPIView. For example, to use a ViewSet that dynamically determines the queryset it should operate on, you might do something like this:", "Note however that upon removal of the queryset property from your ViewSet, any associated router will be unable to derive the basename of your Model automatically, and so you will have to specify the basename kwarg as part of your router registration.", "Also note that although this class provides the complete set of create/list/retrieve/update/destroy actions by default, you can restrict the available operations by using the standard permission classes.", "The ReadOnlyModelViewSet class also inherits from GenericAPIView. As with ModelViewSet it also includes implementations for various actions, but unlike ModelViewSet only provides the 'read-only' actions, .list() and .retrieve().", "As with ModelViewSet, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Again, as with ModelViewSet, you can use any of the standard attributes and method overrides available to GenericAPIView.", "You may need to provide custom ViewSet classes that do not have the full set of ModelViewSet actions, or that customize the behavior in some other way.", "To create a base viewset class that provides create, list and retrieve operations, inherit from GenericViewSet, and mixin the required actions:", "By creating your own base ViewSet classes, you can provide common behavior that can be reused in multiple viewsets across your API.", "viewsets.py"]}, {"name": "RegexField", "path": "api-guide/fields/index#regexfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "RemoteUserAuthentication", "path": "api-guide/authentication/index#remoteuserauthentication", "type": "Ref: Authentication", "text": ["Auth needs to be pluggable.", "\u2014 Jacob Kaplan-Moss, \"REST worst practices\"", "Authentication is the mechanism of associating an incoming request with a set of identifying credentials, such as the user the request came from, or the token that it was signed with. The permission and throttling policies can then use those credentials to determine if the request should be permitted.", "REST framework provides several authentication schemes out of the box, and also allows you to implement custom schemes.", "Authentication always runs at the very start of the view, before the permission and throttling checks occur, and before any other code is allowed to proceed.", "The request.user property will typically be set to an instance of the contrib.auth package's User class.", "The request.auth property is used for any additional authentication information, for example, it may be used to represent an authentication token that the request was signed with.", "Note: Don't forget that authentication by itself won't allow or disallow an incoming request, it simply identifies the credentials that the request was made with.", "For information on how to set up the permission policies for your API please see the permissions documentation.", "The authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set request.user and request.auth using the return value of the first class that successfully authenticates.", "If no class authenticates, request.user will be set to an instance of django.contrib.auth.models.AnonymousUser, and request.auth will be set to None.", "The value of request.user and request.auth for unauthenticated requests can be modified using the UNAUTHENTICATED_USER and UNAUTHENTICATED_TOKEN settings.", "The default authentication schemes may be set globally, using the DEFAULT_AUTHENTICATION_CLASSES setting. For example.", "You can also set the authentication scheme on a per-view or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "When an unauthenticated request is denied permission there are two different error codes that may be appropriate.", "HTTP 401 responses must always include a WWW-Authenticate header, that instructs the client how to authenticate. HTTP 403 responses do not include the WWW-Authenticate header.", "The kind of response that will be used depends on the authentication scheme. Although multiple authentication schemes may be in use, only one scheme may be used to determine the type of response. The first authentication class set on the view is used when determining the type of response.", "Note that when a request may successfully authenticate, but still be denied permission to perform the request, in which case a 403 Permission Denied response will always be used, regardless of the authentication scheme.", "Note that if deploying to Apache using mod_wsgi, the authorization header is not passed through to a WSGI application by default, as it is assumed that authentication will be handled by Apache, rather than at an application level.", "If you are deploying to Apache, and using any non-session based authentication, you will need to explicitly configure mod_wsgi to pass the required headers through to the application. This can be done by specifying the WSGIPassAuthorization directive in the appropriate context and setting it to 'On'.", "This authentication scheme uses HTTP Basic Authentication, signed against a user's username and password. Basic authentication is generally only appropriate for testing.", "If successfully authenticated, BasicAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "Note: If you use BasicAuthentication in production you must ensure that your API is only available over https. You should also ensure that your API clients will always re-request the username and password at login, and will never store those details to persistent storage.", "This authentication scheme uses a simple token-based HTTP Authentication scheme. Token authentication is appropriate for client-server setups, such as native desktop and mobile clients.", "To use the TokenAuthentication scheme you'll need to configure the authentication classes to include TokenAuthentication, and additionally include rest_framework.authtoken in your INSTALLED_APPS setting:", "Note: Make sure to run manage.py migrate after changing your settings. The rest_framework.authtoken app provides Django database migrations.", "You'll also need to create tokens for your users.", "For clients to authenticate, the token key should be included in the Authorization HTTP header. The key should be prefixed by the string literal \"Token\", with whitespace separating the two strings. For example:", "Note: If you want to use a different keyword in the header, such as Bearer, simply subclass TokenAuthentication and set the keyword class variable.", "If successfully authenticated, TokenAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "The curl command line tool may be useful for testing token authenticated APIs. For example:", "Note: If you use TokenAuthentication in production you must ensure that your API is only available over https.", "If you want every user to have an automatically generated Token, you can simply catch the User's post_save signal.", "Note that you'll want to ensure you place this code snippet in an installed models.py module, or some other location that will be imported by Django on startup.", "If you've already created some users, you can generate tokens for all existing users like this:", "When using TokenAuthentication, you may want to provide a mechanism for clients to obtain a token given the username and password. REST framework provides a built-in view to provide this behaviour. To use it, add the obtain_auth_token view to your URLconf:", "Note that the URL part of the pattern can be whatever you want to use.", "The obtain_auth_token view will return a JSON response when valid username and password fields are POSTed to the view using form data or JSON:", "Note that the default obtain_auth_token view explicitly uses JSON requests and responses, rather than using default renderer and parser classes in your settings.", "By default, there are no permissions or throttling applied to the obtain_auth_token view. If you do wish to apply to throttle you'll need to override the view class, and include them using the throttle_classes attribute.", "If you need a customized version of the obtain_auth_token view, you can do so by subclassing the ObtainAuthToken view class, and using that in your url conf instead.", "For example, you may return additional user information beyond the token value:", "And in your urls.py:", "It is also possible to create Tokens manually through the admin interface. In case you are using a large user base, we recommend that you monkey patch the TokenAdmin class customize it to your needs, more specifically by declaring the user field as raw_field.", "your_app/admin.py:", "Since version 3.6.4 it's possible to generate a user token using the following command:", "this command will return the API token for the given user, creating it if it doesn't exist:", "In case you want to regenerate the token (for example if it has been compromised or leaked) you can pass an additional parameter:", "This authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website.", "If successfully authenticated, SessionAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 403 Forbidden response.", "If you're using an AJAX-style API with SessionAuthentication, you'll need to make sure you include a valid CSRF token for any \"unsafe\" HTTP method calls, such as PUT, PATCH, POST or DELETE requests. See the Django CSRF documentation for more details.", "Warning: Always use Django's standard login view when creating login pages. This will ensure your login views are properly protected.", "CSRF validation in REST framework works slightly differently from standard Django due to the need to support both session and non-session based authentication to the same views. This means that only authenticated requests require CSRF tokens, and anonymous requests may be sent without CSRF tokens. This behaviour is not suitable for login views, which should always have CSRF validation applied.", "This authentication scheme allows you to delegate authentication to your web server, which sets the REMOTE_USER environment variable.", "To use it, you must have django.contrib.auth.backends.RemoteUserBackend (or a subclass) in your AUTHENTICATION_BACKENDS setting. By default, RemoteUserBackend creates User objects for usernames that don't already exist. To change this and other behaviour, consult the Django documentation.", "If successfully authenticated, RemoteUserAuthentication provides the following credentials:", "Consult your web server's documentation for information about configuring an authentication method, e.g.:", "To implement a custom authentication scheme, subclass BaseAuthentication and override the .authenticate(self, request) method. The method should return a two-tuple of (user, auth) if authentication succeeds, or None otherwise.", "In some circumstances instead of returning None, you may want to raise an AuthenticationFailed exception from the .authenticate() method.", "Typically the approach you should take is:", "You may also override the .authenticate_header(self, request) method. If implemented, it should return a string that will be used as the value of the WWW-Authenticate header in a HTTP 401 Unauthorized response.", "If the .authenticate_header() method is not overridden, the authentication scheme will return HTTP 403 Forbidden responses when an unauthenticated request is denied access.", "Note: When your custom authenticator is invoked by the request object's .user or .auth properties, you may see an AttributeError re-raised as a WrappedAttributeError. This is necessary to prevent the original exception from being suppressed by the outer property access. Python will not recognize that the AttributeError originates from your custom authenticator and will instead assume that the request object does not have a .user or .auth property. These errors should be fixed or otherwise handled by your authenticator.", "The following example will authenticate any incoming request as the user given by the username in a custom request header named 'X-USERNAME'.", "The following third-party packages are also available.", "The Django OAuth Toolkit package provides OAuth 2.0 support and works with Python 3.4+. The package is maintained by jazzband and uses the excellent OAuthLib. The package is well documented, and well supported and is currently our recommended package for OAuth 2.0 support.", "Install using pip.", "Add the package to your INSTALLED_APPS and modify your REST framework settings.", "For more details see the Django REST framework - Getting started documentation.", "The Django REST framework OAuth package provides both OAuth1 and OAuth2 support for REST framework.", "This package was previously included directly in the REST framework but is now supported and maintained as a third-party package.", "Install the package using pip.", "For details on configuration and usage see the Django REST framework OAuth documentation for authentication and permissions.", "JSON Web Token is a fairly new standard which can be used for token-based authentication. Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn't need to use a database to validate a token. A package for JWT authentication is djangorestframework-simplejwt which provides some features as well as a pluggable token blacklist app.", "The HawkREST library builds on the Mohawk library to let you work with Hawk signed requests and responses in your API. Hawk lets two parties securely communicate with each other using messages signed by a shared key. It is based on HTTP MAC access authentication (which was based on parts of OAuth 1.0).", "HTTP Signature (currently a IETF draft) provides a way to achieve origin authentication and message integrity for HTTP messages. Similar to Amazon's HTTP Signature scheme, used by many of its services, it permits stateless, per-request authentication. Elvio Toccalino maintains the djangorestframework-httpsignature (outdated) package which provides an easy to use HTTP Signature Authentication mechanism. You can use the updated fork version of djangorestframework-httpsignature, which is drf-httpsig.", "Djoser library provides a set of views to handle basic actions such as registration, login, logout, password reset and account activation. The package works with a custom user model and uses token-based authentication. This is ready to use REST implementation of the Django authentication system.", "This library provides a set of REST API endpoints for registration, authentication (including social media authentication), password reset, retrieve and update user details, etc. By having these API endpoints, your client apps such as AngularJS, iOS, Android, and others can communicate to your Django backend site independently via REST APIs for user management.", "There are currently two forks of this project.", "Django-rest-framework-social-oauth2 library provides an easy way to integrate social plugins (facebook, twitter, google, etc.) to your authentication system and an easy oauth2 setup. With this library, you will be able to authenticate users based on external tokens (e.g. facebook access token), convert these tokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to authenticate your users.", "Django-rest-knox library provides models and views to handle token-based authentication in a more secure and extensible way than the built-in TokenAuthentication scheme - with Single Page Applications and Mobile clients in mind. It provides per-client tokens, and views to generate them when provided some other authentication (usually basic authentication), to delete the token (providing a server enforced logout) and to delete all tokens (logs out all clients that a user is logged into).", "drfpasswordless adds (Medium, Square Cash inspired) passwordless support to Django REST Framework's TokenAuthentication scheme. Users log in and sign up with a token sent to a contact point like an email address or a mobile number.", "django-rest-authemail provides a RESTful API interface for user signup and authentication. Email addresses are used for authentication, rather than usernames. API endpoints are available for signup, signup email verification, login, logout, password reset, password reset verification, email change, email change verification, password change, and user detail. A fully functional example project and detailed instructions are included.", "Django-Rest-Durin is built with the idea to have one library that does token auth for multiple Web/CLI/Mobile API clients via one interface but allows different token configuration for each API Client that consumes the API. It provides support for multiple tokens per user via custom models, views, permissions that work with Django-Rest-Framework. The token expiration time can be different per API client and is customizable via the Django Admin Interface.", "More information can be found in the Documentation.", "authentication.py"]}, {"name": "Renderers", "path": "api-guide/renderers/index", "type": "API Guide", "text": ["Before a TemplateResponse instance can be returned to the client, it must be rendered. The rendering process takes the intermediate representation of template and context, and turns it into the final byte stream that can be served to the client.", "\u2014 Django documentation", "REST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.", "The set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.", "The basic process of content negotiation involves examining the request's Accept header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL http://example.com/api/users_count.json might be an endpoint that always returns JSON data.", "For more information see the documentation on content negotiation.", "The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use JSON as the main media type and also include the self describing API.", "You can also set the renderers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "It's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an Accept: */* header, or not including an Accept header at all, then REST framework will select the first renderer in the list to use for the response.", "For example if your API serves JSON responses and the HTML browsable API, you might want to make JSONRenderer your default renderer, in order to send JSON responses to clients that do not specify an Accept header.", "If your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making TemplateHTMLRenderer your default renderer, in order to play nicely with older browsers that send broken accept headers.", "Renders the request data into JSON, using utf-8 encoding.", "Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:", "The client may additionally include an 'indent' media type parameter, in which case the returned JSON will be indented. For example Accept: application/json; indent=4.", "The default JSON encoding style can be altered using the UNICODE_JSON and COMPACT_JSON settings keys.", ".media_type: application/json", ".format: 'json'", ".charset: None", "Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the Response does not need to be serialized. Also, unlike other renderers, you may want to include a template_name argument when creating the Response.", "The TemplateHTMLRenderer will create a RequestContext, using the response.data as the context dict, and determine a template name to use to render the context.", "Note: When used with a view that makes use of a serializer the Response sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the TemplateHTMLRenderer to render it. For example:", "The template name is determined by (in order of preference):", "An example of a view that uses TemplateHTMLRenderer:", "You can use TemplateHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", "If you're building websites that use TemplateHTMLRenderer along with other renderer classes, you should consider listing TemplateHTMLRenderer as the first class in the renderer_classes list, so that it will be prioritised first even for browsers that send poorly formed ACCEPT: headers.", "See the HTML & Forms Topic Page for further examples of TemplateHTMLRenderer usage.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: StaticHTMLRenderer", "A simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.", "An example of a view that uses StaticHTMLRenderer:", "You can use StaticHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: TemplateHTMLRenderer", "Renders data into HTML for the Browsable API:", "", "This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.", ".media_type: text/html", ".format: 'api'", ".charset: utf-8", ".template: 'rest_framework/api.html'", "By default the response content will be rendered with the highest priority renderer apart from BrowsableAPIRenderer. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the get_default_renderer() method. For example:", "Renders data into HTML for an admin-like display:", "", "This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.", "Note that views that have nested or list serializers for their input won't work well with the AdminRenderer, as the HTML forms are unable to properly support them.", "Note: The AdminRenderer is only able to include links to detail pages when a properly configured URL_FIELD_NAME (url by default) attribute is present in the data. For HyperlinkedModelSerializer this will be the case, but for ModelSerializer or plain Serializer classes you'll need to make sure to include the field explicitly. For example here we use models get_absolute_url method:", ".media_type: text/html", ".format: 'admin'", ".charset: utf-8", ".template: 'rest_framework/admin.html'", "Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing <form> tags, a hidden CSRF input or any submit buttons.", "This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the render_form template tag.", "For more information see the HTML & Forms documentation.", ".media_type: text/html", ".format: 'form'", ".charset: utf-8", ".template: 'rest_framework/horizontal/form.html'", "This renderer is used for rendering HTML multipart form data. It is not suitable as a response renderer, but is instead used for creating test requests, using REST framework's test client and test request factory.", ".media_type: multipart/form-data; boundary=BoUnDaRyStRiNg", ".format: 'multipart'", ".charset: utf-8", "To implement a custom renderer, you should override BaseRenderer, set the .media_type and .format properties, and implement the .render(self, data, media_type=None, renderer_context=None) method.", "The method should return a bytestring, which will be used as the body of the HTTP response.", "The arguments passed to the .render() method are:", "The request data, as set by the Response() instantiation.", "Optional. If provided, this is the accepted media type, as determined by the content negotiation stage.", "Depending on the client's Accept: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"application/json; nested=true\".", "Optional. If provided, this is a dictionary of contextual information provided by the view.", "By default this will include the following keys: view, request, response, args, kwargs.", "The following is an example plaintext renderer that will return a response with the data parameter as the content of the response.", "By default renderer classes are assumed to be using the UTF-8 encoding. To use a different encoding, set the charset attribute on the renderer.", "Note that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the Response class, with the charset attribute set on the renderer used to determine the encoding.", "If the renderer returns a bytestring representing raw binary content, you should set a charset value of None, which will ensure the Content-Type header of the response will not have a charset value set.", "In some cases you may also want to set the render_style attribute to 'binary'. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.", "You can do some pretty flexible things using REST framework's renderers. Some examples...", "In some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access request.accepted_renderer to determine the negotiated renderer that will be used for the response.", "For example:", "In some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a media_type value such as image/*, or */*.", "If you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the content_type attribute. For example:", "For the purposes of many Web APIs, simple JSON responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and HATEOAS you'll need to consider the design and usage of your media types in more detail.", "In the words of Roy Fielding, \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".", "For good examples of custom media types, see GitHub's use of a custom application/vnd.github+json media type, and Mike Amundsen's IANA approved application/vnd.collection+json JSON-based hypermedia.", "Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an Http404 or PermissionDenied exception, or a subclass of APIException.", "If you're using either the TemplateHTMLRenderer or the StaticHTMLRenderer and an exception is raised, the behavior is slightly different, and mirrors Django's default handling of error views.", "Exceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.", "Templates will render with a RequestContext which includes the status_code and details keys.", "Note: If DEBUG=True, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST framework JSONP provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Warning: If you require cross-domain AJAX requests, you should generally be using the more modern approach of CORS as an alternative to JSONP. See the CORS documentation for more details.", "The jsonp approach is essentially a browser hack, and is only appropriate for globally readable API endpoints, where GET requests are unauthenticated and do not require any user permissions.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "XLSX is the world's most popular binary spreadsheet format. Tim Allen of The Wharton School maintains drf-renderer-xlsx, which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.", "Install using pip.", "Modify your REST framework settings.", "To avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the Content-Disposition header. If no filename is provided, it will default to export.xlsx. For example:", "Comma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. Mjumbe Poe maintains the djangorestframework-csv package which provides CSV renderer support for REST framework.", "UltraJSON is an optimized C JSON encoder which can give significantly faster JSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now unmaintained drf-ujson-renderer, which implements JSON rendering using the UJSON package.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "Django REST Pandas provides a serializer and renderers that support additional data processing and output via the Pandas DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both .xls and .xlsx), and a number of other formats. It is maintained by S. Andrew Sheppard as part of the wq Project.", "Rest Framework Latex provides a renderer that outputs PDFs using Laulatex. It is maintained by Pebble (S/F Software).", "renderers.py"]}, {"name": "Requests", "path": "api-guide/requests/index", "type": "API Guide", "text": ["If you're doing REST-based web service stuff ... you should ignore request.POST.", "\u2014 Malcom Tredinnick, Django developers group", "REST framework's Request class extends the standard HttpRequest, adding support for REST framework's flexible request parsing and request authentication.", "REST framework's Request objects provide flexible request parsing that allows you to treat requests with JSON data or other media types in the same way that you would normally deal with form data.", "request.data returns the parsed content of the request body. This is similar to the standard request.POST and request.FILES attributes except that:", "For more details see the parsers documentation.", "request.query_params is a more correctly named synonym for request.GET.", "For clarity inside your code, we recommend using request.query_params instead of the Django's standard request.GET. Doing so will help keep your codebase more correct and obvious - any HTTP method type may include query parameters, not just GET requests.", "The APIView class or @api_view decorator will ensure that this property is automatically set to a list of Parser instances, based on the parser_classes set on the view or based on the DEFAULT_PARSER_CLASSES setting.", "You won't typically need to access this property.", "Note: If a client sends malformed content, then accessing request.data may raise a ParseError. By default REST framework's APIView class or @api_view decorator will catch the error and return a 400 Bad Request response.", "If a client sends a request with a content-type that cannot be parsed then a UnsupportedMediaType exception will be raised, which by default will be caught and return a 415 Unsupported Media Type response.", "The request exposes some properties that allow you to determine the result of the content negotiation stage. This allows you to implement behaviour such as selecting a different serialization schemes for different media types.", "The renderer instance that was selected by the content negotiation stage.", "A string representing the media type that was accepted by the content negotiation stage.", "REST framework provides flexible, per-request authentication, that gives you the ability to:", "request.user typically returns an instance of django.contrib.auth.models.User, although the behavior depends on the authentication policy being used.", "If the request is unauthenticated the default value of request.user is an instance of django.contrib.auth.models.AnonymousUser.", "For more details see the authentication documentation.", "request.auth returns any additional authentication context. The exact behavior of request.auth depends on the authentication policy being used, but it may typically be an instance of the token that the request was authenticated against.", "If the request is unauthenticated, or if no additional context is present, the default value of request.auth is None.", "For more details see the authentication documentation.", "The APIView class or @api_view decorator will ensure that this property is automatically set to a list of Authentication instances, based on the authentication_classes set on the view or based on the DEFAULT_AUTHENTICATORS setting.", "You won't typically need to access this property.", "Note: You may see a WrappedAttributeError raised when calling the .user or .auth properties. These errors originate from an authenticator as a standard AttributeError, however it's necessary that they be re-raised as a different exception type in order to prevent them from being suppressed by the outer property access. Python will not recognize that the AttributeError originates from the authenticator and will instead assume that the request object does not have a .user or .auth property. The authenticator will need to be fixed.", "REST framework supports a few browser enhancements such as browser-based PUT, PATCH and DELETE forms.", "request.method returns the uppercased string representation of the request's HTTP method.", "Browser-based PUT, PATCH and DELETE forms are transparently supported.", "For more information see the browser enhancements documentation.", "request.content_type, returns a string object representing the media type of the HTTP request's body, or an empty string if no media type was provided.", "You won't typically need to directly access the request's content type, as you'll normally rely on REST framework's default request parsing behavior.", "If you do need to access the content type of the request you should use the .content_type property in preference to using request.META.get('HTTP_CONTENT_TYPE'), as it provides transparent support for browser-based non-form content.", "For more information see the browser enhancements documentation.", "request.stream returns a stream representing the content of the request body.", "You won't typically need to directly access the request's content, as you'll normally rely on REST framework's default request parsing behavior.", "As REST framework's Request extends Django's HttpRequest, all the other standard attributes and methods are also available. For example the request.META and request.session dictionaries are available as normal.", "Note that due to implementation reasons the Request class does not inherit from HttpRequest class, but instead extends the class using composition.", "request.py"]}, {"name": "Responses", "path": "api-guide/responses/index", "type": "API Guide", "text": ["Unlike basic HttpResponse objects, TemplateResponse objects retain the details of the context that was provided by the view to compute the response. The final output of the response is not computed until it is needed, later in the response process.", "\u2014 Django documentation", "REST framework supports HTTP content negotiation by providing a Response class which allows you to return content that can be rendered into multiple content types, depending on the client request.", "The Response class subclasses Django's SimpleTemplateResponse. Response objects are initialised with data, which should consist of native Python primitives. REST framework then uses standard HTTP content negotiation to determine how it should render the final response content.", "There's no requirement for you to use the Response class, you can also return regular HttpResponse or StreamingHttpResponse objects from your views if required. Using the Response class simply provides a nicer interface for returning content-negotiated Web API responses, that can be rendered to multiple formats.", "Unless you want to heavily customize REST framework for some reason, you should always use an APIView class or @api_view function for views that return Response objects. Doing so ensures that the view can perform content negotiation and select the appropriate renderer for the response, before it is returned from the view.", "Signature: Response(data, status=None, template_name=None, headers=None, content_type=None)", "Unlike regular HttpResponse objects, you do not instantiate Response objects with rendered content. Instead you pass in unrendered data, which may consist of any Python primitives.", "The renderers used by the Response class cannot natively handle complex datatypes such as Django model instances, so you need to serialize the data into primitive datatypes before creating the Response object.", "You can use REST framework's Serializer classes to perform this data serialization, or use your own custom serialization.", "Arguments:", "The unrendered, serialized data of the response.", "The numeric status code of the HTTP response.", "The rendered content of the response. The .render() method must have been called before .content can be accessed.", "The template_name, if supplied. Only required if HTMLRenderer or some other custom template renderer is the accepted renderer for the response.", "The renderer instance that will be used to render the response.", "Set automatically by the APIView or @api_view immediately before the response is returned from the view.", "The media type that was selected by the content negotiation stage.", "Set automatically by the APIView or @api_view immediately before the response is returned from the view.", "A dictionary of additional context information that will be passed to the renderer's .render() method.", "Set automatically by the APIView or @api_view immediately before the response is returned from the view.", "The Response class extends SimpleTemplateResponse, and all the usual attributes and methods are also available on the response. For example you can set headers on the response in the standard way:", "Signature: .render()", "As with any other TemplateResponse, this method is called to render the serialized data of the response into the final response content. When .render() is called, the response content will be set to the result of calling the .render(data, accepted_media_type, renderer_context) method on the accepted_renderer instance.", "You won't typically need to call .render() yourself, as it's handled by Django's standard response cycle.", "response.py"]}, {"name": "RetrieveAPIView", "path": "api-guide/generic-views/index#retrieveapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "RetrieveDestroyAPIView", "path": "api-guide/generic-views/index#retrievedestroyapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "RetrieveModelMixin", "path": "api-guide/generic-views/index#retrievemodelmixin", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "RetrieveUpdateAPIView", "path": "api-guide/generic-views/index#retrieveupdateapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "RetrieveUpdateDestroyAPIView", "path": "api-guide/generic-views/index#retrieveupdatedestroyapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "Returning URLs", "path": "api-guide/reverse/index", "type": "API Guide", "text": ["The central feature that distinguishes the REST architectural style from other network-based styles is its emphasis on a uniform interface between components.", "\u2014 Roy Fielding, Architectural Styles and the Design of Network-based Software Architectures", "As a rule, it's probably better practice to return absolute URIs from your Web APIs, such as http://example.com/foobar, rather than returning relative URIs, such as /foobar.", "The advantages of doing so are:", "REST framework provides two utility functions to make it more simple to return absolute URIs from your Web API.", "There's no requirement for you to use them, but if you do then the self-describing API will be able to automatically hyperlink its output for you, which makes browsing the API much easier.", "Signature: reverse(viewname, *args, **kwargs)", "Has the same behavior as django.urls.reverse, except that it returns a fully qualified URL, using the request to determine the host and port.", "You should include the request as a keyword argument to the function, for example:", "Signature: reverse_lazy(viewname, *args, **kwargs)", "Has the same behavior as django.urls.reverse_lazy, except that it returns a fully qualified URL, using the request to determine the host and port.", "As with the reverse function, you should include the request as a keyword argument to the function, for example:", "reverse.py"]}, {"name": "Routers", "path": "api-guide/routers/index", "type": "API Guide", "text": ["Resource routing allows you to quickly declare all of the common routes for a given resourceful controller. Instead of declaring separate routes for your index... a resourceful route declares them in a single line of code.", "\u2014 Ruby on Rails Documentation", "Some Web frameworks such as Rails provide functionality for automatically determining how the URLs for an application should be mapped to the logic that deals with handling incoming requests.", "REST framework adds support for automatic URL routing to Django, and provides you with a simple, quick and consistent way of wiring your view logic to a set of URLs.", "Here's an example of a simple URL conf, that uses SimpleRouter.", "There are two mandatory arguments to the register() method:", "Optionally, you may also specify an additional argument:", "The example above would generate the following URL patterns:", "Note: The basename argument is used to specify the initial part of the view name pattern. In the example above, that's the user or account part.", "Typically you won't need to specify the basename argument, but if you have a viewset where you've defined a custom get_queryset method, then the viewset may not have a .queryset attribute set. If you try to register that viewset you'll see an error like this:", "This means you'll need to explicitly set the basename argument when registering the viewset, as it could not be automatically determined from the model name.", "The .urls attribute on a router instance is simply a standard list of URL patterns. There are a number of different styles for how you can include these URLs.", "For example, you can append router.urls to a list of existing views...", "Alternatively you can use Django's include function, like so...", "You may use include with an application namespace:", "Or both an application and instance namespace:", "See Django's URL namespaces docs and the include API reference for more details.", "Note: If using namespacing with hyperlinked serializers you'll also need to ensure that any view_name parameters on the serializers correctly reflect the namespace. In the examples above you'd need to include a parameter such as view_name='app_name:user-detail' for serializer fields hyperlinked to the user detail view.", "The automatic view_name generation uses a pattern like %(model_name)-detail. Unless your models names actually clash you may be better off not namespacing your Django REST Framework views when using hyperlinked serializers.", "A viewset may mark extra actions for routing by decorating a method with the @action decorator. These extra actions will be included in the generated routes. For example, given the set_password method on the UserViewSet class:", "The following route would be generated:", "By default, the URL pattern is based on the method name, and the URL name is the combination of the ViewSet.basename and the hyphenated method name. If you don't want to use the defaults for either of these values, you can instead provide the url_path and url_name arguments to the @action decorator.", "For example, if you want to change the URL for our custom action to ^users/{pk}/change-password/$, you could write:", "The above example would now generate the following URL pattern:", "This router includes routes for the standard set of list, create, retrieve, update, partial_update and destroy actions. The viewset can also mark additional methods to be routed, using the @action decorator.", "By default the URLs created by SimpleRouter are appended with a trailing slash. This behavior can be modified by setting the trailing_slash argument to False when instantiating the router. For example:", "Trailing slashes are conventional in Django, but are not used by default in some other frameworks such as Rails. Which style you choose to use is largely a matter of preference, although some javascript frameworks may expect a particular routing style.", "The router will match lookup values containing any characters except slashes and period characters. For a more restrictive (or lenient) lookup pattern, set the lookup_value_regex attribute on the viewset. For example, you can limit the lookup to valid UUIDs:", "This router is similar to SimpleRouter as above, but additionally includes a default API root view, that returns a response containing hyperlinks to all the list views. It also generates routes for optional .json style format suffixes.", "As with SimpleRouter the trailing slashes on the URL routes can be removed by setting the trailing_slash argument to False when instantiating the router.", "Implementing a custom router isn't something you'd need to do very often, but it can be useful if you have specific requirements about how the URLs for your API are structured. Doing so allows you to encapsulate the URL structure in a reusable way that ensures you don't have to write your URL patterns explicitly for each new view.", "The simplest way to implement a custom router is to subclass one of the existing router classes. The .routes attribute is used to template the URL patterns that will be mapped to each viewset. The .routes attribute is a list of Route named tuples.", "The arguments to the Route named tuple are:", "url: A string representing the URL to be routed. May include the following format strings:", "mapping: A mapping of HTTP method names to the view methods", "name: The name of the URL as used in reverse calls. May include the following format string:", "initkwargs: A dictionary of any additional arguments that should be passed when instantiating the view. Note that the detail, basename, and suffix arguments are reserved for viewset introspection and are also used by the browsable API to generate the view name and breadcrumb links.", "You can also customize how the @action decorator is routed. Include the DynamicRoute named tuple in the .routes list, setting the detail argument as appropriate for the list-based and detail-based routes. In addition to detail, the arguments to DynamicRoute are:", "url: A string representing the URL to be routed. May include the same format strings as Route, and additionally accepts the {url_path} format string.", "name: The name of the URL as used in reverse calls. May include the following format strings:", "initkwargs: A dictionary of any additional arguments that should be passed when instantiating the view.", "The following example will only route to the list and retrieve actions, and does not use the trailing slash convention.", "Let's take a look at the routes our CustomReadOnlyRouter would generate for a simple viewset.", "views.py:", "urls.py:", "The following mappings would be generated...", "For another example of setting the .routes attribute, see the source code for the SimpleRouter class.", "If you want to provide totally custom behavior, you can override BaseRouter and override the get_urls(self) method. The method should inspect the registered viewsets and return a list of URL patterns. The registered prefix, viewset and basename tuples may be inspected by accessing the self.registry attribute.", "You may also want to override the get_default_basename(self, viewset) method, or else always explicitly set the basename argument when registering your viewsets with the router.", "The following third party packages are also available.", "The drf-nested-routers package provides routers and relationship fields for working with nested resources.", "The wq.db package provides an advanced ModelRouter class (and singleton instance) that extends DefaultRouter with a register_model() API. Much like Django's admin.site.register, the only required argument to rest.router.register_model is a model class. Reasonable defaults for a url prefix, serializer, and viewset will be inferred from the model and global configuration.", "The DRF-extensions package provides routers for creating nested viewsets, collection level controllers with customizable endpoint names.", "routers.py"]}, {"name": "Schema", "path": "api-guide/schemas/index", "type": "API Guide", "text": ["A machine-readable [schema] describes what resources are available via the API, what their URLs are, how they are represented and what operations they support.", "\u2014 Heroku, JSON Schema for the Heroku Platform API", "API schemas are a useful tool that allow for a range of use cases, including generating reference documentation, or driving dynamic client libraries that can interact with your API.", "Django REST Framework provides support for automatic generation of OpenAPI schemas.", "Schema generation has several moving parts. It's worth having an overview:", "The following sections explain more.", "If your schema is static, you can use the generateschema management command:", "Once you've generated a schema in this way you can annotate it with any additional information that cannot be automatically inferred by the schema generator.", "You might want to check your API schema into version control and update it with each new release, or serve the API schema from your site's static media.", "If you require a dynamic schema, because foreign key choices depend on database values, for example, you can route a SchemaView that will generate and serve your schema on demand.", "To route a SchemaView, use the get_schema_view() helper.", "In urls.py:", "The get_schema_view() helper takes the following keyword arguments:", "url: May be used to pass a canonical base URL for the schema.", "urlconf: A string representing the import path to the URL conf that you want to generate an API schema for. This defaults to the value of Django's ROOT_URLCONF setting.", "patterns: List of url patterns to limit the schema introspection to. If you only want the myproject.api urls to be exposed in the schema:", "generator_class: May be used to specify a SchemaGenerator subclass to be passed to the SchemaView.", "Schema-level customization", "SchemaGenerator is a class that walks a list of routed URL patterns, requests the schema for each view and collates the resulting OpenAPI schema.", "Typically you won't need to instantiate SchemaGenerator yourself, but you can do so like so:", "Arguments:", "In order to customize the top-level schema, subclass rest_framework.schemas.openapi.SchemaGenerator and provide your subclass as an argument to the generateschema command or get_schema_view() helper function.", "Returns a dictionary that represents the OpenAPI schema:", "The request argument is optional, and may be used if you want to apply per-user permissions to the resulting schema generation.", "This is a good point to override if you want to customize the generated dictionary For example you might wish to add terms of service to the top-level info object:", "Per-View Customization", "By default, view introspection is performed by an AutoSchema instance accessible via the schema attribute on APIView.", "AutoSchema provides the OpenAPI elements needed for each view, request method and path:", "In compiling the schema, SchemaGenerator calls get_components() and get_operation() for each view, allowed method, and path.", "Note: The automatic introspection of components, and many operation parameters relies on the relevant attributes and methods of GenericAPIView: get_serializer(), pagination_class, filter_backends, etc. For basic APIView subclasses, default introspection is essentially limited to the URL kwarg path parameters for this reason.", "AutoSchema encapsulates the view introspection needed for schema generation. Because of this all the schema generation logic is kept in a single place, rather than being spread around the already extensive view, serializer and field APIs.", "Keeping with this pattern, try not to let schema logic leak into your own views, serializers, or fields when customizing the schema generation. You might be tempted to do something like this:", "Here, the AutoSchema subclass goes looking for schema_extra_info on the view. This is OK (it doesn't actually hurt) but it means you'll end up with your schema logic spread out in a number of different places.", "Instead try to subclass AutoSchema such that the extra_info doesn't leak out into the view:", "This style is slightly more verbose but maintains the encapsulation of the schema related code. It's more cohesive in the parlance. It'll keep the rest of your API code more tidy.", "If an option applies to many view classes, rather than creating a specific subclass per-view, you may find it more convenient to allow specifying the option as an __init__() kwarg to your base AutoSchema subclass:", "This saves you having to create a custom subclass per-view for a commonly used option.", "Not all AutoSchema methods expose related __init__() kwargs, but those for the more commonly needed options do.", "Generates the OpenAPI components that describe request and response bodies, deriving their properties from the serializer.", "Returns a dictionary mapping the component name to the generated representation. By default this has just a single pair but you may override get_components() to return multiple pairs if your view uses multiple serializers.", "Computes the component's name from the serializer.", "You may see warnings if your API has duplicate component names. If so you can override get_component_name() or pass the component_name __init__() kwarg (see below) to provide different names.", "Maps serializers to their OpenAPI representations.", "Most serializers should conform to the standard OpenAPI object type, but you may wish to override map_serializer() in order to customize this or other serializer-level fields.", "Maps individual serializer fields to their schema representation. The base implementation will handle the default fields that Django REST Framework provides.", "For SerializerMethodField instances, for which the schema is unknown, or custom field subclasses you should override map_field() to generate the correct schema:", "Authors of third-party packages should aim to provide an AutoSchema subclass, and a mixin, overriding map_field() so that users can easily generate schemas for their custom fields.", "OpenAPI groups operations by tags. By default tags taken from the first path segment of the routed URL. For example, a URL like /users/{id}/ will generate the tag users.", "You can pass an __init__() kwarg to manually specify tags (see below), or override get_tags() to provide custom logic.", "Returns the OpenAPI operation object that describes the endpoint, including path and query parameters for pagination, filtering, and so on.", "Together with get_components(), this is the main entry point to the view introspection.", "There must be a unique operationid for each operation. By default the operationId is deduced from the model name, serializer name or view name. The operationId looks like \"listItems\", \"retrieveItem\", \"updateItem\", etc. The operationId is camelCase by convention.", "If you have several views with the same model name, you may see duplicate operationIds.", "In order to work around this, you can override get_operation_id_base() to provide a different base for name part of the ID.", "If the view has implemented get_serializer(), returns the result.", "By default returns get_serializer() but can be overridden to differentiate between request and response objects.", "By default returns get_serializer() but can be overridden to differentiate between request and response objects.", "AutoSchema provides a number of __init__() kwargs that can be used for common customizations, if the default generated values are not appropriate.", "The available kwargs are:", "You pass the kwargs when declaring the AutoSchema instance on your view:", "Assuming a Pet model and PetSerializer serializer, the kwargs in this example are probably not needed. Often, though, you'll need to pass the kwargs if you have multiple view targeting the same model, or have multiple views with identically named serializers.", "If your views have related customizations that are needed frequently, you can create a base AutoSchema subclass for your project that takes additional __init__() kwargs to save subclassing AutoSchema for each view.", "schemas"]}, {"name": "Schema generation controls", "path": "api-guide/settings/index#schema-generation-controls", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "ScopedRateThrottle", "path": "api-guide/throttling/index#scopedratethrottle", "type": "Ref: Throttling", "text": ["HTTP/1.1 420 Enhance Your Calm", "Twitter API rate limiting response", "Throttling is similar to permissions, in that it determines if a request should be authorized. Throttles indicate a temporary state, and are used to control the rate of requests that clients can make to an API.", "As with permissions, multiple throttles may be used. Your API might have a restrictive throttle for unauthenticated requests, and a less restrictive throttle for authenticated requests.", "Another scenario where you might want to use multiple throttles would be if you need to impose different constraints on different parts of the API, due to some services being particularly resource-intensive.", "Multiple throttles can also be used if you want to impose both burst throttling rates, and sustained throttling rates. For example, you might want to limit a user to a maximum of 60 requests per minute, and 1000 requests per day.", "Throttles do not necessarily only refer to rate-limiting requests. For example a storage service might also need to throttle against bandwidth, and a paid data service might want to throttle against a certain number of a records being accessed.", "As with permissions and authentication, throttling in REST framework is always defined as a list of classes.", "Before running the main body of the view each throttle in the list is checked. If any throttle check fails an exceptions.Throttled exception will be raised, and the main body of the view will not run.", "The default throttling policy may be set globally, using the DEFAULT_THROTTLE_CLASSES and DEFAULT_THROTTLE_RATES settings. For example.", "The rate descriptions used in DEFAULT_THROTTLE_RATES may include second, minute, hour or day as the throttle period.", "You can also set the throttling policy on a per-view or per-viewset basis, using the APIView class-based views.", "If you're using the @api_view decorator with function based views you can use the following decorator.", "It's also possible to set throttle classes for routes that are created using the @action decorator. Throttle classes set in this way will override any viewset level class settings.", "The X-Forwarded-For HTTP header and REMOTE_ADDR WSGI variable are used to uniquely identify client IP addresses for throttling. If the X-Forwarded-For header is present then it will be used, otherwise the value of the REMOTE_ADDR variable from the WSGI environment will be used.", "If you need to strictly identify unique client IP addresses, you'll need to first configure the number of application proxies that the API runs behind by setting the NUM_PROXIES setting. This setting should be an integer of zero or more. If set to non-zero then the client IP will be identified as being the last IP address in the X-Forwarded-For header, once any application proxy IP addresses have first been excluded. If set to zero, then the REMOTE_ADDR value will always be used as the identifying IP address.", "It is important to understand that if you configure the NUM_PROXIES setting, then all clients behind a unique NAT'd gateway will be treated as a single client.", "Further context on how the X-Forwarded-For header works, and identifying a remote client IP can be found here.", "The throttle classes provided by REST framework use Django's cache backend. You should make sure that you've set appropriate cache settings. The default value of LocMemCache backend should be okay for simple setups. See Django's cache documentation for more details.", "If you need to use a cache other than 'default', you can do so by creating a custom throttle class and setting the cache attribute. For example:", "You'll need to remember to also set your custom throttle class in the 'DEFAULT_THROTTLE_CLASSES' settings key, or using the throttle_classes view attribute.", "The AnonRateThrottle will only ever throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.", "The allowed request rate is determined from one of the following (in order of preference).", "AnonRateThrottle is suitable if you want to restrict the rate of requests from unknown sources.", "The UserRateThrottle will throttle users to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.", "The allowed request rate is determined from one of the following (in order of preference).", "An API may have multiple UserRateThrottles in place at the same time. To do so, override UserRateThrottle and set a unique \"scope\" for each class.", "For example, multiple user throttle rates could be implemented by using the following classes...", "...and the following settings.", "UserRateThrottle is suitable if you want simple global rate restrictions per-user.", "The ScopedRateThrottle class can be used to restrict access to specific parts of the API. This throttle will only be applied if the view that is being accessed includes a .throttle_scope property. The unique throttle key will then be formed by concatenating the \"scope\" of the request with the unique user id or IP address.", "The allowed request rate is determined by the DEFAULT_THROTTLE_RATES setting using a key from the request \"scope\".", "For example, given the following views...", "...and the following settings.", "User requests to either ContactListView or ContactDetailView would be restricted to a total of 1000 requests per-day. User requests to UploadView would be restricted to 20 requests per day.", "To create a custom throttle, override BaseThrottle and implement .allow_request(self, request, view). The method should return True if the request should be allowed, and False otherwise.", "Optionally you may also override the .wait() method. If implemented, .wait() should return a recommended number of seconds to wait before attempting the next request, or None. The .wait() method will only be called if .allow_request() has previously returned False.", "If the .wait() method is implemented and the request is throttled, then a Retry-After header will be included in the response.", "The following is an example of a rate throttle, that will randomly throttle 1 in every 10 requests.", "throttling.py"]}, {"name": "SearchFilter", "path": "api-guide/filtering/index#searchfilter", "type": "Ref: Filtering", "text": ["The root QuerySet provided by the Manager describes all objects in the database table. Usually, though, you'll need to select only a subset of the complete set of objects.", "\u2014 Django documentation", "The default behavior of REST framework's generic list views is to return the entire queryset for a model manager. Often you will want your API to restrict the items that are returned by the queryset.", "The simplest way to filter the queryset of any view that subclasses GenericAPIView is to override the .get_queryset() method.", "Overriding this method allows you to customize the queryset returned by the view in a number of different ways.", "You might want to filter the queryset to ensure that only results relevant to the currently authenticated user making the request are returned.", "You can do so by filtering based on the value of request.user.", "For example:", "Another style of filtering might involve restricting the queryset based on some part of the URL.", "For example if your URL config contained an entry like this:", "You could then write a view that returned a purchase queryset filtered by the username portion of the URL:", "A final example of filtering the initial queryset would be to determine the initial queryset based on query parameters in the url.", "We can override .get_queryset() to deal with URLs such as http://example.com/api/purchases?username=denvercoder9, and filter the queryset only if the username parameter is included in the URL:", "As well as being able to override the default queryset, REST framework also includes support for generic filtering backends that allow you to easily construct complex searches and filters.", "Generic filters can also present themselves as HTML controls in the browsable API and admin API.", "", "The default filter backends may be set globally, using the DEFAULT_FILTER_BACKENDS setting. For example.", "You can also set the filter backends on a per-view, or per-viewset basis, using the GenericAPIView class-based views.", "Note that if a filter backend is configured for a view, then as well as being used to filter list views, it will also be used to filter the querysets used for returning a single object.", "For instance, given the previous example, and a product with an id of 4675, the following URL would either return the corresponding object, or return a 404 response, depending on if the filtering conditions were met by the given product instance:", "Note that you can use both an overridden .get_queryset() and generic filtering together, and everything will work as expected. For example, if Product had a many-to-many relationship with User, named purchase, you might want to write a view like this:", "The django-filter library includes a DjangoFilterBackend class which supports highly customizable field filtering for REST framework.", "To use DjangoFilterBackend, first install django-filter.", "Then add 'django_filters' to Django's INSTALLED_APPS:", "You should now either add the filter backend to your settings:", "Or add the filter backend to an individual View or ViewSet.", "If all you need is simple equality-based filtering, you can set a filterset_fields attribute on the view, or viewset, listing the set of fields you wish to filter against.", "This will automatically create a FilterSet class for the given fields, and will allow you to make requests such as:", "For more advanced filtering requirements you can specify a FilterSet class that should be used by the view. You can read more about FilterSets in the django-filter documentation. It's also recommended that you read the section on DRF integration.", "The SearchFilter class supports simple single query parameter based searching, and is based on the Django admin's search functionality.", "When in use, the browsable API will include a SearchFilter control:", "", "The SearchFilter class will only be applied if the view has a search_fields attribute set. The search_fields attribute should be a list of names of text type fields on the model, such as CharField or TextField.", "This will allow the client to filter the items in the list by making queries such as:", "You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation:", "For JSONField and HStoreField fields you can filter based on nested values within the data structure using the same double-underscore notation:", "By default, searches will use case-insensitive partial matches. The search parameter may contain multiple search terms, which should be whitespace and/or comma separated. If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched.", "The search behavior may be restricted by prepending various characters to the search_fields.", "For example:", "By default, the search parameter is named 'search', but this may be overridden with the SEARCH_PARAM setting.", "To dynamically change search fields based on request content, it's possible to subclass the SearchFilter and override the get_search_fields() function. For example, the following subclass will only search on title if the query parameter title_only is in the request:", "For more details, see the Django documentation.", "The OrderingFilter class supports simple query parameter controlled ordering of results.", "", "By default, the query parameter is named 'ordering', but this may by overridden with the ORDERING_PARAM setting.", "For example, to order users by username:", "The client may also specify reverse orderings by prefixing the field name with '-', like so:", "Multiple orderings may also be specified:", "It's recommended that you explicitly specify which fields the API should allowing in the ordering filter. You can do this by setting an ordering_fields attribute on the view, like so:", "This helps prevent unexpected data leakage, such as allowing users to order against a password hash field or other sensitive data.", "If you don't specify an ordering_fields attribute on the view, the filter class will default to allowing the user to filter on any readable fields on the serializer specified by the serializer_class attribute.", "If you are confident that the queryset being used by the view doesn't contain any sensitive data, you can also explicitly specify that a view should allow ordering on any model field or queryset aggregate, by using the special value '__all__'.", "If an ordering attribute is set on the view, this will be used as the default ordering.", "Typically you'd instead control this by setting order_by on the initial queryset, but using the ordering parameter on the view allows you to specify the ordering in a way that it can then be passed automatically as context to a rendered template. This makes it possible to automatically render column headers differently if they are being used to order the results.", "The ordering attribute may be either a string or a list/tuple of strings.", "You can also provide your own generic filtering backend, or write an installable app for other developers to use.", "To do so override BaseFilterBackend, and override the .filter_queryset(self, request, queryset, view) method. The method should return a new, filtered queryset.", "As well as allowing clients to perform searches and filtering, generic filter backends can be useful for restricting which objects should be visible to any given request or user.", "For example, you might need to restrict users to only being able to see objects they created.", "We could achieve the same behavior by overriding get_queryset() on the views, but using a filter backend allows you to more easily add this restriction to multiple views, or to apply it across the entire API.", "Generic filters may also present an interface in the browsable API. To do so you should implement a to_html() method which returns a rendered HTML representation of the filter. This method should have the following signature:", "to_html(self, request, queryset, view)", "The method should return a rendered HTML string.", "You can also make the filter controls available to the schema autogeneration that REST framework provides, by implementing a get_schema_fields() method. This method should have the following signature:", "get_schema_fields(self, view)", "The method should return a list of coreapi.Field instances.", "The following third party packages provide additional filter implementations.", "The django-rest-framework-filters package works together with the DjangoFilterBackend class, and allows you to easily create filters across relationships, or create multiple filter lookup types for a given field.", "The djangorestframework-word-filter developed as alternative to filters.SearchFilter which will search full word in text, or exact match.", "django-url-filter provides a safe way to filter data via human-friendly URLs. It works very similar to DRF serializers and fields in a sense that they can be nested except they are called filtersets and filters. That provides easy way to filter related data. Also this library is generic-purpose so it can be used to filter other sources of data and not only Django QuerySets.", "drf-url-filter is a simple Django app to apply filters on drf ModelViewSet's Queryset in a clean, simple and configurable way. It also supports validations on incoming query params and their values. A beautiful python package Voluptuous is being used for validations on the incoming query parameters. The best part about voluptuous is you can define your own validations as per your query params requirements.", "filters.py"]}, {"name": "Serializer fields", "path": "api-guide/fields/index", "type": "API Guide", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "Serializer relations", "path": "api-guide/relations/index", "type": "API Guide", "text": ["Data structures, not algorithms, are central to programming.", "\u2014 Rob Pike", "Relational fields are used to represent model relationships. They can be applied to ForeignKey, ManyToManyField and OneToOneField relationships, as well as to reverse relationships, and custom relationships such as GenericForeignKey.", "Note: The relational fields are declared in relations.py, but by convention you should import them from the serializers module, using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "When using the ModelSerializer class, serializer fields and relationships will be automatically generated for you. Inspecting these automatically generated fields can be a useful tool for determining how to customize the relationship style.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "In order to explain the various types of relational fields, we'll use a couple of simple models for our examples. Our models will be for music albums, and the tracks listed on each album.", "StringRelatedField may be used to represent the target of the relationship using its __str__ method.", "For example, the following serializer:", "Would serialize to the following representation:", "This field is read only.", "Arguments:", "PrimaryKeyRelatedField may be used to represent the target of the relationship using its primary key.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Arguments:", "HyperlinkedRelatedField may be used to represent the target of the relationship using a hyperlink.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Note: This field is designed for objects that map to a URL that accepts a single URL keyword argument, as set using the lookup_field and lookup_url_kwarg arguments.", "This is suitable for URLs that contain a single primary key or slug argument as part of the URL.", "If you require more complex hyperlinked representation you'll need to customize the field, as described in the custom hyperlinked fields section, below.", "Arguments:", "SlugRelatedField may be used to represent the target of the relationship using a field on the target.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "When using SlugRelatedField as a read-write field, you will normally want to ensure that the slug field corresponds to a model field with unique=True.", "Arguments:", "This field can be applied as an identity relationship, such as the 'url' field on a HyperlinkedModelSerializer. It can also be used for an attribute on the object. For example, the following serializer:", "Would serialize to a representation like this:", "This field is always read-only.", "Arguments:", "As opposed to previously discussed references to another entity, the referred entity can instead also be embedded or nested in the representation of the object that refers to it. Such nested relationships can be expressed by using serializers as fields. ", "If the field is used to represent a to-many relationship, you should add the many=True flag to the serializer field.", "For example, the following serializer:", "Would serialize to a nested representation like this:", "By default nested serializers are read-only. If you want to support write-operations to a nested serializer field you'll need to create create() and/or update() methods in order to explicitly specify how the child relationships should be saved:", "In rare cases where none of the existing relational styles fit the representation you need, you can implement a completely custom relational field, that describes exactly how the output representation should be generated from the model instance.", "To implement a custom relational field, you should override RelatedField, and implement the .to_representation(self, value) method. This method takes the target of the field as the value argument, and should return the representation that should be used to serialize the target. The value argument will typically be a model instance.", "If you want to implement a read-write relational field, you must also implement the .to_internal_value(self, data) method.", "To provide a dynamic queryset based on the context, you can also override .get_queryset(self) instead of specifying .queryset on the class or when initializing the field.", "For example, we could define a relational field to serialize a track to a custom string representation, using its ordering, title, and duration:", "This custom field would then serialize to the following representation:", "In some cases you may need to customize the behavior of a hyperlinked field, in order to represent URLs that require more than a single lookup field.", "You can achieve this by overriding HyperlinkedRelatedField. There are two methods that may be overridden:", "get_url(self, obj, view_name, request, format)", "The get_url method is used to map the object instance to its URL representation.", "May raise a NoReverseMatch if the view_name and lookup_field attributes are not configured to correctly match the URL conf.", "get_object(self, view_name, view_args, view_kwargs)", "If you want to support a writable hyperlinked field then you'll also want to override get_object, in order to map incoming URLs back to the object they represent. For read-only hyperlinked fields there is no need to override this method.", "The return value of this method should the object that corresponds to the matched URL conf arguments.", "May raise an ObjectDoesNotExist exception.", "Say we have a URL for a customer object that takes two keyword arguments, like so:", "This cannot be represented with the default implementation, which accepts only a single lookup field.", "In this case we'd need to override HyperlinkedRelatedField to get the behavior we want:", "Note that if you wanted to use this style together with the generic views then you'd also need to override .get_object on the view in order to get the correct lookup behavior.", "Generally we recommend a flat style for API representations where possible, but the nested URL style can also be reasonable when used in moderation.", "The queryset argument is only ever required for writable relationship field, in which case it is used for performing the model instance lookup, that maps from the primitive user input, into a model instance.", "In version 2.x a serializer class could sometimes automatically determine the queryset argument if a ModelSerializer class was being used.", "This behavior is now replaced with always using an explicit queryset argument for writable relational fields.", "Doing so reduces the amount of hidden 'magic' that ModelSerializer provides, makes the behavior of the field more clear, and ensures that it is trivial to move between using the ModelSerializer shortcut, or using fully explicit Serializer classes.", "The built-in __str__ method of the model will be used to generate string representations of the objects used to populate the choices property. These choices are used to populate select HTML inputs in the browsable API.", "To provide customized representations for such inputs, override display_value() of a RelatedField subclass. This method will receive a model object, and should return a string suitable for representing it. For example:", "When rendered in the browsable API relational fields will default to only displaying a maximum of 1000 selectable items. If more items are present then a disabled option with \"More than 1000 items\u2026\" will be displayed.", "This behavior is intended to prevent a template from being unable to render in an acceptable timespan due to a very large number of relationships being displayed.", "There are two keyword arguments you can use to control this behavior:", "You can also control these globally using the settings HTML_SELECT_CUTOFF and HTML_SELECT_CUTOFF_TEXT.", "In cases where the cutoff is being enforced you may want to instead use a plain input field in the HTML form. You can do so using the style keyword argument. For example:", "Note that reverse relationships are not automatically included by the ModelSerializer and HyperlinkedModelSerializer classes. To include a reverse relationship, you must explicitly add it to the fields list. For example:", "You'll normally want to ensure that you've set an appropriate related_name argument on the relationship, that you can use as the field name. For example:", "If you have not set a related name for the reverse relationship, you'll need to use the automatically generated related name in the fields argument. For example:", "See the Django documentation on reverse relationships for more details.", "If you want to serialize a generic foreign key, you need to define a custom field, to determine explicitly how you want to serialize the targets of the relationship.", "For example, given the following model for a tag, which has a generic relationship with other arbitrary models:", "And the following two models, which may have associated tags:", "We could define a custom field that could be used to serialize tagged instances, using the type of each instance to determine how it should be serialized:", "If you need the target of the relationship to have a nested representation, you can use the required serializers inside the .to_representation() method:", "Note that reverse generic keys, expressed using the GenericRelation field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.", "For more information see the Django documentation on generic relations.", "By default, relational fields that target a ManyToManyField with a through model specified are set to read-only.", "If you explicitly specify a relational field pointing to a ManyToManyField with a through model, be sure to set read_only to True.", "If you wish to represent extra fields on a through model then you may serialize the through model as a nested object.", "The following third party packages are also available.", "The drf-nested-routers package provides routers and relationship fields for working with nested resources.", "The rest-framework-generic-relations library provides read/write serialization for generic foreign keys.", "relations.py"]}, {"name": "SerializerMethodField", "path": "api-guide/fields/index#serializermethodfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "Serializers", "path": "api-guide/serializers/index", "type": "API Guide", "text": ["Expanding the usefulness of the serializers is something that we would like to address. However, it's not a trivial problem, and it will take some serious design work.", "\u2014 Russell Keith-Magee, Django users group", "Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.", "The serializers in REST framework work very similarly to Django's Form and ModelForm classes. We provide a Serializer class which gives you a powerful, generic way to control the output of your responses, as well as a ModelSerializer class which provides a useful shortcut for creating serializers that deal with model instances and querysets.", "Let's start by creating a simple object we can use for example purposes:", "We'll declare a serializer that we can use to serialize and deserialize data that corresponds to Comment objects.", "Declaring a serializer looks very similar to declaring a form:", "We can now use CommentSerializer to serialize a comment, or list of comments. Again, using the Serializer class looks a lot like using a Form class.", "At this point we've translated the model instance into Python native datatypes. To finalise the serialization process we render the data into json.", "Deserialization is similar. First we parse a stream into Python native datatypes...", "...then we restore those native datatypes into a dictionary of validated data.", "If we want to be able to return complete object instances based on the validated data we need to implement one or both of the .create() and .update() methods. For example:", "If your object instances correspond to Django models you'll also want to ensure that these methods save the object to the database. For example, if Comment was a Django model, the methods might look like this:", "Now when deserializing data, we can call .save() to return an object instance, based on the validated data.", "Calling .save() will either create a new instance, or update an existing instance, depending on if an existing instance was passed when instantiating the serializer class:", "Both the .create() and .update() methods are optional. You can implement either neither, one, or both of them, depending on the use-case for your serializer class.", "Sometimes you'll want your view code to be able to inject additional data at the point of saving the instance. This additional data might include information like the current user, the current time, or anything else that is not part of the request data.", "You can do so by including additional keyword arguments when calling .save(). For example:", "Any additional keyword arguments will be included in the validated_data argument when .create() or .update() are called.", "In some cases the .create() and .update() method names may not be meaningful. For example, in a contact form we may not be creating new instances, but instead sending an email or other message.", "In these cases you might instead choose to override .save() directly, as being more readable and meaningful.", "For example:", "Note that in the case above we're now having to access the serializer .validated_data property directly.", "When deserializing data, you always need to call is_valid() before attempting to access the validated data, or save an object instance. If any validation errors occur, the .errors property will contain a dictionary representing the resulting error messages. For example:", "Each key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The non_field_errors key may also be present, and will list any general validation errors. The name of the non_field_errors key may be customized using the NON_FIELD_ERRORS_KEY REST framework setting.", "When deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items.", "The .is_valid() method takes an optional raise_exception flag that will cause it to raise a serializers.ValidationError exception if there are validation errors.", "These exceptions are automatically dealt with by the default exception handler that REST framework provides, and will return HTTP 400 Bad Request responses by default.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. These are similar to the .clean_<field_name> methods on Django forms.", "These methods take a single argument, which is the field value that requires validation.", "Your validate_<field_name> methods should return the validated value or raise a serializers.ValidationError. For example:", "Note: If your <field_name> is declared on your serializer with the parameter required=False then this validation step will not take place if the field is not included.", "To do any other validation that requires access to multiple fields, add a method called .validate() to your Serializer subclass. This method takes a single argument, which is a dictionary of field values. It should raise a serializers.ValidationError if necessary, or just return the validated values. For example:", "Individual fields on a serializer can include validators, by declaring them on the field instance, for example:", "Serializer classes can also include reusable validators that are applied to the complete set of field data. These validators are included by declaring them on an inner Meta class, like so:", "For more information see the validators documentation.", "When passing an initial object or queryset to a serializer instance, the object will be made available as .instance. If no initial object is passed then the .instance attribute will be None.", "When passing data to a serializer instance, the unmodified data will be made available as .initial_data. If the data keyword argument is not passed then the .initial_data attribute will not exist.", "By default, serializers must be passed values for all required fields or they will raise validation errors. You can use the partial argument in order to allow partial updates.", "The previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers.", "The Serializer class is itself a type of Field, and can be used to represent relationships where one object type is nested inside another.", "If a nested representation may optionally accept the None value you should pass the required=False flag to the nested serializer.", "Similarly if a nested representation should be a list of items, you should pass the many=True flag to the nested serializer.", "When dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object.", "Similarly, the .validated_data property will include nested data structures.", "If you're supporting writable nested representations you'll need to write .create() or .update() methods that handle saving multiple objects.", "The following example demonstrates how you might handle creating a user with a nested profile object.", "For updates you'll want to think carefully about how to handle updates to relationships. For example if the data for the relationship is None, or not provided, which of the following should occur?", "Here's an example for an .update() method on our previous UserSerializer class.", "Because the behavior of nested creates and updates can be ambiguous, and may require complex dependencies between related models, REST framework 3 requires you to always write these methods explicitly. The default ModelSerializer .create() and .update() methods do not include support for writable nested representations.", "There are however, third-party packages available such as DRF Writable Nested that support automatic writable nested representations.", "An alternative to saving multiple related instances in the serializer is to write custom model manager classes that handle creating the correct instances.", "For example, suppose we wanted to ensure that User instances and Profile instances are always created together as a pair. We might write a custom manager class that looks something like this:", "This manager class now more nicely encapsulates that user instances and profile instances are always created at the same time. Our .create() method on the serializer class can now be re-written to use the new manager method.", "For more details on this approach see the Django documentation on model managers, and this blogpost on using model and manager classes.", "The Serializer class can also handle serializing or deserializing lists of objects.", "To serialize a queryset or list of objects instead of a single object instance, you should pass the many=True flag when instantiating the serializer. You can then pass a queryset or list of objects to be serialized.", "The default behavior for deserializing multiple objects is to support multiple object creation, but not support multiple object updates. For more information on how to support or customize either of these cases, see the ListSerializer documentation below.", "There are some cases where you need to provide extra context to the serializer in addition to the object being serialized. One common case is if you're using a serializer that includes hyperlinked relations, which requires the serializer to have access to the current request so that it can properly generate fully qualified URLs.", "You can provide arbitrary additional context by passing a context argument when instantiating the serializer. For example:", "The context dictionary can be used within any serializer field logic, such as a custom .to_representation() method, by accessing the self.context attribute.", "Often you'll want serializer classes that map closely to Django model definitions.", "The ModelSerializer class provides a shortcut that lets you automatically create a Serializer class with fields that correspond to the Model fields.", "The ModelSerializer class is the same as a regular Serializer class, except that:", "Declaring a ModelSerializer looks like this:", "By default, all the model fields on the class will be mapped to a corresponding serializer fields.", "Any relationships such as foreign keys on the model will be mapped to PrimaryKeyRelatedField. Reverse relationships are not included by default unless explicitly included as specified in the serializer relations documentation.", "Serializer classes generate helpful verbose representation strings, that allow you to fully inspect the state of their fields. This is particularly useful when working with ModelSerializers where you want to determine what set of fields and validators are being automatically created for you.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "If you only want a subset of the default fields to be used in a model serializer, you can do so using fields or exclude options, just as you would with a ModelForm. It is strongly recommended that you explicitly set all fields that should be serialized using the fields attribute. This will make it less likely to result in unintentionally exposing data when your models change.", "For example:", "You can also set the fields attribute to the special value '__all__' to indicate that all fields in the model should be used.", "For example:", "You can set the exclude attribute to a list of fields to be excluded from the serializer.", "For example:", "In the example above, if the Account model had 3 fields account_name, users, and created, this will result in the fields account_name and created to be serialized.", "The names in the fields and exclude attributes will normally map to model fields on the model class.", "Alternatively names in the fields options can map to properties or methods which take no arguments that exist on the model class.", "Since version 3.3.0, it is mandatory to provide one of the attributes fields or exclude.", "The default ModelSerializer uses primary keys for relationships, but you can also easily generate nested representations using the depth option:", "The depth option should be set to an integer value that indicates the depth of relationships that should be traversed before reverting to a flat representation.", "If you want to customize the way the serialization is done you'll need to define the field yourself.", "You can add extra fields to a ModelSerializer or override the default fields by declaring fields on the class, just as you would for a Serializer class.", "Extra fields can correspond to any property or callable on the model.", "You may wish to specify multiple fields as read-only. Instead of adding each field explicitly with the read_only=True attribute, you may use the shortcut Meta option, read_only_fields.", "This option should be a list or tuple of field names, and is declared as follows:", "Model fields which have editable=False set, and AutoField fields will be set to read-only by default, and do not need to be added to the read_only_fields option.", "Note: There is a special-case where a read-only field is part of a unique_together constraint at the model level. In this case the field is required by the serializer class in order to validate the constraint, but should also not be editable by the user.", "The right way to deal with this is to specify the field explicitly on the serializer, providing both the read_only=True and default=\u2026 keyword arguments.", "One example of this is a read-only relation to the currently authenticated User which is unique_together with another identifier. In this case you would declare the user field like so:", "Please review the Validators Documentation for details on the UniqueTogetherValidator and CurrentUserDefault classes.", "There is also a shortcut allowing you to specify arbitrary additional keyword arguments on fields, using the extra_kwargs option. As in the case of read_only_fields, this means you do not need to explicitly declare the field on the serializer.", "This option is a dictionary, mapping field names to a dictionary of keyword arguments. For example:", "Please keep in mind that, if the field has already been explicitly declared on the serializer class, then the extra_kwargs option will be ignored.", "When serializing model instances, there are a number of different ways you might choose to represent relationships. The default representation for ModelSerializer is to use the primary keys of the related instances.", "Alternative representations include serializing using hyperlinks, serializing complete nested representations, or serializing with a custom representation.", "For full details see the serializer relations documentation.", "The ModelSerializer class also exposes an API that you can override in order to alter how serializer fields are automatically determined when instantiating the serializer.", "Normally if a ModelSerializer does not generate the fields you need by default then you should either add them to the class explicitly, or simply use a regular Serializer class instead. However in some cases you may want to create a new base class that defines how the serializer fields are created for any given model.", "A mapping of Django model fields to REST framework serializer fields. You can override this mapping to alter the default serializer fields that should be used for each model field.", "This property should be the serializer field class, that is used for relational fields by default.", "For ModelSerializer this defaults to PrimaryKeyRelatedField.", "For HyperlinkedModelSerializer this defaults to serializers.HyperlinkedRelatedField.", "The serializer field class that should be used for any url field on the serializer.", "Defaults to serializers.HyperlinkedIdentityField", "The serializer field class that should be used for any choice fields on the serializer.", "Defaults to serializers.ChoiceField", "The following methods are called to determine the class and keyword arguments for each field that should be automatically included on the serializer. Each of these methods should return a two tuple of (field_class, field_kwargs).", "Called to generate a serializer field that maps to a standard model field.", "The default implementation returns a serializer class based on the serializer_field_mapping attribute.", "Called to generate a serializer field that maps to a relational model field.", "The default implementation returns a serializer class based on the serializer_related_field attribute.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a relational model field, when the depth option has been set.", "The default implementation dynamically creates a nested serializer class based on either ModelSerializer or HyperlinkedModelSerializer.", "The nested_depth will be the value of the depth option, minus one.", "The relation_info argument is a named tuple, that contains model_field, related_model, to_many and has_through_model properties.", "Called to generate a serializer field that maps to a property or zero-argument method on the model class.", "The default implementation returns a ReadOnlyField class.", "Called to generate a serializer field for the serializer's own url field. The default implementation returns a HyperlinkedIdentityField class.", "Called when the field name did not map to any model field or model property. The default implementation raises an error, although subclasses may customize this behavior.", "The HyperlinkedModelSerializer class is similar to the ModelSerializer class except that it uses hyperlinks to represent relationships, rather than primary keys.", "By default the serializer will include a url field instead of a primary key field.", "The url field will be represented using a HyperlinkedIdentityField serializer field, and any relationships on the model will be represented using a HyperlinkedRelatedField serializer field.", "You can explicitly include the primary key by adding it to the fields option, for example:", "When instantiating a HyperlinkedModelSerializer you must include the current request in the serializer context, for example:", "Doing so will ensure that the hyperlinks can include an appropriate hostname, so that the resulting representation uses fully qualified URLs, such as:", "Rather than relative URLs, such as:", "If you do want to use relative URLs, you should explicitly pass {'request': None} in the serializer context.", "There needs to be a way of determining which views should be used for hyperlinking to model instances.", "By default hyperlinks are expected to correspond to a view name that matches the style '{model_name}-detail', and looks up the instance by a pk keyword argument.", "You can override a URL field view name and lookup field by using either, or both of, the view_name and lookup_field options in the extra_kwargs setting, like so:", "Alternatively you can set the fields on the serializer explicitly. For example:", "Tip: Properly matching together hyperlinked representations and your URL conf can sometimes be a bit fiddly. Printing the repr of a HyperlinkedModelSerializer instance is a particularly useful way to inspect exactly which view names and lookup fields the relationships are expected to map too.", "The name of the URL field defaults to 'url'. You can override this globally, by using the URL_FIELD_NAME setting.", "The ListSerializer class provides the behavior for serializing and validating multiple objects at once. You won't typically need to use ListSerializer directly, but should instead simply pass many=True when instantiating a serializer.", "When a serializer is instantiated and many=True is passed, a ListSerializer instance will be created. The serializer class then becomes a child of the parent ListSerializer", "The following argument can also be passed to a ListSerializer field or a serializer that is passed many=True:", "This is True by default, but can be set to False if you want to disallow empty lists as valid input.", "There are a few use cases when you might want to customize the ListSerializer behavior. For example:", "For these cases you can modify the class that is used when many=True is passed, by using the list_serializer_class option on the serializer Meta class.", "For example:", "The default implementation for multiple object creation is to simply call .create() for each item in the list. If you want to customize this behavior, you'll need to customize the .create() method on ListSerializer class that is used when many=True is passed.", "For example:", "By default the ListSerializer class does not support multiple updates. This is because the behavior that should be expected for insertions and deletions is ambiguous.", "To support multiple updates you'll need to do so explicitly. When writing your multiple update code make sure to keep the following in mind:", "You will need to add an explicit id field to the instance serializer. The default implicitly-generated id field is marked as read_only. This causes it to be removed on updates. Once you declare it explicitly, it will be available in the list serializer's update method.", "Here's an example of how you might choose to implement multiple updates:", "It is possible that a third party package may be included alongside the 3.1 release that provides some automatic support for multiple update operations, similar to the allow_add_remove behavior that was present in REST framework 2.", "When a serializer with many=True is instantiated, we need to determine which arguments and keyword arguments should be passed to the .__init__() method for both the child Serializer class, and for the parent ListSerializer class.", "The default implementation is to pass all arguments to both classes, except for validators, and any custom keyword arguments, both of which are assumed to be intended for the child serializer class.", "Occasionally you might need to explicitly specify how the child and parent classes should be instantiated when many=True is passed. You can do so by using the many_init class method.", "BaseSerializer class that can be used to easily support alternative serialization and deserialization styles.", "This class implements the same basic API as the Serializer class:", "There are four methods that can be overridden, depending on what functionality you want the serializer class to support:", "Because this class provides the same interface as the Serializer class, you can use it with the existing generic class-based views exactly as you would for a regular Serializer or ModelSerializer.", "The only difference you'll notice when doing so is the BaseSerializer classes will not generate HTML forms in the browsable API. This is because the data they return does not include all the field information that would allow each field to be rendered into a suitable HTML input.", "To implement a read-only serializer using the BaseSerializer class, we just need to override the .to_representation() method. Let's take a look at an example using a simple Django model:", "It's simple to create a read-only serializer for converting HighScore instances into primitive data types.", "We can now use this class to serialize single HighScore instances:", "Or use it to serialize multiple instances:", "To create a read-write serializer we first need to implement a .to_internal_value() method. This method returns the validated values that will be used to construct the object instance, and may raise a serializers.ValidationError if the supplied data is in an incorrect format.", "Once you've implemented .to_internal_value(), the basic validation API will be available on the serializer, and you will be able to use .is_valid(), .validated_data and .errors.", "If you want to also support .save() you'll need to also implement either or both of the .create() and .update() methods.", "Here's a complete example of our previous HighScoreSerializer, that's been updated to support both read and write operations.", "The BaseSerializer class is also useful if you want to implement new generic serializer classes for dealing with particular serialization styles, or for integrating with alternative storage backends.", "The following class is an example of a generic serializer that can handle coercing arbitrary objects into primitive representations.", "If you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the .to_representation() or .to_internal_value() methods.", "Some reasons this might be useful include...", "The signatures for these methods are as follows:", "Takes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API.", "May be overridden in order to modify the representation style. For example:", "Takes the unvalidated incoming data as input and should return the validated data that will be made available as serializer.validated_data. The return value will also be passed to the .create() or .update() methods if .save() is called on the serializer class.", "If any of the validation fails, then the method should raise a serializers.ValidationError(errors). The errors argument should be a dictionary mapping field names (or settings.NON_FIELD_ERRORS_KEY) to a list of error messages. If you don't need to alter deserialization behavior and instead want to provide object-level validation, it's recommended that you instead override the .validate() method.", "The data argument passed to this method will normally be the value of request.data, so the datatype it provides will depend on the parser classes you have configured for your API.", "Similar to Django forms, you can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example,", "Like Django's Model and ModelForm classes, the inner Meta class on serializers does not implicitly inherit from it's parents' inner Meta classes. If you want the Meta class to inherit from a parent class you must do so explicitly. For example:", "Typically we would recommend not using inheritance on inner Meta classes, but instead declaring all options explicitly.", "Additionally, the following caveats apply to serializer inheritance:", "It\u2019s possible to declaratively remove a Field inherited from a parent class by setting the name to be None on the subclass.", "However, you can only use this technique to opt out from a field defined declaratively by a parent class; it won\u2019t prevent the ModelSerializer from generating a default field. To opt-out from default fields, see Specifying which fields to include.", "Once a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the .fields attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer.", "Modifying the fields argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.", "For example, if you wanted to be able to set which fields should be used by a serializer at the point of initializing it, you could create a serializer class like so:", "This would then allow you to do the following:", "REST framework 2 provided an API to allow developers to override how a ModelSerializer class would automatically generate the default set of fields.", "This API included the .get_field(), .get_pk_field() and other methods.", "Because the serializers have been fundamentally redesigned with 3.0 this API no longer exists. You can still modify the fields that get created but you'll need to refer to the source code, and be aware that if the changes you make are against private bits of API then they may be subject to change.", "The following third party packages are also available.", "The django-rest-marshmallow package provides an alternative implementation for serializers, using the python marshmallow library. It exposes the same API as the REST framework serializers, and can be used as a drop-in replacement in some use-cases.", "The serpy package is an alternative implementation for serializers that is built for speed. Serpy serializes complex datatypes to simple native types. The native types can be easily converted to JSON or any other format needed.", "The django-rest-framework-mongoengine package provides a MongoEngineModelSerializer serializer class that supports using MongoDB as the storage layer for Django REST framework.", "The django-rest-framework-gis package provides a GeoFeatureModelSerializer serializer class that supports GeoJSON both for read and write operations.", "The django-rest-framework-hstore package provides an HStoreSerializer to support django-hstore DictionaryField model field and its schema-mode feature.", "The dynamic-rest package extends the ModelSerializer and ModelViewSet interfaces, adding API query parameters for filtering, sorting, and including / excluding all fields and relationships defined by your serializers.", "The drf-dynamic-fields package provides a mixin to dynamically limit the fields per serializer to a subset specified by an URL parameter.", "The drf-flex-fields package extends the ModelSerializer and ModelViewSet to provide commonly used functionality for dynamically setting fields and expanding primitive fields to nested models, both from URL parameters and your serializer class definitions.", "The django-rest-framework-serializer-extensions package provides a collection of tools to DRY up your serializers, by allowing fields to be defined on a per-view/request basis. Fields can be whitelisted, blacklisted and child serializers can be optionally expanded.", "The html-json-forms package provides an algorithm and serializer for processing <form> submissions per the (inactive) HTML JSON Form specification. The serializer facilitates processing of arbitrarily nested JSON structures within HTML. For example, <input name=\"items[0][id]\" value=\"5\"> will be interpreted as {\"items\": [{\"id\": \"5\"}]}.", "DRF-Base64 provides a set of field and model serializers that handles the upload of base64-encoded files.", "djangorestframework-queryfields allows API clients to specify which fields will be sent in the response via inclusion/exclusion query parameters.", "The drf-writable-nested package provides writable nested model serializer which allows to create/update models with nested related data.", "The drf-encrypt-content package helps you encrypt your data, serialized through ModelSerializer. It also contains some helper functions. Which helps you to encrypt your data. ", "serializers.py"]}, {"name": "SessionAuthentication", "path": "api-guide/authentication/index#sessionauthentication", "type": "Ref: Authentication", "text": ["Auth needs to be pluggable.", "\u2014 Jacob Kaplan-Moss, \"REST worst practices\"", "Authentication is the mechanism of associating an incoming request with a set of identifying credentials, such as the user the request came from, or the token that it was signed with. The permission and throttling policies can then use those credentials to determine if the request should be permitted.", "REST framework provides several authentication schemes out of the box, and also allows you to implement custom schemes.", "Authentication always runs at the very start of the view, before the permission and throttling checks occur, and before any other code is allowed to proceed.", "The request.user property will typically be set to an instance of the contrib.auth package's User class.", "The request.auth property is used for any additional authentication information, for example, it may be used to represent an authentication token that the request was signed with.", "Note: Don't forget that authentication by itself won't allow or disallow an incoming request, it simply identifies the credentials that the request was made with.", "For information on how to set up the permission policies for your API please see the permissions documentation.", "The authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set request.user and request.auth using the return value of the first class that successfully authenticates.", "If no class authenticates, request.user will be set to an instance of django.contrib.auth.models.AnonymousUser, and request.auth will be set to None.", "The value of request.user and request.auth for unauthenticated requests can be modified using the UNAUTHENTICATED_USER and UNAUTHENTICATED_TOKEN settings.", "The default authentication schemes may be set globally, using the DEFAULT_AUTHENTICATION_CLASSES setting. For example.", "You can also set the authentication scheme on a per-view or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "When an unauthenticated request is denied permission there are two different error codes that may be appropriate.", "HTTP 401 responses must always include a WWW-Authenticate header, that instructs the client how to authenticate. HTTP 403 responses do not include the WWW-Authenticate header.", "The kind of response that will be used depends on the authentication scheme. Although multiple authentication schemes may be in use, only one scheme may be used to determine the type of response. The first authentication class set on the view is used when determining the type of response.", "Note that when a request may successfully authenticate, but still be denied permission to perform the request, in which case a 403 Permission Denied response will always be used, regardless of the authentication scheme.", "Note that if deploying to Apache using mod_wsgi, the authorization header is not passed through to a WSGI application by default, as it is assumed that authentication will be handled by Apache, rather than at an application level.", "If you are deploying to Apache, and using any non-session based authentication, you will need to explicitly configure mod_wsgi to pass the required headers through to the application. This can be done by specifying the WSGIPassAuthorization directive in the appropriate context and setting it to 'On'.", "This authentication scheme uses HTTP Basic Authentication, signed against a user's username and password. Basic authentication is generally only appropriate for testing.", "If successfully authenticated, BasicAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "Note: If you use BasicAuthentication in production you must ensure that your API is only available over https. You should also ensure that your API clients will always re-request the username and password at login, and will never store those details to persistent storage.", "This authentication scheme uses a simple token-based HTTP Authentication scheme. Token authentication is appropriate for client-server setups, such as native desktop and mobile clients.", "To use the TokenAuthentication scheme you'll need to configure the authentication classes to include TokenAuthentication, and additionally include rest_framework.authtoken in your INSTALLED_APPS setting:", "Note: Make sure to run manage.py migrate after changing your settings. The rest_framework.authtoken app provides Django database migrations.", "You'll also need to create tokens for your users.", "For clients to authenticate, the token key should be included in the Authorization HTTP header. The key should be prefixed by the string literal \"Token\", with whitespace separating the two strings. For example:", "Note: If you want to use a different keyword in the header, such as Bearer, simply subclass TokenAuthentication and set the keyword class variable.", "If successfully authenticated, TokenAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "The curl command line tool may be useful for testing token authenticated APIs. For example:", "Note: If you use TokenAuthentication in production you must ensure that your API is only available over https.", "If you want every user to have an automatically generated Token, you can simply catch the User's post_save signal.", "Note that you'll want to ensure you place this code snippet in an installed models.py module, or some other location that will be imported by Django on startup.", "If you've already created some users, you can generate tokens for all existing users like this:", "When using TokenAuthentication, you may want to provide a mechanism for clients to obtain a token given the username and password. REST framework provides a built-in view to provide this behaviour. To use it, add the obtain_auth_token view to your URLconf:", "Note that the URL part of the pattern can be whatever you want to use.", "The obtain_auth_token view will return a JSON response when valid username and password fields are POSTed to the view using form data or JSON:", "Note that the default obtain_auth_token view explicitly uses JSON requests and responses, rather than using default renderer and parser classes in your settings.", "By default, there are no permissions or throttling applied to the obtain_auth_token view. If you do wish to apply to throttle you'll need to override the view class, and include them using the throttle_classes attribute.", "If you need a customized version of the obtain_auth_token view, you can do so by subclassing the ObtainAuthToken view class, and using that in your url conf instead.", "For example, you may return additional user information beyond the token value:", "And in your urls.py:", "It is also possible to create Tokens manually through the admin interface. In case you are using a large user base, we recommend that you monkey patch the TokenAdmin class customize it to your needs, more specifically by declaring the user field as raw_field.", "your_app/admin.py:", "Since version 3.6.4 it's possible to generate a user token using the following command:", "this command will return the API token for the given user, creating it if it doesn't exist:", "In case you want to regenerate the token (for example if it has been compromised or leaked) you can pass an additional parameter:", "This authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website.", "If successfully authenticated, SessionAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 403 Forbidden response.", "If you're using an AJAX-style API with SessionAuthentication, you'll need to make sure you include a valid CSRF token for any \"unsafe\" HTTP method calls, such as PUT, PATCH, POST or DELETE requests. See the Django CSRF documentation for more details.", "Warning: Always use Django's standard login view when creating login pages. This will ensure your login views are properly protected.", "CSRF validation in REST framework works slightly differently from standard Django due to the need to support both session and non-session based authentication to the same views. This means that only authenticated requests require CSRF tokens, and anonymous requests may be sent without CSRF tokens. This behaviour is not suitable for login views, which should always have CSRF validation applied.", "This authentication scheme allows you to delegate authentication to your web server, which sets the REMOTE_USER environment variable.", "To use it, you must have django.contrib.auth.backends.RemoteUserBackend (or a subclass) in your AUTHENTICATION_BACKENDS setting. By default, RemoteUserBackend creates User objects for usernames that don't already exist. To change this and other behaviour, consult the Django documentation.", "If successfully authenticated, RemoteUserAuthentication provides the following credentials:", "Consult your web server's documentation for information about configuring an authentication method, e.g.:", "To implement a custom authentication scheme, subclass BaseAuthentication and override the .authenticate(self, request) method. The method should return a two-tuple of (user, auth) if authentication succeeds, or None otherwise.", "In some circumstances instead of returning None, you may want to raise an AuthenticationFailed exception from the .authenticate() method.", "Typically the approach you should take is:", "You may also override the .authenticate_header(self, request) method. If implemented, it should return a string that will be used as the value of the WWW-Authenticate header in a HTTP 401 Unauthorized response.", "If the .authenticate_header() method is not overridden, the authentication scheme will return HTTP 403 Forbidden responses when an unauthenticated request is denied access.", "Note: When your custom authenticator is invoked by the request object's .user or .auth properties, you may see an AttributeError re-raised as a WrappedAttributeError. This is necessary to prevent the original exception from being suppressed by the outer property access. Python will not recognize that the AttributeError originates from your custom authenticator and will instead assume that the request object does not have a .user or .auth property. These errors should be fixed or otherwise handled by your authenticator.", "The following example will authenticate any incoming request as the user given by the username in a custom request header named 'X-USERNAME'.", "The following third-party packages are also available.", "The Django OAuth Toolkit package provides OAuth 2.0 support and works with Python 3.4+. The package is maintained by jazzband and uses the excellent OAuthLib. The package is well documented, and well supported and is currently our recommended package for OAuth 2.0 support.", "Install using pip.", "Add the package to your INSTALLED_APPS and modify your REST framework settings.", "For more details see the Django REST framework - Getting started documentation.", "The Django REST framework OAuth package provides both OAuth1 and OAuth2 support for REST framework.", "This package was previously included directly in the REST framework but is now supported and maintained as a third-party package.", "Install the package using pip.", "For details on configuration and usage see the Django REST framework OAuth documentation for authentication and permissions.", "JSON Web Token is a fairly new standard which can be used for token-based authentication. Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn't need to use a database to validate a token. A package for JWT authentication is djangorestframework-simplejwt which provides some features as well as a pluggable token blacklist app.", "The HawkREST library builds on the Mohawk library to let you work with Hawk signed requests and responses in your API. Hawk lets two parties securely communicate with each other using messages signed by a shared key. It is based on HTTP MAC access authentication (which was based on parts of OAuth 1.0).", "HTTP Signature (currently a IETF draft) provides a way to achieve origin authentication and message integrity for HTTP messages. Similar to Amazon's HTTP Signature scheme, used by many of its services, it permits stateless, per-request authentication. Elvio Toccalino maintains the djangorestframework-httpsignature (outdated) package which provides an easy to use HTTP Signature Authentication mechanism. You can use the updated fork version of djangorestframework-httpsignature, which is drf-httpsig.", "Djoser library provides a set of views to handle basic actions such as registration, login, logout, password reset and account activation. The package works with a custom user model and uses token-based authentication. This is ready to use REST implementation of the Django authentication system.", "This library provides a set of REST API endpoints for registration, authentication (including social media authentication), password reset, retrieve and update user details, etc. By having these API endpoints, your client apps such as AngularJS, iOS, Android, and others can communicate to your Django backend site independently via REST APIs for user management.", "There are currently two forks of this project.", "Django-rest-framework-social-oauth2 library provides an easy way to integrate social plugins (facebook, twitter, google, etc.) to your authentication system and an easy oauth2 setup. With this library, you will be able to authenticate users based on external tokens (e.g. facebook access token), convert these tokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to authenticate your users.", "Django-rest-knox library provides models and views to handle token-based authentication in a more secure and extensible way than the built-in TokenAuthentication scheme - with Single Page Applications and Mobile clients in mind. It provides per-client tokens, and views to generate them when provided some other authentication (usually basic authentication), to delete the token (providing a server enforced logout) and to delete all tokens (logs out all clients that a user is logged into).", "drfpasswordless adds (Medium, Square Cash inspired) passwordless support to Django REST Framework's TokenAuthentication scheme. Users log in and sign up with a token sent to a contact point like an email address or a mobile number.", "django-rest-authemail provides a RESTful API interface for user signup and authentication. Email addresses are used for authentication, rather than usernames. API endpoints are available for signup, signup email verification, login, logout, password reset, password reset verification, email change, email change verification, password change, and user detail. A fully functional example project and detailed instructions are included.", "Django-Rest-Durin is built with the idea to have one library that does token auth for multiple Web/CLI/Mobile API clients via one interface but allows different token configuration for each API Client that consumes the API. It provides support for multiple tokens per user via custom models, views, permissions that work with Django-Rest-Framework. The token expiration time can be different per API client and is customizable via the Django Admin Interface.", "More information can be found in the Documentation.", "authentication.py"]}, {"name": "Settings", "path": "api-guide/settings/index", "type": "API Guide", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "SimpleRouter", "path": "api-guide/routers/index#simplerouter", "type": "Ref: Routers", "text": ["Resource routing allows you to quickly declare all of the common routes for a given resourceful controller. Instead of declaring separate routes for your index... a resourceful route declares them in a single line of code.", "\u2014 Ruby on Rails Documentation", "Some Web frameworks such as Rails provide functionality for automatically determining how the URLs for an application should be mapped to the logic that deals with handling incoming requests.", "REST framework adds support for automatic URL routing to Django, and provides you with a simple, quick and consistent way of wiring your view logic to a set of URLs.", "Here's an example of a simple URL conf, that uses SimpleRouter.", "There are two mandatory arguments to the register() method:", "Optionally, you may also specify an additional argument:", "The example above would generate the following URL patterns:", "Note: The basename argument is used to specify the initial part of the view name pattern. In the example above, that's the user or account part.", "Typically you won't need to specify the basename argument, but if you have a viewset where you've defined a custom get_queryset method, then the viewset may not have a .queryset attribute set. If you try to register that viewset you'll see an error like this:", "This means you'll need to explicitly set the basename argument when registering the viewset, as it could not be automatically determined from the model name.", "The .urls attribute on a router instance is simply a standard list of URL patterns. There are a number of different styles for how you can include these URLs.", "For example, you can append router.urls to a list of existing views...", "Alternatively you can use Django's include function, like so...", "You may use include with an application namespace:", "Or both an application and instance namespace:", "See Django's URL namespaces docs and the include API reference for more details.", "Note: If using namespacing with hyperlinked serializers you'll also need to ensure that any view_name parameters on the serializers correctly reflect the namespace. In the examples above you'd need to include a parameter such as view_name='app_name:user-detail' for serializer fields hyperlinked to the user detail view.", "The automatic view_name generation uses a pattern like %(model_name)-detail. Unless your models names actually clash you may be better off not namespacing your Django REST Framework views when using hyperlinked serializers.", "A viewset may mark extra actions for routing by decorating a method with the @action decorator. These extra actions will be included in the generated routes. For example, given the set_password method on the UserViewSet class:", "The following route would be generated:", "By default, the URL pattern is based on the method name, and the URL name is the combination of the ViewSet.basename and the hyphenated method name. If you don't want to use the defaults for either of these values, you can instead provide the url_path and url_name arguments to the @action decorator.", "For example, if you want to change the URL for our custom action to ^users/{pk}/change-password/$, you could write:", "The above example would now generate the following URL pattern:", "This router includes routes for the standard set of list, create, retrieve, update, partial_update and destroy actions. The viewset can also mark additional methods to be routed, using the @action decorator.", "By default the URLs created by SimpleRouter are appended with a trailing slash. This behavior can be modified by setting the trailing_slash argument to False when instantiating the router. For example:", "Trailing slashes are conventional in Django, but are not used by default in some other frameworks such as Rails. Which style you choose to use is largely a matter of preference, although some javascript frameworks may expect a particular routing style.", "The router will match lookup values containing any characters except slashes and period characters. For a more restrictive (or lenient) lookup pattern, set the lookup_value_regex attribute on the viewset. For example, you can limit the lookup to valid UUIDs:", "This router is similar to SimpleRouter as above, but additionally includes a default API root view, that returns a response containing hyperlinks to all the list views. It also generates routes for optional .json style format suffixes.", "As with SimpleRouter the trailing slashes on the URL routes can be removed by setting the trailing_slash argument to False when instantiating the router.", "Implementing a custom router isn't something you'd need to do very often, but it can be useful if you have specific requirements about how the URLs for your API are structured. Doing so allows you to encapsulate the URL structure in a reusable way that ensures you don't have to write your URL patterns explicitly for each new view.", "The simplest way to implement a custom router is to subclass one of the existing router classes. The .routes attribute is used to template the URL patterns that will be mapped to each viewset. The .routes attribute is a list of Route named tuples.", "The arguments to the Route named tuple are:", "url: A string representing the URL to be routed. May include the following format strings:", "mapping: A mapping of HTTP method names to the view methods", "name: The name of the URL as used in reverse calls. May include the following format string:", "initkwargs: A dictionary of any additional arguments that should be passed when instantiating the view. Note that the detail, basename, and suffix arguments are reserved for viewset introspection and are also used by the browsable API to generate the view name and breadcrumb links.", "You can also customize how the @action decorator is routed. Include the DynamicRoute named tuple in the .routes list, setting the detail argument as appropriate for the list-based and detail-based routes. In addition to detail, the arguments to DynamicRoute are:", "url: A string representing the URL to be routed. May include the same format strings as Route, and additionally accepts the {url_path} format string.", "name: The name of the URL as used in reverse calls. May include the following format strings:", "initkwargs: A dictionary of any additional arguments that should be passed when instantiating the view.", "The following example will only route to the list and retrieve actions, and does not use the trailing slash convention.", "Let's take a look at the routes our CustomReadOnlyRouter would generate for a simple viewset.", "views.py:", "urls.py:", "The following mappings would be generated...", "For another example of setting the .routes attribute, see the source code for the SimpleRouter class.", "If you want to provide totally custom behavior, you can override BaseRouter and override the get_urls(self) method. The method should inspect the registered viewsets and return a list of URL patterns. The registered prefix, viewset and basename tuples may be inspected by accessing the self.registry attribute.", "You may also want to override the get_default_basename(self, viewset) method, or else always explicitly set the basename argument when registering your viewsets with the router.", "The following third party packages are also available.", "The drf-nested-routers package provides routers and relationship fields for working with nested resources.", "The wq.db package provides an advanced ModelRouter class (and singleton instance) that extends DefaultRouter with a register_model() API. Much like Django's admin.site.register, the only required argument to rest.router.register_model is a model class. Reasonable defaults for a url prefix, serializer, and viewset will be inferred from the model and global configuration.", "The DRF-extensions package provides routers for creating nested viewsets, collection level controllers with customizable endpoint names.", "routers.py"]}, {"name": "SlugField", "path": "api-guide/fields/index#slugfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "SlugRelatedField", "path": "api-guide/relations/index#slugrelatedfield", "type": "Ref: Serializer relations", "text": ["Data structures, not algorithms, are central to programming.", "\u2014 Rob Pike", "Relational fields are used to represent model relationships. They can be applied to ForeignKey, ManyToManyField and OneToOneField relationships, as well as to reverse relationships, and custom relationships such as GenericForeignKey.", "Note: The relational fields are declared in relations.py, but by convention you should import them from the serializers module, using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "When using the ModelSerializer class, serializer fields and relationships will be automatically generated for you. Inspecting these automatically generated fields can be a useful tool for determining how to customize the relationship style.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "In order to explain the various types of relational fields, we'll use a couple of simple models for our examples. Our models will be for music albums, and the tracks listed on each album.", "StringRelatedField may be used to represent the target of the relationship using its __str__ method.", "For example, the following serializer:", "Would serialize to the following representation:", "This field is read only.", "Arguments:", "PrimaryKeyRelatedField may be used to represent the target of the relationship using its primary key.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Arguments:", "HyperlinkedRelatedField may be used to represent the target of the relationship using a hyperlink.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Note: This field is designed for objects that map to a URL that accepts a single URL keyword argument, as set using the lookup_field and lookup_url_kwarg arguments.", "This is suitable for URLs that contain a single primary key or slug argument as part of the URL.", "If you require more complex hyperlinked representation you'll need to customize the field, as described in the custom hyperlinked fields section, below.", "Arguments:", "SlugRelatedField may be used to represent the target of the relationship using a field on the target.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "When using SlugRelatedField as a read-write field, you will normally want to ensure that the slug field corresponds to a model field with unique=True.", "Arguments:", "This field can be applied as an identity relationship, such as the 'url' field on a HyperlinkedModelSerializer. It can also be used for an attribute on the object. For example, the following serializer:", "Would serialize to a representation like this:", "This field is always read-only.", "Arguments:", "As opposed to previously discussed references to another entity, the referred entity can instead also be embedded or nested in the representation of the object that refers to it. Such nested relationships can be expressed by using serializers as fields. ", "If the field is used to represent a to-many relationship, you should add the many=True flag to the serializer field.", "For example, the following serializer:", "Would serialize to a nested representation like this:", "By default nested serializers are read-only. If you want to support write-operations to a nested serializer field you'll need to create create() and/or update() methods in order to explicitly specify how the child relationships should be saved:", "In rare cases where none of the existing relational styles fit the representation you need, you can implement a completely custom relational field, that describes exactly how the output representation should be generated from the model instance.", "To implement a custom relational field, you should override RelatedField, and implement the .to_representation(self, value) method. This method takes the target of the field as the value argument, and should return the representation that should be used to serialize the target. The value argument will typically be a model instance.", "If you want to implement a read-write relational field, you must also implement the .to_internal_value(self, data) method.", "To provide a dynamic queryset based on the context, you can also override .get_queryset(self) instead of specifying .queryset on the class or when initializing the field.", "For example, we could define a relational field to serialize a track to a custom string representation, using its ordering, title, and duration:", "This custom field would then serialize to the following representation:", "In some cases you may need to customize the behavior of a hyperlinked field, in order to represent URLs that require more than a single lookup field.", "You can achieve this by overriding HyperlinkedRelatedField. There are two methods that may be overridden:", "get_url(self, obj, view_name, request, format)", "The get_url method is used to map the object instance to its URL representation.", "May raise a NoReverseMatch if the view_name and lookup_field attributes are not configured to correctly match the URL conf.", "get_object(self, view_name, view_args, view_kwargs)", "If you want to support a writable hyperlinked field then you'll also want to override get_object, in order to map incoming URLs back to the object they represent. For read-only hyperlinked fields there is no need to override this method.", "The return value of this method should the object that corresponds to the matched URL conf arguments.", "May raise an ObjectDoesNotExist exception.", "Say we have a URL for a customer object that takes two keyword arguments, like so:", "This cannot be represented with the default implementation, which accepts only a single lookup field.", "In this case we'd need to override HyperlinkedRelatedField to get the behavior we want:", "Note that if you wanted to use this style together with the generic views then you'd also need to override .get_object on the view in order to get the correct lookup behavior.", "Generally we recommend a flat style for API representations where possible, but the nested URL style can also be reasonable when used in moderation.", "The queryset argument is only ever required for writable relationship field, in which case it is used for performing the model instance lookup, that maps from the primitive user input, into a model instance.", "In version 2.x a serializer class could sometimes automatically determine the queryset argument if a ModelSerializer class was being used.", "This behavior is now replaced with always using an explicit queryset argument for writable relational fields.", "Doing so reduces the amount of hidden 'magic' that ModelSerializer provides, makes the behavior of the field more clear, and ensures that it is trivial to move between using the ModelSerializer shortcut, or using fully explicit Serializer classes.", "The built-in __str__ method of the model will be used to generate string representations of the objects used to populate the choices property. These choices are used to populate select HTML inputs in the browsable API.", "To provide customized representations for such inputs, override display_value() of a RelatedField subclass. This method will receive a model object, and should return a string suitable for representing it. For example:", "When rendered in the browsable API relational fields will default to only displaying a maximum of 1000 selectable items. If more items are present then a disabled option with \"More than 1000 items\u2026\" will be displayed.", "This behavior is intended to prevent a template from being unable to render in an acceptable timespan due to a very large number of relationships being displayed.", "There are two keyword arguments you can use to control this behavior:", "You can also control these globally using the settings HTML_SELECT_CUTOFF and HTML_SELECT_CUTOFF_TEXT.", "In cases where the cutoff is being enforced you may want to instead use a plain input field in the HTML form. You can do so using the style keyword argument. For example:", "Note that reverse relationships are not automatically included by the ModelSerializer and HyperlinkedModelSerializer classes. To include a reverse relationship, you must explicitly add it to the fields list. For example:", "You'll normally want to ensure that you've set an appropriate related_name argument on the relationship, that you can use as the field name. For example:", "If you have not set a related name for the reverse relationship, you'll need to use the automatically generated related name in the fields argument. For example:", "See the Django documentation on reverse relationships for more details.", "If you want to serialize a generic foreign key, you need to define a custom field, to determine explicitly how you want to serialize the targets of the relationship.", "For example, given the following model for a tag, which has a generic relationship with other arbitrary models:", "And the following two models, which may have associated tags:", "We could define a custom field that could be used to serialize tagged instances, using the type of each instance to determine how it should be serialized:", "If you need the target of the relationship to have a nested representation, you can use the required serializers inside the .to_representation() method:", "Note that reverse generic keys, expressed using the GenericRelation field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.", "For more information see the Django documentation on generic relations.", "By default, relational fields that target a ManyToManyField with a through model specified are set to read-only.", "If you explicitly specify a relational field pointing to a ManyToManyField with a through model, be sure to set read_only to True.", "If you wish to represent extra fields on a through model then you may serialize the through model as a nested object.", "The following third party packages are also available.", "The drf-nested-routers package provides routers and relationship fields for working with nested resources.", "The rest-framework-generic-relations library provides read/write serialization for generic foreign keys.", "relations.py"]}, {"name": "StaticHTMLRenderer", "path": "api-guide/renderers/index#statichtmlrenderer", "type": "Ref: Renderers", "text": ["Before a TemplateResponse instance can be returned to the client, it must be rendered. The rendering process takes the intermediate representation of template and context, and turns it into the final byte stream that can be served to the client.", "\u2014 Django documentation", "REST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.", "The set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.", "The basic process of content negotiation involves examining the request's Accept header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL http://example.com/api/users_count.json might be an endpoint that always returns JSON data.", "For more information see the documentation on content negotiation.", "The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use JSON as the main media type and also include the self describing API.", "You can also set the renderers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "It's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an Accept: */* header, or not including an Accept header at all, then REST framework will select the first renderer in the list to use for the response.", "For example if your API serves JSON responses and the HTML browsable API, you might want to make JSONRenderer your default renderer, in order to send JSON responses to clients that do not specify an Accept header.", "If your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making TemplateHTMLRenderer your default renderer, in order to play nicely with older browsers that send broken accept headers.", "Renders the request data into JSON, using utf-8 encoding.", "Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:", "The client may additionally include an 'indent' media type parameter, in which case the returned JSON will be indented. For example Accept: application/json; indent=4.", "The default JSON encoding style can be altered using the UNICODE_JSON and COMPACT_JSON settings keys.", ".media_type: application/json", ".format: 'json'", ".charset: None", "Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the Response does not need to be serialized. Also, unlike other renderers, you may want to include a template_name argument when creating the Response.", "The TemplateHTMLRenderer will create a RequestContext, using the response.data as the context dict, and determine a template name to use to render the context.", "Note: When used with a view that makes use of a serializer the Response sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the TemplateHTMLRenderer to render it. For example:", "The template name is determined by (in order of preference):", "An example of a view that uses TemplateHTMLRenderer:", "You can use TemplateHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", "If you're building websites that use TemplateHTMLRenderer along with other renderer classes, you should consider listing TemplateHTMLRenderer as the first class in the renderer_classes list, so that it will be prioritised first even for browsers that send poorly formed ACCEPT: headers.", "See the HTML & Forms Topic Page for further examples of TemplateHTMLRenderer usage.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: StaticHTMLRenderer", "A simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.", "An example of a view that uses StaticHTMLRenderer:", "You can use StaticHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: TemplateHTMLRenderer", "Renders data into HTML for the Browsable API:", "", "This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.", ".media_type: text/html", ".format: 'api'", ".charset: utf-8", ".template: 'rest_framework/api.html'", "By default the response content will be rendered with the highest priority renderer apart from BrowsableAPIRenderer. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the get_default_renderer() method. For example:", "Renders data into HTML for an admin-like display:", "", "This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.", "Note that views that have nested or list serializers for their input won't work well with the AdminRenderer, as the HTML forms are unable to properly support them.", "Note: The AdminRenderer is only able to include links to detail pages when a properly configured URL_FIELD_NAME (url by default) attribute is present in the data. For HyperlinkedModelSerializer this will be the case, but for ModelSerializer or plain Serializer classes you'll need to make sure to include the field explicitly. For example here we use models get_absolute_url method:", ".media_type: text/html", ".format: 'admin'", ".charset: utf-8", ".template: 'rest_framework/admin.html'", "Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing <form> tags, a hidden CSRF input or any submit buttons.", "This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the render_form template tag.", "For more information see the HTML & Forms documentation.", ".media_type: text/html", ".format: 'form'", ".charset: utf-8", ".template: 'rest_framework/horizontal/form.html'", "This renderer is used for rendering HTML multipart form data. It is not suitable as a response renderer, but is instead used for creating test requests, using REST framework's test client and test request factory.", ".media_type: multipart/form-data; boundary=BoUnDaRyStRiNg", ".format: 'multipart'", ".charset: utf-8", "To implement a custom renderer, you should override BaseRenderer, set the .media_type and .format properties, and implement the .render(self, data, media_type=None, renderer_context=None) method.", "The method should return a bytestring, which will be used as the body of the HTTP response.", "The arguments passed to the .render() method are:", "The request data, as set by the Response() instantiation.", "Optional. If provided, this is the accepted media type, as determined by the content negotiation stage.", "Depending on the client's Accept: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"application/json; nested=true\".", "Optional. If provided, this is a dictionary of contextual information provided by the view.", "By default this will include the following keys: view, request, response, args, kwargs.", "The following is an example plaintext renderer that will return a response with the data parameter as the content of the response.", "By default renderer classes are assumed to be using the UTF-8 encoding. To use a different encoding, set the charset attribute on the renderer.", "Note that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the Response class, with the charset attribute set on the renderer used to determine the encoding.", "If the renderer returns a bytestring representing raw binary content, you should set a charset value of None, which will ensure the Content-Type header of the response will not have a charset value set.", "In some cases you may also want to set the render_style attribute to 'binary'. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.", "You can do some pretty flexible things using REST framework's renderers. Some examples...", "In some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access request.accepted_renderer to determine the negotiated renderer that will be used for the response.", "For example:", "In some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a media_type value such as image/*, or */*.", "If you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the content_type attribute. For example:", "For the purposes of many Web APIs, simple JSON responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and HATEOAS you'll need to consider the design and usage of your media types in more detail.", "In the words of Roy Fielding, \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".", "For good examples of custom media types, see GitHub's use of a custom application/vnd.github+json media type, and Mike Amundsen's IANA approved application/vnd.collection+json JSON-based hypermedia.", "Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an Http404 or PermissionDenied exception, or a subclass of APIException.", "If you're using either the TemplateHTMLRenderer or the StaticHTMLRenderer and an exception is raised, the behavior is slightly different, and mirrors Django's default handling of error views.", "Exceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.", "Templates will render with a RequestContext which includes the status_code and details keys.", "Note: If DEBUG=True, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST framework JSONP provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Warning: If you require cross-domain AJAX requests, you should generally be using the more modern approach of CORS as an alternative to JSONP. See the CORS documentation for more details.", "The jsonp approach is essentially a browser hack, and is only appropriate for globally readable API endpoints, where GET requests are unauthenticated and do not require any user permissions.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "XLSX is the world's most popular binary spreadsheet format. Tim Allen of The Wharton School maintains drf-renderer-xlsx, which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.", "Install using pip.", "Modify your REST framework settings.", "To avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the Content-Disposition header. If no filename is provided, it will default to export.xlsx. For example:", "Comma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. Mjumbe Poe maintains the djangorestframework-csv package which provides CSV renderer support for REST framework.", "UltraJSON is an optimized C JSON encoder which can give significantly faster JSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now unmaintained drf-ujson-renderer, which implements JSON rendering using the UJSON package.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "Django REST Pandas provides a serializer and renderers that support additional data processing and output via the Pandas DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both .xls and .xlsx), and a number of other formats. It is maintained by S. Andrew Sheppard as part of the wq Project.", "Rest Framework Latex provides a renderer that outputs PDFs using Laulatex. It is maintained by Pebble (S/F Software).", "renderers.py"]}, {"name": "Status Codes", "path": "api-guide/status-codes/index", "type": "API Guide", "text": ["418 I'm a teapot - Any attempt to brew coffee with a teapot should result in the error code \"418 I'm a teapot\". The resulting entity body MAY be short and stout.", "\u2014 RFC 2324, Hyper Text Coffee Pot Control Protocol", "Using bare status codes in your responses isn't recommended. REST framework includes a set of named constants that you can use to make your code more obvious and readable.", "The full set of HTTP status codes included in the status module is listed below.", "The module also includes a set of helper functions for testing if a status code is in a given range.", "For more information on proper usage of HTTP status codes see RFC 2616 and RFC 6585.", "This class of status code indicates a provisional response. There are no 1xx status codes used in REST framework by default.", "This class of status code indicates that the client's request was successfully received, understood, and accepted.", "This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.", "The 4xx class of status code is intended for cases in which the client seems to have erred. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.", "Response status codes beginning with the digit \"5\" indicate cases in which the server is aware that it has erred or is incapable of performing the request. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.", "The following helper functions are available for identifying the category of the response code.", "status.py"]}, {"name": "StringRelatedField", "path": "api-guide/relations/index#stringrelatedfield", "type": "Ref: Serializer relations", "text": ["Data structures, not algorithms, are central to programming.", "\u2014 Rob Pike", "Relational fields are used to represent model relationships. They can be applied to ForeignKey, ManyToManyField and OneToOneField relationships, as well as to reverse relationships, and custom relationships such as GenericForeignKey.", "Note: The relational fields are declared in relations.py, but by convention you should import them from the serializers module, using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "When using the ModelSerializer class, serializer fields and relationships will be automatically generated for you. Inspecting these automatically generated fields can be a useful tool for determining how to customize the relationship style.", "To do so, open the Django shell, using python manage.py shell, then import the serializer class, instantiate it, and print the object representation\u2026", "In order to explain the various types of relational fields, we'll use a couple of simple models for our examples. Our models will be for music albums, and the tracks listed on each album.", "StringRelatedField may be used to represent the target of the relationship using its __str__ method.", "For example, the following serializer:", "Would serialize to the following representation:", "This field is read only.", "Arguments:", "PrimaryKeyRelatedField may be used to represent the target of the relationship using its primary key.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Arguments:", "HyperlinkedRelatedField may be used to represent the target of the relationship using a hyperlink.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "Note: This field is designed for objects that map to a URL that accepts a single URL keyword argument, as set using the lookup_field and lookup_url_kwarg arguments.", "This is suitable for URLs that contain a single primary key or slug argument as part of the URL.", "If you require more complex hyperlinked representation you'll need to customize the field, as described in the custom hyperlinked fields section, below.", "Arguments:", "SlugRelatedField may be used to represent the target of the relationship using a field on the target.", "For example, the following serializer:", "Would serialize to a representation like this:", "By default this field is read-write, although you can change this behavior using the read_only flag.", "When using SlugRelatedField as a read-write field, you will normally want to ensure that the slug field corresponds to a model field with unique=True.", "Arguments:", "This field can be applied as an identity relationship, such as the 'url' field on a HyperlinkedModelSerializer. It can also be used for an attribute on the object. For example, the following serializer:", "Would serialize to a representation like this:", "This field is always read-only.", "Arguments:", "As opposed to previously discussed references to another entity, the referred entity can instead also be embedded or nested in the representation of the object that refers to it. Such nested relationships can be expressed by using serializers as fields. ", "If the field is used to represent a to-many relationship, you should add the many=True flag to the serializer field.", "For example, the following serializer:", "Would serialize to a nested representation like this:", "By default nested serializers are read-only. If you want to support write-operations to a nested serializer field you'll need to create create() and/or update() methods in order to explicitly specify how the child relationships should be saved:", "In rare cases where none of the existing relational styles fit the representation you need, you can implement a completely custom relational field, that describes exactly how the output representation should be generated from the model instance.", "To implement a custom relational field, you should override RelatedField, and implement the .to_representation(self, value) method. This method takes the target of the field as the value argument, and should return the representation that should be used to serialize the target. The value argument will typically be a model instance.", "If you want to implement a read-write relational field, you must also implement the .to_internal_value(self, data) method.", "To provide a dynamic queryset based on the context, you can also override .get_queryset(self) instead of specifying .queryset on the class or when initializing the field.", "For example, we could define a relational field to serialize a track to a custom string representation, using its ordering, title, and duration:", "This custom field would then serialize to the following representation:", "In some cases you may need to customize the behavior of a hyperlinked field, in order to represent URLs that require more than a single lookup field.", "You can achieve this by overriding HyperlinkedRelatedField. There are two methods that may be overridden:", "get_url(self, obj, view_name, request, format)", "The get_url method is used to map the object instance to its URL representation.", "May raise a NoReverseMatch if the view_name and lookup_field attributes are not configured to correctly match the URL conf.", "get_object(self, view_name, view_args, view_kwargs)", "If you want to support a writable hyperlinked field then you'll also want to override get_object, in order to map incoming URLs back to the object they represent. For read-only hyperlinked fields there is no need to override this method.", "The return value of this method should the object that corresponds to the matched URL conf arguments.", "May raise an ObjectDoesNotExist exception.", "Say we have a URL for a customer object that takes two keyword arguments, like so:", "This cannot be represented with the default implementation, which accepts only a single lookup field.", "In this case we'd need to override HyperlinkedRelatedField to get the behavior we want:", "Note that if you wanted to use this style together with the generic views then you'd also need to override .get_object on the view in order to get the correct lookup behavior.", "Generally we recommend a flat style for API representations where possible, but the nested URL style can also be reasonable when used in moderation.", "The queryset argument is only ever required for writable relationship field, in which case it is used for performing the model instance lookup, that maps from the primitive user input, into a model instance.", "In version 2.x a serializer class could sometimes automatically determine the queryset argument if a ModelSerializer class was being used.", "This behavior is now replaced with always using an explicit queryset argument for writable relational fields.", "Doing so reduces the amount of hidden 'magic' that ModelSerializer provides, makes the behavior of the field more clear, and ensures that it is trivial to move between using the ModelSerializer shortcut, or using fully explicit Serializer classes.", "The built-in __str__ method of the model will be used to generate string representations of the objects used to populate the choices property. These choices are used to populate select HTML inputs in the browsable API.", "To provide customized representations for such inputs, override display_value() of a RelatedField subclass. This method will receive a model object, and should return a string suitable for representing it. For example:", "When rendered in the browsable API relational fields will default to only displaying a maximum of 1000 selectable items. If more items are present then a disabled option with \"More than 1000 items\u2026\" will be displayed.", "This behavior is intended to prevent a template from being unable to render in an acceptable timespan due to a very large number of relationships being displayed.", "There are two keyword arguments you can use to control this behavior:", "You can also control these globally using the settings HTML_SELECT_CUTOFF and HTML_SELECT_CUTOFF_TEXT.", "In cases where the cutoff is being enforced you may want to instead use a plain input field in the HTML form. You can do so using the style keyword argument. For example:", "Note that reverse relationships are not automatically included by the ModelSerializer and HyperlinkedModelSerializer classes. To include a reverse relationship, you must explicitly add it to the fields list. For example:", "You'll normally want to ensure that you've set an appropriate related_name argument on the relationship, that you can use as the field name. For example:", "If you have not set a related name for the reverse relationship, you'll need to use the automatically generated related name in the fields argument. For example:", "See the Django documentation on reverse relationships for more details.", "If you want to serialize a generic foreign key, you need to define a custom field, to determine explicitly how you want to serialize the targets of the relationship.", "For example, given the following model for a tag, which has a generic relationship with other arbitrary models:", "And the following two models, which may have associated tags:", "We could define a custom field that could be used to serialize tagged instances, using the type of each instance to determine how it should be serialized:", "If you need the target of the relationship to have a nested representation, you can use the required serializers inside the .to_representation() method:", "Note that reverse generic keys, expressed using the GenericRelation field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.", "For more information see the Django documentation on generic relations.", "By default, relational fields that target a ManyToManyField with a through model specified are set to read-only.", "If you explicitly specify a relational field pointing to a ManyToManyField with a through model, be sure to set read_only to True.", "If you wish to represent extra fields on a through model then you may serialize the through model as a nested object.", "The following third party packages are also available.", "The drf-nested-routers package provides routers and relationship fields for working with nested resources.", "The rest-framework-generic-relations library provides read/write serialization for generic foreign keys.", "relations.py"]}, {"name": "TemplateHTMLRenderer", "path": "api-guide/renderers/index#templatehtmlrenderer", "type": "Ref: Renderers", "text": ["Before a TemplateResponse instance can be returned to the client, it must be rendered. The rendering process takes the intermediate representation of template and context, and turns it into the final byte stream that can be served to the client.", "\u2014 Django documentation", "REST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.", "The set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.", "The basic process of content negotiation involves examining the request's Accept header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL http://example.com/api/users_count.json might be an endpoint that always returns JSON data.", "For more information see the documentation on content negotiation.", "The default set of renderers may be set globally, using the DEFAULT_RENDERER_CLASSES setting. For example, the following settings would use JSON as the main media type and also include the self describing API.", "You can also set the renderers used for an individual view, or viewset, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "It's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an Accept: */* header, or not including an Accept header at all, then REST framework will select the first renderer in the list to use for the response.", "For example if your API serves JSON responses and the HTML browsable API, you might want to make JSONRenderer your default renderer, in order to send JSON responses to clients that do not specify an Accept header.", "If your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making TemplateHTMLRenderer your default renderer, in order to play nicely with older browsers that send broken accept headers.", "Renders the request data into JSON, using utf-8 encoding.", "Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:", "The client may additionally include an 'indent' media type parameter, in which case the returned JSON will be indented. For example Accept: application/json; indent=4.", "The default JSON encoding style can be altered using the UNICODE_JSON and COMPACT_JSON settings keys.", ".media_type: application/json", ".format: 'json'", ".charset: None", "Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the Response does not need to be serialized. Also, unlike other renderers, you may want to include a template_name argument when creating the Response.", "The TemplateHTMLRenderer will create a RequestContext, using the response.data as the context dict, and determine a template name to use to render the context.", "Note: When used with a view that makes use of a serializer the Response sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the TemplateHTMLRenderer to render it. For example:", "The template name is determined by (in order of preference):", "An example of a view that uses TemplateHTMLRenderer:", "You can use TemplateHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", "If you're building websites that use TemplateHTMLRenderer along with other renderer classes, you should consider listing TemplateHTMLRenderer as the first class in the renderer_classes list, so that it will be prioritised first even for browsers that send poorly formed ACCEPT: headers.", "See the HTML & Forms Topic Page for further examples of TemplateHTMLRenderer usage.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: StaticHTMLRenderer", "A simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.", "An example of a view that uses StaticHTMLRenderer:", "You can use StaticHTMLRenderer either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.", ".media_type: text/html", ".format: 'html'", ".charset: utf-8", "See also: TemplateHTMLRenderer", "Renders data into HTML for the Browsable API:", "", "This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.", ".media_type: text/html", ".format: 'api'", ".charset: utf-8", ".template: 'rest_framework/api.html'", "By default the response content will be rendered with the highest priority renderer apart from BrowsableAPIRenderer. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the get_default_renderer() method. For example:", "Renders data into HTML for an admin-like display:", "", "This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.", "Note that views that have nested or list serializers for their input won't work well with the AdminRenderer, as the HTML forms are unable to properly support them.", "Note: The AdminRenderer is only able to include links to detail pages when a properly configured URL_FIELD_NAME (url by default) attribute is present in the data. For HyperlinkedModelSerializer this will be the case, but for ModelSerializer or plain Serializer classes you'll need to make sure to include the field explicitly. For example here we use models get_absolute_url method:", ".media_type: text/html", ".format: 'admin'", ".charset: utf-8", ".template: 'rest_framework/admin.html'", "Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing <form> tags, a hidden CSRF input or any submit buttons.", "This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the render_form template tag.", "For more information see the HTML & Forms documentation.", ".media_type: text/html", ".format: 'form'", ".charset: utf-8", ".template: 'rest_framework/horizontal/form.html'", "This renderer is used for rendering HTML multipart form data. It is not suitable as a response renderer, but is instead used for creating test requests, using REST framework's test client and test request factory.", ".media_type: multipart/form-data; boundary=BoUnDaRyStRiNg", ".format: 'multipart'", ".charset: utf-8", "To implement a custom renderer, you should override BaseRenderer, set the .media_type and .format properties, and implement the .render(self, data, media_type=None, renderer_context=None) method.", "The method should return a bytestring, which will be used as the body of the HTTP response.", "The arguments passed to the .render() method are:", "The request data, as set by the Response() instantiation.", "Optional. If provided, this is the accepted media type, as determined by the content negotiation stage.", "Depending on the client's Accept: header, this may be more specific than the renderer's media_type attribute, and may include media type parameters. For example \"application/json; nested=true\".", "Optional. If provided, this is a dictionary of contextual information provided by the view.", "By default this will include the following keys: view, request, response, args, kwargs.", "The following is an example plaintext renderer that will return a response with the data parameter as the content of the response.", "By default renderer classes are assumed to be using the UTF-8 encoding. To use a different encoding, set the charset attribute on the renderer.", "Note that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the Response class, with the charset attribute set on the renderer used to determine the encoding.", "If the renderer returns a bytestring representing raw binary content, you should set a charset value of None, which will ensure the Content-Type header of the response will not have a charset value set.", "In some cases you may also want to set the render_style attribute to 'binary'. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.", "You can do some pretty flexible things using REST framework's renderers. Some examples...", "In some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access request.accepted_renderer to determine the negotiated renderer that will be used for the response.", "For example:", "In some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a media_type value such as image/*, or */*.", "If you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the content_type attribute. For example:", "For the purposes of many Web APIs, simple JSON responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and HATEOAS you'll need to consider the design and usage of your media types in more detail.", "In the words of Roy Fielding, \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".", "For good examples of custom media types, see GitHub's use of a custom application/vnd.github+json media type, and Mike Amundsen's IANA approved application/vnd.collection+json JSON-based hypermedia.", "Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an Http404 or PermissionDenied exception, or a subclass of APIException.", "If you're using either the TemplateHTMLRenderer or the StaticHTMLRenderer and an exception is raised, the behavior is slightly different, and mirrors Django's default handling of error views.", "Exceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.", "Templates will render with a RequestContext which includes the status_code and details keys.", "Note: If DEBUG=True, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.", "The following third party packages are also available.", "REST framework YAML provides YAML parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST Framework XML provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Install using pip.", "Modify your REST framework settings.", "REST framework JSONP provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.", "Warning: If you require cross-domain AJAX requests, you should generally be using the more modern approach of CORS as an alternative to JSONP. See the CORS documentation for more details.", "The jsonp approach is essentially a browser hack, and is only appropriate for globally readable API endpoints, where GET requests are unauthenticated and do not require any user permissions.", "Install using pip.", "Modify your REST framework settings.", "MessagePack is a fast, efficient binary serialization format. Juan Riaza maintains the djangorestframework-msgpack package which provides MessagePack renderer and parser support for REST framework.", "XLSX is the world's most popular binary spreadsheet format. Tim Allen of The Wharton School maintains drf-renderer-xlsx, which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.", "Install using pip.", "Modify your REST framework settings.", "To avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the Content-Disposition header. If no filename is provided, it will default to export.xlsx. For example:", "Comma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. Mjumbe Poe maintains the djangorestframework-csv package which provides CSV renderer support for REST framework.", "UltraJSON is an optimized C JSON encoder which can give significantly faster JSON rendering. Adam Mertz maintains drf_ujson2, a fork of the now unmaintained drf-ujson-renderer, which implements JSON rendering using the UJSON package.", "djangorestframework-camel-case provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by Vitaly Babiy.", "Django REST Pandas provides a serializer and renderers that support additional data processing and output via the Pandas DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both .xls and .xlsx), and a number of other formats. It is maintained by S. Andrew Sheppard as part of the wq Project.", "Rest Framework Latex provides a renderer that outputs PDFs using Laulatex. It is maintained by Pebble (S/F Software).", "renderers.py"]}, {"name": "Test settings", "path": "api-guide/settings/index#test-settings", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "Testing", "path": "api-guide/testing/index", "type": "API Guide", "text": ["Code without tests is broken as designed.", "\u2014 Jacob Kaplan-Moss", "REST framework includes a few helper classes that extend Django's existing test framework, and improve support for making API requests.", "Extends Django's existing RequestFactory class.", "The APIRequestFactory class supports an almost identical API to Django's standard RequestFactory class. This means that the standard .get(), .post(), .put(), .patch(), .delete(), .head() and .options() methods are all available.", "Methods which create a request body, such as post, put and patch, include a format argument, which make it easy to generate requests using a content type other than multipart form data. For example:", "By default the available formats are 'multipart' and 'json'. For compatibility with Django's existing RequestFactory the default format is 'multipart'.", "To support a wider set of request formats, or change the default format, see the configuration section.", "If you need to explicitly encode the request body, you can do so by setting the content_type flag. For example:", "One difference worth noting between Django's RequestFactory and REST framework's APIRequestFactory is that multipart form data will be encoded for methods other than just .post().", "For example, using APIRequestFactory, you can make a form PUT request like so:", "Using Django's RequestFactory, you'd need to explicitly encode the data yourself:", "When testing views directly using a request factory, it's often convenient to be able to directly authenticate the request, rather than having to construct the correct authentication credentials.", "To forcibly authenticate a request, use the force_authenticate() method.", "The signature for the method is force_authenticate(request, user=None, token=None). When making the call, either or both of the user and token may be set.", "For example, when forcibly authenticating using a token, you might do something like the following:", "Note: force_authenticate directly sets request.user to the in-memory user instance. If you are re-using the same user instance across multiple tests that update the saved user state, you may need to call refresh_from_db() between tests.", "Note: When using APIRequestFactory, the object that is returned is Django's standard HttpRequest, and not REST framework's Request object, which is only generated once the view is called.", "This means that setting attributes directly on the request object may not always have the effect you expect. For example, setting .token directly will have no effect, and setting .user directly will only work if session authentication is being used.", "By default, requests created with APIRequestFactory will not have CSRF validation applied when passed to a REST framework view. If you need to explicitly turn CSRF validation on, you can do so by setting the enforce_csrf_checks flag when instantiating the factory.", "Note: It's worth noting that Django's standard RequestFactory doesn't need to include this option, because when using regular Django the CSRF validation takes place in middleware, which is not run when testing views directly. When using REST framework, CSRF validation takes place inside the view, so the request factory needs to disable view-level CSRF checks.", "Extends Django's existing Client class.", "The APIClient class supports the same request interface as Django's standard Client class. This means that the standard .get(), .post(), .put(), .patch(), .delete(), .head() and .options() methods are all available. For example:", "To support a wider set of request formats, or change the default format, see the configuration section.", "The login method functions exactly as it does with Django's regular Client class. This allows you to authenticate requests against any views which include SessionAuthentication.", "To logout, call the logout method as usual.", "The login method is appropriate for testing APIs that use session authentication, for example web sites which include AJAX interaction with the API.", "The credentials method can be used to set headers that will then be included on all subsequent requests by the test client.", "Note that calling credentials a second time overwrites any existing credentials. You can unset any existing credentials by calling the method with no arguments.", "The credentials method is appropriate for testing APIs that require authentication headers, such as basic authentication, OAuth1a and OAuth2 authentication, and simple token authentication schemes.", "Sometimes you may want to bypass authentication entirely and force all requests by the test client to be automatically treated as authenticated.", "This can be a useful shortcut if you're testing the API but don't want to have to construct valid authentication credentials in order to make test requests.", "To unauthenticate subsequent requests, call force_authenticate setting the user and/or token to None.", "By default CSRF validation is not applied when using APIClient. If you need to explicitly enable CSRF validation, you can do so by setting the enforce_csrf_checks flag when instantiating the client.", "As usual CSRF validation will only apply to any session authenticated views. This means CSRF validation will only occur if the client has been logged in by calling login().", "REST framework also includes a client for interacting with your application using the popular Python library, requests. This may be useful if:", "This exposes exactly the same interface as if you were using a requests session directly.", "Note that the requests client requires you to pass fully qualified URLs.", "The RequestsClient class is useful if you want to write tests that solely interact with the service interface. This is a little stricter than using the standard Django test client, as it means that all interactions should be via the API.", "If you're using RequestsClient you'll want to ensure that test setup, and results assertions are performed as regular API calls, rather than interacting with the database models directly. For example, rather than checking that Customer.objects.count() == 3 you would list the customers endpoint, and ensure that it contains three records.", "Custom headers and authentication credentials can be provided in the same way as when using a standard requests.Session instance.", "If you're using SessionAuthentication then you'll need to include a CSRF token for any POST, PUT, PATCH or DELETE requests.", "You can do so by following the same flow that a JavaScript based client would use. First make a GET request in order to obtain a CRSF token, then present that token in the following request.", "For example...", "With careful usage both the RequestsClient and the CoreAPIClient provide the ability to write test cases that can run either in development, or be run directly against your staging server or production environment.", "Using this style to create basic tests of a few core piece of functionality is a powerful way to validate your live service. Doing so may require some careful attention to setup and teardown to ensure that the tests run in a way that they do not directly affect customer data.", "The CoreAPIClient allows you to interact with your API using the Python coreapi client library.", "Custom headers and authentication may be used with CoreAPIClient in a similar way as with RequestsClient.", "REST framework includes the following test case classes, that mirror the existing Django test case classes, but use APIClient instead of Django's default Client.", "You can use any of REST framework's test case classes as you would for the regular Django test case classes. The self.client attribute will be an APIClient instance.", "REST framework also provides a test case class for isolating urlpatterns on a per-class basis. Note that this inherits from Django's SimpleTestCase, and will most likely need to be mixed with another test case class.", "When checking the validity of test responses it's often more convenient to inspect the data that the response was created with, rather than inspecting the fully rendered response.", "For example, it's easier to inspect response.data:", "Instead of inspecting the result of parsing response.content:", "If you're testing views directly using APIRequestFactory, the responses that are returned will not yet be rendered, as rendering of template responses is performed by Django's internal request-response cycle. In order to access response.content, you'll first need to render the response.", "The default format used to make test requests may be set using the TEST_REQUEST_DEFAULT_FORMAT setting key. For example, to always use JSON for test requests by default instead of standard multipart form requests, set the following in your settings.py file:", "If you need to test requests using something other than multipart or json requests, you can do so by setting the TEST_REQUEST_RENDERER_CLASSES setting.", "For example, to add support for using format='html' in test requests, you might have something like this in your settings.py file.", "test.py"]}, {"name": "Throttled", "path": "api-guide/exceptions/index#throttled", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "Throttling", "path": "api-guide/throttling/index", "type": "API Guide", "text": ["HTTP/1.1 420 Enhance Your Calm", "Twitter API rate limiting response", "Throttling is similar to permissions, in that it determines if a request should be authorized. Throttles indicate a temporary state, and are used to control the rate of requests that clients can make to an API.", "As with permissions, multiple throttles may be used. Your API might have a restrictive throttle for unauthenticated requests, and a less restrictive throttle for authenticated requests.", "Another scenario where you might want to use multiple throttles would be if you need to impose different constraints on different parts of the API, due to some services being particularly resource-intensive.", "Multiple throttles can also be used if you want to impose both burst throttling rates, and sustained throttling rates. For example, you might want to limit a user to a maximum of 60 requests per minute, and 1000 requests per day.", "Throttles do not necessarily only refer to rate-limiting requests. For example a storage service might also need to throttle against bandwidth, and a paid data service might want to throttle against a certain number of a records being accessed.", "As with permissions and authentication, throttling in REST framework is always defined as a list of classes.", "Before running the main body of the view each throttle in the list is checked. If any throttle check fails an exceptions.Throttled exception will be raised, and the main body of the view will not run.", "The default throttling policy may be set globally, using the DEFAULT_THROTTLE_CLASSES and DEFAULT_THROTTLE_RATES settings. For example.", "The rate descriptions used in DEFAULT_THROTTLE_RATES may include second, minute, hour or day as the throttle period.", "You can also set the throttling policy on a per-view or per-viewset basis, using the APIView class-based views.", "If you're using the @api_view decorator with function based views you can use the following decorator.", "It's also possible to set throttle classes for routes that are created using the @action decorator. Throttle classes set in this way will override any viewset level class settings.", "The X-Forwarded-For HTTP header and REMOTE_ADDR WSGI variable are used to uniquely identify client IP addresses for throttling. If the X-Forwarded-For header is present then it will be used, otherwise the value of the REMOTE_ADDR variable from the WSGI environment will be used.", "If you need to strictly identify unique client IP addresses, you'll need to first configure the number of application proxies that the API runs behind by setting the NUM_PROXIES setting. This setting should be an integer of zero or more. If set to non-zero then the client IP will be identified as being the last IP address in the X-Forwarded-For header, once any application proxy IP addresses have first been excluded. If set to zero, then the REMOTE_ADDR value will always be used as the identifying IP address.", "It is important to understand that if you configure the NUM_PROXIES setting, then all clients behind a unique NAT'd gateway will be treated as a single client.", "Further context on how the X-Forwarded-For header works, and identifying a remote client IP can be found here.", "The throttle classes provided by REST framework use Django's cache backend. You should make sure that you've set appropriate cache settings. The default value of LocMemCache backend should be okay for simple setups. See Django's cache documentation for more details.", "If you need to use a cache other than 'default', you can do so by creating a custom throttle class and setting the cache attribute. For example:", "You'll need to remember to also set your custom throttle class in the 'DEFAULT_THROTTLE_CLASSES' settings key, or using the throttle_classes view attribute.", "The AnonRateThrottle will only ever throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.", "The allowed request rate is determined from one of the following (in order of preference).", "AnonRateThrottle is suitable if you want to restrict the rate of requests from unknown sources.", "The UserRateThrottle will throttle users to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.", "The allowed request rate is determined from one of the following (in order of preference).", "An API may have multiple UserRateThrottles in place at the same time. To do so, override UserRateThrottle and set a unique \"scope\" for each class.", "For example, multiple user throttle rates could be implemented by using the following classes...", "...and the following settings.", "UserRateThrottle is suitable if you want simple global rate restrictions per-user.", "The ScopedRateThrottle class can be used to restrict access to specific parts of the API. This throttle will only be applied if the view that is being accessed includes a .throttle_scope property. The unique throttle key will then be formed by concatenating the \"scope\" of the request with the unique user id or IP address.", "The allowed request rate is determined by the DEFAULT_THROTTLE_RATES setting using a key from the request \"scope\".", "For example, given the following views...", "...and the following settings.", "User requests to either ContactListView or ContactDetailView would be restricted to a total of 1000 requests per-day. User requests to UploadView would be restricted to 20 requests per day.", "To create a custom throttle, override BaseThrottle and implement .allow_request(self, request, view). The method should return True if the request should be allowed, and False otherwise.", "Optionally you may also override the .wait() method. If implemented, .wait() should return a recommended number of seconds to wait before attempting the next request, or None. The .wait() method will only be called if .allow_request() has previously returned False.", "If the .wait() method is implemented and the request is throttled, then a Retry-After header will be included in the response.", "The following is an example of a rate throttle, that will randomly throttle 1 in every 10 requests.", "throttling.py"]}, {"name": "TimeField", "path": "api-guide/fields/index#timefield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "TokenAuthentication", "path": "api-guide/authentication/index#tokenauthentication", "type": "Ref: Authentication", "text": ["Auth needs to be pluggable.", "\u2014 Jacob Kaplan-Moss, \"REST worst practices\"", "Authentication is the mechanism of associating an incoming request with a set of identifying credentials, such as the user the request came from, or the token that it was signed with. The permission and throttling policies can then use those credentials to determine if the request should be permitted.", "REST framework provides several authentication schemes out of the box, and also allows you to implement custom schemes.", "Authentication always runs at the very start of the view, before the permission and throttling checks occur, and before any other code is allowed to proceed.", "The request.user property will typically be set to an instance of the contrib.auth package's User class.", "The request.auth property is used for any additional authentication information, for example, it may be used to represent an authentication token that the request was signed with.", "Note: Don't forget that authentication by itself won't allow or disallow an incoming request, it simply identifies the credentials that the request was made with.", "For information on how to set up the permission policies for your API please see the permissions documentation.", "The authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set request.user and request.auth using the return value of the first class that successfully authenticates.", "If no class authenticates, request.user will be set to an instance of django.contrib.auth.models.AnonymousUser, and request.auth will be set to None.", "The value of request.user and request.auth for unauthenticated requests can be modified using the UNAUTHENTICATED_USER and UNAUTHENTICATED_TOKEN settings.", "The default authentication schemes may be set globally, using the DEFAULT_AUTHENTICATION_CLASSES setting. For example.", "You can also set the authentication scheme on a per-view or per-viewset basis, using the APIView class-based views.", "Or, if you're using the @api_view decorator with function based views.", "When an unauthenticated request is denied permission there are two different error codes that may be appropriate.", "HTTP 401 responses must always include a WWW-Authenticate header, that instructs the client how to authenticate. HTTP 403 responses do not include the WWW-Authenticate header.", "The kind of response that will be used depends on the authentication scheme. Although multiple authentication schemes may be in use, only one scheme may be used to determine the type of response. The first authentication class set on the view is used when determining the type of response.", "Note that when a request may successfully authenticate, but still be denied permission to perform the request, in which case a 403 Permission Denied response will always be used, regardless of the authentication scheme.", "Note that if deploying to Apache using mod_wsgi, the authorization header is not passed through to a WSGI application by default, as it is assumed that authentication will be handled by Apache, rather than at an application level.", "If you are deploying to Apache, and using any non-session based authentication, you will need to explicitly configure mod_wsgi to pass the required headers through to the application. This can be done by specifying the WSGIPassAuthorization directive in the appropriate context and setting it to 'On'.", "This authentication scheme uses HTTP Basic Authentication, signed against a user's username and password. Basic authentication is generally only appropriate for testing.", "If successfully authenticated, BasicAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "Note: If you use BasicAuthentication in production you must ensure that your API is only available over https. You should also ensure that your API clients will always re-request the username and password at login, and will never store those details to persistent storage.", "This authentication scheme uses a simple token-based HTTP Authentication scheme. Token authentication is appropriate for client-server setups, such as native desktop and mobile clients.", "To use the TokenAuthentication scheme you'll need to configure the authentication classes to include TokenAuthentication, and additionally include rest_framework.authtoken in your INSTALLED_APPS setting:", "Note: Make sure to run manage.py migrate after changing your settings. The rest_framework.authtoken app provides Django database migrations.", "You'll also need to create tokens for your users.", "For clients to authenticate, the token key should be included in the Authorization HTTP header. The key should be prefixed by the string literal \"Token\", with whitespace separating the two strings. For example:", "Note: If you want to use a different keyword in the header, such as Bearer, simply subclass TokenAuthentication and set the keyword class variable.", "If successfully authenticated, TokenAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header. For example:", "The curl command line tool may be useful for testing token authenticated APIs. For example:", "Note: If you use TokenAuthentication in production you must ensure that your API is only available over https.", "If you want every user to have an automatically generated Token, you can simply catch the User's post_save signal.", "Note that you'll want to ensure you place this code snippet in an installed models.py module, or some other location that will be imported by Django on startup.", "If you've already created some users, you can generate tokens for all existing users like this:", "When using TokenAuthentication, you may want to provide a mechanism for clients to obtain a token given the username and password. REST framework provides a built-in view to provide this behaviour. To use it, add the obtain_auth_token view to your URLconf:", "Note that the URL part of the pattern can be whatever you want to use.", "The obtain_auth_token view will return a JSON response when valid username and password fields are POSTed to the view using form data or JSON:", "Note that the default obtain_auth_token view explicitly uses JSON requests and responses, rather than using default renderer and parser classes in your settings.", "By default, there are no permissions or throttling applied to the obtain_auth_token view. If you do wish to apply to throttle you'll need to override the view class, and include them using the throttle_classes attribute.", "If you need a customized version of the obtain_auth_token view, you can do so by subclassing the ObtainAuthToken view class, and using that in your url conf instead.", "For example, you may return additional user information beyond the token value:", "And in your urls.py:", "It is also possible to create Tokens manually through the admin interface. In case you are using a large user base, we recommend that you monkey patch the TokenAdmin class customize it to your needs, more specifically by declaring the user field as raw_field.", "your_app/admin.py:", "Since version 3.6.4 it's possible to generate a user token using the following command:", "this command will return the API token for the given user, creating it if it doesn't exist:", "In case you want to regenerate the token (for example if it has been compromised or leaked) you can pass an additional parameter:", "This authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website.", "If successfully authenticated, SessionAuthentication provides the following credentials.", "Unauthenticated responses that are denied permission will result in an HTTP 403 Forbidden response.", "If you're using an AJAX-style API with SessionAuthentication, you'll need to make sure you include a valid CSRF token for any \"unsafe\" HTTP method calls, such as PUT, PATCH, POST or DELETE requests. See the Django CSRF documentation for more details.", "Warning: Always use Django's standard login view when creating login pages. This will ensure your login views are properly protected.", "CSRF validation in REST framework works slightly differently from standard Django due to the need to support both session and non-session based authentication to the same views. This means that only authenticated requests require CSRF tokens, and anonymous requests may be sent without CSRF tokens. This behaviour is not suitable for login views, which should always have CSRF validation applied.", "This authentication scheme allows you to delegate authentication to your web server, which sets the REMOTE_USER environment variable.", "To use it, you must have django.contrib.auth.backends.RemoteUserBackend (or a subclass) in your AUTHENTICATION_BACKENDS setting. By default, RemoteUserBackend creates User objects for usernames that don't already exist. To change this and other behaviour, consult the Django documentation.", "If successfully authenticated, RemoteUserAuthentication provides the following credentials:", "Consult your web server's documentation for information about configuring an authentication method, e.g.:", "To implement a custom authentication scheme, subclass BaseAuthentication and override the .authenticate(self, request) method. The method should return a two-tuple of (user, auth) if authentication succeeds, or None otherwise.", "In some circumstances instead of returning None, you may want to raise an AuthenticationFailed exception from the .authenticate() method.", "Typically the approach you should take is:", "You may also override the .authenticate_header(self, request) method. If implemented, it should return a string that will be used as the value of the WWW-Authenticate header in a HTTP 401 Unauthorized response.", "If the .authenticate_header() method is not overridden, the authentication scheme will return HTTP 403 Forbidden responses when an unauthenticated request is denied access.", "Note: When your custom authenticator is invoked by the request object's .user or .auth properties, you may see an AttributeError re-raised as a WrappedAttributeError. This is necessary to prevent the original exception from being suppressed by the outer property access. Python will not recognize that the AttributeError originates from your custom authenticator and will instead assume that the request object does not have a .user or .auth property. These errors should be fixed or otherwise handled by your authenticator.", "The following example will authenticate any incoming request as the user given by the username in a custom request header named 'X-USERNAME'.", "The following third-party packages are also available.", "The Django OAuth Toolkit package provides OAuth 2.0 support and works with Python 3.4+. The package is maintained by jazzband and uses the excellent OAuthLib. The package is well documented, and well supported and is currently our recommended package for OAuth 2.0 support.", "Install using pip.", "Add the package to your INSTALLED_APPS and modify your REST framework settings.", "For more details see the Django REST framework - Getting started documentation.", "The Django REST framework OAuth package provides both OAuth1 and OAuth2 support for REST framework.", "This package was previously included directly in the REST framework but is now supported and maintained as a third-party package.", "Install the package using pip.", "For details on configuration and usage see the Django REST framework OAuth documentation for authentication and permissions.", "JSON Web Token is a fairly new standard which can be used for token-based authentication. Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn't need to use a database to validate a token. A package for JWT authentication is djangorestframework-simplejwt which provides some features as well as a pluggable token blacklist app.", "The HawkREST library builds on the Mohawk library to let you work with Hawk signed requests and responses in your API. Hawk lets two parties securely communicate with each other using messages signed by a shared key. It is based on HTTP MAC access authentication (which was based on parts of OAuth 1.0).", "HTTP Signature (currently a IETF draft) provides a way to achieve origin authentication and message integrity for HTTP messages. Similar to Amazon's HTTP Signature scheme, used by many of its services, it permits stateless, per-request authentication. Elvio Toccalino maintains the djangorestframework-httpsignature (outdated) package which provides an easy to use HTTP Signature Authentication mechanism. You can use the updated fork version of djangorestframework-httpsignature, which is drf-httpsig.", "Djoser library provides a set of views to handle basic actions such as registration, login, logout, password reset and account activation. The package works with a custom user model and uses token-based authentication. This is ready to use REST implementation of the Django authentication system.", "This library provides a set of REST API endpoints for registration, authentication (including social media authentication), password reset, retrieve and update user details, etc. By having these API endpoints, your client apps such as AngularJS, iOS, Android, and others can communicate to your Django backend site independently via REST APIs for user management.", "There are currently two forks of this project.", "Django-rest-framework-social-oauth2 library provides an easy way to integrate social plugins (facebook, twitter, google, etc.) to your authentication system and an easy oauth2 setup. With this library, you will be able to authenticate users based on external tokens (e.g. facebook access token), convert these tokens to \"in-house\" oauth2 tokens and use and generate oauth2 tokens to authenticate your users.", "Django-rest-knox library provides models and views to handle token-based authentication in a more secure and extensible way than the built-in TokenAuthentication scheme - with Single Page Applications and Mobile clients in mind. It provides per-client tokens, and views to generate them when provided some other authentication (usually basic authentication), to delete the token (providing a server enforced logout) and to delete all tokens (logs out all clients that a user is logged into).", "drfpasswordless adds (Medium, Square Cash inspired) passwordless support to Django REST Framework's TokenAuthentication scheme. Users log in and sign up with a token sent to a contact point like an email address or a mobile number.", "django-rest-authemail provides a RESTful API interface for user signup and authentication. Email addresses are used for authentication, rather than usernames. API endpoints are available for signup, signup email verification, login, logout, password reset, password reset verification, email change, email change verification, password change, and user detail. A fully functional example project and detailed instructions are included.", "Django-Rest-Durin is built with the idea to have one library that does token auth for multiple Web/CLI/Mobile API clients via one interface but allows different token configuration for each API Client that consumes the API. It provides support for multiple tokens per user via custom models, views, permissions that work with Django-Rest-Framework. The token expiration time can be different per API client and is customizable via the Django Admin Interface.", "More information can be found in the Documentation.", "authentication.py"]}, {"name": "UniqueForDateValidator", "path": "api-guide/validators/index#uniquefordatevalidator", "type": "Ref: Validators", "text": ["Validators can be useful for re-using validation logic between different types of fields.", "\u2014 Django documentation", "Most of the time you're dealing with validation in REST framework you'll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes.", "However, sometimes you'll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.", "Validation in Django REST framework serializers is handled a little differently to how validation works in Django's ModelForm class.", "With ModelForm the validation is performed partially on the form, and partially on the model instance. With REST framework the validation is performed entirely on the serializer class. This is advantageous for the following reasons:", "When you're using ModelSerializer all of this is handled automatically for you. If you want to drop down to using Serializer classes instead, then you need to define the validation rules explicitly.", "As an example of how REST framework uses explicit validation, we'll take a simple model class that has a field with a uniqueness constraint.", "Here's a basic ModelSerializer that we can use for creating or updating instances of CustomerReportRecord:", "If we open up the Django shell using manage.py shell we can now", "The interesting bit here is the reference field. We can see that the uniqueness constraint is being explicitly enforced by a validator on the serializer field.", "Because of this more explicit style REST framework includes a few validator classes that are not available in core Django. These classes are detailed below.", "This validator can be used to enforce the unique=True constraint on model fields. It takes a single required argument, and an optional messages argument:", "This validator should be applied to serializer fields, like so:", "This validator can be used to enforce unique_together constraints on model instances. It has two required arguments, and a single optional messages argument:", "The validator should be applied to serializer classes, like so:", "Note: The UniqueTogetherValidator class always imposes an implicit constraint that all the fields it applies to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "These validators can be used to enforce the unique_for_date, unique_for_month and unique_for_year constraints on model instances. They take the following arguments:", "The validator should be applied to serializer classes, like so:", "The date field that is used for the validation is always required to be present on the serializer class. You can't simply rely on a model class default=..., because the value being used for the default wouldn't be generated until after the validation has run.", "There are a couple of styles you may want to use for this depending on how you want your API to behave. If you're using ModelSerializer you'll probably simply rely on the defaults that REST framework generates for you, but if you are using Serializer or simply want more explicit control, use on of the styles demonstrated below.", "If you want the date field to be writable the only thing worth noting is that you should ensure that it is always available in the input data, either by setting a default argument, or by setting required=True.", "If you want the date field to be visible, but not editable by the user, then set read_only=True and additionally set a default=... argument.", "If you want the date field to be entirely hidden from the user, then use HiddenField. This field type does not accept user input, but instead always returns its default value to the validated_data in the serializer.", "Note: The UniqueFor<Range>Validator classes impose an implicit constraint that the fields they are applied to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "Validators that are applied across multiple fields in the serializer can sometimes require a field input that should not be provided by the API client, but that is available as input to the validator.", "Two patterns that you may want to use for this sort of validation include:", "REST framework includes a couple of defaults that may be useful in this context.", "A default class that can be used to represent the current user. In order to use this, the 'request' must have been provided as part of the context dictionary when instantiating the serializer.", "A default class that can be used to only set a default argument during create operations. During updates the field is omitted.", "It takes a single argument, which is the default value or callable that should be used during create operations.", "There are some ambiguous cases where you'll need to instead handle validation explicitly, rather than relying on the default serializer classes that ModelSerializer generates.", "In these cases you may want to disable the automatically generated validators, by specifying an empty list for the serializer Meta.validators attribute.", "By default \"unique together\" validation enforces that all fields be required=True. In some cases, you might want to explicit apply required=False to one of the fields, in which case the desired behaviour of the validation is ambiguous.", "In this case you will typically need to exclude the validator from the serializer class, and instead write any validation logic explicitly, either in the .validate() method, or else in the view.", "For example:", "When applying an update to an existing instance, uniqueness validators will exclude the current instance from the uniqueness check. The current instance is available in the context of the uniqueness check, because it exists as an attribute on the serializer, having initially been passed using instance=... when instantiating the serializer.", "In the case of update operations on nested serializers there's no way of applying this exclusion, because the instance is not available.", "Again, you'll probably want to explicitly remove the validator from the serializer class, and write the code for the validation constraint explicitly, in a .validate() method, or in the view.", "If you're not sure exactly what behavior a ModelSerializer class will generate it is usually a good idea to run manage.py shell, and print an instance of the serializer, so that you can inspect the fields and validators that it automatically generates for you.", "Also keep in mind that with complex cases it can often be better to explicitly define your serializer classes, rather than relying on the default ModelSerializer behavior. This involves a little more code, but ensures that the resulting behavior is more transparent.", "You can use any of Django's existing validators, or write your own custom validators.", "A validator may be any callable that raises a serializers.ValidationError on failure.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. This is documented in the Serializer docs", "To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior.", "In some advanced cases you might want a validator to be passed the serializer field it is being used with as additional context. You can do so by setting a requires_context = True attribute on the validator. The __call__ method will then be called with the serializer_field or serializer as an additional argument.", "validators.py"]}, {"name": "UniqueForMonthValidator", "path": "api-guide/validators/index#uniqueformonthvalidator", "type": "Ref: Validators", "text": ["Validators can be useful for re-using validation logic between different types of fields.", "\u2014 Django documentation", "Most of the time you're dealing with validation in REST framework you'll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes.", "However, sometimes you'll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.", "Validation in Django REST framework serializers is handled a little differently to how validation works in Django's ModelForm class.", "With ModelForm the validation is performed partially on the form, and partially on the model instance. With REST framework the validation is performed entirely on the serializer class. This is advantageous for the following reasons:", "When you're using ModelSerializer all of this is handled automatically for you. If you want to drop down to using Serializer classes instead, then you need to define the validation rules explicitly.", "As an example of how REST framework uses explicit validation, we'll take a simple model class that has a field with a uniqueness constraint.", "Here's a basic ModelSerializer that we can use for creating or updating instances of CustomerReportRecord:", "If we open up the Django shell using manage.py shell we can now", "The interesting bit here is the reference field. We can see that the uniqueness constraint is being explicitly enforced by a validator on the serializer field.", "Because of this more explicit style REST framework includes a few validator classes that are not available in core Django. These classes are detailed below.", "This validator can be used to enforce the unique=True constraint on model fields. It takes a single required argument, and an optional messages argument:", "This validator should be applied to serializer fields, like so:", "This validator can be used to enforce unique_together constraints on model instances. It has two required arguments, and a single optional messages argument:", "The validator should be applied to serializer classes, like so:", "Note: The UniqueTogetherValidator class always imposes an implicit constraint that all the fields it applies to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "These validators can be used to enforce the unique_for_date, unique_for_month and unique_for_year constraints on model instances. They take the following arguments:", "The validator should be applied to serializer classes, like so:", "The date field that is used for the validation is always required to be present on the serializer class. You can't simply rely on a model class default=..., because the value being used for the default wouldn't be generated until after the validation has run.", "There are a couple of styles you may want to use for this depending on how you want your API to behave. If you're using ModelSerializer you'll probably simply rely on the defaults that REST framework generates for you, but if you are using Serializer or simply want more explicit control, use on of the styles demonstrated below.", "If you want the date field to be writable the only thing worth noting is that you should ensure that it is always available in the input data, either by setting a default argument, or by setting required=True.", "If you want the date field to be visible, but not editable by the user, then set read_only=True and additionally set a default=... argument.", "If you want the date field to be entirely hidden from the user, then use HiddenField. This field type does not accept user input, but instead always returns its default value to the validated_data in the serializer.", "Note: The UniqueFor<Range>Validator classes impose an implicit constraint that the fields they are applied to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "Validators that are applied across multiple fields in the serializer can sometimes require a field input that should not be provided by the API client, but that is available as input to the validator.", "Two patterns that you may want to use for this sort of validation include:", "REST framework includes a couple of defaults that may be useful in this context.", "A default class that can be used to represent the current user. In order to use this, the 'request' must have been provided as part of the context dictionary when instantiating the serializer.", "A default class that can be used to only set a default argument during create operations. During updates the field is omitted.", "It takes a single argument, which is the default value or callable that should be used during create operations.", "There are some ambiguous cases where you'll need to instead handle validation explicitly, rather than relying on the default serializer classes that ModelSerializer generates.", "In these cases you may want to disable the automatically generated validators, by specifying an empty list for the serializer Meta.validators attribute.", "By default \"unique together\" validation enforces that all fields be required=True. In some cases, you might want to explicit apply required=False to one of the fields, in which case the desired behaviour of the validation is ambiguous.", "In this case you will typically need to exclude the validator from the serializer class, and instead write any validation logic explicitly, either in the .validate() method, or else in the view.", "For example:", "When applying an update to an existing instance, uniqueness validators will exclude the current instance from the uniqueness check. The current instance is available in the context of the uniqueness check, because it exists as an attribute on the serializer, having initially been passed using instance=... when instantiating the serializer.", "In the case of update operations on nested serializers there's no way of applying this exclusion, because the instance is not available.", "Again, you'll probably want to explicitly remove the validator from the serializer class, and write the code for the validation constraint explicitly, in a .validate() method, or in the view.", "If you're not sure exactly what behavior a ModelSerializer class will generate it is usually a good idea to run manage.py shell, and print an instance of the serializer, so that you can inspect the fields and validators that it automatically generates for you.", "Also keep in mind that with complex cases it can often be better to explicitly define your serializer classes, rather than relying on the default ModelSerializer behavior. This involves a little more code, but ensures that the resulting behavior is more transparent.", "You can use any of Django's existing validators, or write your own custom validators.", "A validator may be any callable that raises a serializers.ValidationError on failure.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. This is documented in the Serializer docs", "To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior.", "In some advanced cases you might want a validator to be passed the serializer field it is being used with as additional context. You can do so by setting a requires_context = True attribute on the validator. The __call__ method will then be called with the serializer_field or serializer as an additional argument.", "validators.py"]}, {"name": "UniqueForYearValidator", "path": "api-guide/validators/index#uniqueforyearvalidator", "type": "Ref: Validators", "text": ["Validators can be useful for re-using validation logic between different types of fields.", "\u2014 Django documentation", "Most of the time you're dealing with validation in REST framework you'll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes.", "However, sometimes you'll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.", "Validation in Django REST framework serializers is handled a little differently to how validation works in Django's ModelForm class.", "With ModelForm the validation is performed partially on the form, and partially on the model instance. With REST framework the validation is performed entirely on the serializer class. This is advantageous for the following reasons:", "When you're using ModelSerializer all of this is handled automatically for you. If you want to drop down to using Serializer classes instead, then you need to define the validation rules explicitly.", "As an example of how REST framework uses explicit validation, we'll take a simple model class that has a field with a uniqueness constraint.", "Here's a basic ModelSerializer that we can use for creating or updating instances of CustomerReportRecord:", "If we open up the Django shell using manage.py shell we can now", "The interesting bit here is the reference field. We can see that the uniqueness constraint is being explicitly enforced by a validator on the serializer field.", "Because of this more explicit style REST framework includes a few validator classes that are not available in core Django. These classes are detailed below.", "This validator can be used to enforce the unique=True constraint on model fields. It takes a single required argument, and an optional messages argument:", "This validator should be applied to serializer fields, like so:", "This validator can be used to enforce unique_together constraints on model instances. It has two required arguments, and a single optional messages argument:", "The validator should be applied to serializer classes, like so:", "Note: The UniqueTogetherValidator class always imposes an implicit constraint that all the fields it applies to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "These validators can be used to enforce the unique_for_date, unique_for_month and unique_for_year constraints on model instances. They take the following arguments:", "The validator should be applied to serializer classes, like so:", "The date field that is used for the validation is always required to be present on the serializer class. You can't simply rely on a model class default=..., because the value being used for the default wouldn't be generated until after the validation has run.", "There are a couple of styles you may want to use for this depending on how you want your API to behave. If you're using ModelSerializer you'll probably simply rely on the defaults that REST framework generates for you, but if you are using Serializer or simply want more explicit control, use on of the styles demonstrated below.", "If you want the date field to be writable the only thing worth noting is that you should ensure that it is always available in the input data, either by setting a default argument, or by setting required=True.", "If you want the date field to be visible, but not editable by the user, then set read_only=True and additionally set a default=... argument.", "If you want the date field to be entirely hidden from the user, then use HiddenField. This field type does not accept user input, but instead always returns its default value to the validated_data in the serializer.", "Note: The UniqueFor<Range>Validator classes impose an implicit constraint that the fields they are applied to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "Validators that are applied across multiple fields in the serializer can sometimes require a field input that should not be provided by the API client, but that is available as input to the validator.", "Two patterns that you may want to use for this sort of validation include:", "REST framework includes a couple of defaults that may be useful in this context.", "A default class that can be used to represent the current user. In order to use this, the 'request' must have been provided as part of the context dictionary when instantiating the serializer.", "A default class that can be used to only set a default argument during create operations. During updates the field is omitted.", "It takes a single argument, which is the default value or callable that should be used during create operations.", "There are some ambiguous cases where you'll need to instead handle validation explicitly, rather than relying on the default serializer classes that ModelSerializer generates.", "In these cases you may want to disable the automatically generated validators, by specifying an empty list for the serializer Meta.validators attribute.", "By default \"unique together\" validation enforces that all fields be required=True. In some cases, you might want to explicit apply required=False to one of the fields, in which case the desired behaviour of the validation is ambiguous.", "In this case you will typically need to exclude the validator from the serializer class, and instead write any validation logic explicitly, either in the .validate() method, or else in the view.", "For example:", "When applying an update to an existing instance, uniqueness validators will exclude the current instance from the uniqueness check. The current instance is available in the context of the uniqueness check, because it exists as an attribute on the serializer, having initially been passed using instance=... when instantiating the serializer.", "In the case of update operations on nested serializers there's no way of applying this exclusion, because the instance is not available.", "Again, you'll probably want to explicitly remove the validator from the serializer class, and write the code for the validation constraint explicitly, in a .validate() method, or in the view.", "If you're not sure exactly what behavior a ModelSerializer class will generate it is usually a good idea to run manage.py shell, and print an instance of the serializer, so that you can inspect the fields and validators that it automatically generates for you.", "Also keep in mind that with complex cases it can often be better to explicitly define your serializer classes, rather than relying on the default ModelSerializer behavior. This involves a little more code, but ensures that the resulting behavior is more transparent.", "You can use any of Django's existing validators, or write your own custom validators.", "A validator may be any callable that raises a serializers.ValidationError on failure.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. This is documented in the Serializer docs", "To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior.", "In some advanced cases you might want a validator to be passed the serializer field it is being used with as additional context. You can do so by setting a requires_context = True attribute on the validator. The __call__ method will then be called with the serializer_field or serializer as an additional argument.", "validators.py"]}, {"name": "UniqueTogetherValidator", "path": "api-guide/validators/index#uniquetogethervalidator", "type": "Ref: Validators", "text": ["Validators can be useful for re-using validation logic between different types of fields.", "\u2014 Django documentation", "Most of the time you're dealing with validation in REST framework you'll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes.", "However, sometimes you'll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.", "Validation in Django REST framework serializers is handled a little differently to how validation works in Django's ModelForm class.", "With ModelForm the validation is performed partially on the form, and partially on the model instance. With REST framework the validation is performed entirely on the serializer class. This is advantageous for the following reasons:", "When you're using ModelSerializer all of this is handled automatically for you. If you want to drop down to using Serializer classes instead, then you need to define the validation rules explicitly.", "As an example of how REST framework uses explicit validation, we'll take a simple model class that has a field with a uniqueness constraint.", "Here's a basic ModelSerializer that we can use for creating or updating instances of CustomerReportRecord:", "If we open up the Django shell using manage.py shell we can now", "The interesting bit here is the reference field. We can see that the uniqueness constraint is being explicitly enforced by a validator on the serializer field.", "Because of this more explicit style REST framework includes a few validator classes that are not available in core Django. These classes are detailed below.", "This validator can be used to enforce the unique=True constraint on model fields. It takes a single required argument, and an optional messages argument:", "This validator should be applied to serializer fields, like so:", "This validator can be used to enforce unique_together constraints on model instances. It has two required arguments, and a single optional messages argument:", "The validator should be applied to serializer classes, like so:", "Note: The UniqueTogetherValidator class always imposes an implicit constraint that all the fields it applies to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "These validators can be used to enforce the unique_for_date, unique_for_month and unique_for_year constraints on model instances. They take the following arguments:", "The validator should be applied to serializer classes, like so:", "The date field that is used for the validation is always required to be present on the serializer class. You can't simply rely on a model class default=..., because the value being used for the default wouldn't be generated until after the validation has run.", "There are a couple of styles you may want to use for this depending on how you want your API to behave. If you're using ModelSerializer you'll probably simply rely on the defaults that REST framework generates for you, but if you are using Serializer or simply want more explicit control, use on of the styles demonstrated below.", "If you want the date field to be writable the only thing worth noting is that you should ensure that it is always available in the input data, either by setting a default argument, or by setting required=True.", "If you want the date field to be visible, but not editable by the user, then set read_only=True and additionally set a default=... argument.", "If you want the date field to be entirely hidden from the user, then use HiddenField. This field type does not accept user input, but instead always returns its default value to the validated_data in the serializer.", "Note: The UniqueFor<Range>Validator classes impose an implicit constraint that the fields they are applied to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "Validators that are applied across multiple fields in the serializer can sometimes require a field input that should not be provided by the API client, but that is available as input to the validator.", "Two patterns that you may want to use for this sort of validation include:", "REST framework includes a couple of defaults that may be useful in this context.", "A default class that can be used to represent the current user. In order to use this, the 'request' must have been provided as part of the context dictionary when instantiating the serializer.", "A default class that can be used to only set a default argument during create operations. During updates the field is omitted.", "It takes a single argument, which is the default value or callable that should be used during create operations.", "There are some ambiguous cases where you'll need to instead handle validation explicitly, rather than relying on the default serializer classes that ModelSerializer generates.", "In these cases you may want to disable the automatically generated validators, by specifying an empty list for the serializer Meta.validators attribute.", "By default \"unique together\" validation enforces that all fields be required=True. In some cases, you might want to explicit apply required=False to one of the fields, in which case the desired behaviour of the validation is ambiguous.", "In this case you will typically need to exclude the validator from the serializer class, and instead write any validation logic explicitly, either in the .validate() method, or else in the view.", "For example:", "When applying an update to an existing instance, uniqueness validators will exclude the current instance from the uniqueness check. The current instance is available in the context of the uniqueness check, because it exists as an attribute on the serializer, having initially been passed using instance=... when instantiating the serializer.", "In the case of update operations on nested serializers there's no way of applying this exclusion, because the instance is not available.", "Again, you'll probably want to explicitly remove the validator from the serializer class, and write the code for the validation constraint explicitly, in a .validate() method, or in the view.", "If you're not sure exactly what behavior a ModelSerializer class will generate it is usually a good idea to run manage.py shell, and print an instance of the serializer, so that you can inspect the fields and validators that it automatically generates for you.", "Also keep in mind that with complex cases it can often be better to explicitly define your serializer classes, rather than relying on the default ModelSerializer behavior. This involves a little more code, but ensures that the resulting behavior is more transparent.", "You can use any of Django's existing validators, or write your own custom validators.", "A validator may be any callable that raises a serializers.ValidationError on failure.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. This is documented in the Serializer docs", "To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior.", "In some advanced cases you might want a validator to be passed the serializer field it is being used with as additional context. You can do so by setting a requires_context = True attribute on the validator. The __call__ method will then be called with the serializer_field or serializer as an additional argument.", "validators.py"]}, {"name": "UniqueValidator", "path": "api-guide/validators/index#uniquevalidator", "type": "Ref: Validators", "text": ["Validators can be useful for re-using validation logic between different types of fields.", "\u2014 Django documentation", "Most of the time you're dealing with validation in REST framework you'll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes.", "However, sometimes you'll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.", "Validation in Django REST framework serializers is handled a little differently to how validation works in Django's ModelForm class.", "With ModelForm the validation is performed partially on the form, and partially on the model instance. With REST framework the validation is performed entirely on the serializer class. This is advantageous for the following reasons:", "When you're using ModelSerializer all of this is handled automatically for you. If you want to drop down to using Serializer classes instead, then you need to define the validation rules explicitly.", "As an example of how REST framework uses explicit validation, we'll take a simple model class that has a field with a uniqueness constraint.", "Here's a basic ModelSerializer that we can use for creating or updating instances of CustomerReportRecord:", "If we open up the Django shell using manage.py shell we can now", "The interesting bit here is the reference field. We can see that the uniqueness constraint is being explicitly enforced by a validator on the serializer field.", "Because of this more explicit style REST framework includes a few validator classes that are not available in core Django. These classes are detailed below.", "This validator can be used to enforce the unique=True constraint on model fields. It takes a single required argument, and an optional messages argument:", "This validator should be applied to serializer fields, like so:", "This validator can be used to enforce unique_together constraints on model instances. It has two required arguments, and a single optional messages argument:", "The validator should be applied to serializer classes, like so:", "Note: The UniqueTogetherValidator class always imposes an implicit constraint that all the fields it applies to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "These validators can be used to enforce the unique_for_date, unique_for_month and unique_for_year constraints on model instances. They take the following arguments:", "The validator should be applied to serializer classes, like so:", "The date field that is used for the validation is always required to be present on the serializer class. You can't simply rely on a model class default=..., because the value being used for the default wouldn't be generated until after the validation has run.", "There are a couple of styles you may want to use for this depending on how you want your API to behave. If you're using ModelSerializer you'll probably simply rely on the defaults that REST framework generates for you, but if you are using Serializer or simply want more explicit control, use on of the styles demonstrated below.", "If you want the date field to be writable the only thing worth noting is that you should ensure that it is always available in the input data, either by setting a default argument, or by setting required=True.", "If you want the date field to be visible, but not editable by the user, then set read_only=True and additionally set a default=... argument.", "If you want the date field to be entirely hidden from the user, then use HiddenField. This field type does not accept user input, but instead always returns its default value to the validated_data in the serializer.", "Note: The UniqueFor<Range>Validator classes impose an implicit constraint that the fields they are applied to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "Validators that are applied across multiple fields in the serializer can sometimes require a field input that should not be provided by the API client, but that is available as input to the validator.", "Two patterns that you may want to use for this sort of validation include:", "REST framework includes a couple of defaults that may be useful in this context.", "A default class that can be used to represent the current user. In order to use this, the 'request' must have been provided as part of the context dictionary when instantiating the serializer.", "A default class that can be used to only set a default argument during create operations. During updates the field is omitted.", "It takes a single argument, which is the default value or callable that should be used during create operations.", "There are some ambiguous cases where you'll need to instead handle validation explicitly, rather than relying on the default serializer classes that ModelSerializer generates.", "In these cases you may want to disable the automatically generated validators, by specifying an empty list for the serializer Meta.validators attribute.", "By default \"unique together\" validation enforces that all fields be required=True. In some cases, you might want to explicit apply required=False to one of the fields, in which case the desired behaviour of the validation is ambiguous.", "In this case you will typically need to exclude the validator from the serializer class, and instead write any validation logic explicitly, either in the .validate() method, or else in the view.", "For example:", "When applying an update to an existing instance, uniqueness validators will exclude the current instance from the uniqueness check. The current instance is available in the context of the uniqueness check, because it exists as an attribute on the serializer, having initially been passed using instance=... when instantiating the serializer.", "In the case of update operations on nested serializers there's no way of applying this exclusion, because the instance is not available.", "Again, you'll probably want to explicitly remove the validator from the serializer class, and write the code for the validation constraint explicitly, in a .validate() method, or in the view.", "If you're not sure exactly what behavior a ModelSerializer class will generate it is usually a good idea to run manage.py shell, and print an instance of the serializer, so that you can inspect the fields and validators that it automatically generates for you.", "Also keep in mind that with complex cases it can often be better to explicitly define your serializer classes, rather than relying on the default ModelSerializer behavior. This involves a little more code, but ensures that the resulting behavior is more transparent.", "You can use any of Django's existing validators, or write your own custom validators.", "A validator may be any callable that raises a serializers.ValidationError on failure.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. This is documented in the Serializer docs", "To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior.", "In some advanced cases you might want a validator to be passed the serializer field it is being used with as additional context. You can do so by setting a requires_context = True attribute on the validator. The __call__ method will then be called with the serializer_field or serializer as an additional argument.", "validators.py"]}, {"name": "UnsupportedMediaType", "path": "api-guide/exceptions/index#unsupportedmediatype", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "UpdateAPIView", "path": "api-guide/generic-views/index#updateapiview", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "UpdateModelMixin", "path": "api-guide/generic-views/index#updatemodelmixin", "type": "Ref: Generic views", "text": ["Django\u2019s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.", "\u2014 Django Documentation", "One of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.", "The generic views provided by REST framework allow you to quickly build API views that map closely to your database models.", "If the generic views don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.", "Typically when using the generic views, you'll override the view, and set several class attributes.", "For more complex cases you might also want to override various methods on the view class. For example.", "For very simple cases you might want to pass through any class attributes using the .as_view() method. For example, your URLconf might include something like the following entry:", "This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views.", "Each of the concrete generic views provided is built by combining GenericAPIView, with one or more mixin classes.", "Basic settings:", "The following attributes control the basic view behavior.", "Pagination:", "The following attributes are used to control pagination when used with list views.", "Filtering:", "Base methods:", "Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the queryset attribute.", "This method should always be used rather than accessing self.queryset directly, as self.queryset gets evaluated only once, and those results are cached for all subsequent requests.", "May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.", "For example:", "Returns an object instance that should be used for detail views. Defaults to using the lookup_field parameter to filter the base queryset.", "May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.", "For example:", "Note that if your API doesn't include any object level permissions, you may optionally exclude the self.check_object_permissions, and simply return the object from the get_object_or_404 lookup.", "Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.", "For example:", "Returns the class that should be used for the serializer. Defaults to returning the serializer_class attribute.", "May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.", "For example:", "Save and deletion hooks:", "The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.", "These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.", "These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.", "You can also use these hooks to provide additional validation, by raising a ValidationError(). This can be useful if you need some validation logic to apply at the point of database save. For example:", "Other methods:", "You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using GenericAPIView.", "The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as .get() and .post(), directly. This allows for more flexible composition of behavior.", "The mixin classes can be imported from rest_framework.mixins.", "Provides a .list(request, *args, **kwargs) method, that implements listing a queryset.", "If the queryset is populated, this returns a 200 OK response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.", "Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance.", "If an object is created this returns a 201 Created response, with a serialized representation of the object as the body of the response. If the representation contains a key named url, then the Location header of the response will be populated with that value.", "If the request data provided for creating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response.", "If an object can be retrieved this returns a 200 OK response, with a serialized representation of the object as the body of the response. Otherwise it will return a 404 Not Found.", "Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance.", "Also provides a .partial_update(request, *args, **kwargs) method, which is similar to the update method, except that all fields for the update will be optional. This allows support for HTTP PATCH requests.", "If an object is updated this returns a 200 OK response, with a serialized representation of the object as the body of the response.", "If the request data provided for updating the object was invalid, a 400 Bad Request response will be returned, with the error details as the body of the response.", "Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance.", "If an object is deleted this returns a 204 No Content response, otherwise it will return a 404 Not Found.", "The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.", "The view classes can be imported from rest_framework.generics.", "Used for create-only endpoints.", "Provides a post method handler.", "Extends: GenericAPIView, CreateModelMixin", "Used for read-only endpoints to represent a collection of model instances.", "Provides a get method handler.", "Extends: GenericAPIView, ListModelMixin", "Used for read-only endpoints to represent a single model instance.", "Provides a get method handler.", "Extends: GenericAPIView, RetrieveModelMixin", "Used for delete-only endpoints for a single model instance.", "Provides a delete method handler.", "Extends: GenericAPIView, DestroyModelMixin", "Used for update-only endpoints for a single model instance.", "Provides put and patch method handlers.", "Extends: GenericAPIView, UpdateModelMixin", "Used for read-write endpoints to represent a collection of model instances.", "Provides get and post method handlers.", "Extends: GenericAPIView, ListModelMixin, CreateModelMixin", "Used for read or update endpoints to represent a single model instance.", "Provides get, put and patch method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin", "Used for read or delete endpoints to represent a single model instance.", "Provides get and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, DestroyModelMixin", "Used for read-write-delete endpoints to represent a single model instance.", "Provides get, put, patch and delete method handlers.", "Extends: GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin", "Often you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.", "For example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:", "You can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.", "Using custom mixins is a good option if you have custom behavior that needs to be used.", "If you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:", "Using custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.", "Prior to version 3.0 the REST framework mixins treated PUT as either an update or a create operation, depending on if the object already existed or not.", "Allowing PUT as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning 404 responses.", "Both styles \"PUT as 404\" and \"PUT as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.", "If you need to generic PUT-as-create behavior you may want to include something like this AllowPUTAsCreateMixin class as a mixin to your views.", "The following third party packages provide additional generic view implementations.", "Django Rest Multiple Models provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.", "mixins.pygenerics.py"]}, {"name": "URLField", "path": "api-guide/fields/index#urlfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "URLPathVersioning", "path": "api-guide/versioning/index#urlpathversioning", "type": "Ref: Versioning", "text": ["Versioning an interface is just a \"polite\" way to kill deployed clients.", "\u2014 Roy Fielding.", "API versioning allows you to alter behavior between different clients. REST framework provides for a number of different versioning schemes.", "Versioning is determined by the incoming client request, and may either be based on the request URL, or based on the request headers.", "There are a number of valid approaches to approaching versioning. Non-versioned systems can also be appropriate, particularly if you're engineering for very long-term systems with multiple clients outside of your control.", "When API versioning is enabled, the request.version attribute will contain a string that corresponds to the version requested in the incoming client request.", "By default, versioning is not enabled, and request.version will always return None.", "How you vary the API behavior is up to you, but one example you might typically want is to switch to a different serialization style in a newer version. For example:", "The reverse function included by REST framework ties in with the versioning scheme. You need to make sure to include the current request as a keyword argument, like so.", "The above function will apply any URL transformations appropriate to the request version. For example:", "When using hyperlinked serialization styles together with a URL based versioning scheme make sure to include the request as context to the serializer.", "Doing so will allow any returned URLs to include the appropriate versioning.", "The versioning scheme is defined by the DEFAULT_VERSIONING_CLASS settings key.", "Unless it is explicitly set, the value for DEFAULT_VERSIONING_CLASS will be None. In this case the request.version attribute will always return None.", "You can also set the versioning scheme on an individual view. Typically you won't need to do this, as it makes more sense to have a single versioning scheme used globally. If you do need to do so, use the versioning_class attribute.", "The following settings keys are also used to control versioning:", "You can also set your versioning class plus those three values on a per-view or a per-viewset basis by defining your own versioning scheme and using the default_version, allowed_versions and version_param class variables. For example, if you want to use URLPathVersioning:", "This scheme requires the client to specify the version as part of the media type in the Accept header. The version is included as a media type parameter, that supplements the main media type.", "Here's an example HTTP request using the accept header versioning style.", "In the example request above request.version attribute would return the string '1.0'.", "Versioning based on accept headers is generally considered as best practice, although other styles may be suitable depending on your client requirements.", "Strictly speaking the json media type is not specified as including additional parameters. If you are building a well-specified public API you might consider using a vendor media type. To do so, configure your renderers to use a JSON based renderer with a custom media type:", "Your client requests would now look like this:", "This scheme requires the client to specify the version as part of the URL path.", "Your URL conf must include a pattern that matches the version with a 'version' keyword argument, so that this information is available to the versioning scheme.", "To the client, this scheme is the same as URLPathVersioning. The only difference is how it is configured in your Django application, as it uses URL namespacing, instead of URL keyword arguments.", "With this scheme the request.version attribute is determined based on the namespace that matches the incoming request path.", "In the following example we're giving a set of views two different possible URL prefixes, each under a different namespace:", "Both URLPathVersioning and NamespaceVersioning are reasonable if you just need a simple versioning scheme. The URLPathVersioning approach might be better suitable for small ad-hoc projects, and the NamespaceVersioning is probably easier to manage for larger projects.", "The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.", "For example the following is an HTTP request to the http://v1.example.com/bookings/ URL:", "By default this implementation expects the hostname to match this simple regular expression:", "Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.", "The HostNameVersioning scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as 127.0.0.1. There are various online tutorials on how to access localhost with a custom subdomain which you may find helpful in this case.", "Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.", "This scheme is a simple style that includes the version as a query parameter in the URL. For example:", "To implement a custom versioning scheme, subclass BaseVersioning and override the .determine_version method.", "The following example uses a custom X-API-Version header to determine the requested version.", "If your versioning scheme is based on the request URL, you will also want to alter how versioned URLs are determined. In order to do so you should override the .reverse() method on the class. See the source code for examples.", "versioning.py"]}, {"name": "UserRateThrottle", "path": "api-guide/throttling/index#userratethrottle", "type": "Ref: Throttling", "text": ["HTTP/1.1 420 Enhance Your Calm", "Twitter API rate limiting response", "Throttling is similar to permissions, in that it determines if a request should be authorized. Throttles indicate a temporary state, and are used to control the rate of requests that clients can make to an API.", "As with permissions, multiple throttles may be used. Your API might have a restrictive throttle for unauthenticated requests, and a less restrictive throttle for authenticated requests.", "Another scenario where you might want to use multiple throttles would be if you need to impose different constraints on different parts of the API, due to some services being particularly resource-intensive.", "Multiple throttles can also be used if you want to impose both burst throttling rates, and sustained throttling rates. For example, you might want to limit a user to a maximum of 60 requests per minute, and 1000 requests per day.", "Throttles do not necessarily only refer to rate-limiting requests. For example a storage service might also need to throttle against bandwidth, and a paid data service might want to throttle against a certain number of a records being accessed.", "As with permissions and authentication, throttling in REST framework is always defined as a list of classes.", "Before running the main body of the view each throttle in the list is checked. If any throttle check fails an exceptions.Throttled exception will be raised, and the main body of the view will not run.", "The default throttling policy may be set globally, using the DEFAULT_THROTTLE_CLASSES and DEFAULT_THROTTLE_RATES settings. For example.", "The rate descriptions used in DEFAULT_THROTTLE_RATES may include second, minute, hour or day as the throttle period.", "You can also set the throttling policy on a per-view or per-viewset basis, using the APIView class-based views.", "If you're using the @api_view decorator with function based views you can use the following decorator.", "It's also possible to set throttle classes for routes that are created using the @action decorator. Throttle classes set in this way will override any viewset level class settings.", "The X-Forwarded-For HTTP header and REMOTE_ADDR WSGI variable are used to uniquely identify client IP addresses for throttling. If the X-Forwarded-For header is present then it will be used, otherwise the value of the REMOTE_ADDR variable from the WSGI environment will be used.", "If you need to strictly identify unique client IP addresses, you'll need to first configure the number of application proxies that the API runs behind by setting the NUM_PROXIES setting. This setting should be an integer of zero or more. If set to non-zero then the client IP will be identified as being the last IP address in the X-Forwarded-For header, once any application proxy IP addresses have first been excluded. If set to zero, then the REMOTE_ADDR value will always be used as the identifying IP address.", "It is important to understand that if you configure the NUM_PROXIES setting, then all clients behind a unique NAT'd gateway will be treated as a single client.", "Further context on how the X-Forwarded-For header works, and identifying a remote client IP can be found here.", "The throttle classes provided by REST framework use Django's cache backend. You should make sure that you've set appropriate cache settings. The default value of LocMemCache backend should be okay for simple setups. See Django's cache documentation for more details.", "If you need to use a cache other than 'default', you can do so by creating a custom throttle class and setting the cache attribute. For example:", "You'll need to remember to also set your custom throttle class in the 'DEFAULT_THROTTLE_CLASSES' settings key, or using the throttle_classes view attribute.", "The AnonRateThrottle will only ever throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.", "The allowed request rate is determined from one of the following (in order of preference).", "AnonRateThrottle is suitable if you want to restrict the rate of requests from unknown sources.", "The UserRateThrottle will throttle users to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.", "The allowed request rate is determined from one of the following (in order of preference).", "An API may have multiple UserRateThrottles in place at the same time. To do so, override UserRateThrottle and set a unique \"scope\" for each class.", "For example, multiple user throttle rates could be implemented by using the following classes...", "...and the following settings.", "UserRateThrottle is suitable if you want simple global rate restrictions per-user.", "The ScopedRateThrottle class can be used to restrict access to specific parts of the API. This throttle will only be applied if the view that is being accessed includes a .throttle_scope property. The unique throttle key will then be formed by concatenating the \"scope\" of the request with the unique user id or IP address.", "The allowed request rate is determined by the DEFAULT_THROTTLE_RATES setting using a key from the request \"scope\".", "For example, given the following views...", "...and the following settings.", "User requests to either ContactListView or ContactDetailView would be restricted to a total of 1000 requests per-day. User requests to UploadView would be restricted to 20 requests per day.", "To create a custom throttle, override BaseThrottle and implement .allow_request(self, request, view). The method should return True if the request should be allowed, and False otherwise.", "Optionally you may also override the .wait() method. If implemented, .wait() should return a recommended number of seconds to wait before attempting the next request, or None. The .wait() method will only be called if .allow_request() has previously returned False.", "If the .wait() method is implemented and the request is throttled, then a Retry-After header will be included in the response.", "The following is an example of a rate throttle, that will randomly throttle 1 in every 10 requests.", "throttling.py"]}, {"name": "UUIDField", "path": "api-guide/fields/index#uuidfield", "type": "Ref: Serializer fields", "text": ["Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it \u2014 normalizing it to a consistent format.", "\u2014 Django documentation", "Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.", "Note: The serializer fields are declared in fields.py, but by convention you should import them using from rest_framework import serializers and refer to fields as serializers.<FieldName>.", "Each serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:", "Read-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.", "Set this to True to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.", "Defaults to False", "Set this to True to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.", "Defaults to False", "Normally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.", "Setting this to False also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.", "Defaults to True.", "If set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behaviour is to not populate the attribute at all.", "The default is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.", "May be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a requires_context = True attribute, then the serializer field will be passed as an argument.", "For example:", "When serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.", "Note that setting a default value implies that the field is not required. Including both the default and required keyword arguments is invalid and will raise an error.", "Normally an error will be raised if None is passed to a serializer field. Set this keyword argument to True if None should be considered a valid value.", "Note that, without an explicit default, setting this argument to True will imply a default value of null for serialization output, but does not imply a default for input deserialization.", "Defaults to False", "The name of the attribute that will be used to populate the field. May be a method that only takes a self argument, such as URLField(source='get_absolute_url'), or may use dotted notation to traverse attributes, such as EmailField(source='user.email'). When serializing fields with dotted notation, it may be necessary to provide a default value if any object is not present or is empty during attribute traversal.", "The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.", "Defaults to the name of the field.", "A list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise serializers.ValidationError, but Django's built-in ValidationError is also supported for compatibility with validators defined in the Django codebase or third party Django packages.", "A dictionary of error codes to error messages.", "A short text string that may be used as the name of the field in HTML form fields or other descriptive elements.", "A text string that may be used as a description of the field in HTML form fields or other descriptive elements.", "A value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django Field:", "A dictionary of key-value pairs that can be used to control how renderers should render the field.", "Two examples here are 'input_type' and 'base_template':", "For more details see the HTML & Forms documentation.", "A boolean representation.", "When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to False, even if it has a default=True option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.", "Note that Django 2.1 removed the blank kwarg from models.BooleanField. Prior to Django 2.1 models.BooleanField fields were always blank=True. Thus since Django 2.1 default serializers.BooleanField instances will be generated without the required kwarg (i.e. equivalent to required=True) whereas with previous versions of Django, default BooleanField instances will be generated with a required=False option. If you want to control this behaviour manually, explicitly declare the BooleanField on the serializer class, or use the extra_kwargs option to set the required flag.", "Corresponds to django.db.models.fields.BooleanField.", "Signature: BooleanField()", "A boolean representation that also accepts None as a valid value.", "Corresponds to django.db.models.fields.NullBooleanField.", "Signature: NullBooleanField()", "A text representation. Optionally validates the text to be shorter than max_length and longer than min_length.", "Corresponds to django.db.models.fields.CharField or django.db.models.fields.TextField.", "Signature: CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)", "The allow_null option is also available for string fields, although its usage is discouraged in favor of allow_blank. It is valid to set both allow_blank=True and allow_null=True, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.", "A text representation, validates the text to be a valid e-mail address.", "Corresponds to django.db.models.fields.EmailField", "Signature: EmailField(max_length=None, min_length=None, allow_blank=False)", "A text representation, that validates the given value matches against a certain regular expression.", "Corresponds to django.forms.fields.RegexField.", "Signature: RegexField(regex, max_length=None, min_length=None, allow_blank=False)", "The mandatory regex argument may either be a string, or a compiled python regular expression object.", "Uses Django's django.core.validators.RegexValidator for validation.", "A RegexField that validates the input against the pattern [a-zA-Z0-9_-]+.", "Corresponds to django.db.models.fields.SlugField.", "Signature: SlugField(max_length=50, min_length=None, allow_blank=False)", "A RegexField that validates the input against a URL matching pattern. Expects fully qualified URLs of the form http://<host>/<path>.", "Corresponds to django.db.models.fields.URLField. Uses Django's django.core.validators.URLValidator for validation.", "Signature: URLField(max_length=200, min_length=None, allow_blank=False)", "A field that ensures the input is a valid UUID string. The to_internal_value method will return a uuid.UUID instance. On output the field will return a string in the canonical hyphenated format, for example:", "Signature: UUIDField(format='hex_verbose')", "A field whose choices are limited to the filenames in a certain directory on the filesystem", "Corresponds to django.forms.fields.FilePathField.", "Signature: FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)", "A field that ensures the input is a valid IPv4 or IPv6 string.", "Corresponds to django.forms.fields.IPAddressField and django.forms.fields.GenericIPAddressField.", "Signature: IPAddressField(protocol='both', unpack_ipv4=False, **options)", "An integer representation.", "Corresponds to django.db.models.fields.IntegerField, django.db.models.fields.SmallIntegerField, django.db.models.fields.PositiveIntegerField and django.db.models.fields.PositiveSmallIntegerField.", "Signature: IntegerField(max_value=None, min_value=None)", "A floating point representation.", "Corresponds to django.db.models.fields.FloatField.", "Signature: FloatField(max_value=None, min_value=None)", "A decimal representation, represented in Python by a Decimal instance.", "Corresponds to django.db.models.fields.DecimalField.", "Signature: DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)", "To validate numbers up to 999 with a resolution of 2 decimal places, you would use:", "And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:", "This field also takes an optional argument, coerce_to_string. If set to True the representation will be output as a string. If set to False the representation will be left as a Decimal instance and the final representation will be determined by the renderer.", "If unset, this will default to the same value as the COERCE_DECIMAL_TO_STRING setting, which is True unless set otherwise.", "A date and time representation.", "Corresponds to django.db.models.fields.DateTimeField.", "Signature: DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style datetimes should be used. (eg '2013-01-29T12:34:56.000000Z')", "When a value of None is used for the format datetime objects will be returned by to_representation and the final output representation will determined by the renderer class.", "When using ModelSerializer or HyperlinkedModelSerializer, note that any model fields with auto_now=True or auto_now_add=True will use serializer fields that are read_only=True by default.", "If you want to override this behavior, you'll need to declare the DateTimeField explicitly on the serializer. For example:", "A date representation.", "Corresponds to django.db.models.fields.DateField", "Signature: DateField(format=api_settings.DATE_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style dates should be used. (eg '2013-01-29')", "A time representation.", "Corresponds to django.db.models.fields.TimeField", "Signature: TimeField(format=api_settings.TIME_FORMAT, input_formats=None)", "Format strings may either be Python strftime formats which explicitly specify the format, or the special string 'iso-8601', which indicates that ISO 8601 style times should be used. (eg '12:34:56.000000')", "A Duration representation. Corresponds to django.db.models.fields.DurationField", "The validated_data for these fields will contain a datetime.timedelta instance. The representation is a string following this format '[DD] [HH:[MM:]]ss[.uuuuuu]'.", "Signature: DurationField(max_value=None, min_value=None)", "A field that can accept a value out of a limited set of choices.", "Used by ModelSerializer to automatically generate fields if the corresponding model field includes a choices=\u2026 argument.", "Signature: ChoiceField(choices)", "Both the allow_blank and allow_null are valid options on ChoiceField, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. to_internal_value returns a set containing the selected values.", "Signature: MultipleChoiceField(choices)", "As with ChoiceField, both the allow_blank and allow_null options are valid, although it is highly recommended that you only use one and not both. allow_blank should be preferred for textual choices, and allow_null should be preferred for numeric or other non-textual choices.", "The FileField and ImageField classes are only suitable for use with MultiPartParser or FileUploadParser. Most parsers, such as e.g. JSON don't support file uploads. Django's regular FILE_UPLOAD_HANDLERS are used for handling uploaded files.", "A file representation. Performs Django's standard FileField validation.", "Corresponds to django.forms.fields.FileField.", "Signature: FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "An image representation. Validates the uploaded file content as matching a known image format.", "Corresponds to django.forms.fields.ImageField.", "Signature: ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)", "Requires either the Pillow package or PIL package. The Pillow package is recommended, as PIL is no longer actively maintained.", "A field class that validates a list of objects.", "Signature: ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)", "For example, to validate a list of integers you might use something like the following:", "The ListField class also supports a declarative style that allows you to write reusable list field classes.", "We can now reuse our custom StringListField class throughout our application, without having to provide a child argument to it.", "A field class that validates a dictionary of objects. The keys in DictField are always assumed to be string values.", "Signature: DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "For example, to create a field that validates a mapping of strings to strings, you would write something like this:", "You can also use the declarative style, as with ListField. For example:", "A preconfigured DictField that is compatible with Django's postgres HStoreField.", "Signature: HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)", "Note that the child field must be an instance of CharField, as the hstore extension stores values as strings.", "A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.", "Signature: JSONField(binary, encoder)", "A field class that simply returns the value of the field without modification.", "This field is used by default with ModelSerializer when including field names that relate to an attribute rather than a model field.", "Signature: ReadOnlyField()", "For example, if has_expired was a property on the Account model, then the following serializer would automatically generate it as a ReadOnlyField:", "A field class that does not take a value based on user input, but instead takes its value from a default value or callable.", "Signature: HiddenField()", "For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:", "The HiddenField class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.", "For further examples on HiddenField see the validators documentation.", "A generic field that can be tied to any arbitrary model field. The ModelField class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.", "This field is used by ModelSerializer to correspond to custom model field classes.", "Signature: ModelField(model_field=<Django ModelField instance>)", "The ModelField class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a ModelField, it must be passed a field that is attached to an instantiated model. For example: ModelField(model_field=MyModel()._meta.get_field('custom_field'))", "This is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.", "Signature: SerializerMethodField(method_name=None)", "The serializer method referred to by the method_name argument should accept a single argument (in addition to self), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:", "If you want to create a custom field, you'll need to subclass Field and then override either one or both of the .to_representation() and .to_internal_value() methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, date/time/datetime or None. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.", "The .to_representation() method is called to convert the initial datatype into a primitive, serializable datatype.", "The .to_internal_value() method is called to restore a primitive datatype into its internal python representation. This method should raise a serializers.ValidationError if the data is invalid.", "Let's look at an example of serializing a class that represents an RGB color value:", "By default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override .get_attribute() and/or .get_value().", "As an example, let's create a field that can be used to represent the class name of the object being serialized:", "Our ColorField class above currently does not perform any data validation. To indicate invalid data, we should raise a serializers.ValidationError, like so:", "The .fail() method is a shortcut for raising ValidationError that takes a message string from the error_messages dictionary. For example:", "This style keeps your error messages cleaner and more separated from your code, and should be preferred.", "Here we'll take an example of a flat DataPoint model with x_coordinate and y_coordinate attributes.", "Using a custom field and source='*' we can provide a nested representation of the coordinate pair:", "Note that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using source='*', with two IntegerField instances, each with their own source pointing to the relevant field.", "The key points from the example, though, are:", "to_representation is passed the entire DataPoint object and must map from that to the desired output.", "Unless our field is to be read-only, to_internal_value must map back to a dict suitable for updating our target object. With source='*', the return from to_internal_value will update the root validated data dictionary, rather than a single key.", "For completeness lets do the same thing again but with the nested serializer approach suggested above:", "Here the mapping between the target and source attribute pairs (x and x_coordinate, y and y_coordinate) is handled in the IntegerField declarations. It's our NestedCoordinateSerializer that takes source='*'.", "Our new DataPointSerializer exhibits the same behaviour as the custom field approach.", "Serializing:", "Deserializing:", "But we also get the built-in validation for free:", "For this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.", "The following third party packages are also available.", "The drf-compound-fields package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the many=True option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.", "The drf-extra-fields package provides extra serializer fields for REST framework, including Base64ImageField and PointField classes.", "the djangorestframework-recursive package provides a RecursiveField for serializing and deserializing recursive structures", "The django-rest-framework-gis package provides geographic addons for django rest framework like a GeometryField field and a GeoJSON serializer.", "The django-rest-framework-hstore package provides an HStoreField to support django-hstore DictionaryField model field.", "fields.py"]}, {"name": "ValidationError", "path": "api-guide/exceptions/index#validationerror", "type": "Ref: Exceptions", "text": ["Exceptions\u2026 allow error handling to be organized cleanly in a central or high-level place within the program structure.", "\u2014 Doug Hellmann, Python Exception Handling Techniques", "REST framework's views handle various exceptions, and deal with returning appropriate error responses.", "The handled exceptions are:", "In each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.", "Most error responses will include a key detail in the body of the response.", "For example, the following request:", "Might receive an error response indicating that the DELETE method is not allowed on that resource:", "Validation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the NON_FIELD_ERRORS_KEY setting.", "An example validation error might look like this:", "You can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.", "The function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a Response object, or return None if the exception cannot be handled. If the handler returns None then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.", "For example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:", "In order to alter the style of the response, you could write the following custom exception handler:", "The context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as context['view'].", "The exception handler must also be configured in your settings, using the EXCEPTION_HANDLER setting key. For example:", "If not specified, the 'EXCEPTION_HANDLER' setting defaults to the standard exception handler provided by REST framework:", "Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.", "Signature: APIException()", "The base class for all exceptions raised inside an APIView class or @api_view.", "To provide a custom exception, subclass APIException and set the .status_code, .default_detail, and default_code attributes on the class.", "For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:", "There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.", "The available attributes and methods are:", "In most cases the error detail will be a simple item:", "In the case of validation errors the error detail will be either a list or dictionary of items:", "Signature: ParseError(detail=None, code=None)", "Raised if the request contains malformed data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Signature: AuthenticationFailed(detail=None, code=None)", "Raised when an incoming request includes incorrect authentication.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: NotAuthenticated(detail=None, code=None)", "Raised when an unauthenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the authentication documentation for more details.", "Signature: PermissionDenied(detail=None, code=None)", "Raised when an authenticated request fails the permission checks.", "By default this exception results in a response with the HTTP status code \"403 Forbidden\".", "Signature: NotFound(detail=None, code=None)", "Raised when a resource does not exists at the given URL. This exception is equivalent to the standard Http404 Django exception.", "By default this exception results in a response with the HTTP status code \"404 Not Found\".", "Signature: MethodNotAllowed(method, detail=None, code=None)", "Raised when an incoming request occurs that does not map to a handler method on the view.", "By default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".", "Signature: NotAcceptable(detail=None, code=None)", "Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers.", "By default this exception results in a response with the HTTP status code \"406 Not Acceptable\".", "Signature: UnsupportedMediaType(media_type, detail=None, code=None)", "Raised if there are no parsers that can handle the content type of the request data when accessing request.data.", "By default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".", "Signature: Throttled(wait=None, detail=None, code=None)", "Raised when an incoming request fails the throttling checks.", "By default this exception results in a response with the HTTP status code \"429 Too Many Requests\".", "Signature: ValidationError(detail, code=None)", "The ValidationError exception is slightly different from the other APIException classes:", "The ValidationError class should be used for serializer and field validation, and by validator classes. It is also raised when calling serializer.is_valid with the raise_exception keyword argument:", "The generic views use the raise_exception=True flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.", "By default this exception results in a response with the HTTP status code \"400 Bad Request\".", "Django REST Framework provides two error views suitable for providing generic JSON 500 Server Error and 400 Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)", "Use these as per Django's Customizing error views documentation.", "Returns a response with status code 500 and application/json content type.", "Set as handler500:", "Returns a response with status code 400 and application/json content type.", "Set as handler400:", "exceptions.py"]}, {"name": "Validators", "path": "api-guide/validators/index", "type": "API Guide", "text": ["Validators can be useful for re-using validation logic between different types of fields.", "\u2014 Django documentation", "Most of the time you're dealing with validation in REST framework you'll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes.", "However, sometimes you'll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.", "Validation in Django REST framework serializers is handled a little differently to how validation works in Django's ModelForm class.", "With ModelForm the validation is performed partially on the form, and partially on the model instance. With REST framework the validation is performed entirely on the serializer class. This is advantageous for the following reasons:", "When you're using ModelSerializer all of this is handled automatically for you. If you want to drop down to using Serializer classes instead, then you need to define the validation rules explicitly.", "As an example of how REST framework uses explicit validation, we'll take a simple model class that has a field with a uniqueness constraint.", "Here's a basic ModelSerializer that we can use for creating or updating instances of CustomerReportRecord:", "If we open up the Django shell using manage.py shell we can now", "The interesting bit here is the reference field. We can see that the uniqueness constraint is being explicitly enforced by a validator on the serializer field.", "Because of this more explicit style REST framework includes a few validator classes that are not available in core Django. These classes are detailed below.", "This validator can be used to enforce the unique=True constraint on model fields. It takes a single required argument, and an optional messages argument:", "This validator should be applied to serializer fields, like so:", "This validator can be used to enforce unique_together constraints on model instances. It has two required arguments, and a single optional messages argument:", "The validator should be applied to serializer classes, like so:", "Note: The UniqueTogetherValidator class always imposes an implicit constraint that all the fields it applies to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "These validators can be used to enforce the unique_for_date, unique_for_month and unique_for_year constraints on model instances. They take the following arguments:", "The validator should be applied to serializer classes, like so:", "The date field that is used for the validation is always required to be present on the serializer class. You can't simply rely on a model class default=..., because the value being used for the default wouldn't be generated until after the validation has run.", "There are a couple of styles you may want to use for this depending on how you want your API to behave. If you're using ModelSerializer you'll probably simply rely on the defaults that REST framework generates for you, but if you are using Serializer or simply want more explicit control, use on of the styles demonstrated below.", "If you want the date field to be writable the only thing worth noting is that you should ensure that it is always available in the input data, either by setting a default argument, or by setting required=True.", "If you want the date field to be visible, but not editable by the user, then set read_only=True and additionally set a default=... argument.", "If you want the date field to be entirely hidden from the user, then use HiddenField. This field type does not accept user input, but instead always returns its default value to the validated_data in the serializer.", "Note: The UniqueFor<Range>Validator classes impose an implicit constraint that the fields they are applied to are always treated as required. Fields with default values are an exception to this as they always supply a value even when omitted from user input.", "Validators that are applied across multiple fields in the serializer can sometimes require a field input that should not be provided by the API client, but that is available as input to the validator.", "Two patterns that you may want to use for this sort of validation include:", "REST framework includes a couple of defaults that may be useful in this context.", "A default class that can be used to represent the current user. In order to use this, the 'request' must have been provided as part of the context dictionary when instantiating the serializer.", "A default class that can be used to only set a default argument during create operations. During updates the field is omitted.", "It takes a single argument, which is the default value or callable that should be used during create operations.", "There are some ambiguous cases where you'll need to instead handle validation explicitly, rather than relying on the default serializer classes that ModelSerializer generates.", "In these cases you may want to disable the automatically generated validators, by specifying an empty list for the serializer Meta.validators attribute.", "By default \"unique together\" validation enforces that all fields be required=True. In some cases, you might want to explicit apply required=False to one of the fields, in which case the desired behaviour of the validation is ambiguous.", "In this case you will typically need to exclude the validator from the serializer class, and instead write any validation logic explicitly, either in the .validate() method, or else in the view.", "For example:", "When applying an update to an existing instance, uniqueness validators will exclude the current instance from the uniqueness check. The current instance is available in the context of the uniqueness check, because it exists as an attribute on the serializer, having initially been passed using instance=... when instantiating the serializer.", "In the case of update operations on nested serializers there's no way of applying this exclusion, because the instance is not available.", "Again, you'll probably want to explicitly remove the validator from the serializer class, and write the code for the validation constraint explicitly, in a .validate() method, or in the view.", "If you're not sure exactly what behavior a ModelSerializer class will generate it is usually a good idea to run manage.py shell, and print an instance of the serializer, so that you can inspect the fields and validators that it automatically generates for you.", "Also keep in mind that with complex cases it can often be better to explicitly define your serializer classes, rather than relying on the default ModelSerializer behavior. This involves a little more code, but ensures that the resulting behavior is more transparent.", "You can use any of Django's existing validators, or write your own custom validators.", "A validator may be any callable that raises a serializers.ValidationError on failure.", "You can specify custom field-level validation by adding .validate_<field_name> methods to your Serializer subclass. This is documented in the Serializer docs", "To write a class-based validator, use the __call__ method. Class-based validators are useful as they allow you to parameterize and reuse behavior.", "In some advanced cases you might want a validator to be passed the serializer field it is being used with as additional context. You can do so by setting a requires_context = True attribute on the validator. The __call__ method will then be called with the serializer_field or serializer as an additional argument.", "validators.py"]}, {"name": "Versioning", "path": "api-guide/versioning/index", "type": "API Guide", "text": ["Versioning an interface is just a \"polite\" way to kill deployed clients.", "\u2014 Roy Fielding.", "API versioning allows you to alter behavior between different clients. REST framework provides for a number of different versioning schemes.", "Versioning is determined by the incoming client request, and may either be based on the request URL, or based on the request headers.", "There are a number of valid approaches to approaching versioning. Non-versioned systems can also be appropriate, particularly if you're engineering for very long-term systems with multiple clients outside of your control.", "When API versioning is enabled, the request.version attribute will contain a string that corresponds to the version requested in the incoming client request.", "By default, versioning is not enabled, and request.version will always return None.", "How you vary the API behavior is up to you, but one example you might typically want is to switch to a different serialization style in a newer version. For example:", "The reverse function included by REST framework ties in with the versioning scheme. You need to make sure to include the current request as a keyword argument, like so.", "The above function will apply any URL transformations appropriate to the request version. For example:", "When using hyperlinked serialization styles together with a URL based versioning scheme make sure to include the request as context to the serializer.", "Doing so will allow any returned URLs to include the appropriate versioning.", "The versioning scheme is defined by the DEFAULT_VERSIONING_CLASS settings key.", "Unless it is explicitly set, the value for DEFAULT_VERSIONING_CLASS will be None. In this case the request.version attribute will always return None.", "You can also set the versioning scheme on an individual view. Typically you won't need to do this, as it makes more sense to have a single versioning scheme used globally. If you do need to do so, use the versioning_class attribute.", "The following settings keys are also used to control versioning:", "You can also set your versioning class plus those three values on a per-view or a per-viewset basis by defining your own versioning scheme and using the default_version, allowed_versions and version_param class variables. For example, if you want to use URLPathVersioning:", "This scheme requires the client to specify the version as part of the media type in the Accept header. The version is included as a media type parameter, that supplements the main media type.", "Here's an example HTTP request using the accept header versioning style.", "In the example request above request.version attribute would return the string '1.0'.", "Versioning based on accept headers is generally considered as best practice, although other styles may be suitable depending on your client requirements.", "Strictly speaking the json media type is not specified as including additional parameters. If you are building a well-specified public API you might consider using a vendor media type. To do so, configure your renderers to use a JSON based renderer with a custom media type:", "Your client requests would now look like this:", "This scheme requires the client to specify the version as part of the URL path.", "Your URL conf must include a pattern that matches the version with a 'version' keyword argument, so that this information is available to the versioning scheme.", "To the client, this scheme is the same as URLPathVersioning. The only difference is how it is configured in your Django application, as it uses URL namespacing, instead of URL keyword arguments.", "With this scheme the request.version attribute is determined based on the namespace that matches the incoming request path.", "In the following example we're giving a set of views two different possible URL prefixes, each under a different namespace:", "Both URLPathVersioning and NamespaceVersioning are reasonable if you just need a simple versioning scheme. The URLPathVersioning approach might be better suitable for small ad-hoc projects, and the NamespaceVersioning is probably easier to manage for larger projects.", "The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.", "For example the following is an HTTP request to the http://v1.example.com/bookings/ URL:", "By default this implementation expects the hostname to match this simple regular expression:", "Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.", "The HostNameVersioning scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as 127.0.0.1. There are various online tutorials on how to access localhost with a custom subdomain which you may find helpful in this case.", "Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.", "This scheme is a simple style that includes the version as a query parameter in the URL. For example:", "To implement a custom versioning scheme, subclass BaseVersioning and override the .determine_version method.", "The following example uses a custom X-API-Version header to determine the requested version.", "If your versioning scheme is based on the request URL, you will also want to alter how versioned URLs are determined. In order to do so you should override the .reverse() method on the class. See the source code for examples.", "versioning.py"]}, {"name": "Versioning settings", "path": "api-guide/settings/index#versioning-settings", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "View names and descriptions", "path": "api-guide/settings/index#view-names-and-descriptions", "type": "Ref: Settings", "text": ["Namespaces are one honking great idea - let's do more of those!", "\u2014 The Zen of Python", "Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK.", "For example your project's settings.py file might include something like this:", "If you need to access the values of REST framework's API settings in your project, you should use the api_settings object. For example.", "The api_settings object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.", "The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view.", "A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a Response object.", "Default:", "A list or tuple of parser classes, that determines the default set of parsers used when accessing the request.data property.", "Default:", "A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the request.user or request.auth properties.", "Default:", "A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.", "Default:", "A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.", "Default: []", "A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.", "Default: 'rest_framework.negotiation.DefaultContentNegotiation'", "A view inspector class that will be used for schema generation.", "Default: 'rest_framework.schemas.openapi.AutoSchema'", "The following settings control the behavior of the generic class-based views.", "A list of filter backend classes that should be used for generic filtering. If set to None then generic filtering is disabled.", "The default class to use for queryset pagination. If set to None, pagination is disabled by default. See the pagination documentation for further guidance on setting and modifying the pagination style.", "Default: None", "The default page size to use for pagination. If set to None, pagination is disabled by default.", "Default: None", "The name of a query parameter, which can be used to specify the search term used by SearchFilter.", "Default: search", "The name of a query parameter, which can be used to specify the ordering of results returned by OrderingFilter.", "Default: ordering", "The value that should be used for request.version when no versioning information is present.", "Default: None", "If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.", "Default: None", "The string that should used for any versioning parameters, such as in the media type or URL query parameters.", "Default: 'version'", "The following settings control the behavior of unauthenticated requests.", "The class that should be used to initialize request.user for unauthenticated requests. (If removing authentication entirely, e.g. by removing django.contrib.auth from INSTALLED_APPS, set UNAUTHENTICATED_USER to None.)", "Default: django.contrib.auth.models.AnonymousUser", "The class that should be used to initialize request.auth for unauthenticated requests.", "Default: None", "The following settings control the behavior of APIRequestFactory and APIClient", "The default format that should be used when making test requests.", "This should match up with the format of one of the renderer classes in the TEST_REQUEST_RENDERER_CLASSES setting.", "Default: 'multipart'", "The renderer classes that are supported when building test requests.", "The format of any of these renderer classes may be used when constructing a test request, for example: client.post('/users', {'username': 'jamie'}, format='json')", "Default:", "If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be 'id'. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.", "Default: True", "If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.", "Default: {'retrieve': 'read', 'destroy': 'delete'}", "The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=\u2026 query parameter in the request URL.", "For example: http://example.com/organizations/?format=csv", "If the value of this setting is None then URL format overrides will be disabled.", "Default: 'format'", "The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using format_suffix_patterns to include suffixed URL patterns.", "For example: http://example.com/organizations.csv/", "Default: 'format'", "The following settings are used to control how date and time representations may be parsed and rendered.", "A format string that should be used by default for rendering the output of DateTimeField serializer fields. If None, then DateTimeField serializer fields will return Python datetime objects, and the datetime encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateTimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of DateField serializer fields. If None, then DateField serializer fields will return Python date objects, and the date encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to DateField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "A format string that should be used by default for rendering the output of TimeField serializer fields. If None, then TimeField serializer fields will return Python time objects, and the time encoding will be determined by the renderer.", "May be any of None, 'iso-8601' or a Python strftime format string.", "Default: 'iso-8601'", "A list of format strings that should be used by default for parsing inputs to TimeField serializer fields.", "May be a list including the string 'iso-8601' or Python strftime format strings.", "Default: ['iso-8601']", "When set to True, JSON responses will allow unicode characters in responses. For example:", "When set to False, JSON responses will escape non-ascii characters, like so:", "Both styles conform to RFC 4627, and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.", "Default: True", "When set to True, JSON responses will return compact representations, with no spacing after ':' and ',' characters. For example:", "When set to False, JSON responses will return slightly more verbose representations, like so:", "The default style is to return minified responses, in line with Heroku's API design guidelines.", "Default: True", "When set to True, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (nan, inf, -inf) accepted by Python's json module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's JSON.Parse nor PostgreSQL's JSON data type accept these values.", "When set to False, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.", "Default: True", "When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.", "When set to True, the serializer DecimalField class will return strings instead of Decimal objects. When set to False, serializers will return Decimal objects, which the default JSON encoder will return as floats.", "Default: True", "The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API.", "A string representing the function that should be used when generating view names.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_name'", "A string representing the function that should be used when generating view descriptions.", "This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support rst markup in your view docstrings being output in the browsable API.", "This should be a function with the following signature:", "If the view instance inherits ViewSet, it may have been initialized with several optional arguments:", "Default: 'rest_framework.views.get_view_description'", "Global settings for select field cutoffs for rendering relational fields in the browsable API.", "Global setting for the html_cutoff value. Must be an integer.", "Default: 1000", "A string representing a global setting for html_cutoff_text.", "Default: \"More than {count} items...\"", "A string representing the function that should be used when returning a response for any given exception. If the function returns None, a 500 error will be raised.", "This setting can be changed to support error responses other than the default {\"detail\": \"Failure...\"} responses. For example, you can use it to provide API responses like {\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}.", "This should be a function with the following signature:", "Default: 'rest_framework.views.exception_handler'", "A string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.", "Default: 'non_field_errors'", "A string representing the key that should be used for the URL fields generated by HyperlinkedModelSerializer.", "Default: 'url'", "An integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to None then less strict IP matching will be used by the throttle classes.", "Default: None", "settings.py"]}, {"name": "ViewSet", "path": "api-guide/viewsets/index#viewset", "type": "Ref: ViewSets", "text": ["After routing has determined which controller to use for a request, your controller is responsible for making sense of the request and producing the appropriate output.", "\u2014 Ruby on Rails Documentation", "Django REST framework allows you to combine the logic for a set of related views in a single class, called a ViewSet. In other frameworks you may also find conceptually similar implementations named something like 'Resources' or 'Controllers'.", "A ViewSet class is simply a type of class-based View, that does not provide any method handlers such as .get() or .post(), and instead provides actions such as .list() and .create().", "The method handlers for a ViewSet are only bound to the corresponding actions at the point of finalizing the view, using the .as_view() method.", "Typically, rather than explicitly registering the views in a viewset in the urlconf, you'll register the viewset with a router class, that automatically determines the urlconf for you.", "Let's define a simple viewset that can be used to list or retrieve all the users in the system.", "If we need to, we can bind this viewset into two separate views, like so:", "Typically we wouldn't do this, but would instead register the viewset with a router, and allow the urlconf to be automatically generated.", "Rather than writing your own viewsets, you'll often want to use the existing base classes that provide a default set of behavior. For example:", "There are two main advantages of using a ViewSet class over using a View class.", "Both of these come with a trade-off. Using regular views and URL confs is more explicit and gives you more control. ViewSets are helpful if you want to get up and running quickly, or when you have a large API and you want to enforce a consistent URL configuration throughout.", "The default routers included with REST framework will provide routes for a standard set of create/retrieve/update/destroy style actions, as shown below:", "During dispatch, the following attributes are available on the ViewSet.", "You may inspect these attributes to adjust behaviour based on the current action. For example, you could restrict permissions to everything except the list action similar to this:", "If you have ad-hoc methods that should be routable, you can mark them as such with the @action decorator. Like regular actions, extra actions may be intended for either a single object, or an entire collection. To indicate this, set the detail argument to True or False. The router will configure its URL patterns accordingly. e.g., the DefaultRouter will configure detail actions to contain pk in their URL patterns.", "A more complete example of extra actions:", "The action decorator will route GET requests by default, but may also accept other HTTP methods by setting the methods argument. For example:", "The decorator allows you to override any viewset-level configuration such as permission_classes, serializer_class, filter_backends...:", "The two new actions will then be available at the urls ^users/{pk}/set_password/$ and ^users/{pk}/unset_password/$. Use the url_path and url_name parameters to change the URL segment and the reverse URL name of the action.", "To view all extra actions, call the .get_extra_actions() method.", "Extra actions can map additional HTTP methods to separate ViewSet methods. For example, the above password set/unset methods could be consolidated into a single route. Note that additional mappings do not accept arguments.", "If you need to get the URL of an action, use the .reverse_action() method. This is a convenience wrapper for reverse(), automatically passing the view's request object and prepending the url_name with the .basename attribute.", "Note that the basename is provided by the router during ViewSet registration. If you are not using a router, then you must provide the basename argument to the .as_view() method.", "Using the example from the previous section:", "Alternatively, you can use the url_name attribute set by the @action decorator.", "The url_name argument for .reverse_action() should match the same argument to the @action decorator. Additionally, this method can be used to reverse the default actions, such as list and create.", "The ViewSet class inherits from APIView. You can use any of the standard attributes such as permission_classes, authentication_classes in order to control the API policy on the viewset.", "The ViewSet class does not provide any implementations of actions. In order to use a ViewSet class you'll override the class and define the action implementations explicitly.", "The GenericViewSet class inherits from GenericAPIView, and provides the default set of get_object, get_queryset methods and other generic view base behavior, but does not include any actions by default.", "In order to use a GenericViewSet class you'll override the class and either mixin the required mixin classes, or define the action implementations explicitly.", "The ModelViewSet class inherits from GenericAPIView and includes implementations for various actions, by mixing in the behavior of the various mixin classes.", "The actions provided by the ModelViewSet class are .list(), .retrieve(), .create(), .update(), .partial_update(), and .destroy().", "Because ModelViewSet extends GenericAPIView, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Note that you can use any of the standard attributes or method overrides provided by GenericAPIView. For example, to use a ViewSet that dynamically determines the queryset it should operate on, you might do something like this:", "Note however that upon removal of the queryset property from your ViewSet, any associated router will be unable to derive the basename of your Model automatically, and so you will have to specify the basename kwarg as part of your router registration.", "Also note that although this class provides the complete set of create/list/retrieve/update/destroy actions by default, you can restrict the available operations by using the standard permission classes.", "The ReadOnlyModelViewSet class also inherits from GenericAPIView. As with ModelViewSet it also includes implementations for various actions, but unlike ModelViewSet only provides the 'read-only' actions, .list() and .retrieve().", "As with ModelViewSet, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Again, as with ModelViewSet, you can use any of the standard attributes and method overrides available to GenericAPIView.", "You may need to provide custom ViewSet classes that do not have the full set of ModelViewSet actions, or that customize the behavior in some other way.", "To create a base viewset class that provides create, list and retrieve operations, inherit from GenericViewSet, and mixin the required actions:", "By creating your own base ViewSet classes, you can provide common behavior that can be reused in multiple viewsets across your API.", "viewsets.py"]}, {"name": "ViewSets", "path": "api-guide/viewsets/index", "type": "API Guide", "text": ["After routing has determined which controller to use for a request, your controller is responsible for making sense of the request and producing the appropriate output.", "\u2014 Ruby on Rails Documentation", "Django REST framework allows you to combine the logic for a set of related views in a single class, called a ViewSet. In other frameworks you may also find conceptually similar implementations named something like 'Resources' or 'Controllers'.", "A ViewSet class is simply a type of class-based View, that does not provide any method handlers such as .get() or .post(), and instead provides actions such as .list() and .create().", "The method handlers for a ViewSet are only bound to the corresponding actions at the point of finalizing the view, using the .as_view() method.", "Typically, rather than explicitly registering the views in a viewset in the urlconf, you'll register the viewset with a router class, that automatically determines the urlconf for you.", "Let's define a simple viewset that can be used to list or retrieve all the users in the system.", "If we need to, we can bind this viewset into two separate views, like so:", "Typically we wouldn't do this, but would instead register the viewset with a router, and allow the urlconf to be automatically generated.", "Rather than writing your own viewsets, you'll often want to use the existing base classes that provide a default set of behavior. For example:", "There are two main advantages of using a ViewSet class over using a View class.", "Both of these come with a trade-off. Using regular views and URL confs is more explicit and gives you more control. ViewSets are helpful if you want to get up and running quickly, or when you have a large API and you want to enforce a consistent URL configuration throughout.", "The default routers included with REST framework will provide routes for a standard set of create/retrieve/update/destroy style actions, as shown below:", "During dispatch, the following attributes are available on the ViewSet.", "You may inspect these attributes to adjust behaviour based on the current action. For example, you could restrict permissions to everything except the list action similar to this:", "If you have ad-hoc methods that should be routable, you can mark them as such with the @action decorator. Like regular actions, extra actions may be intended for either a single object, or an entire collection. To indicate this, set the detail argument to True or False. The router will configure its URL patterns accordingly. e.g., the DefaultRouter will configure detail actions to contain pk in their URL patterns.", "A more complete example of extra actions:", "The action decorator will route GET requests by default, but may also accept other HTTP methods by setting the methods argument. For example:", "The decorator allows you to override any viewset-level configuration such as permission_classes, serializer_class, filter_backends...:", "The two new actions will then be available at the urls ^users/{pk}/set_password/$ and ^users/{pk}/unset_password/$. Use the url_path and url_name parameters to change the URL segment and the reverse URL name of the action.", "To view all extra actions, call the .get_extra_actions() method.", "Extra actions can map additional HTTP methods to separate ViewSet methods. For example, the above password set/unset methods could be consolidated into a single route. Note that additional mappings do not accept arguments.", "If you need to get the URL of an action, use the .reverse_action() method. This is a convenience wrapper for reverse(), automatically passing the view's request object and prepending the url_name with the .basename attribute.", "Note that the basename is provided by the router during ViewSet registration. If you are not using a router, then you must provide the basename argument to the .as_view() method.", "Using the example from the previous section:", "Alternatively, you can use the url_name attribute set by the @action decorator.", "The url_name argument for .reverse_action() should match the same argument to the @action decorator. Additionally, this method can be used to reverse the default actions, such as list and create.", "The ViewSet class inherits from APIView. You can use any of the standard attributes such as permission_classes, authentication_classes in order to control the API policy on the viewset.", "The ViewSet class does not provide any implementations of actions. In order to use a ViewSet class you'll override the class and define the action implementations explicitly.", "The GenericViewSet class inherits from GenericAPIView, and provides the default set of get_object, get_queryset methods and other generic view base behavior, but does not include any actions by default.", "In order to use a GenericViewSet class you'll override the class and either mixin the required mixin classes, or define the action implementations explicitly.", "The ModelViewSet class inherits from GenericAPIView and includes implementations for various actions, by mixing in the behavior of the various mixin classes.", "The actions provided by the ModelViewSet class are .list(), .retrieve(), .create(), .update(), .partial_update(), and .destroy().", "Because ModelViewSet extends GenericAPIView, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Note that you can use any of the standard attributes or method overrides provided by GenericAPIView. For example, to use a ViewSet that dynamically determines the queryset it should operate on, you might do something like this:", "Note however that upon removal of the queryset property from your ViewSet, any associated router will be unable to derive the basename of your Model automatically, and so you will have to specify the basename kwarg as part of your router registration.", "Also note that although this class provides the complete set of create/list/retrieve/update/destroy actions by default, you can restrict the available operations by using the standard permission classes.", "The ReadOnlyModelViewSet class also inherits from GenericAPIView. As with ModelViewSet it also includes implementations for various actions, but unlike ModelViewSet only provides the 'read-only' actions, .list() and .retrieve().", "As with ModelViewSet, you'll normally need to provide at least the queryset and serializer_class attributes. For example:", "Again, as with ModelViewSet, you can use any of the standard attributes and method overrides available to GenericAPIView.", "You may need to provide custom ViewSet classes that do not have the full set of ModelViewSet actions, or that customize the behavior in some other way.", "To create a base viewset class that provides create, list and retrieve operations, inherit from GenericViewSet, and mixin the required actions:", "By creating your own base ViewSet classes, you can provide common behavior that can be reused in multiple viewsets across your API.", "viewsets.py"]}]